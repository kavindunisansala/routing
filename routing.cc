
#include "ns3/wave-module.h"
#include "ns3/csma-helper.h"
#include "ns3/lte-helper.h"
#include "ns3/aodv-module.h"
#include "ns3/lte-module.h"
#include "ns3/lte-net-device.h"
#include "ns3/wifi-module.h"
#include "ns3/wifi-net-device.h"
#include "ns3/mobility-module.h"
#include "ns3/core-module.h"
#include "ns3/wave-helper.h"
#include "ns3/netanim-module.h"
#include "ns3/point-to-point-helper.h"
#include "ns3/ipv4-global-routing-helper.h"
#include "ns3/internet-module.h"
#include "ns3/applications-module.h"
#include "ns3/node.h"
#include "ns3/core-module.h"
//#include "ns3/ns3-ai-module.h"
#include "ns3/log.h"
#include "ns3/tag.h"
#include "ns3/vector.h"
#include "ns3/nstime.h"
#include "ns3/simulator.h"
#include "ns3/mac48-address.h"
#include "ns3/mac64-address.h"
#include "ns3/constant-acceleration-mobility-model.h"
#include "ns3/mobility-model.h"
#include "ns3/nstime.h"
#include "ns3/event-id.h"
#include "ns3/wifi-mac-queue.h"
//#include "ns3/console-color.h"
#include <iomanip>      // std::setprecision
#include <cmath>
#include "ns3/socket.h"
#include "ns3/application.h"
#include "ns3/udp-socket.h"
#include "ns3/csma-net-device.h"
#include "ns3/ethernet-header.h"
#include "ns3/arp-header.h"
#include "ns3/ipv4-header.h"
#include "ns3/udp-header.h"
#include "ns3/ns2-mobility-helper.h"
#include "string.h"
#include "cstdlib"
#include "sstream"
#include "iostream"
#include "fstream"
#include "vector"
#include <cstdlib>
#include <limits.h>
#include <bits/stdc++.h>

// ============================================================================
// INLINE WORMHOLE ATTACK MODULE
// ============================================================================
// Wormhole attack implementation integrated directly into routing.cc
// This creates realistic wormhole tunnels between malicious nodes that
// intercept AODV routing packets and tunnel them through high-speed links

namespace ns3 {

// Forward declarations for wormhole attack classes
struct WormholeStatistics;
struct FlowLatencyRecord;
struct WormholeDetectionMetrics;
struct WormholeTunnel;
class WormholeEndpointApp;
class WormholeAttackManager;
class WormholeDetector;

/**
 * @brief Statistics for wormhole attack monitoring
 */
struct WormholeStatistics {
    uint32_t packetsIntercepted;      // Total packets intercepted by wormhole endpoints
    uint32_t packetsTunneled;         // Total packets successfully tunneled
    uint32_t packetsDropped;          // Packets dropped during tunneling
    uint32_t routingPacketsAffected;  // Routing protocol packets affected
    uint32_t dataPacketsAffected;     // Data packets affected
    double totalTunnelingDelay;       // Cumulative tunneling delay
    Time firstPacketTime;             // First packet intercepted
    Time lastPacketTime;              // Last packet intercepted
    
    WormholeStatistics() 
        : packetsIntercepted(0), packetsTunneled(0), packetsDropped(0),
          routingPacketsAffected(0), dataPacketsAffected(0), 
          totalTunnelingDelay(0.0) {}
};

/**
 * @brief Per-flow latency tracking for wormhole detection
 */
struct FlowLatencyRecord {
    Ipv4Address srcAddr;              // Source IP address
    Ipv4Address dstAddr;              // Destination IP address
    Time firstPacketTime;             // Time of first packet
    Time lastPacketTime;              // Time of last packet
    double totalLatency;              // Total cumulative latency
    uint32_t packetCount;             // Number of packets in flow
    double avgLatency;                // Average latency for this flow
    bool suspectedWormhole;           // Flag if wormhole detected
    std::vector<uint32_t> pathNodes;  // Nodes in the path
    
    FlowLatencyRecord() 
        : totalLatency(0.0), packetCount(0), avgLatency(0.0), 
          suspectedWormhole(false) {}
};

/**
 * @brief Metrics for wormhole detection evaluation
 */
struct WormholeDetectionMetrics {
    uint32_t totalFlows;              // Total number of flows monitored
    uint32_t flowsAffected;           // Flows affected by wormhole
    uint32_t flowsDetected;           // Flows where wormhole was detected
    uint32_t truePositives;           // Correctly detected wormholes
    uint32_t falsePositives;          // Normal flows flagged as wormhole
    uint32_t falseNegatives;          // Missed wormhole detections
    double detectionAccuracy;         // Detection accuracy percentage
    double avgNormalLatency;          // Average latency for normal flows
    double avgWormholeLatency;        // Average latency for wormhole flows
    double avgLatencyIncrease;        // Average latency increase percentage
    uint32_t routeChanges;            // Number of route changes triggered
    
    WormholeDetectionMetrics() 
        : totalFlows(0), flowsAffected(0), flowsDetected(0),
          truePositives(0), falsePositives(0), falseNegatives(0),
          detectionAccuracy(0.0), avgNormalLatency(0.0), 
          avgWormholeLatency(0.0), avgLatencyIncrease(0.0), routeChanges(0) {}
};

/**
 * @brief Represents a wormhole tunnel between two endpoints
 */
struct WormholeTunnel {
    Ptr<Node> endpointA;              // First endpoint node
    Ptr<Node> endpointB;              // Second endpoint node
    Ptr<WormholeEndpointApp> appA;    // Application on endpoint A
    Ptr<WormholeEndpointApp> appB;    // Application on endpoint B
    uint32_t nodeIdA;                 // Node ID of endpoint A
    uint32_t nodeIdB;                 // Node ID of endpoint B
    NetDeviceContainer tunnelDevices; // Point-to-point devices for tunnel
    Ipv4InterfaceContainer tunnelInterfaces; // IP interfaces
    bool isActive;                    // Whether tunnel is currently active
    Time activationTime;              // When tunnel was activated
    Time deactivationTime;            // When tunnel will be deactivated (if scheduled)
    WormholeStatistics stats;         // Statistics for this tunnel
    
    WormholeTunnel() : nodeIdA(0), nodeIdB(0), isActive(false) {}
};

/**
 * @brief Application that intercepts and tunnels packets (wormhole endpoint)
 */
class WormholeEndpointApp : public Application {
public:
    static TypeId GetTypeId(void);
    
    WormholeEndpointApp();
    virtual ~WormholeEndpointApp();
    
    void SetPeer(Ptr<Node> peer, Ipv4Address peerAddress);
    void SetTunnelId(uint32_t id);
    void SetDropPackets(bool drop);
    void SetSelectiveTunneling(bool routing, bool data);
    WormholeStatistics GetStatistics() const { return m_stats; }
    
protected:
    virtual void StartApplication(void);
    virtual void StopApplication(void);
    
private:
    bool ReceivePacket(Ptr<NetDevice> device, Ptr<const Packet> packet, 
                       uint16_t protocol, const Address &from,
                       const Address &to, NetDevice::PacketType packetType);
    bool InterceptPacket(Ptr<NetDevice> device, Ptr<const Packet> packet,
                        uint16_t protocol, const Address &from,
                        const Address &to, NetDevice::PacketType packetType);
    void ReceiveAODVMessage(Ptr<Socket> socket);
    void SendFakeRREP(Ipv4Address requester);
    void SendFakeRouteAdvertisement();
    void BroadcastFakeRREP();
    void PeriodicBroadcast();
    void PeriodicAttack();
    void HandleTunneledPacket(Ptr<Socket> socket);
    void TunnelPacket(Ptr<Packet> packet, uint16_t protocol);
    bool ShouldTunnelPacket(Ptr<const Packet> packet, uint16_t protocol);
    
    Ptr<Node> m_peer;
    Ipv4Address m_peerAddress;
    Ptr<Socket> m_tunnelSocket;
    Ptr<Socket> m_aodvSocket;
    Ptr<Socket> m_aodvSniffer;
    uint32_t m_tunnelId;
    bool m_dropPackets;
    bool m_tunnelRoutingPackets;
    bool m_tunnelDataPackets;
    WormholeStatistics m_stats;
};

/**
 * @brief Wormhole Attack Manager - Manages all wormhole tunnels
 */
class WormholeAttackManager {
public:
    WormholeAttackManager();
    ~WormholeAttackManager();
    
    void Initialize(std::vector<bool>& maliciousNodes, double attackPercentage, 
                    uint32_t totalNodes);
    void CreateWormholeTunnels(std::string tunnelBandwidth, Time tunnelDelay, 
                               bool selectRandom = true);
    uint32_t CreateWormholeTunnel(uint32_t nodeIdA, uint32_t nodeIdB,
                                  std::string bandwidth, Time delay);
    void ActivateAttack(Time startTime, Time stopTime);
    void DeactivateAttack();
    void ConfigureVisualization(AnimationInterface& anim, 
                                uint8_t r = 255, uint8_t g = 0, uint8_t b = 0);
    void SetWormholeBehavior(bool dropPackets, bool tunnelRouting, bool tunnelData);
    void ConfigureVerificationTraffic(bool enable, uint32_t flowCount,
                                      double packetRate, uint32_t packetSize,
                                      double startOffsetSec, uint16_t basePort = 50000);
    
    uint32_t GetTunnelCount() const { return m_tunnels.size(); }
    WormholeStatistics GetTunnelStatistics(uint32_t tunnelId) const;
    WormholeStatistics GetAggregateStatistics() const;
    void ExportStatistics(std::string filename) const;
    void PrintStatistics() const;
    std::vector<uint32_t> GetMaliciousNodeIds() const;
    
private:
    void SelectRandomPairs(std::vector<uint32_t>& maliciousNodeIds);
    void SelectSequentialPairs(std::vector<uint32_t>& maliciousNodeIds);
    void DeployVerificationTraffic(double startTimeSec, double stopTimeSec);
    void CollectStatisticsFromApps();
    Ipv4Address GetPrimaryAddress(Ptr<Node> node);
    
    std::vector<WormholeTunnel> m_tunnels;
    std::vector<bool> m_maliciousNodes;
    bool m_dropPackets;
    bool m_tunnelRoutingPackets;
    bool m_tunnelDataPackets;
    uint32_t m_totalNodes;
    std::string m_defaultBandwidth;
    Time m_defaultDelay;
    std::vector<Ptr<Socket>> m_testSourceSockets;
    std::vector<Ptr<Socket>> m_testSinkSockets;
    bool m_enableVerificationTraffic;
    uint32_t m_verificationFlowCount;
    double m_verificationPacketRate;
    uint32_t m_verificationPacketSize;
    double m_verificationStartOffset;
    uint16_t m_verificationBasePort;
};

/**
 * @brief Wormhole Detector - Latency-based detection and mitigation
 */
class WormholeDetector {
public:
    WormholeDetector();
    ~WormholeDetector();
    
    void Initialize(uint32_t totalNodes, double latencyThreshold = 2.0);
    void EnableDetection(bool enable);
    void EnableMitigation(bool enable);
    void SetLatencyThreshold(double multiplier);
    
    // Flow monitoring
    void RecordPacketSent(Ipv4Address src, Ipv4Address dst, Time txTime, uint32_t packetId);
    void RecordPacketReceived(Ipv4Address src, Ipv4Address dst, Time rxTime, uint32_t packetId);
    void UpdateFlowLatency(Ipv4Address src, Ipv4Address dst, double latency);
    
    // Detection
    bool DetectWormholeInFlow(Ipv4Address src, Ipv4Address dst);
    void PeriodicDetectionCheck();
    bool IsFlowSuspicious(const FlowLatencyRecord& flow);
    
    // Mitigation
    void BlacklistNode(uint32_t nodeId);
    void UnblacklistNode(uint32_t nodeId);
    bool IsNodeBlacklisted(uint32_t nodeId) const;
    void TriggerRouteChange(Ipv4Address src, Ipv4Address dst);
    
    // Statistics and reporting
    WormholeDetectionMetrics GetMetrics() const { return m_metrics; }
    void PrintDetectionReport() const;
    void ExportDetectionResults(std::string filename) const;
    
private:
    void CalculateBaselineLatency();
    void UpdateDetectionMetrics();
    std::string GetFlowKey(Ipv4Address src, Ipv4Address dst) const;
    
    bool m_detectionEnabled;
    bool m_mitigationEnabled;
    uint32_t m_totalNodes;
    double m_latencyThresholdMultiplier;
    double m_baselineLatency;
    
    std::map<std::string, FlowLatencyRecord> m_flowRecords;
    std::map<uint32_t, Time> m_packetSendTimes;
    std::set<uint32_t> m_blacklistedNodes;
    WormholeDetectionMetrics m_metrics;
    
    Time m_detectionStartTime;
    Time m_lastDetectionCheck;
};

} // namespace ns3

// End of wormhole attack class declarations
// ============================================================================

#define max 40

#define max1 1
#define max2 2
#define max3 3
#define max4 4
#define max5 5
#define max6 6
#define max7 7
#define max8 8
#define max9 9
#define max10 10
#define max11 11
#define max12 12
#define max13 13
#define max14 14
#define max15 15
#define max16 16
#define max17 17
#define max18 18
#define max19 19
#define max20 20
#define max21 21
#define max22 22
#define max23 23
#define max24 24
#define max25 25

int lambda = 30;

const int Flow_size = 55;
uint32_t flow_size = 55;

const int total_size = 28;  // Maximum network size for compile-time arrays
uint32_t N_RSUs = 10;
uint32_t N_Vehicles = 18;
uint32_t actual_total_nodes = 28;  // Runtime node count (N_Vehicles + N_RSUs)

const int flows = 2;

int routing_algorithm = 5; //0-ECMP, 1-RR, 2-QR-SDN, 3-RLMR, 4-proposed, 5-DCMR
int experiment_number = 0; //0 - qos, 1 - flow_size (packet arrival rate), 2 - mobility, 3 - network size

double simTime = 10;  // Short simulation for testing wormhole attack (default was 300)

uint16_t N_eNodeBs = 1+ N_Vehicles/40;
int var = N_Vehicles+N_RSUs;
uint32_t large=50000;

double optimization_frequency = 1.0;
double optimization_period = 1.0/optimization_frequency;
double data_transmission_frequency = 1.0;
double data_transmission_period = 1.0/data_transmission_frequency;
double entropy_threshold = 0.005;
double routing_frequency = data_transmission_frequency;
double contention_threshold = 0.0;
double link_lifetime_threshold = 0.400;
int mobility_scenario = 0;// 0 - urban, 1 - non-urban, 2 - highway
int architecture = 0; // 0 - centralized, 1 - distributed, 2 - hybrid
int attack_number = 2; //1 - blackhole, 2 - wormhole, 3 - sybil, 4 - reply, 5 - routing-table-poisioning
double attack_percentage=0.2; //percentage of attackers (20%)

// Attack presence flags
bool present_blackhole_attack_nodes = false;
bool present_wormhole_attack_nodes = true;
bool present_sybil_attack_nodes = false;
bool present_reply_attack_nodes = false;
bool present_replay_attack_nodes = false;  // Alias for reply attack
bool present_routing_table_poisoning_attack_nodes = false;

bool present_blackhole_attack_controllers = false;
bool present_wormhole_attack_controllers = true;
bool present_sybil_attack_controllers = false;
bool present_reply_attack_controllers = false;
bool present_replay_attack_controllers = false;  // Alias for reply attack
bool present_routing_table_poisoning_attack_controllers = false;

// Enhanced Wormhole Attack Configuration
bool use_enhanced_wormhole = true;              // Use AODV-based wormhole attack (realistic)
std::string wormhole_tunnel_bandwidth = "1000Mbps"; // Tunnel bandwidth
uint32_t wormhole_tunnel_delay_us = 50000;      // Tunnel delay in microseconds (50ms = realistic long-distance tunnel)
bool wormhole_random_pairing = true;            // Random vs sequential pairing
bool wormhole_drop_packets = false;             // Drop instead of tunnel
bool wormhole_tunnel_routing = true;            // Tunnel routing packets
bool wormhole_tunnel_data = true;               // Tunnel data packets
double wormhole_start_time = 0.0;               // When to start attack (seconds)
double wormhole_stop_time = 0.0;                // When to stop attack (0 = simTime)
bool wormhole_enable_verification_flows = true; // Install background verification flows
uint32_t wormhole_verification_flow_count = 3;  // Number of verification flow pairs
double wormhole_verification_packet_rate = 40.0; // Packets per second per flow
uint32_t wormhole_verification_packet_size = 512; // UDP packet size in bytes
double wormhole_verification_start_offset = 0.5; // Seconds after attack start to begin flows
uint16_t wormhole_verification_base_port = 50000; // Base UDP port for verification flows

// Wormhole Detection and Mitigation Configuration
bool enable_wormhole_detection = false;         // Enable latency-based wormhole detection
bool enable_wormhole_mitigation = false;        // Enable automatic mitigation (route changes)
double detection_latency_threshold = 2.0;       // Latency multiplier for detection (2.0 = 200% of baseline)
double detection_check_interval = 1.0;          // Seconds between detection checks

// Number of controllers
const int controllers = 6;

// Malicious state arrays for nodes
std::vector<bool> blackhole_malicious_nodes(total_size, false);
std::vector<bool> wormhole_malicious_nodes(total_size, false);
std::vector<bool> sybil_malicious_nodes(total_size, false);
std::vector<bool> reply_malicious_nodes(total_size, false);
std::vector<bool> replay_malicious_nodes(total_size, false);  // Alias for reply
std::vector<bool> routing_table_poisoning_malicious_nodes(total_size, false);

// Malicious state arrays for controllers
std::vector<bool> blackhole_malicious_controllers(controllers, false);
std::vector<bool> wormhole_malicious_controllers(controllers, false);
std::vector<bool> sybil_malicious_controllers(controllers, false);
std::vector<bool> reply_malicious_controllers(controllers, false);
std::vector<bool> replay_malicious_controllers(controllers, false);  // Alias for reply
std::vector<bool> routing_table_poisoning_malicious_controllers(controllers, false);

// Global wormhole attack manager instance
ns3::WormholeAttackManager* g_wormholeManager = nullptr;

// Global wormhole detector instance
ns3::WormholeDetector* g_wormholeDetector = nullptr;

int maxspeed = 80;	

int paper = 1; //0-optimization, 1 -architecture

uint32_t flow_packet_size = 100;
uint32_t qf = 1;
uint32_t AIFSN = 0;
double B_max = 0.0;
double latency_max = 0.0;
double loss_max = 0.0;
uint32_t CW_max = 0;
double AIFS = 0.0;

double mu1 = 0.10;
double mu2 = 1.00;
double mu3 = 0.25;


bool training = false; //true if training data set for machine learnng is generated
bool training_delay = false;

using namespace std;
using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("vanet");

// Forward declarations for global node containers
extern NodeContainer Nodes;
extern NodeContainer RSU_Nodes;
extern uint32_t N_Vehicles;

// Helper function to convert node ID to IP address for detection system
Ipv4Address GetIpFromNodeId(uint32_t nodeId) {
    try {
        if (nodeId < N_Vehicles && nodeId < Nodes.GetN()) {
            // Vehicle node
            Ptr<Ipv4> ipv4 = Nodes.Get(nodeId)->GetObject<Ipv4>();
            if (ipv4 && ipv4->GetNInterfaces() > 1) {
                return ipv4->GetAddress(1,0).GetLocal();
            }
        } else if (nodeId >= N_Vehicles) {
            // RSU node
            uint32_t rsuIndex = nodeId - N_Vehicles;
            if (rsuIndex < RSU_Nodes.GetN()) {
                Ptr<Ipv4> ipv4 = RSU_Nodes.Get(rsuIndex)->GetObject<Ipv4>();
                if (ipv4) {
                    uint32_t interfaceIndex = (N_Vehicles > 0) ? 1 : 0;
                    if (ipv4->GetNInterfaces() > interfaceIndex) {
                        return ipv4->GetAddress(interfaceIndex, 0).GetLocal();
                    }
                }
            }
        }
    } catch (...) {
        // Return invalid address on error
    }
    return Ipv4Address("0.0.0.0");
}

class CustomDataTag : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);



	CustomDataTag();
	CustomDataTag(uint32_t node_id);
	virtual ~CustomDataTag();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag);

CustomDataTag::CustomDataTag() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag::CustomDataTag(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag::~CustomDataTag() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag> ();
  return tid;
}
TypeId CustomDataTag::GetInstanceTypeId (void) const
{
  return CustomDataTag::GetTypeId ();
}

 

 
uint32_t CustomDataTag::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/

double flow_initiation_time; 

void CustomDataTag::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag::SetTimestamp(Time t) {
	m_timestamp = t;
}


class CustomDataTag1 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag1();
	CustomDataTag1(uint32_t node_id);
	virtual ~CustomDataTag1();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max1+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag1");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag1);

CustomDataTag1::CustomDataTag1() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag1::CustomDataTag1(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag1::~CustomDataTag1() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag1::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag1")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag1> ();
  return tid;
}
TypeId CustomDataTag1::GetInstanceTypeId (void) const
{
  return CustomDataTag1::GetTypeId ();
}

 

 
uint32_t CustomDataTag1::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag1::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag1::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag1::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag1::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag1::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag1::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag1::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag1::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag1::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag1::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag1::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag1::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag1::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag1::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max1;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag1::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag2 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag2();
	CustomDataTag2(uint32_t node_id);
	virtual ~CustomDataTag2();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max2+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag2");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag2);

CustomDataTag2::CustomDataTag2() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag2::CustomDataTag2(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag2::~CustomDataTag2() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag2::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag2")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag2> ();
  return tid;
}
TypeId CustomDataTag2::GetInstanceTypeId (void) const
{
  return CustomDataTag2::GetTypeId ();
}

 

 
uint32_t CustomDataTag2::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag2::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag2::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag2::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag2::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag2::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag2::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag2::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag2::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag2::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag2::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag2::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag2::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag2::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag2::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max2;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag2::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag3 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag3();
	CustomDataTag3(uint32_t node_id);
	virtual ~CustomDataTag3();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max3+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag3");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag3);

CustomDataTag3::CustomDataTag3() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag3::CustomDataTag3(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag3::~CustomDataTag3() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag3::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag3")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag3> ();
  return tid;
}
TypeId CustomDataTag3::GetInstanceTypeId (void) const
{
  return CustomDataTag3::GetTypeId ();
}

 

 
uint32_t CustomDataTag3::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag3::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag3::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag3::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag3::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag3::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag3::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag3::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag3::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag3::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag3::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag3::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag3::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag3::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag3::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max3;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag3::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag4 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag4();
	CustomDataTag4(uint32_t node_id);
	virtual ~CustomDataTag4();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max4+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag4");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag4);

CustomDataTag4::CustomDataTag4() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag4::CustomDataTag4(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag4::~CustomDataTag4() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag4::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag4")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag4> ();
  return tid;
}
TypeId CustomDataTag4::GetInstanceTypeId (void) const
{
  return CustomDataTag4::GetTypeId ();
}

 

 
uint32_t CustomDataTag4::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag4::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag4::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag4::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag4::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag4::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag4::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag4::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag4::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag4::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag4::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag4::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag4::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag4::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag4::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max4;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag4::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag5 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag5();
	CustomDataTag5(uint32_t node_id);
	virtual ~CustomDataTag5();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max5+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag5");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag5);

CustomDataTag5::CustomDataTag5() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag5::CustomDataTag5(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag5::~CustomDataTag5() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag5::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag5")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag5> ();
  return tid;
}
TypeId CustomDataTag5::GetInstanceTypeId (void) const
{
  return CustomDataTag5::GetTypeId ();
}

 

 
uint32_t CustomDataTag5::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag5::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag5::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag5::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag5::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag5::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag5::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag5::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag5::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag5::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag5::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag5::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag5::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag5::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag5::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max5;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag5::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag6 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag6();
	CustomDataTag6(uint32_t node_id);
	virtual ~CustomDataTag6();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max6+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag6");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag6);

CustomDataTag6::CustomDataTag6() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag6::CustomDataTag6(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag6::~CustomDataTag6() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag6::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag6")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag6> ();
  return tid;
}
TypeId CustomDataTag6::GetInstanceTypeId (void) const
{
  return CustomDataTag6::GetTypeId ();
}

 

 
uint32_t CustomDataTag6::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag6::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag6::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag6::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag6::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag6::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag6::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag6::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag6::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag6::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag6::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag6::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag6::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag6::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag6::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max6;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag6::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag7 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag7();
	CustomDataTag7(uint32_t node_id);
	virtual ~CustomDataTag7();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max7+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag7");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag7);

CustomDataTag7::CustomDataTag7() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag7::CustomDataTag7(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag7::~CustomDataTag7() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag7::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag7")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag7> ();
  return tid;
}
TypeId CustomDataTag7::GetInstanceTypeId (void) const
{
  return CustomDataTag7::GetTypeId ();
}

 

 
uint32_t CustomDataTag7::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag7::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag7::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag7::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag7::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag7::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag7::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag7::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag7::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag7::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag7::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag7::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag7::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag7::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag7::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max7;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag7::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag8 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag8();
	CustomDataTag8(uint32_t node_id);
	virtual ~CustomDataTag8();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max8+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag8");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag8);

CustomDataTag8::CustomDataTag8() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag8::CustomDataTag8(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag8::~CustomDataTag8() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag8::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag8")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag8> ();
  return tid;
}
TypeId CustomDataTag8::GetInstanceTypeId (void) const
{
  return CustomDataTag8::GetTypeId ();
}

 

 
uint32_t CustomDataTag8::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag8::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag8::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag8::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag8::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag8::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag8::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag8::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag8::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag8::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag8::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag8::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag8::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag8::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag8::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max8;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag8::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag9 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag9();
	CustomDataTag9(uint32_t node_id);
	virtual ~CustomDataTag9();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max9+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag9");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag9);

CustomDataTag9::CustomDataTag9() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag9::CustomDataTag9(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag9::~CustomDataTag9() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag9::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag9")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag9> ();
  return tid;
}
TypeId CustomDataTag9::GetInstanceTypeId (void) const
{
  return CustomDataTag9::GetTypeId ();
}

 

 
uint32_t CustomDataTag9::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag9::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag9::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag9::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag9::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag9::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag9::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag9::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag9::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag9::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag9::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag9::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag9::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag9::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag9::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max9;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag9::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag10 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag10();
	CustomDataTag10(uint32_t node_id);
	virtual ~CustomDataTag10();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max10+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag10");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag10);

CustomDataTag10::CustomDataTag10() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag10::CustomDataTag10(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag10::~CustomDataTag10() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag10::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag10")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag10> ();
  return tid;
}
TypeId CustomDataTag10::GetInstanceTypeId (void) const
{
  return CustomDataTag10::GetTypeId ();
}

 

 
uint32_t CustomDataTag10::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag10::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag10::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag10::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag10::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag10::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag10::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag10::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag10::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag10::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag10::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag10::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag10::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag10::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag10::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max10;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag10::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag11 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag11();
	CustomDataTag11(uint32_t node_id);
	virtual ~CustomDataTag11();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max11+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag11");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag11);

CustomDataTag11::CustomDataTag11() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag11::CustomDataTag11(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag11::~CustomDataTag11() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag11::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag11")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag11> ();
  return tid;
}
TypeId CustomDataTag11::GetInstanceTypeId (void) const
{
  return CustomDataTag11::GetTypeId ();
}

 

 
uint32_t CustomDataTag11::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag11::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag11::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag11::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag11::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag11::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag11::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag11::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag11::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag11::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag11::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag11::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag11::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag11::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag11::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max11;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag11::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag12 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag12();
	CustomDataTag12(uint32_t node_id);
	virtual ~CustomDataTag12();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max12+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag12");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag12);

CustomDataTag12::CustomDataTag12() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag12::CustomDataTag12(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag12::~CustomDataTag12() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag12::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag12")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag12> ();
  return tid;
}
TypeId CustomDataTag12::GetInstanceTypeId (void) const
{
  return CustomDataTag12::GetTypeId ();
}

 

 
uint32_t CustomDataTag12::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag12::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag12::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag12::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag12::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag12::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag12::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag12::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag12::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag12::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag12::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag12::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag12::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag12::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag12::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max12;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag12::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag13 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag13();
	CustomDataTag13(uint32_t node_id);
	virtual ~CustomDataTag13();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max13+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag13");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag13);

CustomDataTag13::CustomDataTag13() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag13::CustomDataTag13(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag13::~CustomDataTag13() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag13::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag13")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag13> ();
  return tid;
}
TypeId CustomDataTag13::GetInstanceTypeId (void) const
{
  return CustomDataTag13::GetTypeId ();
}

 

 
uint32_t CustomDataTag13::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag13::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag13::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag13::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag13::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag13::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag13::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag13::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag13::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag13::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag13::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag13::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag13::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag13::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag13::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max13;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag13::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag14 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag14();
	CustomDataTag14(uint32_t node_id);
	virtual ~CustomDataTag14();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max14+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag14");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag14);

CustomDataTag14::CustomDataTag14() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag14::CustomDataTag14(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag14::~CustomDataTag14() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag14::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag14")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag14> ();
  return tid;
}
TypeId CustomDataTag14::GetInstanceTypeId (void) const
{
  return CustomDataTag14::GetTypeId ();
}

 

 
uint32_t CustomDataTag14::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag14::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag14::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag14::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag14::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag14::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag14::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag14::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag14::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag14::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag14::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag14::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag14::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag14::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag14::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max14;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag14::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag15 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag15();
	CustomDataTag15(uint32_t node_id);
	virtual ~CustomDataTag15();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max15+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag15);

CustomDataTag15::CustomDataTag15() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag15::CustomDataTag15(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag15::~CustomDataTag15() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag15::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag15")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag15> ();
  return tid;
}
TypeId CustomDataTag15::GetInstanceTypeId (void) const
{
  return CustomDataTag15::GetTypeId ();
}

 

 
uint32_t CustomDataTag15::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag15::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag15::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag15::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag15::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag15::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag15::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag15::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag15::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag15::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag15::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag15::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag15::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag15::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag15::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max15;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag15::GetNeighborids()
{
	return m_neighborid;
}

class CustomDataTag16 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag16();
	CustomDataTag16(uint32_t node_id);
	virtual ~CustomDataTag16();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max16+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag16");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag16);

CustomDataTag16::CustomDataTag16() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag16::CustomDataTag16(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag16::~CustomDataTag16() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag16::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag16")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag16> ();
  return tid;
}
TypeId CustomDataTag16::GetInstanceTypeId (void) const
{
  return CustomDataTag16::GetTypeId ();
}

 

 
uint32_t CustomDataTag16::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag16::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag16::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag16::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag16::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag16::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag16::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag16::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag16::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag16::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag16::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag16::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag16::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag16::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag16::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max16;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag16::GetNeighborids()
{
	return m_neighborid;
}

class CustomDataTag17 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag17();
	CustomDataTag17(uint32_t node_id);
	virtual ~CustomDataTag17();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max17+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag17");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag17);

CustomDataTag17::CustomDataTag17() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag17::CustomDataTag17(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag17::~CustomDataTag17() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag17::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag17")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag17> ();
  return tid;
}
TypeId CustomDataTag17::GetInstanceTypeId (void) const
{
  return CustomDataTag17::GetTypeId ();
}

 

 
uint32_t CustomDataTag17::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag17::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag17::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag17::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag17::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag17::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag17::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag17::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag17::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag17::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag17::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag17::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag17::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag17::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag17::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max17;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag17::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag18 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag18();
	CustomDataTag18(uint32_t node_id);
	virtual ~CustomDataTag18();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max18+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag18");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag18);

CustomDataTag18::CustomDataTag18() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag18::CustomDataTag18(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag18::~CustomDataTag18() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag18::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag18")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag18> ();
  return tid;
}
TypeId CustomDataTag18::GetInstanceTypeId (void) const
{
  return CustomDataTag18::GetTypeId ();
}

 

 
uint32_t CustomDataTag18::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag18::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag18::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag18::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag18::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag18::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag18::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag18::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag18::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag18::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag18::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag18::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag18::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag18::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag18::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max18;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag18::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag19 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag19();
	CustomDataTag19(uint32_t node_id);
	virtual ~CustomDataTag19();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max19+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag19");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag19);

CustomDataTag19::CustomDataTag19() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag19::CustomDataTag19(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag19::~CustomDataTag19() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag19::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag19")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag19> ();
  return tid;
}
TypeId CustomDataTag19::GetInstanceTypeId (void) const
{
  return CustomDataTag19::GetTypeId ();
}

 

 
uint32_t CustomDataTag19::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag19::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag19::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag19::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag19::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag19::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag19::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag19::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag19::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag19::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag19::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag19::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag19::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag19::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag19::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max19;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag19::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag20 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag20();
	CustomDataTag20(uint32_t node_id);
	virtual ~CustomDataTag20();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max20+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag20");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag20);

CustomDataTag20::CustomDataTag20() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag20::CustomDataTag20(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag20::~CustomDataTag20() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag20::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag20")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag20> ();
  return tid;
}
TypeId CustomDataTag20::GetInstanceTypeId (void) const
{
  return CustomDataTag20::GetTypeId ();
}

 

 
uint32_t CustomDataTag20::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag20::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag20::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag20::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag20::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag20::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag20::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag20::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag20::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag20::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag20::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag20::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag20::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag20::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag20::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max20;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag20::GetNeighborids()
{
	return m_neighborid;
}


class CustomDataTag21 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag21();
	CustomDataTag21(uint32_t node_id);
	virtual ~CustomDataTag21();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max21+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag21");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag21);

CustomDataTag21::CustomDataTag21() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag21::CustomDataTag21(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag21::~CustomDataTag21() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag21::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag21")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag21> ();
  return tid;
}
TypeId CustomDataTag21::GetInstanceTypeId (void) const
{
  return CustomDataTag21::GetTypeId ();
}

 

 
uint32_t CustomDataTag21::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag21::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag21::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag21::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag21::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag21::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag21::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag21::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag21::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag21::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag21::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag21::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag21::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag21::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag21::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max21;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag21::GetNeighborids()
{
	return m_neighborid;
}

class CustomDataTag22 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag22();
	CustomDataTag22(uint32_t node_id);
	virtual ~CustomDataTag22();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max22+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag22");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag22);

CustomDataTag22::CustomDataTag22() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag22::CustomDataTag22(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag22::~CustomDataTag22() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag22::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag22")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag22> ();
  return tid;
}
TypeId CustomDataTag22::GetInstanceTypeId (void) const
{
  return CustomDataTag22::GetTypeId ();
}

 

 
uint32_t CustomDataTag22::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag22::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag22::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag22::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag22::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag22::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag22::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag22::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag22::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag22::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag22::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag22::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag22::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag22::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag22::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max22;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag22::GetNeighborids()
{
	return m_neighborid;
}

class CustomDataTag23 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag23();
	CustomDataTag23(uint32_t node_id);
	virtual ~CustomDataTag23();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max23+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag23");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag23);

CustomDataTag23::CustomDataTag23() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag23::CustomDataTag23(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag23::~CustomDataTag23() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag23::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag23")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag23> ();
  return tid;
}
TypeId CustomDataTag23::GetInstanceTypeId (void) const
{
  return CustomDataTag23::GetTypeId ();
}

 

 
uint32_t CustomDataTag23::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag23::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag23::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag23::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag23::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag23::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag23::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag23::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag23::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag23::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag23::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag23::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag23::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag23::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag23::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max23;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag23::GetNeighborids()
{
	return m_neighborid;
}

class CustomDataTag24 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag24();
	CustomDataTag24(uint32_t node_id);
	virtual ~CustomDataTag24();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max24+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag24");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag24);

CustomDataTag24::CustomDataTag24() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag24::CustomDataTag24(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag24::~CustomDataTag24() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag24::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag24")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag24> ();
  return tid;
}
TypeId CustomDataTag24::GetInstanceTypeId (void) const
{
  return CustomDataTag24::GetTypeId ();
}

 

 
uint32_t CustomDataTag24::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag24::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag24::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag24::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag24::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag24::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag24::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag24::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag24::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag24::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag24::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag24::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag24::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag24::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag24::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max24;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag24::GetNeighborids()
{
	return m_neighborid;
}

class CustomDataTag25 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTag25();
	CustomDataTag25(uint32_t node_id);
	virtual ~CustomDataTag25();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max25+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTag25");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTag25);

CustomDataTag25::CustomDataTag25() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTag25::CustomDataTag25(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTag25::~CustomDataTag25() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTag25::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTag25")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTag25> ();
  return tid;
}
TypeId CustomDataTag25::GetInstanceTypeId (void) const
{
  return CustomDataTag25::GetTypeId ();
}

 

 
uint32_t CustomDataTag25::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTag25::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTag25::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTag25::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTag25::GetNodeId() {
	return m_nodeId;
}

void CustomDataTag25::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTag25::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTag25::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTag25::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTag25::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTag25::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTag25::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTag25::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTag25::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTag25::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max25;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTag25::GetNeighborids()
{
	return m_neighborid;
}

class CustomDataTagmax : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	Vector GetPosition(void);
	Vector GetVelocity(void);
	Vector GetAcceleration(void);
	uint32_t GetNodeId();
	Time GetTimestamp ();
	uint32_t * GetNeighborids();

	void SetPosition (Vector pos);
	void SetVelocity (Vector vel);
	void SetAcceleration (Vector acce);
	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void SetNeighborids(uint32_t * nid);


	CustomDataTagmax();
	CustomDataTagmax(uint32_t node_id);
	virtual ~CustomDataTagmax();
private:

	uint32_t m_nodeId;
	
	/* Current status data */
	
	Vector m_currentPosition;
	Vector m_currentVelocity;
	Vector m_currentAcceleration;
	uint32_t m_neighborid[max+1];
	Time m_timestamp;
	

};


//NS_LOG_COMPONENT_DEFINE("CustomDataTagmax");
NS_OBJECT_ENSURE_REGISTERED (CustomDataTagmax);

CustomDataTagmax::CustomDataTagmax() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomDataTagmax::CustomDataTagmax(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomDataTagmax::~CustomDataTagmax() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataTagmax::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataTagmax")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataTagmax> ();
  return tid;
}
TypeId CustomDataTagmax::GetInstanceTypeId (void) const
{
  return CustomDataTagmax::GetTypeId ();
}

 

 
uint32_t CustomDataTagmax::GetSerializedSize (void) const
{
	return sizeof(Vector) + sizeof(Vector) + sizeof(Vector) + sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataTagmax::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//then we store the position
	i.WriteDouble (m_currentPosition.x);
	i.WriteDouble (m_currentPosition.y);
	i.WriteDouble (m_currentPosition.z);
	
	//then we store the velocity
	i.WriteDouble (m_currentVelocity.x);
	i.WriteDouble (m_currentVelocity.y);
	i.WriteDouble (m_currentVelocity.z);
	
	//then we store the acceleration
	i.WriteDouble (m_currentAcceleration.x);
	i.WriteDouble (m_currentAcceleration.y);
	i.WriteDouble (m_currentAcceleration.z);
	
	for (uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}

/* This function reads data from a buffer and store it in class's instance variables.

*/


void CustomDataTagmax::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;

	//Then the position
	m_currentPosition.x = i.ReadDouble();
	m_currentPosition.y = i.ReadDouble();
	m_currentPosition.z = i.ReadDouble();
	
	//Then the velocity
	m_currentVelocity.x = i.ReadDouble();
	m_currentVelocity.y = i.ReadDouble();
	m_currentVelocity.z = i.ReadDouble();
	
	//Then the acceleration
	m_currentAcceleration.x = i.ReadDouble();
	m_currentAcceleration.y = i.ReadDouble();
	m_currentAcceleration.z = i.ReadDouble();
	
	for (uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}

/*
  This function can be used with ASCII traces if enabled. 
 
*/


void CustomDataTagmax::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")" << " Pos (" << m_currentPosition << ")";
}

//Your accessor and mutator functions 
uint32_t CustomDataTagmax::GetNodeId() {
	return m_nodeId;
}

void CustomDataTagmax::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}
Vector CustomDataTagmax::GetPosition(void) {
	return m_currentPosition;
}

Vector CustomDataTagmax::GetVelocity(void) {
	return m_currentVelocity;
}

Vector CustomDataTagmax::GetAcceleration(void) {
	return m_currentAcceleration;
}

Time CustomDataTagmax::GetTimestamp() {
	return m_timestamp;
}

void CustomDataTagmax::SetPosition(Vector pos) {
	m_currentPosition = pos;
}

void CustomDataTagmax::SetVelocity(Vector vel) {
	m_currentVelocity = vel;
}

void CustomDataTagmax::SetAcceleration(Vector acce) {
	m_currentAcceleration = acce;
}

void CustomDataTagmax::SetTimestamp(Time t) {
	m_timestamp = t;
}

void CustomDataTagmax::SetNeighborids(uint32_t * nid)
{
	for(uint32_t i =0; i<max;i++)
	{
		m_neighborid[i] = *(nid+i);
	}
}

uint32_t * CustomDataTagmax::GetNeighborids()
{
	return m_neighborid;
}


class CustomMetaDataBroadcastTag : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);



	CustomMetaDataBroadcastTag();
	CustomMetaDataBroadcastTag(uint32_t node_id);
	virtual ~CustomMetaDataBroadcastTag();
private:

	uint32_t m_nodeId;
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataBroadcastTag);

CustomMetaDataBroadcastTag::CustomMetaDataBroadcastTag() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataBroadcastTag::CustomMetaDataBroadcastTag(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataBroadcastTag::~CustomMetaDataBroadcastTag() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataBroadcastTag::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataBroadcastTag")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataBroadcastTag> ();
  return tid;
}
TypeId CustomMetaDataBroadcastTag::GetInstanceTypeId (void) const
{
  return CustomMetaDataBroadcastTag::GetTypeId ();
}

 

 
uint32_t CustomMetaDataBroadcastTag::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataBroadcastTag::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());

	//Then we store the node ID
	i.WriteU32(m_nodeId);
}



void CustomMetaDataBroadcastTag::Deserialize (TagBuffer i)
{
	//We extract what we stored first, so we extract the timestamp
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	//Finally, we extract the node id
	m_nodeId = i.ReadU32();

}




void CustomMetaDataBroadcastTag::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataBroadcastTag::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataBroadcastTag::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataBroadcastTag::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataBroadcastTag::SetTimestamp(Time t) {
	m_timestamp = t;
}



class CustomDataUnicastTag : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag();
	//CustomDataUnicastTag(uint32_t node_id);
	virtual ~CustomDataUnicastTag();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max+1];
	Vector m_acceleration[max+1];
	Vector m_velocity[max+1];
	Vector m_position[max+1];
	Time m_timestamp[max+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag);

CustomDataUnicastTag::CustomDataUnicastTag() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag::CustomDataUnicastTag(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag::~CustomDataUnicastTag() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag> ();
  return tid;
}
TypeId CustomDataUnicastTag::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max+1) + (sizeof(double))*3*(max+1) + (sizeof(double))*3*(max+1) + (sizeof(double))*3*(max+1) + (sizeof(double))*(max+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag::Serialize (TagBuffer i) const
{
	for(int j=0;j<max;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag_ModifiedRouting : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetflowId();
	uint32_t GetpacketId();
	uint32_t Getprevious_senderId();
	uint32_t GetchannelId();
	Time Getprevious_timestamp();
	Time Getoriginal_timestamp();

	void SetflowId(uint32_t destination_id);
	void SetpacketId(uint32_t packet_id);
	void SetchannelId(uint32_t packet_id);
	void Setprevious_senderId(uint32_t destination_id);
	void Setprevious_timestamp (Time time);
	void Setoriginal_timestamp (Time time);

	CustomDataUnicastTag_ModifiedRouting();
	//CustomDataUnicastTag_ModifiedRouting(uint32_t node_id);
	virtual ~CustomDataUnicastTag_ModifiedRouting();
private:
	uint32_t m_previous_senderId;
	uint32_t m_packetId;
	uint32_t m_channelId;
	uint32_t m_flowId;
	Time m_original_timestamp;
	Time m_previous_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomDataUnicastTag_ModifiedRouting");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag_ModifiedRouting);

CustomDataUnicastTag_ModifiedRouting::CustomDataUnicastTag_ModifiedRouting() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag_ModifiedRouting::CustomDataUnicastTag_ModifiedRouting(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag_ModifiedRouting::~CustomDataUnicastTag_ModifiedRouting() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag_ModifiedRouting::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag_ModifiedRouting")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag_ModifiedRouting> ();
  return tid;
}
TypeId CustomDataUnicastTag_ModifiedRouting::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag_ModifiedRouting::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag_ModifiedRouting::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof(uint32_t) + sizeof(uint32_t)  + sizeof(uint32_t) + sizeof(uint32_t) + (sizeof(double))*2);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag_ModifiedRouting::Serialize (TagBuffer i) const
{
	i.WriteU32(m_previous_senderId);
	i.WriteU32(m_packetId);
	i.WriteU32(m_channelId);
	i.WriteU32(m_flowId);
	i.WriteDouble(m_original_timestamp.GetDouble());
	i.WriteDouble(m_previous_timestamp.GetDouble());
}



void CustomDataUnicastTag_ModifiedRouting::Deserialize (TagBuffer i)
{

	m_previous_senderId = i.ReadU32();
	m_packetId = i.ReadU32();
	m_channelId = i.ReadU32();
	m_flowId = i.ReadU32();
	m_original_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);
	m_previous_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);
}




void CustomDataUnicastTag_ModifiedRouting::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << ")";
}

//Your accessor and mutator functions 
void CustomDataUnicastTag_ModifiedRouting::SetflowId(uint32_t flow_id)
{
	m_flowId = flow_id;
}

uint32_t CustomDataUnicastTag_ModifiedRouting::GetflowId()
{	
	return m_flowId;
}

void CustomDataUnicastTag_ModifiedRouting::SetpacketId(uint32_t packet_id)
{
	m_packetId = packet_id;
}

uint32_t CustomDataUnicastTag_ModifiedRouting::GetpacketId()
{	
	return m_packetId;
}

void CustomDataUnicastTag_ModifiedRouting::SetchannelId(uint32_t channel_id)
{
	m_channelId = channel_id;
}

uint32_t CustomDataUnicastTag_ModifiedRouting::GetchannelId()
{	
	return m_channelId;
}

void CustomDataUnicastTag_ModifiedRouting::Setprevious_senderId(uint32_t previous_sender_id)
{
	m_previous_senderId = previous_sender_id;
}

uint32_t CustomDataUnicastTag_ModifiedRouting::Getprevious_senderId()
{	
	return m_previous_senderId;
}


Time CustomDataUnicastTag_ModifiedRouting::Getoriginal_timestamp() {
	return m_original_timestamp;
}

void CustomDataUnicastTag_ModifiedRouting::Setoriginal_timestamp(Time ti) {
	
		m_original_timestamp = ti;
}


Time CustomDataUnicastTag_ModifiedRouting::Getprevious_timestamp() {
	return m_previous_timestamp;
}

void CustomDataUnicastTag_ModifiedRouting::Setprevious_timestamp(Time ti) {
	
		m_previous_timestamp = ti;
}




class CustomDataUnicastTag_Routing : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();
	uint32_t GetdestinationId();

	void SetdestinationId(uint32_t destination_id);
	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag_Routing();
	//CustomDataUnicastTag_Routing(uint32_t node_id);
	virtual ~CustomDataUnicastTag_Routing();
private:
	uint32_t m_senderId;
	uint32_t m_destinationId;
	uint32_t m_nodeId[max1+1];
	Vector m_acceleration[max1+1];
	Vector m_velocity[max1+1];
	Vector m_position[max1+1];
	Time m_timestamp[max1+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomDataUnicastTag_Routing");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag_Routing);

CustomDataUnicastTag_Routing::CustomDataUnicastTag_Routing() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag_Routing::CustomDataUnicastTag_Routing(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag_Routing::~CustomDataUnicastTag_Routing() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag_Routing::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag_Routing")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag_Routing> ();
  return tid;
}
TypeId CustomDataUnicastTag_Routing::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag_Routing::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag_Routing::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max1+1) + (sizeof(double))*3*(max1+1) + (sizeof(double))*3*(max1+1) + (sizeof(double))*3*(max1+1) + (sizeof(double))*(max1+1)+ 2*sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag_Routing::Serialize (TagBuffer i) const
{
	for(int j=0;j<max1;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max1;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max1;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max1;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max1;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);
	i.WriteU32(m_destinationId);

}



void CustomDataUnicastTag_Routing::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max1;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max1;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max1;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max1;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max1;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
	m_destinationId = i.ReadU32();
}




void CustomDataUnicastTag_Routing::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag_Routing::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag_Routing::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max1;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag_Routing::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag_Routing::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max1;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag_Routing::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag_Routing::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag_Routing::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag_Routing::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max1;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag_Routing::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag_Routing::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max1;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag_Routing::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag_Routing::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

uint32_t CustomDataUnicastTag_Routing::GetdestinationId()
{	
	return m_destinationId;
}

void CustomDataUnicastTag_Routing::SetdestinationId(uint32_t destination_id)
{
	m_destinationId = destination_id;
}


class CustomFlowDataUplinkTag1 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getsource();
	uint32_t * Getdestination();
	uint32_t * GetX();
	uint32_t * GetP();
	uint32_t * GetQ();

	void Setsource (uint32_t * node_id);
	void Setdestination (uint32_t * node_id);
	void SetX (uint32_t * X);
	void SetP (uint32_t * P);
	void SetQ (uint32_t * Q);

	CustomFlowDataUplinkTag1();
	//CustomFlowDataUplinkTag1(uint32_t node_id);
	virtual ~CustomFlowDataUplinkTag1();
private:
	uint32_t m_source[(2*flows)+1];
	uint32_t m_destination[(2*flows)+1];
	uint32_t m_X[(2*flows)+1];
	uint32_t m_P[(2*flows)+1];
	uint32_t m_Q[(2*flows)+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomFlowDataUplinkTag1");
NS_OBJECT_ENSURE_REGISTERED (CustomFlowDataUplinkTag1);

CustomFlowDataUplinkTag1::CustomFlowDataUplinkTag1() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomFlowDataUplinkTag1::CustomFlowDataUplinkTag1(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomFlowDataUplinkTag1::~CustomFlowDataUplinkTag1() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomFlowDataUplinkTag1::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomFlowDataUplinkTag1")
    .SetParent<Tag> ()
    .AddConstructor<CustomFlowDataUplinkTag1> ();
  return tid;
}
TypeId CustomFlowDataUplinkTag1::GetInstanceTypeId (void) const
{
  return CustomFlowDataUplinkTag1::GetTypeId ();
}

 
uint32_t CustomFlowDataUplinkTag1::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return ((sizeof (uint32_t))*((2*flows)+1) + (sizeof (uint32_t))*((2*flows)+1) + (sizeof (uint32_t))*((2*flows)+1) + (sizeof (uint32_t))*((2*flows)+1) + (sizeof (uint32_t))*((2*flows)+1));
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomFlowDataUplinkTag1::Serialize (TagBuffer i) const
{
	for(int j=0;j<(2*flows);j++)
	{
		i.WriteU32(m_source[j]);
	}
	
	for(int j=0;j<(2*flows);j++)
	{
		i.WriteU32(m_destination[j]);
	}
	
	for(int j=0;j<(2*flows);j++)
	{
		i.WriteU32(m_X[j]);
	}
	
	for(int j=0;j<(2*flows);j++)
	{
		i.WriteU32(m_P[j]);
	}
	
	for(int j=0;j<(2*flows);j++)
	{
		i.WriteU32(m_Q[j]);
	}

}



void CustomFlowDataUplinkTag1::Deserialize (TagBuffer i)
{
	for(int j=0;j<(2*flows);j++)
	{
		m_source[j] = i.ReadU32();
	}
	
	for(int j=0;j<(2*flows);j++)
	{
		m_destination[j] = i.ReadU32();
	}
	
	for(int j=0;j<(2*flows);j++)
	{
		m_X[j] = i.ReadU32();
	}
	
	for(int j=0;j<(2*flows);j++)
	{
		m_P[j] = i.ReadU32();
	}
	
	for(int j=0;j<(2*flows);j++)
	{
		m_Q[j] = i.ReadU32();
	}
}




void CustomFlowDataUplinkTag1::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :"<<endl;
}

//Your accessor and mutator functions 
uint32_t * CustomFlowDataUplinkTag1::Getsource() {
	return m_source;
}

void CustomFlowDataUplinkTag1::Setsource(uint32_t * node_id) {
	for(uint32_t i=0;i<(2*flows);i++)
	{
		m_source[i] = *(node_id+i);
	}
}


uint32_t * CustomFlowDataUplinkTag1::Getdestination() {
	return m_destination;
}

void CustomFlowDataUplinkTag1::Setdestination(uint32_t * node_id) {
	for(uint32_t i=0;i<(2*flows);i++)
	{
		m_destination[i] = *(node_id+i);
	}
}


uint32_t * CustomFlowDataUplinkTag1::GetX() {
	return m_X;
}

void CustomFlowDataUplinkTag1::SetX(uint32_t * node_id) {
	for(uint32_t i=0;i<(2*flows);i++)
	{
		m_X[i] = *(node_id+i);
	}
}



uint32_t * CustomFlowDataUplinkTag1::GetP() {
	return m_P;
}

void CustomFlowDataUplinkTag1::SetP(uint32_t * node_id) {
	for(uint32_t i=0;i<(2*flows);i++)
	{
		m_P[i] = *(node_id+i);
	}
}


uint32_t * CustomFlowDataUplinkTag1::GetQ() {
	return m_Q;
}

void CustomFlowDataUplinkTag1::SetQ(uint32_t * node_id) {
	for(uint32_t i=0;i<(2*flows);i++)
	{
		m_Q[i] = *(node_id+i);
	}
}






class CustomStatusDataUplinkTag1 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();

	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);

	CustomStatusDataUplinkTag1();
	//CustomStatusDataUplinkTag1(uint32_t node_id);
	virtual ~CustomStatusDataUplinkTag1();
private:
	uint32_t m_nodeId[max1+1];
	Vector m_acceleration[max1+1];
	Vector m_velocity[max1+1];
	Vector m_position[max1+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomStatusDataUplinkTag1");
NS_OBJECT_ENSURE_REGISTERED (CustomStatusDataUplinkTag1);

CustomStatusDataUplinkTag1::CustomStatusDataUplinkTag1() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomStatusDataUplinkTag1::CustomStatusDataUplinkTag1(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomStatusDataUplinkTag1::~CustomStatusDataUplinkTag1() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomStatusDataUplinkTag1::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomStatusDataUplinkTag1")
    .SetParent<Tag> ()
    .AddConstructor<CustomStatusDataUplinkTag1> ();
  return tid;
}
TypeId CustomStatusDataUplinkTag1::GetInstanceTypeId (void) const
{
  return CustomStatusDataUplinkTag1::GetTypeId ();
}

 
uint32_t CustomStatusDataUplinkTag1::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max1+1) + (sizeof(double))*3*(max1+1) + (sizeof(double))*3*(max1+1) + (sizeof(double))*3*(max1+1);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomStatusDataUplinkTag1::Serialize (TagBuffer i) const
{
	for(int j=0;j<max1;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max1;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max1;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max1;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
}



void CustomStatusDataUplinkTag1::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max1;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max1;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max1;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max1;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
}




void CustomStatusDataUplinkTag1::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId<<endl;
}

//Your accessor and mutator functions 
uint32_t * CustomStatusDataUplinkTag1::GetNodeId() {
	return m_nodeId;
}

void CustomStatusDataUplinkTag1::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max1;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomStatusDataUplinkTag1::Getacceleration()
{
	return m_acceleration;
}

void CustomStatusDataUplinkTag1::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max1;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomStatusDataUplinkTag1::Getvelocity()
{
	return m_velocity;
}

void CustomStatusDataUplinkTag1::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomStatusDataUplinkTag1::Getposition()
{
	return m_position;
}

void CustomStatusDataUplinkTag1::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max1;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}



class CustomDataUnicastTag1 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag1();
	//CustomDataUnicastTag1(uint32_t node_id);
	virtual ~CustomDataUnicastTag1();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max1+1];
	Vector m_acceleration[max1+1];
	Vector m_velocity[max1+1];
	Vector m_position[max1+1];
	Time m_timestamp[max1+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomDataUnicastTag1");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag1);

CustomDataUnicastTag1::CustomDataUnicastTag1() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag1::CustomDataUnicastTag1(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag1::~CustomDataUnicastTag1() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag1::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag1")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag1> ();
  return tid;
}
TypeId CustomDataUnicastTag1::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag1::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag1::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max1+1) + (sizeof(double))*3*(max1+1) + (sizeof(double))*3*(max1+1) + (sizeof(double))*3*(max1+1) + (sizeof(double))*(max1+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag1::Serialize (TagBuffer i) const
{
	for(int j=0;j<max1;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max1;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max1;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max1;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max1;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag1::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max1;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max1;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max1;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max1;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max1;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag1::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag1::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag1::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max1;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag1::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag1::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max1;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag1::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag1::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag1::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag1::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max1;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag1::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag1::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max1;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag1::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag1::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}


class CustomDataUnicastTag2 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag2();
	//CustomDataUnicastTag2(uint32_t node_id);
	virtual ~CustomDataUnicastTag2();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max2+1];
	Vector m_acceleration[max2+1];
	Vector m_velocity[max2+1];
	Vector m_position[max2+1];
	Time m_timestamp[max2+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomDataUnicastTag");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag2);

CustomDataUnicastTag2::CustomDataUnicastTag2() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag2::CustomDataUnicastTag2(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag2::~CustomDataUnicastTag2() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag2::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag2")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag2> ();
  return tid;
}
TypeId CustomDataUnicastTag2::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag2::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag2::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max2+1) + (sizeof(double))*3*(max2+1) + (sizeof(double))*3*(max2+1) + (sizeof(double))*3*(max2+1) + (sizeof(double))*(max2+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag2::Serialize (TagBuffer i) const
{
	for(int j=0;j<max2;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max2;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max2;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max2;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max2;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag2::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max2;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max2;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max2;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max2;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max2;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag2::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag2::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag2::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max2;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag2::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag2::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max2;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag2::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag2::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag2::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag2::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max2;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag2::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag2::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max2;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag2::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag2::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag3 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag3();
	//CustomDataUnicastTag3(uint32_t node_id);
	virtual ~CustomDataUnicastTag3();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max3+1];
	Vector m_acceleration[max3+1];
	Vector m_velocity[max3+1];
	Vector m_position[max3+1];
	Time m_timestamp[max3+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomDataUnicastTag");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag3);

CustomDataUnicastTag3::CustomDataUnicastTag3() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag3::CustomDataUnicastTag3(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag3::~CustomDataUnicastTag3() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag3::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag3")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag3> ();
  return tid;
}
TypeId CustomDataUnicastTag3::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag3::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag3::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max3+1) + (sizeof(double))*3*(max3+1) + (sizeof(double))*3*(max3+1) + (sizeof(double))*3*(max3+1) + (sizeof(double))*(max3+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag3::Serialize (TagBuffer i) const
{
	for(int j=0;j<max3;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max3;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max3;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max3;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max3;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag3::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max3;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max3;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max3;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max3;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max3;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag3::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag3::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag3::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max3;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag3::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag3::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max3;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag3::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag3::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag3::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag3::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max3;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag3::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag3::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max3;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag3::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag3::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag4 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag4();
	//CustomDataUnicastTag4(uint32_t node_id);
	virtual ~CustomDataUnicastTag4();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max4+1];
	Vector m_acceleration[max4+1];
	Vector m_velocity[max4+1];
	Vector m_position[max4+1];
	Time m_timestamp[max4+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomDataUnicastTag");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag4);

CustomDataUnicastTag4::CustomDataUnicastTag4() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag4::CustomDataUnicastTag4(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag4::~CustomDataUnicastTag4() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag4::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag4")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag4> ();
  return tid;
}
TypeId CustomDataUnicastTag4::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag4::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag4::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max4+1) + (sizeof(double))*3*(max4+1) + (sizeof(double))*3*(max4+1) + (sizeof(double))*3*(max4+1) + (sizeof(double))*(max4+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag4::Serialize (TagBuffer i) const
{
	for(int j=0;j<max4;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max4;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max4;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max4;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max4;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag4::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max4;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max4;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max4;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max4;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max4;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag4::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag4::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag4::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max4;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag4::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag4::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max4;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag4::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag4::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag4::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag4::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max4;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag4::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag4::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max4;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag4::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag4::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag5 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag5();
	//CustomDataUnicastTag5(uint32_t node_id);
	virtual ~CustomDataUnicastTag5();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max5+1];
	Vector m_acceleration[max5+1];
	Vector m_velocity[max5+1];
	Vector m_position[max5+1];
	Time m_timestamp[max5+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomDataUnicastTag5");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag5);

CustomDataUnicastTag5::CustomDataUnicastTag5() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag5::CustomDataUnicastTag5(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag5::~CustomDataUnicastTag5() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag5::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag5")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag5> ();
  return tid;
}
TypeId CustomDataUnicastTag5::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag5::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag5::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max5+1) + (sizeof(double))*3*(max5+1) + (sizeof(double))*3*(max5+1) + (sizeof(double))*3*(max5+1) + (sizeof(double))*(max5+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag5::Serialize (TagBuffer i) const
{
	for(int j=0;j<max5;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max5;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max5;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max5;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max5;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag5::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max5;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max5;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max5;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max5;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max5;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag5::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag5::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag5::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max5;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag5::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag5::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max5;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag5::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag5::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag5::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag5::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max5;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag5::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag5::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max5;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag5::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag5::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}


class CustomDataUnicastTag6 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag6();
	//CustomDataUnicastTag6(uint32_t node_id);
	virtual ~CustomDataUnicastTag6();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max+1];
	Vector m_acceleration[max+1];
	Vector m_velocity[max+1];
	Vector m_position[max+1];
	Time m_timestamp[max+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomDataUnicastTag");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag6);

CustomDataUnicastTag6::CustomDataUnicastTag6() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag6::CustomDataUnicastTag6(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag6::~CustomDataUnicastTag6() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag6::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag6")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag6> ();
  return tid;
}
TypeId CustomDataUnicastTag6::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag6::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag6::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max6+1) + (sizeof(double))*3*(max6+1) + (sizeof(double))*3*(max6+1) + (sizeof(double))*3*(max6+1) + (sizeof(double))*(max6+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag6::Serialize (TagBuffer i) const
{
	for(int j=0;j<max6;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max6;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max6;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max6;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max6;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag6::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max6;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max6;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max6;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max6;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max6;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag6::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag6::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag6::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max6;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag6::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag6::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max6;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag6::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag6::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag6::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag6::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max6;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag6::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag6::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max6;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag6::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag6::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag7 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag7();
	//CustomDataUnicastTag7(uint32_t node_id);
	virtual ~CustomDataUnicastTag7();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max7+1];
	Vector m_acceleration[max7+1];
	Vector m_velocity[max7+1];
	Vector m_position[max7+1];
	Time m_timestamp[max7+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomDataUnicastTag7");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag7);

CustomDataUnicastTag7::CustomDataUnicastTag7() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag7::CustomDataUnicastTag7(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag7::~CustomDataUnicastTag7() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag7::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag7")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag7> ();
  return tid;
}
TypeId CustomDataUnicastTag7::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag7::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag7::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max7+1) + (sizeof(double))*3*(max7+1) + (sizeof(double))*3*(max7+1) + (sizeof(double))*3*(max7+1) + (sizeof(double))*(max7+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag7::Serialize (TagBuffer i) const
{
	for(int j=0;j<max7;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max7;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max7;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max7;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max7;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag7::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max7;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max7;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max7;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max7;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max7;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag7::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag7::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag7::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max7;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag7::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag7::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max7;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag7::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag7::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag7::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag7::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max7;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag7::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag7::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max7;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag7::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag7::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag8 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag8();
	//CustomDataUnicastTag8(uint32_t node_id);
	virtual ~CustomDataUnicastTag8();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max8+1];
	Vector m_acceleration[max8+1];
	Vector m_velocity[max8+1];
	Vector m_position[max8+1];
	Time m_timestamp[max8+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomDataUnicastTag8");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag8);

CustomDataUnicastTag8::CustomDataUnicastTag8() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag8::CustomDataUnicastTag8(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag8::~CustomDataUnicastTag8() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag8::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag8")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag8> ();
  return tid;
}
TypeId CustomDataUnicastTag8::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag8::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag8::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max8+1) + (sizeof(double))*3*(max8+1) + (sizeof(double))*3*(max8+1) + (sizeof(double))*3*(max8+1) + (sizeof(double))*(max8+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag8::Serialize (TagBuffer i) const
{
	for(int j=0;j<max8;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max8;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max8;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max8;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max8;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag8::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max8;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max8;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max8;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max8;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max8;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag8::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag8::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag8::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max8;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag8::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag8::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max8;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag8::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag8::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag8::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag8::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max8;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag8::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag8::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max8;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag8::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag8::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}


class CustomDataUnicastTag9 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag9();
	//CustomDataUnicastTag9(uint32_t node_id);
	virtual ~CustomDataUnicastTag9();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max9+1];
	Vector m_acceleration[max9+1];
	Vector m_velocity[max9+1];
	Vector m_position[max9+1];
	Time m_timestamp[max9+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag9");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag9);

CustomDataUnicastTag9::CustomDataUnicastTag9() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag9::CustomDataUnicastTag9(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag9::~CustomDataUnicastTag9() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag9::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag9")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag9> ();
  return tid;
}
TypeId CustomDataUnicastTag9::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag9::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag9::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max9+1) + (sizeof(double))*3*(max9+1) + (sizeof(double))*3*(max9+1) + (sizeof(double))*3*(max9+1) + (sizeof(double))*(max9+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag9::Serialize (TagBuffer i) const
{
	for(int j=0;j<max9;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max9;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max9;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max9;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max9;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag9::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max9;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max9;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max9;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max9;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max9;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag9::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag9::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag9::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max9;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag9::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag9::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max9;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag9::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag9::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag9::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag9::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max9;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag9::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag9::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max9;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag9::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag9::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag10 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag10();
	//CustomDataUnicastTag(uint32_t node_id);
	virtual ~CustomDataUnicastTag10();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max10+1];
	Vector m_acceleration[max10+1];
	Vector m_velocity[max10+1];
	Vector m_position[max10+1];
	Time m_timestamp[max10+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag10);

CustomDataUnicastTag10::CustomDataUnicastTag10() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag10::CustomDataUnicastTag10(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag10::~CustomDataUnicastTag10() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag10::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag10")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag10> ();
  return tid;
}
TypeId CustomDataUnicastTag10::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag10::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag10::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max10+1) + (sizeof(double))*3*(max10+1) + (sizeof(double))*3*(max10+1) + (sizeof(double))*3*(max10+1) + (sizeof(double))*(max10+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag10::Serialize (TagBuffer i) const
{
	for(int j=0;j<max10;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max10;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max10;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max10;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max10;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag10::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max10;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max10;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max10;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max10;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max10;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag10::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag10::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag10::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max10;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag10::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag10::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max10;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag10::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag10::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag10::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag10::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max10;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag10::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag10::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max10;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag10::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag10::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag11 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag11();
	//CustomDataUnicastTag11(uint32_t node_id);
	virtual ~CustomDataUnicastTag11();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max11+1];
	Vector m_acceleration[max11+1];
	Vector m_velocity[max11+1];
	Vector m_position[max11+1];
	Time m_timestamp[max11+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag11");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag11);

CustomDataUnicastTag11::CustomDataUnicastTag11() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag11::CustomDataUnicastTag11(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag11::~CustomDataUnicastTag11() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag11::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag11")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag11> ();
  return tid;
}
TypeId CustomDataUnicastTag11::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag11::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag11::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max11+1) + (sizeof(double))*3*(max11+1) + (sizeof(double))*3*(max11+1) + (sizeof(double))*3*(max11+1) + (sizeof(double))*(max11+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag11::Serialize (TagBuffer i) const
{
	for(int j=0;j<max11;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max11;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max11;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max11;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max11;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag11::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max11;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max11;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max11;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max11;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max11;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag11::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag11::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag11::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max11;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag11::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag11::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max11;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag11::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag11::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag11::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag11::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max11;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag11::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag11::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max11;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag11::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag11::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}


class CustomDataUnicastTag12 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag12();
	//CustomDataUnicastTag12(uint32_t node_id);
	virtual ~CustomDataUnicastTag12();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max12+1];
	Vector m_acceleration[max12+1];
	Vector m_velocity[max12+1];
	Vector m_position[max12+1];
	Time m_timestamp[max12+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag12");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag12);

CustomDataUnicastTag12::CustomDataUnicastTag12() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag12::CustomDataUnicastTag12(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag12::~CustomDataUnicastTag12() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag12::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag12")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag12> ();
  return tid;
}
TypeId CustomDataUnicastTag12::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag12::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag12::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max12+1) + (sizeof(double))*3*(max12+1) + (sizeof(double))*3*(max12+1) + (sizeof(double))*3*(max12+1) + (sizeof(double))*(max12+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag12::Serialize (TagBuffer i) const
{
	for(int j=0;j<max12;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max12;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max12;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max12;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max12;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag12::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max12;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max12;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max12;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max12;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max12;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag12::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag12::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag12::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max12;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag12::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag12::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max12;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag12::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag12::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag12::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag12::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max12;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag12::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag12::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max12;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}


uint32_t CustomDataUnicastTag12::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag12::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}


class CustomDataUnicastTag13 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag13();
	//CustomDataUnicastTag13(uint32_t node_id);
	virtual ~CustomDataUnicastTag13();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max13+1];
	Vector m_acceleration[max13+1];
	Vector m_velocity[max13+1];
	Vector m_position[max13+1];
	Time m_timestamp[max13+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag13");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag13);

CustomDataUnicastTag13::CustomDataUnicastTag13() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag13::CustomDataUnicastTag13(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag13::~CustomDataUnicastTag13() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag13::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag13")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag13> ();
  return tid;
}
TypeId CustomDataUnicastTag13::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag13::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag13::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max13+1) + (sizeof(double))*3*(max13+1) + (sizeof(double))*3*(max13+1) + (sizeof(double))*3*(max13+1) + (sizeof(double))*(max13+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag13::Serialize (TagBuffer i) const
{
	for(int j=0;j<max13;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max13;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max13;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max13;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max13;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag13::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max13;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max13;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max13;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max13;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max13;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag13::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag13::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag13::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max13;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag13::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag13::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max13;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag13::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag13::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag13::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag13::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max13;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag13::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag13::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max13;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag13::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag13::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag14 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag14();
	//CustomDataUnicastTag14(uint32_t node_id);
	virtual ~CustomDataUnicastTag14();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max14+1];
	Vector m_acceleration[max14+1];
	Vector m_velocity[max14+1];
	Vector m_position[max14+1];
	Time m_timestamp[max14+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag14");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag14);

CustomDataUnicastTag14::CustomDataUnicastTag14() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag14::CustomDataUnicastTag14(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag14::~CustomDataUnicastTag14() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag14::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag14")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag14> ();
  return tid;
}
TypeId CustomDataUnicastTag14::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag14::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag14::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max14+1) + (sizeof(double))*3*(max14+1) + (sizeof(double))*3*(max14+1) + (sizeof(double))*3*(max14+1) + (sizeof(double))*(max14+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag14::Serialize (TagBuffer i) const
{
	for(int j=0;j<max14;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max14;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max14;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max14;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max14;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag14::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max14;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max14;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max14;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max14;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max14;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag14::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag14::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag14::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max14;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag14::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag14::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max14;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag14::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag14::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag14::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag14::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max14;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag14::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag14::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max14;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag14::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag14::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag15 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag15();
	//CustomDataUnicastTag15(uint32_t node_id);
	virtual ~CustomDataUnicastTag15();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max15+1];
	Vector m_acceleration[max15+1];
	Vector m_velocity[max15+1];
	Vector m_position[max15+1];
	Time m_timestamp[max15+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag15);

CustomDataUnicastTag15::CustomDataUnicastTag15() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag15::CustomDataUnicastTag15(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag15::~CustomDataUnicastTag15() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag15::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag15")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag15> ();
  return tid;
}
TypeId CustomDataUnicastTag15::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag15::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag15::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max15+1) + (sizeof(double))*3*(max15+1) + (sizeof(double))*3*(max15+1) + (sizeof(double))*3*(max15+1) + (sizeof(double))*(max15+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag15::Serialize (TagBuffer i) const
{
	for(int j=0;j<max15;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max15;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max15;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max15;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max15;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag15::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max15;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max15;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max15;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max15;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max15;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag15::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag15::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag15::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max15;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag15::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag15::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max15;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag15::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag15::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag15::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag15::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max15;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag15::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag15::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max15;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag15::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag15::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}


class CustomDataUnicastTag16 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag16();
	//CustomDataUnicastTag16(uint32_t node_id);
	virtual ~CustomDataUnicastTag16();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max16+1];
	Vector m_acceleration[max16+1];
	Vector m_velocity[max16+1];
	Vector m_position[max16+1];
	Time m_timestamp[max16+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag16);

CustomDataUnicastTag16::CustomDataUnicastTag16() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag16::CustomDataUnicastTag16(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag16::~CustomDataUnicastTag16() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag16::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag16")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag16> ();
  return tid;
}
TypeId CustomDataUnicastTag16::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag16::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag16::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max16+1) + (sizeof(double))*3*(max16+1) + (sizeof(double))*3*(max16+1) + (sizeof(double))*3*(max16+1) + (sizeof(double))*(max16+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag16::Serialize (TagBuffer i) const
{
	for(int j=0;j<max16;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max16;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max16;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max16;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max16;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag16::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max16;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max16;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max16;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max16;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max16;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag16::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag16::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag16::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max16;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag16::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag16::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max16;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag16::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag16::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag16::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag16::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max16;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag16::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag16::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max16;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag16::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag16::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag17 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag17();
	//CustomDataUnicastTag17(uint32_t node_id);
	virtual ~CustomDataUnicastTag17();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max17+1];
	Vector m_acceleration[max17+1];
	Vector m_velocity[max17+1];
	Vector m_position[max17+1];
	Time m_timestamp[max17+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag17);

CustomDataUnicastTag17::CustomDataUnicastTag17() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag17::CustomDataUnicastTag17(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag17::~CustomDataUnicastTag17() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag17::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag17")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag17> ();
  return tid;
}
TypeId CustomDataUnicastTag17::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag17::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag17::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max17+1) + (sizeof(double))*3*(max17+1) + (sizeof(double))*3*(max17+1) + (sizeof(double))*3*(max17+1) + (sizeof(double))*(max17+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag17::Serialize (TagBuffer i) const
{
	for(int j=0;j<max17;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max17;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max17;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max17;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max17;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag17::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max17;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max17;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max17;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max17;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max17;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag17::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag17::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag17::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max17;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag17::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag17::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max17;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag17::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag17::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag17::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag17::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max17;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag17::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag17::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max17;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag17::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag17::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag18 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag18();
	//CustomDataUnicastTag18(uint32_t node_id);
	virtual ~CustomDataUnicastTag18();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max18+1];
	Vector m_acceleration[max18+1];
	Vector m_velocity[max18+1];
	Vector m_position[max18+1];
	Time m_timestamp[max18+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag18);

CustomDataUnicastTag18::CustomDataUnicastTag18() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag18::CustomDataUnicastTag18(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag18::~CustomDataUnicastTag18() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag18::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag18")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag18> ();
  return tid;
}
TypeId CustomDataUnicastTag18::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag18::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag18::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max18+1) + (sizeof(double))*3*(max18+1) + (sizeof(double))*3*(max18+1) + (sizeof(double))*3*(max18+1) + (sizeof(double))*(max18+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag18::Serialize (TagBuffer i) const
{
	for(int j=0;j<max18;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max18;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max18;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max18;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max18;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag18::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max18;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max18;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max18;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max18;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max18;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag18::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag18::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag18::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max18;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag18::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag18::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max18;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag18::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag18::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag18::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag18::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max18;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag18::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag18::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max18;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag18::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag18::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}


class CustomDataUnicastTag19 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag19();
	//CustomDataUnicastTag19(uint32_t node_id);
	virtual ~CustomDataUnicastTag19();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max19+1];
	Vector m_acceleration[max19+1];
	Vector m_velocity[max19+1];
	Vector m_position[max19+1];
	Time m_timestamp[max19+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag19);

CustomDataUnicastTag19::CustomDataUnicastTag19() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag19::CustomDataUnicastTag19(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag19::~CustomDataUnicastTag19() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag19::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag19")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag19> ();
  return tid;
}
TypeId CustomDataUnicastTag19::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag19::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag19::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max19+1) + (sizeof(double))*3*(max19+1) + (sizeof(double))*3*(max19+1) + (sizeof(double))*3*(max19+1) + (sizeof(double))*(max19+1)+ sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag19::Serialize (TagBuffer i) const
{
	for(int j=0;j<max19;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max19;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max19;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max19;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max19;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag19::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max19;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max19;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max19;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max19;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max19;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag19::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag19::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag19::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max19;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag19::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag19::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max19;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag19::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag19::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag19::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag19::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max19;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag19::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag19::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max19;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag19::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag19::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag20 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag20();
	//CustomDataUnicastTag20(uint32_t node_id);
	virtual ~CustomDataUnicastTag20();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max20+1];
	Vector m_acceleration[max20+1];
	Vector m_velocity[max20+1];
	Vector m_position[max20+1];
	Time m_timestamp[max20+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag20);

CustomDataUnicastTag20::CustomDataUnicastTag20() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag20::CustomDataUnicastTag20(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag20::~CustomDataUnicastTag20() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag20::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag20")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag20> ();
  return tid;
}
TypeId CustomDataUnicastTag20::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag20::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag20::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max20+1) + (sizeof(double))*3*(max20+1) + (sizeof(double))*3*(max20+1) + (sizeof(double))*3*(max20+1) + (sizeof(double))*(max20+1) + sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag20::Serialize (TagBuffer i) const
{
	for(int j=0;j<max20;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max20;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max20;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max20;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max20;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag20::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max20;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max20;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max20;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max20;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max20;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag20::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag20::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag20::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max20;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag20::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag20::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max20;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag20::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag20::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag20::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag20::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max20;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag20::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag20::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max20;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag20::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag20::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}



class CustomDataUnicastTag21 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag21();
	//CustomDataUnicastTag21(uint32_t node_id);
	virtual ~CustomDataUnicastTag21();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max21+1];
	Vector m_acceleration[max21+1];
	Vector m_velocity[max21+1];
	Vector m_position[max21+1];
	Time m_timestamp[max21+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag21);

CustomDataUnicastTag21::CustomDataUnicastTag21() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag21::CustomDataUnicastTag21(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag21::~CustomDataUnicastTag21() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag21::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag21")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag21> ();
  return tid;
}
TypeId CustomDataUnicastTag21::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag21::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag21::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max21+1) + (sizeof(double))*3*(max21+1) + (sizeof(double))*3*(max21+1) + (sizeof(double))*3*(max21+1) + (sizeof(double))*(max21+1) + sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag21::Serialize (TagBuffer i) const
{
	for(int j=0;j<max21;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max21;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max21;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max21;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max21;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag21::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max21;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max21;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max21;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max21;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max21;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag21::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag21::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag21::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max21;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag21::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag21::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max21;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag21::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag21::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag21::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag21::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max21;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag21::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag21::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max21;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag21::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag21::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}


class CustomDataUnicastTag22 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag22();
	//CustomDataUnicastTag22(uint32_t node_id);
	virtual ~CustomDataUnicastTag22();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max22+1];
	Vector m_acceleration[max22+1];
	Vector m_velocity[max22+1];
	Vector m_position[max22+1];
	Time m_timestamp[max22+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag22);

CustomDataUnicastTag22::CustomDataUnicastTag22() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag22::CustomDataUnicastTag22(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag22::~CustomDataUnicastTag22() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag22::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag22")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag22> ();
  return tid;
}
TypeId CustomDataUnicastTag22::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag22::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag22::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max22+1) + (sizeof(double))*3*(max22+1) + (sizeof(double))*3*(max22+1) + (sizeof(double))*3*(max22+1) + (sizeof(double))*(max22+1) + sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag22::Serialize (TagBuffer i) const
{
	for(int j=0;j<max22;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max22;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max22;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max22;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max22;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag22::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max22;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max22;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max22;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max22;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max22;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag22::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag22::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag22::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max22;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag22::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag22::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max22;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag22::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag22::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag22::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag22::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max22;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag22::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag22::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max22;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag22::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag22::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}


class CustomDataUnicastTag23 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag23();
	//CustomDataUnicastTag23(uint32_t node_id);
	virtual ~CustomDataUnicastTag23();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max23+1];
	Vector m_acceleration[max23+1];
	Vector m_velocity[max23+1];
	Vector m_position[max23+1];
	Time m_timestamp[max23+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag23);

CustomDataUnicastTag23::CustomDataUnicastTag23() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag23::CustomDataUnicastTag23(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag23::~CustomDataUnicastTag23() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag23::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag23")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag23> ();
  return tid;
}
TypeId CustomDataUnicastTag23::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag23::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag23::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max23+1) + (sizeof(double))*3*(max23+1) + (sizeof(double))*3*(max23+1) + (sizeof(double))*3*(max23+1) + (sizeof(double))*(max23+1) + sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag23::Serialize (TagBuffer i) const
{
	for(int j=0;j<max23;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max23;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max23;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max23;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max23;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag23::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max23;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max23;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max23;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max23;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max23;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag23::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag23::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag23::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max23;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag23::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag23::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max23;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag23::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag23::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag23::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag23::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max23;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag23::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag23::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max23;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag23::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag23::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}


class CustomDataUnicastTag24 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag24();
	//CustomDataUnicastTag24(uint32_t node_id);
	virtual ~CustomDataUnicastTag24();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max24+1];
	Vector m_acceleration[max24+1];
	Vector m_velocity[max24+1];
	Vector m_position[max24+1];
	Time m_timestamp[max24+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag24);

CustomDataUnicastTag24::CustomDataUnicastTag24() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag24::CustomDataUnicastTag24(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag24::~CustomDataUnicastTag24() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag24::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag24")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag24> ();
  return tid;
}
TypeId CustomDataUnicastTag24::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag24::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag24::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max24+1) + (sizeof(double))*3*(max24+1) + (sizeof(double))*3*(max24+1) + (sizeof(double))*3*(max24+1) + (sizeof(double))*(max24+1) + sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag24::Serialize (TagBuffer i) const
{
	for(int j=0;j<max24;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max24;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max24;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max24;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max24;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag24::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max24;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max24;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max24;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max24;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max24;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag24::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag24::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag24::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max24;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag24::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag24::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max24;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag24::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag24::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag24::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag24::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max24;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag24::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag24::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max24;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag24::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag24::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomDataUnicastTag25 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * GetNodeId();
	Vector * Getacceleration();
	Vector * Getvelocity();
	Vector * Getposition();
	Time * GetTimestamp();
	uint32_t GetsenderId();

	void SetsenderId(uint32_t sender_id);
	void SetNodeId (uint32_t * node_id);
	void Setacceleration (Vector * accn);
	void Setvelocity (Vector * vel);
	void Setposition (Vector * pos);
	void SetTimestamp (Time * time);

	CustomDataUnicastTag25();
	//CustomDataUnicastTag25(uint32_t node_id);
	virtual ~CustomDataUnicastTag25();
private:
	uint32_t m_senderId;
	uint32_t m_nodeId[max25+1];
	Vector m_acceleration[max25+1];
	Vector m_velocity[max25+1];
	Vector m_position[max25+1];
	Time m_timestamp[max25+1];
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomDataUnicastTag25);

CustomDataUnicastTag25::CustomDataUnicastTag25() {
	//m_timestamp = Simulator::Now();
	//m_nodeId = -1;
}
/*
CustomDataUnicastTag25::CustomDataUnicastTag25(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}
*/

CustomDataUnicastTag25::~CustomDataUnicastTag25() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDataUnicastTag25::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDataUnicastTag25")
    .SetParent<Tag> ()
    .AddConstructor<CustomDataUnicastTag25> ();
  return tid;
}
TypeId CustomDataUnicastTag25::GetInstanceTypeId (void) const
{
  return CustomDataUnicastTag25::GetTypeId ();
}

 
uint32_t CustomDataUnicastTag25::GetSerializedSize (void) const
{
	//return sizeof (m_nodeId) + sizeof(m_acceleration) + sizeof(m_velocity) + sizeof(m_position) + sizeof(m_timestamp) + sizeof(uint32_t);
	return (sizeof (uint32_t))*(max25+1) + (sizeof(double))*3*(max25+1) + (sizeof(double))*3*(max25+1) + (sizeof(double))*3*(max25+1) + (sizeof(double))*(max25+1) + sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDataUnicastTag25::Serialize (TagBuffer i) const
{
	for(int j=0;j<max25;j++)
	{
		i.WriteU32(m_nodeId[j]);
	}
	for(int j=0;j<max25;j++)
	{
		i.WriteDouble(m_acceleration[j].x);
		i.WriteDouble(m_acceleration[j].y);
		i.WriteDouble(m_acceleration[j].z);
	}
	for(int j=0;j<max25;j++)
	{
		i.WriteDouble(m_velocity[j].x);
		i.WriteDouble(m_velocity[j].y);
		i.WriteDouble(m_velocity[j].z);
	}
	for(int j=0;j<max25;j++)
	{
		i.WriteDouble(m_position[j].x);
		i.WriteDouble(m_position[j].y);
		i.WriteDouble(m_position[j].z);
	}
	for(int j=0;j<max25;j++)
	{
		i.WriteDouble(m_timestamp[j].GetDouble());
	}
	i.WriteU32(m_senderId);

}



void CustomDataUnicastTag25::Deserialize (TagBuffer i)
{
	
	for(int j=0;j<max25;j++)
	{
		m_nodeId[j] = i.ReadU32();
	}
	
	for(int j=0;j<max25;j++)
	{
		m_acceleration[j].x = i.ReadDouble();
		m_acceleration[j].y = i.ReadDouble();
		m_acceleration[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max25;j++)
	{
		m_velocity[j].x = i.ReadDouble();
		m_velocity[j].y = i.ReadDouble();
		m_velocity[j].z = i.ReadDouble();
	}
	
	for(int j=0;j<max25;j++)
	{
		m_position[j].x = i.ReadDouble();
		m_position[j].y = i.ReadDouble();
		m_position[j].z = i.ReadDouble();
	}
	
	
	for(int j=0;j<max25;j++)
	{
		m_timestamp[j] =  Time::FromDouble (i.ReadDouble(), Time::NS);
	}
	m_senderId = i.ReadU32();
}




void CustomDataUnicastTag25::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t * CustomDataUnicastTag25::GetNodeId() {
	return m_nodeId;
}

void CustomDataUnicastTag25::SetNodeId(uint32_t * node_id) {
	for(uint32_t i=0;i<max25;i++)
	{
		m_nodeId[i] = *(node_id+i);
	}
}


Vector * CustomDataUnicastTag25::Getacceleration()
{
	return m_acceleration;
}

void CustomDataUnicastTag25::Setacceleration (Vector * accn)
{
	for(uint32_t i=0;i<max25;i++)
	{
		m_acceleration[i].x = accn[i].x;
		m_acceleration[i].y = accn[i].y;
		m_acceleration[i].z = accn[i].z;
	}
}

Vector * CustomDataUnicastTag25::Getvelocity()
{
	return m_velocity;
}

void CustomDataUnicastTag25::Setvelocity (Vector * vel)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_velocity[i].x = vel[i].x;
		m_velocity[i].y = vel[i].y;
		m_velocity[i].z = vel[i].z;
	}
}

Vector * CustomDataUnicastTag25::Getposition()
{
	return m_position;
}

void CustomDataUnicastTag25::Setposition (Vector * pos)
{
	for(uint32_t i=0;i<max25;i++)
	{
		m_position[i].x = pos[i].x;
		m_position[i].y = pos[i].y;
		m_position[i].z = pos[i].z;
	}
}


Time * CustomDataUnicastTag25::GetTimestamp() {
	return m_timestamp;
}

void CustomDataUnicastTag25::SetTimestamp(Time * ti) {
	
	for(uint32_t i=0;i<max25;i++)
	{
		m_timestamp[i] = *(ti+i);
	}
}

uint32_t CustomDataUnicastTag25::GetsenderId()
{	
	return m_senderId;
}

void CustomDataUnicastTag25::SetsenderId(uint32_t sender_id)
{
	m_senderId = sender_id;
}

class CustomMetaDataUnicastTag : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag();
	CustomMetaDataUnicastTag(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag);

CustomMetaDataUnicastTag::CustomMetaDataUnicastTag() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag::CustomMetaDataUnicastTag(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag::~CustomMetaDataUnicastTag() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


class CustomMetaDataUnicastTag0 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);


	CustomMetaDataUnicastTag0();
	CustomMetaDataUnicastTag0(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag0();
private:

	uint32_t m_nodeId;
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag0");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag0);

CustomMetaDataUnicastTag0::CustomMetaDataUnicastTag0() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag0::CustomMetaDataUnicastTag0(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag0::~CustomMetaDataUnicastTag0() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag0::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag0")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag0> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag0::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag0::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag0::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag0::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag0::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag0::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag0::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag0::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag0::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag0::SetTimestamp(Time t) {
	m_timestamp = t;
}


class CustomMetaDataUnicastTag1 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag1();
	CustomMetaDataUnicastTag1(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag1();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max1+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag1");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag1);

CustomMetaDataUnicastTag1::CustomMetaDataUnicastTag1() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag1::CustomMetaDataUnicastTag1(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag1::~CustomMetaDataUnicastTag1() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag1::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag1")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag1> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag1::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag1::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag1::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag1::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag1::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag1::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag1::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag1::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag1::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag1::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag1::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag1::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


class CustomMetaDataUnicastTag2 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag2();
	CustomMetaDataUnicastTag2(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag2();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max2+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag2");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag2);

CustomMetaDataUnicastTag2::CustomMetaDataUnicastTag2() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag2::CustomMetaDataUnicastTag2(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag2::~CustomMetaDataUnicastTag2() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag2::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag2")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag2> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag2::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag2::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag2::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag2::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag2::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag2::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag2::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag2::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag2::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag2::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag2::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag2::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


class CustomMetaDataUnicastTag3 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag3();
	CustomMetaDataUnicastTag3(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag3();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max3+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag3");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag3);

CustomMetaDataUnicastTag3::CustomMetaDataUnicastTag3() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag3::CustomMetaDataUnicastTag3(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag3::~CustomMetaDataUnicastTag3() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag3::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag3")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag3> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag3::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag3::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag3::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag3::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag3::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag3::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag3::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag3::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag3::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag3::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag3::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag3::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


class CustomMetaDataUnicastTag4 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag4();
	CustomMetaDataUnicastTag4(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag4();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max4+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag4");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag4);

CustomMetaDataUnicastTag4::CustomMetaDataUnicastTag4() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag4::CustomMetaDataUnicastTag4(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag4::~CustomMetaDataUnicastTag4() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag4::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag4")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag4> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag4::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag4::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag4::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag4::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag4::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag4::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag4::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag4::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag4::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag4::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag4::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag4::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


class CustomMetaDataUnicastTag5 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag5();
	CustomMetaDataUnicastTag5(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag5();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max5+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag5");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag5);

CustomMetaDataUnicastTag5::CustomMetaDataUnicastTag5() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag5::CustomMetaDataUnicastTag5(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag5::~CustomMetaDataUnicastTag5() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag5::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag5")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag5> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag5::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag5::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag5::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag5::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag5::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag5::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag5::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag5::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag5::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag5::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag5::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag5::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


class CustomMetaDataUnicastTag6 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag6();
	CustomMetaDataUnicastTag6(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag6();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max6+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag6");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag6);

CustomMetaDataUnicastTag6::CustomMetaDataUnicastTag6() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag6::CustomMetaDataUnicastTag6(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag6::~CustomMetaDataUnicastTag6() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag6::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag6")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag6> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag6::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag6::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag6::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag6::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag6::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag6::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag6::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag6::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag6::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag6::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag6::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag6::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


class CustomMetaDataUnicastTag7 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag7();
	CustomMetaDataUnicastTag7(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag7();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max7+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag7");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag7);

CustomMetaDataUnicastTag7::CustomMetaDataUnicastTag7() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag7::CustomMetaDataUnicastTag7(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag7::~CustomMetaDataUnicastTag7() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag7::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag7")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag7> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag7::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag7::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag7::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag7::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag7::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag7::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag7::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag7::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag7::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag7::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag7::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag7::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

class CustomMetaDataUnicastTag8 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag8();
	CustomMetaDataUnicastTag8(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag8();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max8+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag8");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag8);

CustomMetaDataUnicastTag8::CustomMetaDataUnicastTag8() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag8::CustomMetaDataUnicastTag8(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag8::~CustomMetaDataUnicastTag8() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag8::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag8")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag8> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag8::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag8::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag8::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag8::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag8::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag8::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag8::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag8::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag8::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag8::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag8::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag8::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

class CustomMetaDataUnicastTag9 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag9();
	CustomMetaDataUnicastTag9(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag9();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max9+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag9");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag9);

CustomMetaDataUnicastTag9::CustomMetaDataUnicastTag9() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag9::CustomMetaDataUnicastTag9(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag9::~CustomMetaDataUnicastTag9() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag9::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag9")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag9> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag9::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag9::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag9::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag9::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag9::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag9::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag9::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag9::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag9::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag9::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag9::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag9::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

class CustomMetaDataUnicastTag10 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag10();
	CustomMetaDataUnicastTag10(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag10();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max10+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag10");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag10);

CustomMetaDataUnicastTag10::CustomMetaDataUnicastTag10() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag10::CustomMetaDataUnicastTag10(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag10::~CustomMetaDataUnicastTag10() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag10::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag10")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag10> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag10::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag10::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag10::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag10::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag10::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag10::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag10::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag10::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag10::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag10::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag10::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag10::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

class CustomMetaDataUnicastTag11 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag11();
	CustomMetaDataUnicastTag11(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag11();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max11+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag11");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag11);

CustomMetaDataUnicastTag11::CustomMetaDataUnicastTag11() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag11::CustomMetaDataUnicastTag11(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag11::~CustomMetaDataUnicastTag11() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag11::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag11")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag11> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag11::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag11::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag11::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag11::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag11::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag11::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag11::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag11::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag11::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag11::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag11::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag11::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

class CustomMetaDataUnicastTag12 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag12();
	CustomMetaDataUnicastTag12(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag12();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max12+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag12");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag12);

CustomMetaDataUnicastTag12::CustomMetaDataUnicastTag12() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag12::CustomMetaDataUnicastTag12(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag12::~CustomMetaDataUnicastTag12() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag12::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag12")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag12> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag12::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag12::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag12::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag12::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag12::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag12::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag12::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag12::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag12::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag12::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag12::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag12::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

class CustomMetaDataUnicastTag13 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag13();
	CustomMetaDataUnicastTag13(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag13();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max13+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag13");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag13);

CustomMetaDataUnicastTag13::CustomMetaDataUnicastTag13() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag13::CustomMetaDataUnicastTag13(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag13::~CustomMetaDataUnicastTag13() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag13::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag13")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag13> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag13::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag13::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag13::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag13::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag13::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag13::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag13::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag13::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag13::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag13::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag13::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag13::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

class CustomMetaDataUnicastTag14 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag14();
	CustomMetaDataUnicastTag14(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag14();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max14+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag14");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag14);

CustomMetaDataUnicastTag14::CustomMetaDataUnicastTag14() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag14::CustomMetaDataUnicastTag14(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag14::~CustomMetaDataUnicastTag14() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag14::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag14")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag14> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag14::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag14::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag14::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag14::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag14::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag14::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag14::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag14::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag14::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag14::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag14::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag14::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

class CustomMetaDataUnicastTag15 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag15();
	CustomMetaDataUnicastTag15(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag15();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max15+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag15);

CustomMetaDataUnicastTag15::CustomMetaDataUnicastTag15() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag15::CustomMetaDataUnicastTag15(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag15::~CustomMetaDataUnicastTag15() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag15::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag15")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag15> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag15::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag15::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag15::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag15::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag15::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag15::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag15::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag15::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag15::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag15::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag15::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag15::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


class CustomMetaDataUnicastTag16 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag16();
	CustomMetaDataUnicastTag16(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag16();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max16+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag16);

CustomMetaDataUnicastTag16::CustomMetaDataUnicastTag16() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag16::CustomMetaDataUnicastTag16(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag16::~CustomMetaDataUnicastTag16() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag16::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag16")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag16> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag16::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag16::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag16::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag16::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag16::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag16::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag16::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag16::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag16::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag16::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag16::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag16::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

class CustomMetaDataUnicastTag17 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag17();
	CustomMetaDataUnicastTag17(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag17();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max17+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag17);

CustomMetaDataUnicastTag17::CustomMetaDataUnicastTag17() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag17::CustomMetaDataUnicastTag17(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag17::~CustomMetaDataUnicastTag17() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag17::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag17")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag17> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag17::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag17::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag17::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag17::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag17::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag17::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag17::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag17::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag17::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag17::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag17::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag17::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

class CustomMetaDataUnicastTag18 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag18();
	CustomMetaDataUnicastTag18(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag18();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max18+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag18);

CustomMetaDataUnicastTag18::CustomMetaDataUnicastTag18() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag18::CustomMetaDataUnicastTag18(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag18::~CustomMetaDataUnicastTag18() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag18::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag18")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag18> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag18::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag18::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag18::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag18::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag18::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag18::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag18::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag18::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag18::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag18::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag18::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag18::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

class CustomMetaDataUnicastTag19 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag19();
	CustomMetaDataUnicastTag19(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag19();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max19+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag19);

CustomMetaDataUnicastTag19::CustomMetaDataUnicastTag19() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag19::CustomMetaDataUnicastTag19(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag19::~CustomMetaDataUnicastTag19() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag19::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag19")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag19> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag19::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag19::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag19::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag19::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag19::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag19::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag19::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag19::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag19::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag19::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag19::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag19::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

class CustomMetaDataUnicastTag20 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag20();
	CustomMetaDataUnicastTag20(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag20();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max20+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag20);

CustomMetaDataUnicastTag20::CustomMetaDataUnicastTag20() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag20::CustomMetaDataUnicastTag20(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag20::~CustomMetaDataUnicastTag20() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag20::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag20")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag20> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag20::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag20::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag20::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag20::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag20::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag20::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag20::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag20::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag20::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag20::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag20::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag20::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}



class CustomMetaDataUnicastTag21 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag21();
	CustomMetaDataUnicastTag21(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag21();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max21+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag21);

CustomMetaDataUnicastTag21::CustomMetaDataUnicastTag21() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag21::CustomMetaDataUnicastTag21(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag21::~CustomMetaDataUnicastTag21() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag21::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag21")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag21> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag21::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag21::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag21::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag21::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag21::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag21::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag21::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag21::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag21::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag21::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag21::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag21::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}



class CustomMetaDataUnicastTag22 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag22();
	CustomMetaDataUnicastTag22(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag22();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max22+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag22);

CustomMetaDataUnicastTag22::CustomMetaDataUnicastTag22() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag22::CustomMetaDataUnicastTag22(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag22::~CustomMetaDataUnicastTag22() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag22::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag22")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag22> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag22::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag22::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag22::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag22::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag22::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag22::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag22::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag22::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag22::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag22::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag22::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag22::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}



class CustomMetaDataUnicastTag23 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag23();
	CustomMetaDataUnicastTag23(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag23();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max23+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag23);

CustomMetaDataUnicastTag23::CustomMetaDataUnicastTag23() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag23::CustomMetaDataUnicastTag23(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag23::~CustomMetaDataUnicastTag23() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag23::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag23")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag23> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag23::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag23::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag23::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag23::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag23::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag23::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag23::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag23::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag23::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag23::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag23::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag23::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


class CustomMetaDataUnicastTag24 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag24();
	CustomMetaDataUnicastTag24(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag24();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max24+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag24);

CustomMetaDataUnicastTag24::CustomMetaDataUnicastTag24() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag24::CustomMetaDataUnicastTag24(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag24::~CustomMetaDataUnicastTag24() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag24::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag24")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag24> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag24::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag24::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag24::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag24::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag24::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag24::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag24::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag24::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag24::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag24::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag24::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag24::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


class CustomMetaDataUnicastTag25 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	uint32_t * Getneighborid();
	Time GetTimestamp ();

	void SetNodeId (uint32_t node_id);
	void SetTimestamp (Time t);
	void Setneighborid (uint32_t * neighborid);


	CustomMetaDataUnicastTag25();
	CustomMetaDataUnicastTag25(uint32_t node_id);
	virtual ~CustomMetaDataUnicastTag25();
private:

	uint32_t m_nodeId;
	uint32_t m_neighborid[max25+1];
	Time m_timestamp;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataBroadcastTag15");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTag25);

CustomMetaDataUnicastTag25::CustomMetaDataUnicastTag25() {
	m_timestamp = Simulator::Now();
	m_nodeId = -1;
}
CustomMetaDataUnicastTag25::CustomMetaDataUnicastTag25(uint32_t node_id) {
	m_timestamp = Simulator::Now();
	m_nodeId = node_id;
}

CustomMetaDataUnicastTag25::~CustomMetaDataUnicastTag25() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTag25::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTag25")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTag25> ();
  return tid;
}
TypeId CustomMetaDataUnicastTag25::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTag25::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTag25::GetSerializedSize (void) const
{
	return sizeof (ns3::Time) + sizeof(uint32_t) + sizeof(m_neighborid);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTag25::Serialize (TagBuffer i) const
{
	//we store timestamp first
	i.WriteDouble(m_timestamp.GetDouble());
	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeId);
}



void CustomMetaDataUnicastTag25::Deserialize (TagBuffer i)
{
	m_timestamp =  Time::FromDouble (i.ReadDouble(), Time::NS);;
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeId = i.ReadU32();

}




void CustomMetaDataUnicastTag25::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t(" << m_timestamp  << ")";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataUnicastTag25::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataUnicastTag25::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


Time CustomMetaDataUnicastTag25::GetTimestamp() {
	return m_timestamp;
}

void CustomMetaDataUnicastTag25::SetTimestamp(Time t) {
	m_timestamp = t;
}

uint32_t * CustomMetaDataUnicastTag25::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTag25::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}



class CustomMetaDataUnicastTagN01max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN01max();
	virtual ~CustomMetaDataUnicastTagN01max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN01max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN01max);

CustomMetaDataUnicastTagN01max::CustomMetaDataUnicastTagN01max() {

}


CustomMetaDataUnicastTagN01max::~CustomMetaDataUnicastTagN01max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN01max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN01max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN01max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN01max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN01max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN01max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN01max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN01max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN01max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN01max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN01max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN01max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN01max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN011 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN011();
	virtual ~CustomMetaDataUnicastTagN011();
private:

	uint32_t m_neighborid[max1+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN011");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN011);

CustomMetaDataUnicastTagN011::CustomMetaDataUnicastTagN011() {
}


CustomMetaDataUnicastTagN011::~CustomMetaDataUnicastTagN011() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN011::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN011")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN011> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN011::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN011::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN011::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN011::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN011::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN011::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN011::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN011::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN011::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN011::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN012 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN012();
	virtual ~CustomMetaDataUnicastTagN012();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN012");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN012);

CustomMetaDataUnicastTagN012::CustomMetaDataUnicastTagN012() {

}


CustomMetaDataUnicastTagN012::~CustomMetaDataUnicastTagN012() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN012::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN012")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN012> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN012::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN012::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN012::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN012::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN012::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN012::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN012::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN012::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN012::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN012::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN013 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN013();
	virtual ~CustomMetaDataUnicastTagN013();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN013");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN013);

CustomMetaDataUnicastTagN013::CustomMetaDataUnicastTagN013() {

}


CustomMetaDataUnicastTagN013::~CustomMetaDataUnicastTagN013() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN013::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN013")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN013> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN013::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN013::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN013::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN013::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN013::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN013::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN013::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN013::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN013::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN013::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN014 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN014();
	virtual ~CustomMetaDataUnicastTagN014();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN014");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN014);

CustomMetaDataUnicastTagN014::CustomMetaDataUnicastTagN014() {
	
}


CustomMetaDataUnicastTagN014::~CustomMetaDataUnicastTagN014() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN014::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN014")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN014> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN014::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN014::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN014::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN014::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN014::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN014::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN014::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN014::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN014::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN014::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN015 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN015();
	virtual ~CustomMetaDataUnicastTagN015();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN015");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN015);

CustomMetaDataUnicastTagN015::CustomMetaDataUnicastTagN015() {
}


CustomMetaDataUnicastTagN015::~CustomMetaDataUnicastTagN015() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN015::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN015")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN015> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN015::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN015::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN015::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN015::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN015::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN015::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN015::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN015::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN015::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN015::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN016 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN016();
	virtual ~CustomMetaDataUnicastTagN016();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN016");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN016);

CustomMetaDataUnicastTagN016::CustomMetaDataUnicastTagN016() {

}

CustomMetaDataUnicastTagN016::~CustomMetaDataUnicastTagN016() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN016::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN016")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN016> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN016::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN016::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN016::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN016::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN016::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN016::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN016::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN016::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN016::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN016::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN017 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN017();
	virtual ~CustomMetaDataUnicastTagN017();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN017");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN017);

CustomMetaDataUnicastTagN017::CustomMetaDataUnicastTagN017() {

}


CustomMetaDataUnicastTagN017::~CustomMetaDataUnicastTagN017() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN017::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN017")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN017> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN017::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN017::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN017::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN017::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN017::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN017::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN017::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN017::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN017::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN017::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN018 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN018();
	virtual ~CustomMetaDataUnicastTagN018();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN018");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN018);

CustomMetaDataUnicastTagN018::CustomMetaDataUnicastTagN018() {
}


CustomMetaDataUnicastTagN018::~CustomMetaDataUnicastTagN018() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN018::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN018")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN018> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN018::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN018::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN018::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN018::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN018::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN018::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN018::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN018::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN018::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN018::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN019 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN019();
	virtual ~CustomMetaDataUnicastTagN019();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN019");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN019);

CustomMetaDataUnicastTagN019::CustomMetaDataUnicastTagN019() {

}


CustomMetaDataUnicastTagN019::~CustomMetaDataUnicastTagN019() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN019::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN019")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN019> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN019::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN019::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN019::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN019::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN019::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN019::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN019::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN019::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN019::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN019::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0110 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0110();
	virtual ~CustomMetaDataUnicastTagN0110();
private:

	uint32_t m_neighborid[max10+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0110");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0110);

CustomMetaDataUnicastTagN0110::CustomMetaDataUnicastTagN0110() {
	
}


CustomMetaDataUnicastTagN0110::~CustomMetaDataUnicastTagN0110() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0110::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0110")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0110> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0110::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0110::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0110::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0110::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0110::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0110::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN0110::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0110::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN0110::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0110::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0111 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN0111();
	virtual ~CustomMetaDataUnicastTagN0111();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0111");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0111);

CustomMetaDataUnicastTagN0111::CustomMetaDataUnicastTagN0111() {

}


CustomMetaDataUnicastTagN0111::~CustomMetaDataUnicastTagN0111() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0111::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0111")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0111> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0111::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0111::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0111::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0111::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN0111::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN0111::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN0111::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0111::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0111::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0111::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0112 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0112();

	virtual ~CustomMetaDataUnicastTagN0112();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0112");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0112);

CustomMetaDataUnicastTagN0112::CustomMetaDataUnicastTagN0112() {
}


CustomMetaDataUnicastTagN0112::~CustomMetaDataUnicastTagN0112() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0112::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0112")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0112> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0112::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0112::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0112::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0112::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0112::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN0112::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN0112::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0112::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0112::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0112::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0113 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0113();
	virtual ~CustomMetaDataUnicastTagN0113();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0113");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0113);

CustomMetaDataUnicastTagN0113::CustomMetaDataUnicastTagN0113() {

}


CustomMetaDataUnicastTagN0113::~CustomMetaDataUnicastTagN0113() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0113::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0113")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0113> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0113::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0113::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN0113::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0113::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0113::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0113::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN0113::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0113::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0113::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0113::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0114 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	CustomMetaDataUnicastTagN0114();
	virtual ~CustomMetaDataUnicastTagN0114();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0114");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0114);

CustomMetaDataUnicastTagN0114::CustomMetaDataUnicastTagN0114() {

}


CustomMetaDataUnicastTagN0114::~CustomMetaDataUnicastTagN0114() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0114::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0114")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0114> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0114::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0114::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0114::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0114::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0114::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0114::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN0114::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0114::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0114::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0114::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0115 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0115();
	virtual ~CustomMetaDataUnicastTagN0115();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0115");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0115);

CustomMetaDataUnicastTagN0115::CustomMetaDataUnicastTagN0115() {

}

CustomMetaDataUnicastTagN0115::~CustomMetaDataUnicastTagN0115() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0115::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0115")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0115> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0115::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0115::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0115::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0115::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0115::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0115::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0115::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0115::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0115::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0115::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0116 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0116();
	virtual ~CustomMetaDataUnicastTagN0116();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0116");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0116);

CustomMetaDataUnicastTagN0116::CustomMetaDataUnicastTagN0116() {

}

CustomMetaDataUnicastTagN0116::~CustomMetaDataUnicastTagN0116() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0116::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0116")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0116> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0116::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0116::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0116::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0116::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0116::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0116::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0116::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0116::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0116::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0116::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0117 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0117();
	virtual ~CustomMetaDataUnicastTagN0117();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0117");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0117);

CustomMetaDataUnicastTagN0117::CustomMetaDataUnicastTagN0117() {

}

CustomMetaDataUnicastTagN0117::~CustomMetaDataUnicastTagN0117() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0117::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0117")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0117> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0117::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0117::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0117::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0117::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0117::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0117::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0117::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0117::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0117::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0117::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0118 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0118();
	virtual ~CustomMetaDataUnicastTagN0118();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0118");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0118);

CustomMetaDataUnicastTagN0118::CustomMetaDataUnicastTagN0118() {

}

CustomMetaDataUnicastTagN0118::~CustomMetaDataUnicastTagN0118() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0118::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0118")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0118> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0118::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0118::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0118::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0118::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0118::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0118::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0118::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0118::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0118::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0118::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0119 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0119();
	virtual ~CustomMetaDataUnicastTagN0119();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0119");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0119);

CustomMetaDataUnicastTagN0119::CustomMetaDataUnicastTagN0119() {

}

CustomMetaDataUnicastTagN0119::~CustomMetaDataUnicastTagN0119() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0119::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0119")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0119> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0119::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0119::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0119::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0119::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0119::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0119::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0119::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0119::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0119::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0119::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0120 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0120();
	virtual ~CustomMetaDataUnicastTagN0120();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0120");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0120);

CustomMetaDataUnicastTagN0120::CustomMetaDataUnicastTagN0120() {

}

CustomMetaDataUnicastTagN0120::~CustomMetaDataUnicastTagN0120() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0120::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0120")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0120> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0120::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0120::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0120::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0120::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0120::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0120::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0120::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0120::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0120::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0120::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0121 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0121();
	virtual ~CustomMetaDataUnicastTagN0121();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0121");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0121);

CustomMetaDataUnicastTagN0121::CustomMetaDataUnicastTagN0121() {

}

CustomMetaDataUnicastTagN0121::~CustomMetaDataUnicastTagN0121() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0121::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0121")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0121> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0121::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0121::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0121::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0121::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0121::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0121::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0121::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0121::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0121::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0121::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0122 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0122();
	virtual ~CustomMetaDataUnicastTagN0122();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0122");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0122);

CustomMetaDataUnicastTagN0122::CustomMetaDataUnicastTagN0122() {

}

CustomMetaDataUnicastTagN0122::~CustomMetaDataUnicastTagN0122() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0122::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0122")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0122> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0122::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0122::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0122::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0122::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0122::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0122::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0122::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0122::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0122::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0122::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0123 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0123();
	virtual ~CustomMetaDataUnicastTagN0123();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0123");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0123);

CustomMetaDataUnicastTagN0123::CustomMetaDataUnicastTagN0123() {

}

CustomMetaDataUnicastTagN0123::~CustomMetaDataUnicastTagN0123() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0123::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0123")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0123> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0123::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0123::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0123::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0123::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0123::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0123::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0123::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0123::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0123::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0123::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0124 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0124();
	virtual ~CustomMetaDataUnicastTagN0124();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0124");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0124);

CustomMetaDataUnicastTagN0124::CustomMetaDataUnicastTagN0124() {

}

CustomMetaDataUnicastTagN0124::~CustomMetaDataUnicastTagN0124() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0124::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0124")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0124> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0124::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0124::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0124::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0124::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0124::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0124::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0124::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0124::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0124::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0124::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN0125 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0125();
	virtual ~CustomMetaDataUnicastTagN0125();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0125");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0125);

CustomMetaDataUnicastTagN0125::CustomMetaDataUnicastTagN0125() {

}

CustomMetaDataUnicastTagN0125::~CustomMetaDataUnicastTagN0125() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0125::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0125")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0125> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0125::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0125::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0125::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0125::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0125::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0125::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0125::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0125::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0125::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0125::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2max();
	virtual ~CustomMetaDataUnicastTagN2max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2max);

CustomMetaDataUnicastTagN2max::CustomMetaDataUnicastTagN2max() {

}


CustomMetaDataUnicastTagN2max::~CustomMetaDataUnicastTagN2max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN021 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN021();
	virtual ~CustomMetaDataUnicastTagN021();
private:

	uint32_t m_neighborid[max1+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN021");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN021);

CustomMetaDataUnicastTagN021::CustomMetaDataUnicastTagN021() {
}


CustomMetaDataUnicastTagN021::~CustomMetaDataUnicastTagN021() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN021::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN021")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN021> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN021::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN021::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN021::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN021::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN021::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN021::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN021::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN021::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN021::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN021::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN022 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN022();
	virtual ~CustomMetaDataUnicastTagN022();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN022");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN022);

CustomMetaDataUnicastTagN022::CustomMetaDataUnicastTagN022() {

}


CustomMetaDataUnicastTagN022::~CustomMetaDataUnicastTagN022() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN022::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN022")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN022> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN022::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN022::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN022::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN022::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN022::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN022::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN022::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN022::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN022::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN022::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN023 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN023();
	virtual ~CustomMetaDataUnicastTagN023();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN023");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN023);

CustomMetaDataUnicastTagN023::CustomMetaDataUnicastTagN023() {

}


CustomMetaDataUnicastTagN023::~CustomMetaDataUnicastTagN023() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN023::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN023")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN023> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN023::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN023::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN023::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN023::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN023::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN023::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN023::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN023::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN023::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN023::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN024 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN024();
	virtual ~CustomMetaDataUnicastTagN024();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN024");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN024);

CustomMetaDataUnicastTagN024::CustomMetaDataUnicastTagN024() {
	
}


CustomMetaDataUnicastTagN024::~CustomMetaDataUnicastTagN024() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN024::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN024")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN024> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN024::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN024::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN024::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN024::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN024::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN024::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN024::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN024::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN024::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN024::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN025 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN025();
	virtual ~CustomMetaDataUnicastTagN025();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN025");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN025);

CustomMetaDataUnicastTagN025::CustomMetaDataUnicastTagN025() {
}


CustomMetaDataUnicastTagN025::~CustomMetaDataUnicastTagN025() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN025::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN025")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN025> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN025::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN025::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN025::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN025::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN025::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN025::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN025::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN025::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN025::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN025::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN026 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN026();
	virtual ~CustomMetaDataUnicastTagN026();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN026");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN026);

CustomMetaDataUnicastTagN026::CustomMetaDataUnicastTagN026() {

}

CustomMetaDataUnicastTagN026::~CustomMetaDataUnicastTagN026() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN026::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN026")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN026> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN026::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN026::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN026::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN026::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN026::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN026::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN026::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN026::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN026::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN026::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN027 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN027();
	virtual ~CustomMetaDataUnicastTagN027();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN027");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN027);

CustomMetaDataUnicastTagN027::CustomMetaDataUnicastTagN027() {

}


CustomMetaDataUnicastTagN027::~CustomMetaDataUnicastTagN027() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN027::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN027")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN027> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN027::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN027::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN027::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN027::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN027::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN027::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN027::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN027::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN027::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN027::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN028 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN028();
	virtual ~CustomMetaDataUnicastTagN028();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN028");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN028);

CustomMetaDataUnicastTagN028::CustomMetaDataUnicastTagN028() {
}


CustomMetaDataUnicastTagN028::~CustomMetaDataUnicastTagN028() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN028::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN028")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN028> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN028::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN028::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN028::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN028::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN028::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN028::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN028::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN028::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN028::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN028::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN029 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN029();
	virtual ~CustomMetaDataUnicastTagN029();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN029");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN029);

CustomMetaDataUnicastTagN029::CustomMetaDataUnicastTagN029() {

}


CustomMetaDataUnicastTagN029::~CustomMetaDataUnicastTagN029() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN029::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN029")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN029> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN029::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN029::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN029::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN029::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN029::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN029::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN029::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN029::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN029::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN029::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0210 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN0210();
	virtual ~CustomMetaDataUnicastTagN0210();
private:

	uint32_t m_neighborid[max10+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0210");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0210);

CustomMetaDataUnicastTagN0210::CustomMetaDataUnicastTagN0210() {
	
}


CustomMetaDataUnicastTagN0210::~CustomMetaDataUnicastTagN0210() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0210::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0210")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0210> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0210::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0210::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0210::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0210::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0210::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0210::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN0210::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0210::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0210::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0210::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN0211 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN0211();
	virtual ~CustomMetaDataUnicastTagN0211();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0211");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0211);

CustomMetaDataUnicastTagN0211::CustomMetaDataUnicastTagN0211() {

}


CustomMetaDataUnicastTagN0211::~CustomMetaDataUnicastTagN0211() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0211::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0211")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0211> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0211::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0211::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0211::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0211::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN0211::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN0211::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN0211::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0211::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0211::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0211::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0212 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN0212();

	virtual ~CustomMetaDataUnicastTagN0212();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0212");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0212);

CustomMetaDataUnicastTagN0212::CustomMetaDataUnicastTagN0212() {
}


CustomMetaDataUnicastTagN0212::~CustomMetaDataUnicastTagN0212() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0212::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0212")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0212> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0212::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0212::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0212::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0212::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0212::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN0212::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN0212::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0212::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0212::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0212::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0213 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN0213();
	virtual ~CustomMetaDataUnicastTagN0213();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max13+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0213");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0213);

CustomMetaDataUnicastTagN0213::CustomMetaDataUnicastTagN0213() {

}


CustomMetaDataUnicastTagN0213::~CustomMetaDataUnicastTagN0213() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0213::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0213")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0213> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0213::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0213::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN0213::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0213::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0213::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0213::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN0213::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0213::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0213::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0213::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0214 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN0214();
	virtual ~CustomMetaDataUnicastTagN0214();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0214");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0214);

CustomMetaDataUnicastTagN0214::CustomMetaDataUnicastTagN0214() {

}


CustomMetaDataUnicastTagN0214::~CustomMetaDataUnicastTagN0214() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0214::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0214")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0214> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0214::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0214::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0214::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0214::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0214::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0214::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN0214::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0214::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0214::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0214::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN0215 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0215();
	virtual ~CustomMetaDataUnicastTagN0215();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0215");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0215);

CustomMetaDataUnicastTagN0215::CustomMetaDataUnicastTagN0215() {

}

CustomMetaDataUnicastTagN0215::~CustomMetaDataUnicastTagN0215() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0215::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0215")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0215> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0215::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0215::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0215::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0215::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0215::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0215::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0215::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0215::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0215::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0215::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0216 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0216();
	virtual ~CustomMetaDataUnicastTagN0216();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0216");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0216);

CustomMetaDataUnicastTagN0216::CustomMetaDataUnicastTagN0216() {

}

CustomMetaDataUnicastTagN0216::~CustomMetaDataUnicastTagN0216() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0216::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0216")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0216> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0216::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0216::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0216::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0216::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0216::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0216::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0216::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0216::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0216::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0216::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0217 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0217();
	virtual ~CustomMetaDataUnicastTagN0217();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0217");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0217);

CustomMetaDataUnicastTagN0217::CustomMetaDataUnicastTagN0217() {

}

CustomMetaDataUnicastTagN0217::~CustomMetaDataUnicastTagN0217() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0217::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0217")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0217> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0217::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0217::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0217::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0217::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0217::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0217::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0217::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0217::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0217::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0217::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0218 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0218();
	virtual ~CustomMetaDataUnicastTagN0218();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0218");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0218);

CustomMetaDataUnicastTagN0218::CustomMetaDataUnicastTagN0218() {

}

CustomMetaDataUnicastTagN0218::~CustomMetaDataUnicastTagN0218() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0218::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0218")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0218> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0218::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0218::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0218::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0218::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0218::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0218::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0218::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0218::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0218::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0218::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0219 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0219();
	virtual ~CustomMetaDataUnicastTagN0219();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0219");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0219);

CustomMetaDataUnicastTagN0219::CustomMetaDataUnicastTagN0219() {

}

CustomMetaDataUnicastTagN0219::~CustomMetaDataUnicastTagN0219() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0219::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0219")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0219> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0219::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0219::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0219::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0219::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0219::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0219::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0219::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0219::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0219::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0219::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0220 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0220();
	virtual ~CustomMetaDataUnicastTagN0220();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0220");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0220);

CustomMetaDataUnicastTagN0220::CustomMetaDataUnicastTagN0220() {

}

CustomMetaDataUnicastTagN0220::~CustomMetaDataUnicastTagN0220() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0220::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0220")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0220> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0220::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0220::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0220::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0220::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0220::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0220::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0220::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0220::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0220::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0220::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN0221 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0221();
	virtual ~CustomMetaDataUnicastTagN0221();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0221");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0221);

CustomMetaDataUnicastTagN0221::CustomMetaDataUnicastTagN0221() {

}

CustomMetaDataUnicastTagN0221::~CustomMetaDataUnicastTagN0221() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0221::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0221")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0221> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0221::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0221::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0221::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0221::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0221::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0221::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0221::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0221::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0221::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0221::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0222 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0222();
	virtual ~CustomMetaDataUnicastTagN0222();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0222");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0222);

CustomMetaDataUnicastTagN0222::CustomMetaDataUnicastTagN0222() {

}

CustomMetaDataUnicastTagN0222::~CustomMetaDataUnicastTagN0222() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0222::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0222")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0222> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0222::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0222::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0222::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0222::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0222::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0222::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0222::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0222::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0222::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0222::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0223 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0223();
	virtual ~CustomMetaDataUnicastTagN0223();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0223");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0223);

CustomMetaDataUnicastTagN0223::CustomMetaDataUnicastTagN0223() {

}

CustomMetaDataUnicastTagN0223::~CustomMetaDataUnicastTagN0223() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0223::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0223")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0223> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0223::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0223::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0223::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0223::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0223::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0223::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0223::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0223::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0223::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0223::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN0224 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0224();
	virtual ~CustomMetaDataUnicastTagN0224();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0224");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0224);

CustomMetaDataUnicastTagN0224::CustomMetaDataUnicastTagN0224() {

}

CustomMetaDataUnicastTagN0224::~CustomMetaDataUnicastTagN0224() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0224::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0224")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0224> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0224::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0224::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0224::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0224::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0224::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0224::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0224::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0224::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0224::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0224::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN0225 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN0225();
	virtual ~CustomMetaDataUnicastTagN0225();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN0225");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN0225);

CustomMetaDataUnicastTagN0225::CustomMetaDataUnicastTagN0225() {

}

CustomMetaDataUnicastTagN0225::~CustomMetaDataUnicastTagN0225() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN0225::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN0225")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN0225> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN0225::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN0225::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN0225::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN0225::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN0225::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN0225::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN0225::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN0225::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN0225::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN0225::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN3max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN3max();
	virtual ~CustomMetaDataUnicastTagN3max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN3max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN3max);

CustomMetaDataUnicastTagN3max::CustomMetaDataUnicastTagN3max() {

}


CustomMetaDataUnicastTagN3max::~CustomMetaDataUnicastTagN3max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN3max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN3max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN3max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN3max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN3max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN3max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN3max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN3max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN3max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN3max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN3max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN3max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN3max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN31 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN31();
	virtual ~CustomMetaDataUnicastTagN31();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN31");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN31);

CustomMetaDataUnicastTagN31::CustomMetaDataUnicastTagN31() {
}


CustomMetaDataUnicastTagN31::~CustomMetaDataUnicastTagN31() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN31::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN31")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN31> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN31::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN31::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN31::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN31::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN31::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN31::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN31::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN31::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN31::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN31::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN32 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN32();
	virtual ~CustomMetaDataUnicastTagN32();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN32");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN32);

CustomMetaDataUnicastTagN32::CustomMetaDataUnicastTagN32() {

}


CustomMetaDataUnicastTagN32::~CustomMetaDataUnicastTagN32() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN32::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN32")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN32> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN32::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN32::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN32::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN32::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN32::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN32::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN32::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN32::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN32::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN32::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN33 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN33();
	virtual ~CustomMetaDataUnicastTagN33();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN33");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN33);

CustomMetaDataUnicastTagN33::CustomMetaDataUnicastTagN33() {

}


CustomMetaDataUnicastTagN33::~CustomMetaDataUnicastTagN33() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN33::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN33")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN33> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN33::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN33::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN33::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN33::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN33::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN33::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN33::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN33::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN33::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN33::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN34 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN34();
	virtual ~CustomMetaDataUnicastTagN34();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN34");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN34);

CustomMetaDataUnicastTagN34::CustomMetaDataUnicastTagN34() {
	
}


CustomMetaDataUnicastTagN34::~CustomMetaDataUnicastTagN34() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN34::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN34")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN34> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN34::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN34::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN34::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN34::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN34::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN34::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN34::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN34::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN34::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN34::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN35 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN35();
	virtual ~CustomMetaDataUnicastTagN35();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN35");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN35);

CustomMetaDataUnicastTagN35::CustomMetaDataUnicastTagN35() {
}


CustomMetaDataUnicastTagN35::~CustomMetaDataUnicastTagN35() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN35::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN35")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN35> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN35::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN35::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN35::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN35::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN35::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN35::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN35::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN35::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN35::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN35::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN36 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN36();
	virtual ~CustomMetaDataUnicastTagN36();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN36");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN36);

CustomMetaDataUnicastTagN36::CustomMetaDataUnicastTagN36() {

}

CustomMetaDataUnicastTagN36::~CustomMetaDataUnicastTagN36() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN36::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN36")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN36> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN36::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN36::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN36::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN36::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN36::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN36::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN36::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN36::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN36::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN36::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN37 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN37();
	virtual ~CustomMetaDataUnicastTagN37();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN37");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN37);

CustomMetaDataUnicastTagN37::CustomMetaDataUnicastTagN37() {

}


CustomMetaDataUnicastTagN37::~CustomMetaDataUnicastTagN37() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN37::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN37")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN37> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN37::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN37::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN37::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN37::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN37::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN37::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN37::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN37::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN37::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN37::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN38 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN38();
	virtual ~CustomMetaDataUnicastTagN38();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN38");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN38);

CustomMetaDataUnicastTagN38::CustomMetaDataUnicastTagN38() {
}


CustomMetaDataUnicastTagN38::~CustomMetaDataUnicastTagN38() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN38::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN38")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN38> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN38::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN38::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN38::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN38::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN38::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN38::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN38::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN38::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN38::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN38::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN39 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN39();
	virtual ~CustomMetaDataUnicastTagN39();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN39");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN39);

CustomMetaDataUnicastTagN39::CustomMetaDataUnicastTagN39() {

}


CustomMetaDataUnicastTagN39::~CustomMetaDataUnicastTagN39() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN39::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN39")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN39> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN39::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN39::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN39::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN39::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN39::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN39::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN39::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN39::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN39::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN39::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN310 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN310();
	virtual ~CustomMetaDataUnicastTagN310();
private:

	uint32_t m_neighborid[max10+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN310");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN310);

CustomMetaDataUnicastTagN310::CustomMetaDataUnicastTagN310() {
	
}


CustomMetaDataUnicastTagN310::~CustomMetaDataUnicastTagN310() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN310::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN310")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN310> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN310::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN310::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN310::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN310::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN310::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN310::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN310::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN310::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN310::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN310::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN311 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN311();
	virtual ~CustomMetaDataUnicastTagN311();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN311");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN311);

CustomMetaDataUnicastTagN311::CustomMetaDataUnicastTagN311() {

}


CustomMetaDataUnicastTagN311::~CustomMetaDataUnicastTagN311() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN311::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN311")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN311> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN311::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN311::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN311::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN311::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN311::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN311::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN311::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN311::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN311::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN311::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN312 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN312();

	virtual ~CustomMetaDataUnicastTagN312();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN312");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN312);

CustomMetaDataUnicastTagN312::CustomMetaDataUnicastTagN312() {
}


CustomMetaDataUnicastTagN312::~CustomMetaDataUnicastTagN312() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN312::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN312")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN312> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN312::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN312::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN312::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN312::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN312::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN312::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN312::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN312::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN312::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN312::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN313 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN313();
	virtual ~CustomMetaDataUnicastTagN313();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN313");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN313);

CustomMetaDataUnicastTagN313::CustomMetaDataUnicastTagN313() {

}


CustomMetaDataUnicastTagN313::~CustomMetaDataUnicastTagN313() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN313::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN313")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN313> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN313::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN313::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN313::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN313::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN313::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN313::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN313::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN313::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN313::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN313::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN314 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN314();
	virtual ~CustomMetaDataUnicastTagN314();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN314");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN314);

CustomMetaDataUnicastTagN314::CustomMetaDataUnicastTagN314() {

}


CustomMetaDataUnicastTagN314::~CustomMetaDataUnicastTagN314() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN314::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN314")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN314> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN314::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN314::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN314::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN314::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN314::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN314::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN314::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN314::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN314::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN314::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN315 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN315();
	virtual ~CustomMetaDataUnicastTagN315();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN315");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN315);

CustomMetaDataUnicastTagN315::CustomMetaDataUnicastTagN315() {

}

CustomMetaDataUnicastTagN315::~CustomMetaDataUnicastTagN315() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN315::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN315")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN315> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN315::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN315::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN315::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN315::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN315::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN315::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN315::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN315::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN315::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN315::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN316 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN316();
	virtual ~CustomMetaDataUnicastTagN316();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN316");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN316);

CustomMetaDataUnicastTagN316::CustomMetaDataUnicastTagN316() {

}

CustomMetaDataUnicastTagN316::~CustomMetaDataUnicastTagN316() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN316::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN316")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN316> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN316::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN316::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN316::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN316::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN316::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN316::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN316::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN316::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN316::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN316::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN317 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN317();
	virtual ~CustomMetaDataUnicastTagN317();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN317");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN317);

CustomMetaDataUnicastTagN317::CustomMetaDataUnicastTagN317() {

}

CustomMetaDataUnicastTagN317::~CustomMetaDataUnicastTagN317() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN317::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN317")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN317> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN317::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN317::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN317::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN317::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN317::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN317::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN317::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN317::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN317::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN317::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN318 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN318();
	virtual ~CustomMetaDataUnicastTagN318();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN318");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN318);

CustomMetaDataUnicastTagN318::CustomMetaDataUnicastTagN318() {

}

CustomMetaDataUnicastTagN318::~CustomMetaDataUnicastTagN318() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN318::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN318")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN318> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN318::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN318::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN318::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN318::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN318::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN318::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN318::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN318::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN318::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN318::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN319 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN319();
	virtual ~CustomMetaDataUnicastTagN319();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN319");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN319);

CustomMetaDataUnicastTagN319::CustomMetaDataUnicastTagN319() {

}

CustomMetaDataUnicastTagN319::~CustomMetaDataUnicastTagN319() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN319::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN319")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN319> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN319::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN319::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN319::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN319::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN319::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN319::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN319::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN319::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN319::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN319::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN320 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN320();
	virtual ~CustomMetaDataUnicastTagN320();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN320");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN320);

CustomMetaDataUnicastTagN320::CustomMetaDataUnicastTagN320() {

}

CustomMetaDataUnicastTagN320::~CustomMetaDataUnicastTagN320() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN320::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN320")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN320> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN320::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN320::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN320::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN320::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN320::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN320::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN320::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN320::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN320::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN320::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN321 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN321();
	virtual ~CustomMetaDataUnicastTagN321();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN321");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN321);

CustomMetaDataUnicastTagN321::CustomMetaDataUnicastTagN321() {

}

CustomMetaDataUnicastTagN321::~CustomMetaDataUnicastTagN321() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN321::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN321")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN321> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN321::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN321::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN321::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN321::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN321::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN321::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN321::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN321::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN321::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN321::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN322 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN322();
	virtual ~CustomMetaDataUnicastTagN322();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN322");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN322);

CustomMetaDataUnicastTagN322::CustomMetaDataUnicastTagN322() {

}

CustomMetaDataUnicastTagN322::~CustomMetaDataUnicastTagN322() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN322::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN322")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN322> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN322::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN322::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN322::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN322::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN322::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN322::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN322::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN322::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN322::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN322::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN323 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN323();
	virtual ~CustomMetaDataUnicastTagN323();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN323");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN323);

CustomMetaDataUnicastTagN323::CustomMetaDataUnicastTagN323() {

}

CustomMetaDataUnicastTagN323::~CustomMetaDataUnicastTagN323() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN323::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN323")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN323> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN323::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN323::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN323::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN323::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN323::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN323::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN323::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN323::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN323::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN323::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN324 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN324();
	virtual ~CustomMetaDataUnicastTagN324();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN324");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN324);

CustomMetaDataUnicastTagN324::CustomMetaDataUnicastTagN324() {

}

CustomMetaDataUnicastTagN324::~CustomMetaDataUnicastTagN324() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN324::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN324")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN324> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN324::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN324::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN324::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN324::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN324::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN324::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN324::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN324::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN324::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN324::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN325 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN325();
	virtual ~CustomMetaDataUnicastTagN325();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN325");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN325);

CustomMetaDataUnicastTagN325::CustomMetaDataUnicastTagN325() {

}

CustomMetaDataUnicastTagN325::~CustomMetaDataUnicastTagN325() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN325::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN325")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN325> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN325::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN325::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN325::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN325::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN325::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN325::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN325::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN325::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN325::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN325::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN4max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN4max();
	virtual ~CustomMetaDataUnicastTagN4max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN4max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN4max);

CustomMetaDataUnicastTagN4max::CustomMetaDataUnicastTagN4max() {

}


CustomMetaDataUnicastTagN4max::~CustomMetaDataUnicastTagN4max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN4max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN4max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN4max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN4max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN4max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN4max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN4max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN4max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN4max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN4max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN4max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN4max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN4max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN41 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN41();
	virtual ~CustomMetaDataUnicastTagN41();
private:

	uint32_t m_neighborid[max1+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN41");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN41);

CustomMetaDataUnicastTagN41::CustomMetaDataUnicastTagN41() {
}


CustomMetaDataUnicastTagN41::~CustomMetaDataUnicastTagN41() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN41::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN41")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN41> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN41::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN41::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN41::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN41::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN41::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN41::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN41::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN41::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN41::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN41::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN42 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN42();
	virtual ~CustomMetaDataUnicastTagN42();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN42");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN42);

CustomMetaDataUnicastTagN42::CustomMetaDataUnicastTagN42() {

}


CustomMetaDataUnicastTagN42::~CustomMetaDataUnicastTagN42() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN42::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN42")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN42> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN42::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN42::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN42::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN42::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN42::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN42::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN42::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN42::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN42::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN42::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN43 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN43();
	virtual ~CustomMetaDataUnicastTagN43();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN43");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN43);

CustomMetaDataUnicastTagN43::CustomMetaDataUnicastTagN43() {

}


CustomMetaDataUnicastTagN43::~CustomMetaDataUnicastTagN43() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN43::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN43")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN43> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN43::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN43::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN43::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN43::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN43::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN43::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN43::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN43::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN43::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN43::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN44 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN44();
	virtual ~CustomMetaDataUnicastTagN44();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN44");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN44);

CustomMetaDataUnicastTagN44::CustomMetaDataUnicastTagN44() {
	
}


CustomMetaDataUnicastTagN44::~CustomMetaDataUnicastTagN44() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN44::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN44")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN44> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN44::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN44::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN44::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN44::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN44::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN44::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN44::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN44::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN44::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN44::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN45 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN45();
	virtual ~CustomMetaDataUnicastTagN45();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN45");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN45);

CustomMetaDataUnicastTagN45::CustomMetaDataUnicastTagN45() {
}


CustomMetaDataUnicastTagN45::~CustomMetaDataUnicastTagN45() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN45::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN45")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN45> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN45::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN45::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN45::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN45::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN45::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN45::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN45::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN45::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN45::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN45::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN46 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN46();
	virtual ~CustomMetaDataUnicastTagN46();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN46");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN46);

CustomMetaDataUnicastTagN46::CustomMetaDataUnicastTagN46() {

}

CustomMetaDataUnicastTagN46::~CustomMetaDataUnicastTagN46() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN46::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN46")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN46> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN46::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN46::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN46::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN46::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN46::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN46::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN46::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN46::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN46::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN46::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN47 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN47();
	virtual ~CustomMetaDataUnicastTagN47();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN47");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN47);

CustomMetaDataUnicastTagN47::CustomMetaDataUnicastTagN47() {

}


CustomMetaDataUnicastTagN47::~CustomMetaDataUnicastTagN47() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN47::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN47")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN47> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN47::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN47::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN47::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN47::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN47::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN47::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN47::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN47::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN47::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN47::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN48 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN48();
	virtual ~CustomMetaDataUnicastTagN48();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN48");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN48);

CustomMetaDataUnicastTagN48::CustomMetaDataUnicastTagN48() {
}


CustomMetaDataUnicastTagN48::~CustomMetaDataUnicastTagN48() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN48::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN48")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN48> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN48::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN48::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN48::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN48::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN48::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN48::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN48::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN48::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN48::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN48::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN49 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN49();
	virtual ~CustomMetaDataUnicastTagN49();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN49");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN49);

CustomMetaDataUnicastTagN49::CustomMetaDataUnicastTagN49() {

}


CustomMetaDataUnicastTagN49::~CustomMetaDataUnicastTagN49() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN49::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN49")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN49> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN49::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN49::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN49::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN49::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN49::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN49::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN49::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN49::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN49::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN49::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN410 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN410();
	virtual ~CustomMetaDataUnicastTagN410();
private:

	uint32_t m_neighborid[max10+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN410");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN410);

CustomMetaDataUnicastTagN410::CustomMetaDataUnicastTagN410() {
	
}


CustomMetaDataUnicastTagN410::~CustomMetaDataUnicastTagN410() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN410::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN410")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN410> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN410::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN410::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN410::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN410::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN410::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN410::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN410::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN410::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN410::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN410::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN411 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN411();
	virtual ~CustomMetaDataUnicastTagN411();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN411");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN411);

CustomMetaDataUnicastTagN411::CustomMetaDataUnicastTagN411() {

}


CustomMetaDataUnicastTagN411::~CustomMetaDataUnicastTagN411() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN411::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN411")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN411> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN411::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN411::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN411::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN411::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN411::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN411::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN411::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN411::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN411::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN411::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN412 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN412();

	virtual ~CustomMetaDataUnicastTagN412();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN412");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN412);

CustomMetaDataUnicastTagN412::CustomMetaDataUnicastTagN412() {
}


CustomMetaDataUnicastTagN412::~CustomMetaDataUnicastTagN412() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN412::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN412")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN412> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN412::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN412::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN412::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN412::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN412::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN412::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN412::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN412::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN412::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN412::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN413 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN413();
	virtual ~CustomMetaDataUnicastTagN413();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN413");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN413);

CustomMetaDataUnicastTagN413::CustomMetaDataUnicastTagN413() {

}


CustomMetaDataUnicastTagN413::~CustomMetaDataUnicastTagN413() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN413::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN413")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN413> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN413::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN413::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN413::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN413::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN413::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN413::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN413::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN413::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN413::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN413::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN414 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN414();
	virtual ~CustomMetaDataUnicastTagN414();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN414");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN414);

CustomMetaDataUnicastTagN414::CustomMetaDataUnicastTagN414() {

}


CustomMetaDataUnicastTagN414::~CustomMetaDataUnicastTagN414() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN414::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN414")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN414> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN414::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN414::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN414::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN414::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN414::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN414::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN414::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN414::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN414::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN414::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN415 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN415();
	virtual ~CustomMetaDataUnicastTagN415();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN415");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN415);

CustomMetaDataUnicastTagN415::CustomMetaDataUnicastTagN415() {

}

CustomMetaDataUnicastTagN415::~CustomMetaDataUnicastTagN415() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN415::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN415")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN415> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN415::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN415::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN415::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN415::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN415::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN415::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN415::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN415::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN415::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN415::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN416 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN416();
	virtual ~CustomMetaDataUnicastTagN416();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN416");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN416);

CustomMetaDataUnicastTagN416::CustomMetaDataUnicastTagN416() {

}

CustomMetaDataUnicastTagN416::~CustomMetaDataUnicastTagN416() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN416::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN416")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN416> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN416::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN416::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN416::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN416::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN416::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN416::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN416::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN416::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN416::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN416::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN417 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN417();
	virtual ~CustomMetaDataUnicastTagN417();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN417");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN417);

CustomMetaDataUnicastTagN417::CustomMetaDataUnicastTagN417() {

}

CustomMetaDataUnicastTagN417::~CustomMetaDataUnicastTagN417() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN417::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN417")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN417> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN417::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN417::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN417::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN417::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN417::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN417::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN417::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN417::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN417::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN417::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN418 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN418();
	virtual ~CustomMetaDataUnicastTagN418();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN418");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN418);

CustomMetaDataUnicastTagN418::CustomMetaDataUnicastTagN418() {

}

CustomMetaDataUnicastTagN418::~CustomMetaDataUnicastTagN418() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN418::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN418")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN418> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN418::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN418::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN418::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN418::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN418::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN418::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN418::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN418::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN418::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN418::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN419 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN419();
	virtual ~CustomMetaDataUnicastTagN419();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN419");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN419);

CustomMetaDataUnicastTagN419::CustomMetaDataUnicastTagN419() {

}

CustomMetaDataUnicastTagN419::~CustomMetaDataUnicastTagN419() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN419::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN419")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN419> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN419::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN419::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN419::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN419::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN419::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN419::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN419::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN419::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN419::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN419::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN420 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN420();
	virtual ~CustomMetaDataUnicastTagN420();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN420");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN420);

CustomMetaDataUnicastTagN420::CustomMetaDataUnicastTagN420() {

}

CustomMetaDataUnicastTagN420::~CustomMetaDataUnicastTagN420() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN420::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN420")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN420> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN420::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN420::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN420::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN420::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN420::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN420::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN420::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN420::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN420::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN420::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN421 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN421();
	virtual ~CustomMetaDataUnicastTagN421();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN421");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN421);

CustomMetaDataUnicastTagN421::CustomMetaDataUnicastTagN421() {

}

CustomMetaDataUnicastTagN421::~CustomMetaDataUnicastTagN421() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN421::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN421")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN421> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN421::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN421::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN421::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN421::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN421::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN421::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN421::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN421::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN421::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN421::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN422 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN422();
	virtual ~CustomMetaDataUnicastTagN422();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN422");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN422);

CustomMetaDataUnicastTagN422::CustomMetaDataUnicastTagN422() {

}

CustomMetaDataUnicastTagN422::~CustomMetaDataUnicastTagN422() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN422::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN422")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN422> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN422::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN422::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN422::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN422::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN422::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN422::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN422::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN422::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN422::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN422::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN423 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN423();
	virtual ~CustomMetaDataUnicastTagN423();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN423");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN423);

CustomMetaDataUnicastTagN423::CustomMetaDataUnicastTagN423() {

}

CustomMetaDataUnicastTagN423::~CustomMetaDataUnicastTagN423() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN423::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN423")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN423> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN423::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN423::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN423::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN423::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN423::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN423::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN423::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN423::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN423::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN423::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN424 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN424();
	virtual ~CustomMetaDataUnicastTagN424();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN424");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN424);

CustomMetaDataUnicastTagN424::CustomMetaDataUnicastTagN424() {

}

CustomMetaDataUnicastTagN424::~CustomMetaDataUnicastTagN424() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN424::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN424")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN424> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN424::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN424::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN424::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN424::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN424::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN424::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN424::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN424::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN424::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN424::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN425 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN425();
	virtual ~CustomMetaDataUnicastTagN425();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN425");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN425);

CustomMetaDataUnicastTagN425::CustomMetaDataUnicastTagN425() {

}

CustomMetaDataUnicastTagN425::~CustomMetaDataUnicastTagN425() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN425::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN425")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN425> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN425::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN425::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN425::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN425::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN425::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN425::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN425::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN425::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN425::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN425::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN5max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN5max();
	virtual ~CustomMetaDataUnicastTagN5max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN5max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN5max);

CustomMetaDataUnicastTagN5max::CustomMetaDataUnicastTagN5max() {

}


CustomMetaDataUnicastTagN5max::~CustomMetaDataUnicastTagN5max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN5max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN5max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN5max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN5max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN5max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN5max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN5max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN5max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN5max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN5max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN5max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN5max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN5max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}





class CustomMetaDataUnicastTagN51 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN51();
	virtual ~CustomMetaDataUnicastTagN51();
private:

	uint32_t m_neighborid[max1+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN51");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN51);

CustomMetaDataUnicastTagN51::CustomMetaDataUnicastTagN51() {
}


CustomMetaDataUnicastTagN51::~CustomMetaDataUnicastTagN51() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN51::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN51")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN51> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN51::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN51::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN51::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN51::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN51::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN51::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN51::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN51::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN51::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN51::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN52 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN52();
	virtual ~CustomMetaDataUnicastTagN52();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN52");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN52);

CustomMetaDataUnicastTagN52::CustomMetaDataUnicastTagN52() {

}


CustomMetaDataUnicastTagN52::~CustomMetaDataUnicastTagN52() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN52::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN52")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN52> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN52::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN52::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN52::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN52::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN52::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN52::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN52::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN52::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN52::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN52::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN53 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN53();
	virtual ~CustomMetaDataUnicastTagN53();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN53");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN53);

CustomMetaDataUnicastTagN53::CustomMetaDataUnicastTagN53() {

}


CustomMetaDataUnicastTagN53::~CustomMetaDataUnicastTagN53() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN53::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN53")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN53> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN53::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN53::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN53::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN53::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN53::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN53::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN53::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN53::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN53::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN53::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN54 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN54();
	virtual ~CustomMetaDataUnicastTagN54();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN54");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN54);

CustomMetaDataUnicastTagN54::CustomMetaDataUnicastTagN54() {
	
}


CustomMetaDataUnicastTagN54::~CustomMetaDataUnicastTagN54() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN54::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN54")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN54> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN54::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN54::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN54::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN54::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN54::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN54::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN54::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN54::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN54::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN54::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN55 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN55();
	virtual ~CustomMetaDataUnicastTagN55();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN55");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN55);

CustomMetaDataUnicastTagN55::CustomMetaDataUnicastTagN55() {
}


CustomMetaDataUnicastTagN55::~CustomMetaDataUnicastTagN55() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN55::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN55")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN55> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN55::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN55::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN55::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN55::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN55::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN55::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN55::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN55::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN55::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN55::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN56 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN56();
	virtual ~CustomMetaDataUnicastTagN56();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN56");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN56);

CustomMetaDataUnicastTagN56::CustomMetaDataUnicastTagN56() {

}

CustomMetaDataUnicastTagN56::~CustomMetaDataUnicastTagN56() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN56::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN56")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN56> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN56::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN56::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN56::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN56::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN56::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN56::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN56::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN56::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN56::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN56::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN57 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN57();
	virtual ~CustomMetaDataUnicastTagN57();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN57");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN57);

CustomMetaDataUnicastTagN57::CustomMetaDataUnicastTagN57() {

}


CustomMetaDataUnicastTagN57::~CustomMetaDataUnicastTagN57() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN57::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN57")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN57> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN57::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN57::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN57::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN57::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN57::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN57::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN57::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN57::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN57::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN57::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN58 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN58();
	virtual ~CustomMetaDataUnicastTagN58();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN58");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN58);

CustomMetaDataUnicastTagN58::CustomMetaDataUnicastTagN58() {
}


CustomMetaDataUnicastTagN58::~CustomMetaDataUnicastTagN58() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN58::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN58")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN58> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN58::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN58::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN58::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN58::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN58::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN58::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN58::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN58::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN58::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN58::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN59 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN59();
	virtual ~CustomMetaDataUnicastTagN59();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN59");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN59);

CustomMetaDataUnicastTagN59::CustomMetaDataUnicastTagN59() {

}


CustomMetaDataUnicastTagN59::~CustomMetaDataUnicastTagN59() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN59::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN59")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN59> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN59::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN59::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN59::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN59::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN59::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN59::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN59::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN59::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN59::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN59::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN510 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN510();
	virtual ~CustomMetaDataUnicastTagN510();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN510");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN510);

CustomMetaDataUnicastTagN510::CustomMetaDataUnicastTagN510() {
	
}


CustomMetaDataUnicastTagN510::~CustomMetaDataUnicastTagN510() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN510::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN510")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN510> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN510::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN510::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN510::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN510::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN510::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN510::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN510::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN510::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN510::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN510::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN511 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN511();
	virtual ~CustomMetaDataUnicastTagN511();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN511");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN511);

CustomMetaDataUnicastTagN511::CustomMetaDataUnicastTagN511() {

}


CustomMetaDataUnicastTagN511::~CustomMetaDataUnicastTagN511() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN511::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN511")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN511> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN511::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN511::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN511::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN511::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN511::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN511::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN511::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN511::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN511::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN511::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN512 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN512();

	virtual ~CustomMetaDataUnicastTagN512();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN512");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN512);

CustomMetaDataUnicastTagN512::CustomMetaDataUnicastTagN512() {
}


CustomMetaDataUnicastTagN512::~CustomMetaDataUnicastTagN512() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN512::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN512")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN512> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN512::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN512::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN512::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN512::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN512::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN512::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN512::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN512::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN512::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN512::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN513 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN513();
	virtual ~CustomMetaDataUnicastTagN513();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN513");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN513);

CustomMetaDataUnicastTagN513::CustomMetaDataUnicastTagN513() {

}


CustomMetaDataUnicastTagN513::~CustomMetaDataUnicastTagN513() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN513::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN513")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN513> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN513::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN513::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN513::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN513::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN513::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN513::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN513::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN513::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN513::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN513::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN514 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN514();
	virtual ~CustomMetaDataUnicastTagN514();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN514");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN514);

CustomMetaDataUnicastTagN514::CustomMetaDataUnicastTagN514() {

}


CustomMetaDataUnicastTagN514::~CustomMetaDataUnicastTagN514() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN514::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN514")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN514> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN514::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN514::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN514::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN514::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN514::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN514::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN514::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN514::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN514::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN514::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN515 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN515();
	virtual ~CustomMetaDataUnicastTagN515();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN515");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN515);

CustomMetaDataUnicastTagN515::CustomMetaDataUnicastTagN515() {

}

CustomMetaDataUnicastTagN515::~CustomMetaDataUnicastTagN515() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN515::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN515")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN515> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN515::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN515::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN515::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN515::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN515::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN515::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN515::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN515::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN515::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN515::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN516 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN516();
	virtual ~CustomMetaDataUnicastTagN516();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN516");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN516);

CustomMetaDataUnicastTagN516::CustomMetaDataUnicastTagN516() {

}

CustomMetaDataUnicastTagN516::~CustomMetaDataUnicastTagN516() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN516::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN516")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN516> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN516::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN516::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN516::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN516::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN516::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN516::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN516::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN516::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN516::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN516::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN517 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN517();
	virtual ~CustomMetaDataUnicastTagN517();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN517");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN517);

CustomMetaDataUnicastTagN517::CustomMetaDataUnicastTagN517() {

}

CustomMetaDataUnicastTagN517::~CustomMetaDataUnicastTagN517() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN517::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN517")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN517> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN517::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN517::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN517::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN517::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN517::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN517::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN517::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN517::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN517::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN517::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN518 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN518();
	virtual ~CustomMetaDataUnicastTagN518();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN518");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN518);

CustomMetaDataUnicastTagN518::CustomMetaDataUnicastTagN518() {

}

CustomMetaDataUnicastTagN518::~CustomMetaDataUnicastTagN518() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN518::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN518")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN518> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN518::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN518::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN518::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN518::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN518::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN518::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN518::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN518::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN518::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN518::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN519 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN519();
	virtual ~CustomMetaDataUnicastTagN519();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN519");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN519);

CustomMetaDataUnicastTagN519::CustomMetaDataUnicastTagN519() {

}

CustomMetaDataUnicastTagN519::~CustomMetaDataUnicastTagN519() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN519::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN519")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN519> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN519::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN519::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN519::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN519::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN519::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN519::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN519::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN519::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN519::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN519::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN520 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN520();
	virtual ~CustomMetaDataUnicastTagN520();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN520");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN520);

CustomMetaDataUnicastTagN520::CustomMetaDataUnicastTagN520() {

}

CustomMetaDataUnicastTagN520::~CustomMetaDataUnicastTagN520() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN520::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN520")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN520> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN520::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN520::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN520::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN520::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN520::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN520::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN520::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN520::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN520::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN520::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN521 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN521();
	virtual ~CustomMetaDataUnicastTagN521();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN521");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN521);

CustomMetaDataUnicastTagN521::CustomMetaDataUnicastTagN521() {

}

CustomMetaDataUnicastTagN521::~CustomMetaDataUnicastTagN521() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN521::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN521")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN521> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN521::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN521::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN521::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN521::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN521::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN521::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN521::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN521::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN521::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN521::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN522 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN522();
	virtual ~CustomMetaDataUnicastTagN522();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN522");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN522);

CustomMetaDataUnicastTagN522::CustomMetaDataUnicastTagN522() {

}

CustomMetaDataUnicastTagN522::~CustomMetaDataUnicastTagN522() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN522::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN522")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN522> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN522::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN522::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN522::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN522::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN522::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN522::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN522::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN522::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN522::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN522::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN523 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN523();
	virtual ~CustomMetaDataUnicastTagN523();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN523");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN523);

CustomMetaDataUnicastTagN523::CustomMetaDataUnicastTagN523() {

}

CustomMetaDataUnicastTagN523::~CustomMetaDataUnicastTagN523() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN523::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN523")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN523> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN523::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN523::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN523::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN523::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN523::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN523::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN523::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN523::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN523::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN523::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN524 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN524();
	virtual ~CustomMetaDataUnicastTagN524();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN524");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN524);

CustomMetaDataUnicastTagN524::CustomMetaDataUnicastTagN524() {

}

CustomMetaDataUnicastTagN524::~CustomMetaDataUnicastTagN524() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN524::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN524")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN524> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN524::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN524::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN524::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN524::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN524::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN524::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN524::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN524::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN524::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN524::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN525 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN525();
	virtual ~CustomMetaDataUnicastTagN525();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN525");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN525);

CustomMetaDataUnicastTagN525::CustomMetaDataUnicastTagN525() {

}

CustomMetaDataUnicastTagN525::~CustomMetaDataUnicastTagN525() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN525::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN525")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN525> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN525::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN525::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN525::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN525::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN525::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN525::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN525::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN525::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN525::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN525::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN6max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN6max();
	virtual ~CustomMetaDataUnicastTagN6max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN6max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN6max);

CustomMetaDataUnicastTagN6max::CustomMetaDataUnicastTagN6max() {

}


CustomMetaDataUnicastTagN6max::~CustomMetaDataUnicastTagN6max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN6max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN6max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN6max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN6max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN6max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN6max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN6max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN6max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN6max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN6max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN6max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN6max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN6max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN61 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN61();
	virtual ~CustomMetaDataUnicastTagN61();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN61");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN61);

CustomMetaDataUnicastTagN61::CustomMetaDataUnicastTagN61() {
}


CustomMetaDataUnicastTagN61::~CustomMetaDataUnicastTagN61() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN61::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN61")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN61> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN61::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN61::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN61::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN61::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN61::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN61::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN61::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN61::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN61::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN61::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN62 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN62();
	virtual ~CustomMetaDataUnicastTagN62();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN62");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN62);

CustomMetaDataUnicastTagN62::CustomMetaDataUnicastTagN62() {

}


CustomMetaDataUnicastTagN62::~CustomMetaDataUnicastTagN62() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN62::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN62")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN62> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN62::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN62::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN62::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN62::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN62::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN62::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN62::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN62::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN62::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN62::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN63 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN63();
	virtual ~CustomMetaDataUnicastTagN63();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN63");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN63);

CustomMetaDataUnicastTagN63::CustomMetaDataUnicastTagN63() {

}


CustomMetaDataUnicastTagN63::~CustomMetaDataUnicastTagN63() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN63::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN63")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN63> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN63::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN63::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN63::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN63::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN63::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN63::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN63::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN63::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN63::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN63::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN64 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN64();
	virtual ~CustomMetaDataUnicastTagN64();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN64");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN64);

CustomMetaDataUnicastTagN64::CustomMetaDataUnicastTagN64() {
	
}


CustomMetaDataUnicastTagN64::~CustomMetaDataUnicastTagN64() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN64::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN64")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN64> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN64::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN64::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN64::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN64::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN64::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN64::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN64::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN64::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN64::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN64::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN65 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN65();
	virtual ~CustomMetaDataUnicastTagN65();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN65");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN65);

CustomMetaDataUnicastTagN65::CustomMetaDataUnicastTagN65() {
}


CustomMetaDataUnicastTagN65::~CustomMetaDataUnicastTagN65() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN65::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN65")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN65> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN65::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN65::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN65::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN65::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN65::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN65::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN65::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN65::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN65::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN65::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN66 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN66();
	virtual ~CustomMetaDataUnicastTagN66();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN66");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN66);

CustomMetaDataUnicastTagN66::CustomMetaDataUnicastTagN66() {

}

CustomMetaDataUnicastTagN66::~CustomMetaDataUnicastTagN66() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN66::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN66")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN66> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN66::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN66::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN66::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN66::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN66::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN66::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN66::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN66::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN66::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN66::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN67 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN67();
	virtual ~CustomMetaDataUnicastTagN67();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN67");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN67);

CustomMetaDataUnicastTagN67::CustomMetaDataUnicastTagN67() {

}


CustomMetaDataUnicastTagN67::~CustomMetaDataUnicastTagN67() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN67::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN67")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN67> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN67::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN67::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN67::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN67::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN67::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN67::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN67::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN67::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN67::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN67::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN68 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN68();
	virtual ~CustomMetaDataUnicastTagN68();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN68");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN68);

CustomMetaDataUnicastTagN68::CustomMetaDataUnicastTagN68() {
}


CustomMetaDataUnicastTagN68::~CustomMetaDataUnicastTagN68() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN68::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN68")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN68> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN68::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN68::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN68::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN68::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN68::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN68::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN68::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN68::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN68::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN68::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN69 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN69();
	virtual ~CustomMetaDataUnicastTagN69();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN69");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN69);

CustomMetaDataUnicastTagN69::CustomMetaDataUnicastTagN69() {

}


CustomMetaDataUnicastTagN69::~CustomMetaDataUnicastTagN69() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN69::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN69")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN69> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN69::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN69::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN69::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN69::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN69::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN69::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN69::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN69::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN69::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN69::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN610 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN610();
	virtual ~CustomMetaDataUnicastTagN610();
private:

	uint32_t m_neighborid[max10+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN610");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN610);

CustomMetaDataUnicastTagN610::CustomMetaDataUnicastTagN610() {
	
}


CustomMetaDataUnicastTagN610::~CustomMetaDataUnicastTagN610() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN610::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN610")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN610> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN610::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN610::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN610::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN610::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN610::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN610::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN610::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN610::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN610::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN610::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN611 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN611();
	virtual ~CustomMetaDataUnicastTagN611();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN611");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN611);

CustomMetaDataUnicastTagN611::CustomMetaDataUnicastTagN611() {

}


CustomMetaDataUnicastTagN611::~CustomMetaDataUnicastTagN611() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN611::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN611")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN611> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN611::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN611::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN611::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN611::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN611::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN611::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN611::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN611::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN611::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN611::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN612 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN612();

	virtual ~CustomMetaDataUnicastTagN612();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN612");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN612);

CustomMetaDataUnicastTagN612::CustomMetaDataUnicastTagN612() {
}


CustomMetaDataUnicastTagN612::~CustomMetaDataUnicastTagN612() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN612::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN612")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN612> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN612::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN612::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN612::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN612::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN612::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN612::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN612::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN612::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN612::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN612::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN613 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN613();
	virtual ~CustomMetaDataUnicastTagN613();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN613");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN613);

CustomMetaDataUnicastTagN613::CustomMetaDataUnicastTagN613() {

}


CustomMetaDataUnicastTagN613::~CustomMetaDataUnicastTagN613() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN613::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN613")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN613> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN613::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN613::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN613::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN613::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN613::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN613::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN613::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN613::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN613::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN613::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN614 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN614();
	virtual ~CustomMetaDataUnicastTagN614();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN614");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN614);

CustomMetaDataUnicastTagN614::CustomMetaDataUnicastTagN614() {

}


CustomMetaDataUnicastTagN614::~CustomMetaDataUnicastTagN614() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN614::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN614")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN614> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN614::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN614::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN614::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN614::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN614::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN614::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN614::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN614::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN614::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN614::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN615 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN615();
	virtual ~CustomMetaDataUnicastTagN615();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN615");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN615);

CustomMetaDataUnicastTagN615::CustomMetaDataUnicastTagN615() {

}

CustomMetaDataUnicastTagN615::~CustomMetaDataUnicastTagN615() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN615::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN615")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN615> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN615::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN615::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN615::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN615::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN615::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN615::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN615::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN615::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN615::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN615::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN616 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN616();
	virtual ~CustomMetaDataUnicastTagN616();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN616");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN616);

CustomMetaDataUnicastTagN616::CustomMetaDataUnicastTagN616() {

}

CustomMetaDataUnicastTagN616::~CustomMetaDataUnicastTagN616() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN616::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN616")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN616> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN616::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN616::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN616::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN616::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN616::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN616::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN616::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN616::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN616::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN616::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN617 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN617();
	virtual ~CustomMetaDataUnicastTagN617();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN617");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN617);

CustomMetaDataUnicastTagN617::CustomMetaDataUnicastTagN617() {

}

CustomMetaDataUnicastTagN617::~CustomMetaDataUnicastTagN617() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN617::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN617")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN617> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN617::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN617::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN617::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN617::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN617::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN617::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN617::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN617::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN617::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN617::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN618 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN618();
	virtual ~CustomMetaDataUnicastTagN618();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN618");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN618);

CustomMetaDataUnicastTagN618::CustomMetaDataUnicastTagN618() {

}

CustomMetaDataUnicastTagN618::~CustomMetaDataUnicastTagN618() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN618::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN618")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN618> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN618::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN618::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN618::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN618::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN618::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN618::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN618::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN618::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN618::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN618::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN619 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN619();
	virtual ~CustomMetaDataUnicastTagN619();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN619");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN619);

CustomMetaDataUnicastTagN619::CustomMetaDataUnicastTagN619() {

}

CustomMetaDataUnicastTagN619::~CustomMetaDataUnicastTagN619() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN619::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN619")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN619> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN619::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN619::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN619::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN619::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN619::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN619::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN619::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN619::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN619::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN619::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN620 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN620();
	virtual ~CustomMetaDataUnicastTagN620();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN620");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN620);

CustomMetaDataUnicastTagN620::CustomMetaDataUnicastTagN620() {

}

CustomMetaDataUnicastTagN620::~CustomMetaDataUnicastTagN620() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN620::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN620")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN620> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN620::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN620::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN620::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN620::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN620::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN620::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN620::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN620::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN620::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN620::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN621 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN621();
	virtual ~CustomMetaDataUnicastTagN621();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN621");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN621);

CustomMetaDataUnicastTagN621::CustomMetaDataUnicastTagN621() {

}

CustomMetaDataUnicastTagN621::~CustomMetaDataUnicastTagN621() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN621::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN621")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN621> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN621::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN621::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN621::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN621::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN621::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN621::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN621::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN621::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN621::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN621::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN622 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN622();
	virtual ~CustomMetaDataUnicastTagN622();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN622");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN622);

CustomMetaDataUnicastTagN622::CustomMetaDataUnicastTagN622() {

}

CustomMetaDataUnicastTagN622::~CustomMetaDataUnicastTagN622() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN622::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN622")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN622> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN622::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN622::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN622::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN622::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN622::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN622::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN622::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN622::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN622::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN622::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN623 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN623();
	virtual ~CustomMetaDataUnicastTagN623();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN623");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN623);

CustomMetaDataUnicastTagN623::CustomMetaDataUnicastTagN623() {

}

CustomMetaDataUnicastTagN623::~CustomMetaDataUnicastTagN623() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN623::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN623")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN623> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN623::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN623::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN623::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN623::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN623::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN623::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN623::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN623::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN623::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN623::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN624 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN624();
	virtual ~CustomMetaDataUnicastTagN624();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN624");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN624);

CustomMetaDataUnicastTagN624::CustomMetaDataUnicastTagN624() {

}

CustomMetaDataUnicastTagN624::~CustomMetaDataUnicastTagN624() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN624::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN624")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN624> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN624::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN624::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN624::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN624::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN624::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN624::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN624::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN624::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN624::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN624::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN625 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN625();
	virtual ~CustomMetaDataUnicastTagN625();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN625");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN625);

CustomMetaDataUnicastTagN625::CustomMetaDataUnicastTagN625() {

}

CustomMetaDataUnicastTagN625::~CustomMetaDataUnicastTagN625() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN625::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN625")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN625> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN625::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN625::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN625::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN625::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN625::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN625::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN625::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN625::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN625::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN625::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN7max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN7max();
	virtual ~CustomMetaDataUnicastTagN7max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN7max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN7max);

CustomMetaDataUnicastTagN7max::CustomMetaDataUnicastTagN7max() {

}


CustomMetaDataUnicastTagN7max::~CustomMetaDataUnicastTagN7max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN7max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN7max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN7max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN7max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN7max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN7max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN7max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN7max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN7max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN7max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN7max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN7max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN7max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN71 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN71();
	virtual ~CustomMetaDataUnicastTagN71();
private:

	uint32_t m_neighborid[max1+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN71");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN71);

CustomMetaDataUnicastTagN71::CustomMetaDataUnicastTagN71() {
}


CustomMetaDataUnicastTagN71::~CustomMetaDataUnicastTagN71() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN71::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN71")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN71> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN71::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN71::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN71::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN71::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN71::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN71::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN71::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN71::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN71::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN71::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN72 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN72();
	virtual ~CustomMetaDataUnicastTagN72();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN72");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN72);

CustomMetaDataUnicastTagN72::CustomMetaDataUnicastTagN72() {

}


CustomMetaDataUnicastTagN72::~CustomMetaDataUnicastTagN72() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN72::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN72")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN72> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN72::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN72::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN72::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN72::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN72::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN72::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN72::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN72::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN72::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN72::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN73 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN73();
	virtual ~CustomMetaDataUnicastTagN73();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN73");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN73);

CustomMetaDataUnicastTagN73::CustomMetaDataUnicastTagN73() {

}


CustomMetaDataUnicastTagN73::~CustomMetaDataUnicastTagN73() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN73::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN73")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN73> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN73::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN73::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN73::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN73::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN73::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN73::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN73::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN73::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN73::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN73::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN74 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN74();
	virtual ~CustomMetaDataUnicastTagN74();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN74");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN74);

CustomMetaDataUnicastTagN74::CustomMetaDataUnicastTagN74() {
	
}


CustomMetaDataUnicastTagN74::~CustomMetaDataUnicastTagN74() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN74::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN74")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN74> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN74::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN74::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN74::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN74::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN74::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN74::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN74::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN74::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN74::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN74::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN75 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN75();
	virtual ~CustomMetaDataUnicastTagN75();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN75");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN75);

CustomMetaDataUnicastTagN75::CustomMetaDataUnicastTagN75() {
}


CustomMetaDataUnicastTagN75::~CustomMetaDataUnicastTagN75() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN75::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN75")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN75> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN75::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN75::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN75::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN75::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN75::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN75::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN75::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN75::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN75::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN75::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN76 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN76();
	virtual ~CustomMetaDataUnicastTagN76();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN76");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN76);

CustomMetaDataUnicastTagN76::CustomMetaDataUnicastTagN76() {

}

CustomMetaDataUnicastTagN76::~CustomMetaDataUnicastTagN76() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN76::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN76")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN76> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN76::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN76::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN76::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN76::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN76::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN76::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN76::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN76::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN76::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN76::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN77 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN77();
	virtual ~CustomMetaDataUnicastTagN77();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN77");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN77);

CustomMetaDataUnicastTagN77::CustomMetaDataUnicastTagN77() {

}


CustomMetaDataUnicastTagN77::~CustomMetaDataUnicastTagN77() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN77::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN77")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN77> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN77::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN77::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN77::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN77::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN77::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN77::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN77::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN77::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN77::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN77::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN78 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN78();
	virtual ~CustomMetaDataUnicastTagN78();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN78");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN78);

CustomMetaDataUnicastTagN78::CustomMetaDataUnicastTagN78() {
}


CustomMetaDataUnicastTagN78::~CustomMetaDataUnicastTagN78() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN78::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN78")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN78> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN78::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN78::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN78::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN78::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN78::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN78::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN78::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN78::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN78::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN78::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN79 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN79();
	virtual ~CustomMetaDataUnicastTagN79();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN79");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN79);

CustomMetaDataUnicastTagN79::CustomMetaDataUnicastTagN79() {

}


CustomMetaDataUnicastTagN79::~CustomMetaDataUnicastTagN79() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN79::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN79")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN79> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN79::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN79::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN79::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN79::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN79::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN79::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN79::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN79::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN79::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN79::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN710 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN710();
	virtual ~CustomMetaDataUnicastTagN710();
private:

	uint32_t m_neighborid[max10+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN710");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN710);

CustomMetaDataUnicastTagN710::CustomMetaDataUnicastTagN710() {
	
}


CustomMetaDataUnicastTagN710::~CustomMetaDataUnicastTagN710() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN710::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN710")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN710> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN710::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN710::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN710::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN710::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN710::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN710::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN710::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN710::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN710::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN710::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN711 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN711();
	virtual ~CustomMetaDataUnicastTagN711();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN711");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN711);

CustomMetaDataUnicastTagN711::CustomMetaDataUnicastTagN711() {

}


CustomMetaDataUnicastTagN711::~CustomMetaDataUnicastTagN711() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN711::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN711")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN711> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN711::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN711::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN711::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN711::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN711::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN711::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN711::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN711::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN711::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN711::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN712 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN712();

	virtual ~CustomMetaDataUnicastTagN712();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN712");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN712);

CustomMetaDataUnicastTagN712::CustomMetaDataUnicastTagN712() {
}


CustomMetaDataUnicastTagN712::~CustomMetaDataUnicastTagN712() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN712::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN712")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN712> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN712::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN712::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN712::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN712::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN712::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN712::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN712::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN712::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN712::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN712::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN713 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN713();
	virtual ~CustomMetaDataUnicastTagN713();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN713");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN713);

CustomMetaDataUnicastTagN713::CustomMetaDataUnicastTagN713() {

}


CustomMetaDataUnicastTagN713::~CustomMetaDataUnicastTagN713() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN713::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN713")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN713> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN713::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN713::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN713::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN713::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN713::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN713::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN713::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN713::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN713::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN713::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN714 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN714();
	virtual ~CustomMetaDataUnicastTagN714();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN714");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN714);

CustomMetaDataUnicastTagN714::CustomMetaDataUnicastTagN714() {

}


CustomMetaDataUnicastTagN714::~CustomMetaDataUnicastTagN714() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN714::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN714")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN714> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN714::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN714::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN714::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN714::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN714::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN714::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN714::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN714::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN714::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN714::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN715 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN715();
	virtual ~CustomMetaDataUnicastTagN715();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN715");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN715);

CustomMetaDataUnicastTagN715::CustomMetaDataUnicastTagN715() {

}

CustomMetaDataUnicastTagN715::~CustomMetaDataUnicastTagN715() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN715::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN715")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN715> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN715::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN715::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN715::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN715::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN715::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN715::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN715::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN715::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN715::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN715::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN716 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN716();
	virtual ~CustomMetaDataUnicastTagN716();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN716");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN716);

CustomMetaDataUnicastTagN716::CustomMetaDataUnicastTagN716() {

}

CustomMetaDataUnicastTagN716::~CustomMetaDataUnicastTagN716() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN716::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN716")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN716> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN716::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN716::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN716::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN716::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN716::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN716::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN716::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN716::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN716::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN716::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN717 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN717();
	virtual ~CustomMetaDataUnicastTagN717();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN717");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN717);

CustomMetaDataUnicastTagN717::CustomMetaDataUnicastTagN717() {

}

CustomMetaDataUnicastTagN717::~CustomMetaDataUnicastTagN717() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN717::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN717")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN717> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN717::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN717::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN717::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN717::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN717::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN717::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN717::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN717::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN717::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN717::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN718 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN718();
	virtual ~CustomMetaDataUnicastTagN718();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN718");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN718);

CustomMetaDataUnicastTagN718::CustomMetaDataUnicastTagN718() {

}

CustomMetaDataUnicastTagN718::~CustomMetaDataUnicastTagN718() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN718::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN718")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN718> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN718::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN718::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN718::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN718::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN718::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN718::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN718::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN718::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN718::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN718::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN719 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN719();
	virtual ~CustomMetaDataUnicastTagN719();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN719");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN719);

CustomMetaDataUnicastTagN719::CustomMetaDataUnicastTagN719() {

}

CustomMetaDataUnicastTagN719::~CustomMetaDataUnicastTagN719() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN719::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN719")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN719> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN719::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN719::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN719::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN719::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN719::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN719::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN719::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN719::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN719::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN719::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN720 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN720();
	virtual ~CustomMetaDataUnicastTagN720();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN720");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN720);

CustomMetaDataUnicastTagN720::CustomMetaDataUnicastTagN720() {

}

CustomMetaDataUnicastTagN720::~CustomMetaDataUnicastTagN720() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN720::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN720")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN720> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN720::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN720::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN720::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN720::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN720::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN720::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN720::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN720::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN720::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN720::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN721 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN721();
	virtual ~CustomMetaDataUnicastTagN721();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN721");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN721);

CustomMetaDataUnicastTagN721::CustomMetaDataUnicastTagN721() {

}

CustomMetaDataUnicastTagN721::~CustomMetaDataUnicastTagN721() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN721::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN721")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN721> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN721::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN721::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN721::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN721::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN721::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN721::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN721::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN721::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN721::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN721::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN722 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN722();
	virtual ~CustomMetaDataUnicastTagN722();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN722");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN722);

CustomMetaDataUnicastTagN722::CustomMetaDataUnicastTagN722() {

}

CustomMetaDataUnicastTagN722::~CustomMetaDataUnicastTagN722() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN722::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN722")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN722> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN722::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN722::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN722::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN722::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN722::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN722::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN722::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN722::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN722::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN722::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN723 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN723();
	virtual ~CustomMetaDataUnicastTagN723();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN723");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN723);

CustomMetaDataUnicastTagN723::CustomMetaDataUnicastTagN723() {

}

CustomMetaDataUnicastTagN723::~CustomMetaDataUnicastTagN723() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN723::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN723")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN723> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN723::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN723::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN723::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN723::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN723::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN723::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN723::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN723::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN723::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN723::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN724 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN724();
	virtual ~CustomMetaDataUnicastTagN724();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN724");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN724);

CustomMetaDataUnicastTagN724::CustomMetaDataUnicastTagN724() {

}

CustomMetaDataUnicastTagN724::~CustomMetaDataUnicastTagN724() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN724::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN724")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN724> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN724::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN724::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN724::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN724::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN724::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN724::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN724::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN724::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN724::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN724::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN725 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN725();
	virtual ~CustomMetaDataUnicastTagN725();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN725");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN725);

CustomMetaDataUnicastTagN725::CustomMetaDataUnicastTagN725() {

}

CustomMetaDataUnicastTagN725::~CustomMetaDataUnicastTagN725() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN725::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN725")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN725> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN725::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN725::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN725::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN725::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN725::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN725::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN725::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN725::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN725::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN725::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN8max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN8max();
	virtual ~CustomMetaDataUnicastTagN8max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN8max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN8max);

CustomMetaDataUnicastTagN8max::CustomMetaDataUnicastTagN8max() {

}


CustomMetaDataUnicastTagN8max::~CustomMetaDataUnicastTagN8max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN8max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN8max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN8max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN8max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN8max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN8max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN8max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN8max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN8max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN8max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN8max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN8max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN8max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN81 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN81();
	virtual ~CustomMetaDataUnicastTagN81();
private:

	uint32_t m_neighborid[max1+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN81");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN81);

CustomMetaDataUnicastTagN81::CustomMetaDataUnicastTagN81() {
}


CustomMetaDataUnicastTagN81::~CustomMetaDataUnicastTagN81() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN81::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN81")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN81> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN81::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN81::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN81::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN81::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN81::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN81::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN81::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN81::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN81::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN81::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN82 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN82();
	virtual ~CustomMetaDataUnicastTagN82();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN82");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN82);

CustomMetaDataUnicastTagN82::CustomMetaDataUnicastTagN82() {

}


CustomMetaDataUnicastTagN82::~CustomMetaDataUnicastTagN82() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN82::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN82")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN82> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN82::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN82::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN82::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN82::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN82::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN82::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN82::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN82::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN82::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN82::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN83 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN83();
	virtual ~CustomMetaDataUnicastTagN83();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN83");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN83);

CustomMetaDataUnicastTagN83::CustomMetaDataUnicastTagN83() {

}


CustomMetaDataUnicastTagN83::~CustomMetaDataUnicastTagN83() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN83::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN83")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN83> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN83::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN83::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN83::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN83::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN83::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN83::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN83::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN83::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN83::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN83::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN84 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN84();
	virtual ~CustomMetaDataUnicastTagN84();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN84");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN84);

CustomMetaDataUnicastTagN84::CustomMetaDataUnicastTagN84() {
	
}


CustomMetaDataUnicastTagN84::~CustomMetaDataUnicastTagN84() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN84::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN84")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN84> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN84::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN84::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN84::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN84::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN84::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN84::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN84::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN84::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN84::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN84::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN85 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN85();
	virtual ~CustomMetaDataUnicastTagN85();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN85");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN85);

CustomMetaDataUnicastTagN85::CustomMetaDataUnicastTagN85() {
}


CustomMetaDataUnicastTagN85::~CustomMetaDataUnicastTagN85() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN85::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN85")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN85> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN85::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN85::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN85::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN85::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN85::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN85::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN85::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN85::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN85::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN85::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN86 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN86();
	virtual ~CustomMetaDataUnicastTagN86();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN86");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN86);

CustomMetaDataUnicastTagN86::CustomMetaDataUnicastTagN86() {

}

CustomMetaDataUnicastTagN86::~CustomMetaDataUnicastTagN86() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN86::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN86")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN86> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN86::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN86::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN86::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN86::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN86::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN86::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN86::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN86::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN86::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN86::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN87 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN87();
	virtual ~CustomMetaDataUnicastTagN87();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN87");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN87);

CustomMetaDataUnicastTagN87::CustomMetaDataUnicastTagN87() {

}


CustomMetaDataUnicastTagN87::~CustomMetaDataUnicastTagN87() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN87::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN87")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN87> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN87::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN87::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN87::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN87::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN87::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN87::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN87::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN87::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN87::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN87::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN88 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN88();
	virtual ~CustomMetaDataUnicastTagN88();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN88");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN88);

CustomMetaDataUnicastTagN88::CustomMetaDataUnicastTagN88() {
}


CustomMetaDataUnicastTagN88::~CustomMetaDataUnicastTagN88() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN88::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN88")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN88> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN88::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN88::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN88::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN88::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN88::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN88::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN88::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN88::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN88::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN88::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN89 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN89();
	virtual ~CustomMetaDataUnicastTagN89();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN89");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN89);

CustomMetaDataUnicastTagN89::CustomMetaDataUnicastTagN89() {

}


CustomMetaDataUnicastTagN89::~CustomMetaDataUnicastTagN89() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN89::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN89")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN89> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN89::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN89::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN89::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN89::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN89::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN89::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN89::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN89::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN89::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN89::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN810 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN810();
	virtual ~CustomMetaDataUnicastTagN810();
private:

	uint32_t m_neighborid[max10+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN810");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN810);

CustomMetaDataUnicastTagN810::CustomMetaDataUnicastTagN810() {
	
}


CustomMetaDataUnicastTagN810::~CustomMetaDataUnicastTagN810() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN810::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN810")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN810> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN810::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN810::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN810::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN810::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN810::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN810::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN810::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN810::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN810::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN810::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN811 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN811();
	virtual ~CustomMetaDataUnicastTagN811();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN811");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN811);

CustomMetaDataUnicastTagN811::CustomMetaDataUnicastTagN811() {

}


CustomMetaDataUnicastTagN811::~CustomMetaDataUnicastTagN811() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN811::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN811")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN811> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN811::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN811::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN811::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN811::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN811::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN811::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN811::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN811::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN811::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN811::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN812 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN812();

	virtual ~CustomMetaDataUnicastTagN812();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN812");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN812);

CustomMetaDataUnicastTagN812::CustomMetaDataUnicastTagN812() {
}


CustomMetaDataUnicastTagN812::~CustomMetaDataUnicastTagN812() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN812::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN812")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN812> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN812::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN812::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN812::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN812::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN812::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN812::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN812::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN812::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN812::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN812::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN813 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN813();
	virtual ~CustomMetaDataUnicastTagN813();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN813");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN813);

CustomMetaDataUnicastTagN813::CustomMetaDataUnicastTagN813() {

}


CustomMetaDataUnicastTagN813::~CustomMetaDataUnicastTagN813() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN813::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN813")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN813> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN813::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN813::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN813::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN813::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN813::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN813::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN813::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN813::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN813::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN813::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN814 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN814();
	virtual ~CustomMetaDataUnicastTagN814();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN814");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN814);

CustomMetaDataUnicastTagN814::CustomMetaDataUnicastTagN814() {

}


CustomMetaDataUnicastTagN814::~CustomMetaDataUnicastTagN814() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN814::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN814")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN814> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN814::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN814::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN814::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN814::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN814::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN814::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN814::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN814::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN814::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN814::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN815 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN815();
	virtual ~CustomMetaDataUnicastTagN815();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN815");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN815);

CustomMetaDataUnicastTagN815::CustomMetaDataUnicastTagN815() {

}

CustomMetaDataUnicastTagN815::~CustomMetaDataUnicastTagN815() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN815::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN815")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN815> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN815::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN815::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN815::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN815::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN815::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN815::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN815::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN815::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN815::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN815::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN816 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN816();
	virtual ~CustomMetaDataUnicastTagN816();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN816");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN816);

CustomMetaDataUnicastTagN816::CustomMetaDataUnicastTagN816() {

}

CustomMetaDataUnicastTagN816::~CustomMetaDataUnicastTagN816() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN816::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN816")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN816> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN816::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN816::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN816::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN816::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN816::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN816::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN816::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN816::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN816::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN816::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN817 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN817();
	virtual ~CustomMetaDataUnicastTagN817();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN817");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN817);

CustomMetaDataUnicastTagN817::CustomMetaDataUnicastTagN817() {

}

CustomMetaDataUnicastTagN817::~CustomMetaDataUnicastTagN817() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN817::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN817")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN817> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN817::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN817::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN817::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN817::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN817::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN817::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN817::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN817::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN817::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN817::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN818 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN818();
	virtual ~CustomMetaDataUnicastTagN818();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN818");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN818);

CustomMetaDataUnicastTagN818::CustomMetaDataUnicastTagN818() {

}

CustomMetaDataUnicastTagN818::~CustomMetaDataUnicastTagN818() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN818::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN818")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN818> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN818::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN818::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN818::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN818::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN818::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN818::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN818::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN818::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN818::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN818::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN819 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN819();
	virtual ~CustomMetaDataUnicastTagN819();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN819");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN819);

CustomMetaDataUnicastTagN819::CustomMetaDataUnicastTagN819() {

}

CustomMetaDataUnicastTagN819::~CustomMetaDataUnicastTagN819() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN819::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN819")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN819> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN819::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN819::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN819::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN819::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN819::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN819::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN819::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN819::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN819::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN819::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN820 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN820();
	virtual ~CustomMetaDataUnicastTagN820();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN820");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN820);

CustomMetaDataUnicastTagN820::CustomMetaDataUnicastTagN820() {

}

CustomMetaDataUnicastTagN820::~CustomMetaDataUnicastTagN820() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN820::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN820")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN820> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN820::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN820::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN820::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN820::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN820::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN820::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN820::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN820::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN820::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN820::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN821 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN821();
	virtual ~CustomMetaDataUnicastTagN821();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN821");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN821);

CustomMetaDataUnicastTagN821::CustomMetaDataUnicastTagN821() {

}

CustomMetaDataUnicastTagN821::~CustomMetaDataUnicastTagN821() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN821::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN821")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN821> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN821::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN821::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN821::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN821::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN821::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN821::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN821::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN821::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN821::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN821::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN822 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN822();
	virtual ~CustomMetaDataUnicastTagN822();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN822");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN822);

CustomMetaDataUnicastTagN822::CustomMetaDataUnicastTagN822() {

}

CustomMetaDataUnicastTagN822::~CustomMetaDataUnicastTagN822() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN822::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN822")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN822> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN822::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN822::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN822::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN822::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN822::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN822::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN822::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN822::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN822::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN822::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN823 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN823();
	virtual ~CustomMetaDataUnicastTagN823();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN823");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN823);

CustomMetaDataUnicastTagN823::CustomMetaDataUnicastTagN823() {

}

CustomMetaDataUnicastTagN823::~CustomMetaDataUnicastTagN823() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN823::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN823")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN823> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN823::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN823::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN823::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN823::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN823::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN823::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN823::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN823::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN823::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN823::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN824 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN824();
	virtual ~CustomMetaDataUnicastTagN824();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN824");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN824);

CustomMetaDataUnicastTagN824::CustomMetaDataUnicastTagN824() {

}

CustomMetaDataUnicastTagN824::~CustomMetaDataUnicastTagN824() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN824::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN824")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN824> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN824::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN824::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN824::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN824::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN824::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN824::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN824::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN824::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN824::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN824::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN825 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN825();
	virtual ~CustomMetaDataUnicastTagN825();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN825");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN825);

CustomMetaDataUnicastTagN825::CustomMetaDataUnicastTagN825() {

}

CustomMetaDataUnicastTagN825::~CustomMetaDataUnicastTagN825() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN825::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN825")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN825> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN825::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN825::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN825::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN825::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN825::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN825::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN825::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN825::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN825::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN825::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN9max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN9max();
	virtual ~CustomMetaDataUnicastTagN9max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN9max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN9max);

CustomMetaDataUnicastTagN9max::CustomMetaDataUnicastTagN9max() {

}


CustomMetaDataUnicastTagN9max::~CustomMetaDataUnicastTagN9max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN9max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN9max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN9max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN9max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN9max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN9max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN9max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN9max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN9max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN9max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN9max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN9max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN9max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN91 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN91();
	virtual ~CustomMetaDataUnicastTagN91();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN91");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN91);

CustomMetaDataUnicastTagN91::CustomMetaDataUnicastTagN91() {
}


CustomMetaDataUnicastTagN91::~CustomMetaDataUnicastTagN91() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN91::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN91")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN91> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN91::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN91::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN91::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN91::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN91::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN91::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN91::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN91::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN91::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN91::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN92 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN92();
	virtual ~CustomMetaDataUnicastTagN92();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN92");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN92);

CustomMetaDataUnicastTagN92::CustomMetaDataUnicastTagN92() {

}


CustomMetaDataUnicastTagN92::~CustomMetaDataUnicastTagN92() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN92::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN92")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN92> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN92::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN92::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN92::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN92::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN92::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN92::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN92::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN92::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN92::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN92::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN93 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN93();
	virtual ~CustomMetaDataUnicastTagN93();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN93");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN93);

CustomMetaDataUnicastTagN93::CustomMetaDataUnicastTagN93() {

}


CustomMetaDataUnicastTagN93::~CustomMetaDataUnicastTagN93() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN93::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN93")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN93> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN93::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN93::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN93::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN93::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN93::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN93::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN93::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN93::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN93::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN93::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN94 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN94();
	virtual ~CustomMetaDataUnicastTagN94();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN94");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN94);

CustomMetaDataUnicastTagN94::CustomMetaDataUnicastTagN94() {
	
}


CustomMetaDataUnicastTagN94::~CustomMetaDataUnicastTagN94() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN94::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN94")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN94> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN94::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN94::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN94::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN94::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN94::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN94::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN94::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN94::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN94::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN94::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN95 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN95();
	virtual ~CustomMetaDataUnicastTagN95();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN95");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN95);

CustomMetaDataUnicastTagN95::CustomMetaDataUnicastTagN95() {
}


CustomMetaDataUnicastTagN95::~CustomMetaDataUnicastTagN95() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN95::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN95")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN95> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN95::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN95::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN95::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN95::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN95::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN95::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN95::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN95::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN95::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN95::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN96 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN96();
	virtual ~CustomMetaDataUnicastTagN96();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN96");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN96);

CustomMetaDataUnicastTagN96::CustomMetaDataUnicastTagN96() {

}

CustomMetaDataUnicastTagN96::~CustomMetaDataUnicastTagN96() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN96::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN96")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN96> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN96::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN96::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN96::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN96::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN96::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN96::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN96::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN96::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN96::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN96::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN97 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN97();
	virtual ~CustomMetaDataUnicastTagN97();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN97");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN97);

CustomMetaDataUnicastTagN97::CustomMetaDataUnicastTagN97() {

}


CustomMetaDataUnicastTagN97::~CustomMetaDataUnicastTagN97() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN97::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN97")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN97> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN97::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN97::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN97::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN97::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN97::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN97::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN97::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN97::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN97::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN97::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN98 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN98();
	virtual ~CustomMetaDataUnicastTagN98();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN98");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN98);

CustomMetaDataUnicastTagN98::CustomMetaDataUnicastTagN98() {
}


CustomMetaDataUnicastTagN98::~CustomMetaDataUnicastTagN98() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN98::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN98")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN98> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN98::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN98::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN98::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN98::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN98::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN98::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN98::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN98::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN98::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN98::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN99 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN99();
	virtual ~CustomMetaDataUnicastTagN99();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN99");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN99);

CustomMetaDataUnicastTagN99::CustomMetaDataUnicastTagN99() {

}


CustomMetaDataUnicastTagN99::~CustomMetaDataUnicastTagN99() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN99::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN99")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN99> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN99::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN99::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN99::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN99::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN99::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN99::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN99::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN99::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN99::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN99::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN910 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN910();
	virtual ~CustomMetaDataUnicastTagN910();
private:

	uint32_t m_neighborid[max10+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN910");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN910);

CustomMetaDataUnicastTagN910::CustomMetaDataUnicastTagN910() {
	
}


CustomMetaDataUnicastTagN910::~CustomMetaDataUnicastTagN910() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN910::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN910")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN910> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN910::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN910::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN910::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN910::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN910::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN910::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN910::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN910::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN910::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN910::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN911 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN911();
	virtual ~CustomMetaDataUnicastTagN911();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN911");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN911);

CustomMetaDataUnicastTagN911::CustomMetaDataUnicastTagN911() {

}


CustomMetaDataUnicastTagN911::~CustomMetaDataUnicastTagN911() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN911::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN911")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN911> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN911::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN911::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN911::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN911::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN911::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN911::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN911::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN911::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN911::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN911::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN912 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN912();

	virtual ~CustomMetaDataUnicastTagN912();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN912");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN912);

CustomMetaDataUnicastTagN912::CustomMetaDataUnicastTagN912() {
}


CustomMetaDataUnicastTagN912::~CustomMetaDataUnicastTagN912() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN912::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN912")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN912> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN912::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN912::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN912::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN912::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN912::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN912::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN912::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN912::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN912::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN912::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN913 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN913();
	virtual ~CustomMetaDataUnicastTagN913();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN913");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN913);

CustomMetaDataUnicastTagN913::CustomMetaDataUnicastTagN913() {

}


CustomMetaDataUnicastTagN913::~CustomMetaDataUnicastTagN913() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN913::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN913")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN913> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN913::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN913::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN913::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN913::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN913::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN913::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN913::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN913::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN913::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN913::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN914 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN914();
	virtual ~CustomMetaDataUnicastTagN914();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN914");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN914);

CustomMetaDataUnicastTagN914::CustomMetaDataUnicastTagN914() {

}


CustomMetaDataUnicastTagN914::~CustomMetaDataUnicastTagN914() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN914::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN914")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN914> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN914::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN914::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN914::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN914::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN914::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN914::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN914::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN914::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN914::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN914::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN915 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN915();
	virtual ~CustomMetaDataUnicastTagN915();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN915");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN915);

CustomMetaDataUnicastTagN915::CustomMetaDataUnicastTagN915() {

}

CustomMetaDataUnicastTagN915::~CustomMetaDataUnicastTagN915() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN915::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN915")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN915> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN915::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN915::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN915::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN915::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN915::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN915::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN915::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN915::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN915::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN915::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN916 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN916();
	virtual ~CustomMetaDataUnicastTagN916();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN916");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN916);

CustomMetaDataUnicastTagN916::CustomMetaDataUnicastTagN916() {

}

CustomMetaDataUnicastTagN916::~CustomMetaDataUnicastTagN916() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN916::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN916")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN916> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN916::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN916::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN916::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN916::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN916::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN916::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN916::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN916::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN916::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN916::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN917 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN917();
	virtual ~CustomMetaDataUnicastTagN917();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN917");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN917);

CustomMetaDataUnicastTagN917::CustomMetaDataUnicastTagN917() {

}

CustomMetaDataUnicastTagN917::~CustomMetaDataUnicastTagN917() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN917::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN917")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN917> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN917::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN917::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN917::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN917::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN917::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN917::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN917::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN917::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN917::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN917::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN918 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN918();
	virtual ~CustomMetaDataUnicastTagN918();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN918");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN918);

CustomMetaDataUnicastTagN918::CustomMetaDataUnicastTagN918() {

}

CustomMetaDataUnicastTagN918::~CustomMetaDataUnicastTagN918() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN918::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN918")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN918> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN918::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN918::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN918::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN918::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN918::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN918::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN918::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN918::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN918::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN918::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN919 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN919();
	virtual ~CustomMetaDataUnicastTagN919();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN919");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN919);

CustomMetaDataUnicastTagN919::CustomMetaDataUnicastTagN919() {

}

CustomMetaDataUnicastTagN919::~CustomMetaDataUnicastTagN919() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN919::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN919")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN919> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN919::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN919::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN919::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN919::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN919::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN919::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN919::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN919::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN919::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN919::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN920 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN920();
	virtual ~CustomMetaDataUnicastTagN920();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN920");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN920);

CustomMetaDataUnicastTagN920::CustomMetaDataUnicastTagN920() {

}

CustomMetaDataUnicastTagN920::~CustomMetaDataUnicastTagN920() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN920::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN920")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN920> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN920::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN920::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN920::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN920::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN920::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN920::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN920::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN920::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN920::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN920::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN921 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN921();
	virtual ~CustomMetaDataUnicastTagN921();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN921");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN921);

CustomMetaDataUnicastTagN921::CustomMetaDataUnicastTagN921() {

}

CustomMetaDataUnicastTagN921::~CustomMetaDataUnicastTagN921() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN921::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN921")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN921> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN921::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN921::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN921::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN921::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN921::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN921::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN921::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN921::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN921::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN921::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN922 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN922();
	virtual ~CustomMetaDataUnicastTagN922();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN922");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN922);

CustomMetaDataUnicastTagN922::CustomMetaDataUnicastTagN922() {

}

CustomMetaDataUnicastTagN922::~CustomMetaDataUnicastTagN922() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN922::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN922")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN922> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN922::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN922::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN922::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN922::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN922::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN922::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN922::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN922::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN922::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN922::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN923 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN923();
	virtual ~CustomMetaDataUnicastTagN923();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN923");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN923);

CustomMetaDataUnicastTagN923::CustomMetaDataUnicastTagN923() {

}

CustomMetaDataUnicastTagN923::~CustomMetaDataUnicastTagN923() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN923::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN923")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN923> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN923::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN923::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN923::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN923::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN923::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN923::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN923::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN923::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN923::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN923::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN924 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN924();
	virtual ~CustomMetaDataUnicastTagN924();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN924");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN924);

CustomMetaDataUnicastTagN924::CustomMetaDataUnicastTagN924() {

}

CustomMetaDataUnicastTagN924::~CustomMetaDataUnicastTagN924() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN924::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN924")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN924> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN924::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN924::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN924::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN924::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN924::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN924::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN924::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN924::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN924::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN924::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN925 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN925();
	virtual ~CustomMetaDataUnicastTagN925();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN925");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN925);

CustomMetaDataUnicastTagN925::CustomMetaDataUnicastTagN925() {

}

CustomMetaDataUnicastTagN925::~CustomMetaDataUnicastTagN925() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN925::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN925")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN925> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN925::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN925::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN925::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN925::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN925::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN925::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN925::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN925::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN925::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN925::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN10max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN10max();
	virtual ~CustomMetaDataUnicastTagN10max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN10max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN10max);

CustomMetaDataUnicastTagN10max::CustomMetaDataUnicastTagN10max() {

}


CustomMetaDataUnicastTagN10max::~CustomMetaDataUnicastTagN10max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN10max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN10max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN10max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN10max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN10max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN10max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN10max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN10max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN10max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN10max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN10max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN10max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN10max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN101 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN101();
	virtual ~CustomMetaDataUnicastTagN101();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN101");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN101);

CustomMetaDataUnicastTagN101::CustomMetaDataUnicastTagN101() {
}


CustomMetaDataUnicastTagN101::~CustomMetaDataUnicastTagN101() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN101::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN101")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN101> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN101::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN101::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN101::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN101::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN101::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN101::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN101::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN101::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN101::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN101::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN102 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN102();
	virtual ~CustomMetaDataUnicastTagN102();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN102");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN102);

CustomMetaDataUnicastTagN102::CustomMetaDataUnicastTagN102() {

}


CustomMetaDataUnicastTagN102::~CustomMetaDataUnicastTagN102() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN102::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN102")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN102> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN102::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN102::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN102::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN102::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN102::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN102::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN102::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN102::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN102::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN102::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN103 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN103();
	virtual ~CustomMetaDataUnicastTagN103();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN103");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN103);

CustomMetaDataUnicastTagN103::CustomMetaDataUnicastTagN103() {

}


CustomMetaDataUnicastTagN103::~CustomMetaDataUnicastTagN103() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN103::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN103")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN103> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN103::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN103::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN103::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN103::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN103::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN103::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN103::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN103::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN103::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN103::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN104 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN104();
	virtual ~CustomMetaDataUnicastTagN104();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN104");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN104);

CustomMetaDataUnicastTagN104::CustomMetaDataUnicastTagN104() {
	
}


CustomMetaDataUnicastTagN104::~CustomMetaDataUnicastTagN104() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN104::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN104")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN104> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN104::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN104::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN104::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN104::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN104::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN104::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN104::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN104::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN104::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN104::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN105 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN105();
	virtual ~CustomMetaDataUnicastTagN105();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN105");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN105);

CustomMetaDataUnicastTagN105::CustomMetaDataUnicastTagN105() {
}


CustomMetaDataUnicastTagN105::~CustomMetaDataUnicastTagN105() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN105::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN105")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN105> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN105::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN105::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN105::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN105::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN105::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN105::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN105::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN105::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN105::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN105::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN106 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN106();
	virtual ~CustomMetaDataUnicastTagN106();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN106");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN106);

CustomMetaDataUnicastTagN106::CustomMetaDataUnicastTagN106() {

}

CustomMetaDataUnicastTagN106::~CustomMetaDataUnicastTagN106() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN106::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN106")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN106> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN106::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN106::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN106::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN106::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN106::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN106::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN106::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN106::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN106::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN106::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN107 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN107();
	virtual ~CustomMetaDataUnicastTagN107();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN107");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN107);

CustomMetaDataUnicastTagN107::CustomMetaDataUnicastTagN107() {

}


CustomMetaDataUnicastTagN107::~CustomMetaDataUnicastTagN107() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN107::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN107")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN107> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN107::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN107::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN107::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN107::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN107::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN107::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN107::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN107::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN107::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN107::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN108 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN108();
	virtual ~CustomMetaDataUnicastTagN108();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN108");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN108);

CustomMetaDataUnicastTagN108::CustomMetaDataUnicastTagN108() {
}


CustomMetaDataUnicastTagN108::~CustomMetaDataUnicastTagN108() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN108::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN108")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN108> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN108::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN108::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN108::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN108::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN108::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN108::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN108::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN108::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN108::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN108::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN109 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN109();
	virtual ~CustomMetaDataUnicastTagN109();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN109");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN109);

CustomMetaDataUnicastTagN109::CustomMetaDataUnicastTagN109() {

}


CustomMetaDataUnicastTagN109::~CustomMetaDataUnicastTagN109() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN109::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN109")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN109> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN109::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN109::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN109::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN109::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN109::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN109::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN109::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN109::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN109::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN109::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1010 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1010();
	virtual ~CustomMetaDataUnicastTagN1010();
private:

	uint32_t m_neighborid[max10+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1010");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1010);

CustomMetaDataUnicastTagN1010::CustomMetaDataUnicastTagN1010() {
	
}


CustomMetaDataUnicastTagN1010::~CustomMetaDataUnicastTagN1010() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1010::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1010")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1010> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1010::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1010::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1010::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1010::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1010::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1010::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1010::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1010::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1010::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1010::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1011 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1011();
	virtual ~CustomMetaDataUnicastTagN1011();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1011");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1011);

CustomMetaDataUnicastTagN1011::CustomMetaDataUnicastTagN1011() {

}


CustomMetaDataUnicastTagN1011::~CustomMetaDataUnicastTagN1011() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1011::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1011")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1011> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1011::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1011::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1011::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1011::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN1011::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1011::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1011::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1011::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1011::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1011::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1012 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1012();

	virtual ~CustomMetaDataUnicastTagN1012();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1012");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1012);

CustomMetaDataUnicastTagN1012::CustomMetaDataUnicastTagN1012() {
}


CustomMetaDataUnicastTagN1012::~CustomMetaDataUnicastTagN1012() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1012::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1012")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1012> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1012::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1012::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1012::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1012::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1012::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1012::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1012::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1012::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN1012::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1012::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1013 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1013();
	virtual ~CustomMetaDataUnicastTagN1013();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1013");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1013);

CustomMetaDataUnicastTagN1013::CustomMetaDataUnicastTagN1013() {

}


CustomMetaDataUnicastTagN1013::~CustomMetaDataUnicastTagN1013() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1013::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1013")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1013> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1013::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1013::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN1013::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1013::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1013::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1013::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1013::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1013::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1013::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1013::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1014 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN1014();
	virtual ~CustomMetaDataUnicastTagN1014();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1014");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1014);

CustomMetaDataUnicastTagN1014::CustomMetaDataUnicastTagN1014() {

}


CustomMetaDataUnicastTagN1014::~CustomMetaDataUnicastTagN1014() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1014::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1014")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1014> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1014::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1014::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1014::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1014::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1014::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1014::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN1014::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1014::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1014::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1014::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1015 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1015();
	virtual ~CustomMetaDataUnicastTagN1015();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1015");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1015);

CustomMetaDataUnicastTagN1015::CustomMetaDataUnicastTagN1015() {

}

CustomMetaDataUnicastTagN1015::~CustomMetaDataUnicastTagN1015() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1015::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1015")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1015> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1015::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1015::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1015::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1015::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1015::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1015::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1015::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1015::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1015::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1015::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1016 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1016();
	virtual ~CustomMetaDataUnicastTagN1016();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1016");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1016);

CustomMetaDataUnicastTagN1016::CustomMetaDataUnicastTagN1016() {

}

CustomMetaDataUnicastTagN1016::~CustomMetaDataUnicastTagN1016() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1016::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1016")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1016> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1016::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1016::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1016::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1016::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1016::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1016::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1016::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1016::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1016::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1016::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1017 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1017();
	virtual ~CustomMetaDataUnicastTagN1017();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1017");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1017);

CustomMetaDataUnicastTagN1017::CustomMetaDataUnicastTagN1017() {

}

CustomMetaDataUnicastTagN1017::~CustomMetaDataUnicastTagN1017() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1017::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1017")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1017> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1017::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1017::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1017::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1017::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1017::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1017::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1017::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1017::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1017::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1017::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1018 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1018();
	virtual ~CustomMetaDataUnicastTagN1018();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1018");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1018);

CustomMetaDataUnicastTagN1018::CustomMetaDataUnicastTagN1018() {

}

CustomMetaDataUnicastTagN1018::~CustomMetaDataUnicastTagN1018() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1018::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1018")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1018> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1018::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1018::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1018::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1018::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1018::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1018::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1018::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1018::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1018::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1018::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1019 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1019();
	virtual ~CustomMetaDataUnicastTagN1019();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1019");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1019);

CustomMetaDataUnicastTagN1019::CustomMetaDataUnicastTagN1019() {

}

CustomMetaDataUnicastTagN1019::~CustomMetaDataUnicastTagN1019() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1019::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1019")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1019> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1019::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1019::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1019::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1019::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1019::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1019::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1019::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1019::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1019::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1019::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1020 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1020();
	virtual ~CustomMetaDataUnicastTagN1020();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1020");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1020);

CustomMetaDataUnicastTagN1020::CustomMetaDataUnicastTagN1020() {

}

CustomMetaDataUnicastTagN1020::~CustomMetaDataUnicastTagN1020() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1020::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1020")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1020> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1020::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1020::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1020::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1020::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1020::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1020::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1020::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1020::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1020::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1020::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1021 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1021();
	virtual ~CustomMetaDataUnicastTagN1021();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1021");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1021);

CustomMetaDataUnicastTagN1021::CustomMetaDataUnicastTagN1021() {

}

CustomMetaDataUnicastTagN1021::~CustomMetaDataUnicastTagN1021() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1021::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1021")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1021> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1021::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1021::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1021::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1021::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1021::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1021::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1021::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1021::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1021::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1021::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1022 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1022();
	virtual ~CustomMetaDataUnicastTagN1022();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1022");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1022);

CustomMetaDataUnicastTagN1022::CustomMetaDataUnicastTagN1022() {

}

CustomMetaDataUnicastTagN1022::~CustomMetaDataUnicastTagN1022() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1022::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1022")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1022> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1022::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1022::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1022::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1022::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1022::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1022::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1022::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1022::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1022::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1022::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1023 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1023();
	virtual ~CustomMetaDataUnicastTagN1023();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1023");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1023);

CustomMetaDataUnicastTagN1023::CustomMetaDataUnicastTagN1023() {

}

CustomMetaDataUnicastTagN1023::~CustomMetaDataUnicastTagN1023() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1023::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1023")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1023> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1023::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1023::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1023::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1023::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1023::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1023::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1023::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1023::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1023::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1023::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1024 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1024();
	virtual ~CustomMetaDataUnicastTagN1024();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1024");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1024);

CustomMetaDataUnicastTagN1024::CustomMetaDataUnicastTagN1024() {

}

CustomMetaDataUnicastTagN1024::~CustomMetaDataUnicastTagN1024() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1024::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1024")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1024> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1024::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1024::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1024::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1024::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1024::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1024::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1024::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1024::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1024::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1024::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1025 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1025();
	virtual ~CustomMetaDataUnicastTagN1025();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1025");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1025);

CustomMetaDataUnicastTagN1025::CustomMetaDataUnicastTagN1025() {

}

CustomMetaDataUnicastTagN1025::~CustomMetaDataUnicastTagN1025() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1025::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1025")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1025> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1025::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1025::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1025::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1025::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1025::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1025::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1025::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1025::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1025::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1025::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN11max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN11max();
	virtual ~CustomMetaDataUnicastTagN11max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN11max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN11max);

CustomMetaDataUnicastTagN11max::CustomMetaDataUnicastTagN11max() {

}


CustomMetaDataUnicastTagN11max::~CustomMetaDataUnicastTagN11max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN11max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN11max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN11max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN11max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN11max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN11max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN11max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN11max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN11max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN11max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN11max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN11max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN11max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN111 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN111();
	virtual ~CustomMetaDataUnicastTagN111();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN111");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN111);

CustomMetaDataUnicastTagN111::CustomMetaDataUnicastTagN111() {
}


CustomMetaDataUnicastTagN111::~CustomMetaDataUnicastTagN111() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN111::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN111")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN111> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN111::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN111::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN111::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN111::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN111::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN111::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN111::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN111::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN111::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN111::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN112 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN112();
	virtual ~CustomMetaDataUnicastTagN112();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN112");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN112);

CustomMetaDataUnicastTagN112::CustomMetaDataUnicastTagN112() {

}


CustomMetaDataUnicastTagN112::~CustomMetaDataUnicastTagN112() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN112::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN112")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN112> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN112::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN112::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN112::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN112::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN112::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN112::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN112::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN112::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN112::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN112::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN113 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN113();
	virtual ~CustomMetaDataUnicastTagN113();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN113");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN113);

CustomMetaDataUnicastTagN113::CustomMetaDataUnicastTagN113() {

}


CustomMetaDataUnicastTagN113::~CustomMetaDataUnicastTagN113() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN113::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN113")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN113> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN113::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN113::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN113::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN113::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN113::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN113::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN113::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN113::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN113::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN113::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN114 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN114();
	virtual ~CustomMetaDataUnicastTagN114();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN114");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN114);

CustomMetaDataUnicastTagN114::CustomMetaDataUnicastTagN114() {
	
}


CustomMetaDataUnicastTagN114::~CustomMetaDataUnicastTagN114() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN114::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN114")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN114> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN114::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN114::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN114::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN114::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN114::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN114::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN114::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN114::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN114::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN114::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN115 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN115();
	virtual ~CustomMetaDataUnicastTagN115();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN115");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN115);

CustomMetaDataUnicastTagN115::CustomMetaDataUnicastTagN115() {
}


CustomMetaDataUnicastTagN115::~CustomMetaDataUnicastTagN115() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN115::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN115")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN115> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN115::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN115::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN115::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN115::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN115::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN115::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN115::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN115::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN115::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN115::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN116 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN116();
	virtual ~CustomMetaDataUnicastTagN116();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN116");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN116);

CustomMetaDataUnicastTagN116::CustomMetaDataUnicastTagN116() {

}

CustomMetaDataUnicastTagN116::~CustomMetaDataUnicastTagN116() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN116::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN116")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN116> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN116::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN116::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN116::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN116::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN116::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN116::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN116::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN116::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN116::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN116::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN117 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN117();
	virtual ~CustomMetaDataUnicastTagN117();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN117");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN117);

CustomMetaDataUnicastTagN117::CustomMetaDataUnicastTagN117() {

}


CustomMetaDataUnicastTagN117::~CustomMetaDataUnicastTagN117() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN117::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN117")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN117> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN117::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN117::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN117::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN117::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN117::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN117::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN117::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN117::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN117::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN117::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN118 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN118();
	virtual ~CustomMetaDataUnicastTagN118();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN118");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN118);

CustomMetaDataUnicastTagN118::CustomMetaDataUnicastTagN118() {
}


CustomMetaDataUnicastTagN118::~CustomMetaDataUnicastTagN118() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN118::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN118")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN118> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN118::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN118::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN118::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN118::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN118::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN118::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN118::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN118::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN118::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN118::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN119 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN119();
	virtual ~CustomMetaDataUnicastTagN119();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN119");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN119);

CustomMetaDataUnicastTagN119::CustomMetaDataUnicastTagN119() {

}


CustomMetaDataUnicastTagN119::~CustomMetaDataUnicastTagN119() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN119::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN119")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN119> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN119::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN119::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN119::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN119::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN119::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN119::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN119::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN119::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN119::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN119::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1110 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1110();
	virtual ~CustomMetaDataUnicastTagN1110();
private:

	uint32_t m_neighborid[max10+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1110");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1110);

CustomMetaDataUnicastTagN1110::CustomMetaDataUnicastTagN1110() {
	
}


CustomMetaDataUnicastTagN1110::~CustomMetaDataUnicastTagN1110() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1110::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1110")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1110> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1110::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1110::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1110::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1110::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1110::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1110::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1110::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1110::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1110::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1110::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1111 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1111();
	virtual ~CustomMetaDataUnicastTagN1111();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1111");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1111);

CustomMetaDataUnicastTagN1111::CustomMetaDataUnicastTagN1111() {

}


CustomMetaDataUnicastTagN1111::~CustomMetaDataUnicastTagN1111() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1111::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1111")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1111> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1111::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1111::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1111::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1111::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN1111::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1111::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1111::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1111::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1111::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1111::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1112 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1112();

	virtual ~CustomMetaDataUnicastTagN1112();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1112");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1112);

CustomMetaDataUnicastTagN1112::CustomMetaDataUnicastTagN1112() {
}


CustomMetaDataUnicastTagN1112::~CustomMetaDataUnicastTagN1112() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1112::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1112")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1112> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1112::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1112::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1112::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1112::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1112::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1112::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1112::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1112::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1112::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1112::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1113 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1113();
	virtual ~CustomMetaDataUnicastTagN1113();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1113");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1113);

CustomMetaDataUnicastTagN1113::CustomMetaDataUnicastTagN1113() {

}


CustomMetaDataUnicastTagN1113::~CustomMetaDataUnicastTagN1113() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1113::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1113")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1113> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1113::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1113::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN1113::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1113::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1113::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1113::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1113::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1113::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN1113::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1113::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1114 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN1114();
	virtual ~CustomMetaDataUnicastTagN1114();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1114");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1114);

CustomMetaDataUnicastTagN1114::CustomMetaDataUnicastTagN1114() {

}


CustomMetaDataUnicastTagN1114::~CustomMetaDataUnicastTagN1114() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1114::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1114")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1114> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1114::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1114::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1114::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1114::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1114::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1114::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN1114::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1114::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1114::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1114::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1115 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1115();
	virtual ~CustomMetaDataUnicastTagN1115();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1115");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1115);

CustomMetaDataUnicastTagN1115::CustomMetaDataUnicastTagN1115() {

}

CustomMetaDataUnicastTagN1115::~CustomMetaDataUnicastTagN1115() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1115::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1115")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1115> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1115::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1115::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1115::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1115::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1115::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1115::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1115::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1115::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1115::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1115::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1116 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1116();
	virtual ~CustomMetaDataUnicastTagN1116();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1116");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1116);

CustomMetaDataUnicastTagN1116::CustomMetaDataUnicastTagN1116() {

}

CustomMetaDataUnicastTagN1116::~CustomMetaDataUnicastTagN1116() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1116::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1116")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1116> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1116::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1116::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1116::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1116::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1116::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1116::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1116::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1116::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1116::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1116::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1117 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1117();
	virtual ~CustomMetaDataUnicastTagN1117();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1117");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1117);

CustomMetaDataUnicastTagN1117::CustomMetaDataUnicastTagN1117() {

}

CustomMetaDataUnicastTagN1117::~CustomMetaDataUnicastTagN1117() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1117::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1117")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1117> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1117::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1117::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1117::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1117::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1117::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1117::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1117::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1117::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1117::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1117::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1118 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1118();
	virtual ~CustomMetaDataUnicastTagN1118();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1118");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1118);

CustomMetaDataUnicastTagN1118::CustomMetaDataUnicastTagN1118() {

}

CustomMetaDataUnicastTagN1118::~CustomMetaDataUnicastTagN1118() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1118::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1118")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1118> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1118::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1118::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1118::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1118::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1118::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1118::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1118::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1118::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1118::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1118::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1119 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1119();
	virtual ~CustomMetaDataUnicastTagN1119();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1119");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1119);

CustomMetaDataUnicastTagN1119::CustomMetaDataUnicastTagN1119() {

}

CustomMetaDataUnicastTagN1119::~CustomMetaDataUnicastTagN1119() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1119::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1119")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1119> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1119::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1119::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1119::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1119::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1119::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1119::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1119::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1119::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1119::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1119::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1120 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1120();
	virtual ~CustomMetaDataUnicastTagN1120();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1120");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1120);

CustomMetaDataUnicastTagN1120::CustomMetaDataUnicastTagN1120() {

}

CustomMetaDataUnicastTagN1120::~CustomMetaDataUnicastTagN1120() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1120::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1120")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1120> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1120::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1120::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1120::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1120::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1120::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1120::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1120::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1120::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1120::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1120::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1121 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1121();
	virtual ~CustomMetaDataUnicastTagN1121();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1121");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1121);

CustomMetaDataUnicastTagN1121::CustomMetaDataUnicastTagN1121() {

}

CustomMetaDataUnicastTagN1121::~CustomMetaDataUnicastTagN1121() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1121::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1121")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1121> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1121::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1121::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1121::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1121::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1121::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1121::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1121::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1121::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1121::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1121::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1122 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1122();
	virtual ~CustomMetaDataUnicastTagN1122();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1122");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1122);

CustomMetaDataUnicastTagN1122::CustomMetaDataUnicastTagN1122() {

}

CustomMetaDataUnicastTagN1122::~CustomMetaDataUnicastTagN1122() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1122::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1122")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1122> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1122::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1122::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1122::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1122::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1122::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1122::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1122::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1122::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1122::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1122::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1123 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1123();
	virtual ~CustomMetaDataUnicastTagN1123();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1123");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1123);

CustomMetaDataUnicastTagN1123::CustomMetaDataUnicastTagN1123() {

}

CustomMetaDataUnicastTagN1123::~CustomMetaDataUnicastTagN1123() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1123::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1123")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1123> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1123::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1123::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1123::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1123::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1123::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1123::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1123::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1123::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1123::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1123::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1124 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1124();
	virtual ~CustomMetaDataUnicastTagN1124();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1124");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1124);

CustomMetaDataUnicastTagN1124::CustomMetaDataUnicastTagN1124() {

}

CustomMetaDataUnicastTagN1124::~CustomMetaDataUnicastTagN1124() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1124::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1124")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1124> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1124::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1124::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1124::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1124::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1124::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1124::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1124::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1124::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1124::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1124::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1125 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1125();
	virtual ~CustomMetaDataUnicastTagN1125();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1125");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1125);

CustomMetaDataUnicastTagN1125::CustomMetaDataUnicastTagN1125() {

}

CustomMetaDataUnicastTagN1125::~CustomMetaDataUnicastTagN1125() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1125::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1125")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1125> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1125::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1125::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1125::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1125::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1125::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1125::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1125::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1125::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1125::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1125::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN12max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN12max();
	virtual ~CustomMetaDataUnicastTagN12max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN12max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN12max);

CustomMetaDataUnicastTagN12max::CustomMetaDataUnicastTagN12max() {

}


CustomMetaDataUnicastTagN12max::~CustomMetaDataUnicastTagN12max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN12max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN12max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN12max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN12max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN12max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN12max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN12max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN12max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN12max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN12max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN12max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN12max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN12max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN121 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN121();
	virtual ~CustomMetaDataUnicastTagN121();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN121");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN121);

CustomMetaDataUnicastTagN121::CustomMetaDataUnicastTagN121() {
}


CustomMetaDataUnicastTagN121::~CustomMetaDataUnicastTagN121() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN121::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN121")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN121> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN121::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN121::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN121::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN121::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN121::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN121::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN121::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN121::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN121::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN121::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN122 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN122();
	virtual ~CustomMetaDataUnicastTagN122();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN122");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN122);

CustomMetaDataUnicastTagN122::CustomMetaDataUnicastTagN122() {

}


CustomMetaDataUnicastTagN122::~CustomMetaDataUnicastTagN122() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN122::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN122")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN122> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN122::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN122::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN122::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN122::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN122::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN122::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN122::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN122::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN122::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN122::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN123 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN123();
	virtual ~CustomMetaDataUnicastTagN123();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN123");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN123);

CustomMetaDataUnicastTagN123::CustomMetaDataUnicastTagN123() {

}


CustomMetaDataUnicastTagN123::~CustomMetaDataUnicastTagN123() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN123::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN123")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN123> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN123::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN123::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN123::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN123::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN123::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN123::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN123::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN123::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN123::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN123::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN124 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN124();
	virtual ~CustomMetaDataUnicastTagN124();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN124");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN124);

CustomMetaDataUnicastTagN124::CustomMetaDataUnicastTagN124() {
	
}


CustomMetaDataUnicastTagN124::~CustomMetaDataUnicastTagN124() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN124::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN124")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN124> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN124::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN124::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN124::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN124::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN124::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN124::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN124::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN124::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN124::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN124::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN125 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN125();
	virtual ~CustomMetaDataUnicastTagN125();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN125");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN125);

CustomMetaDataUnicastTagN125::CustomMetaDataUnicastTagN125() {
}


CustomMetaDataUnicastTagN125::~CustomMetaDataUnicastTagN125() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN125::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN125")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN125> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN125::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN125::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN125::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN125::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN125::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN125::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN125::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN125::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN125::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN125::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN126 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN126();
	virtual ~CustomMetaDataUnicastTagN126();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN126");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN126);

CustomMetaDataUnicastTagN126::CustomMetaDataUnicastTagN126() {

}

CustomMetaDataUnicastTagN126::~CustomMetaDataUnicastTagN126() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN126::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN126")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN126> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN126::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN126::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN126::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN126::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN126::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN126::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN126::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN126::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN126::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN126::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN127 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN127();
	virtual ~CustomMetaDataUnicastTagN127();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN127");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN127);

CustomMetaDataUnicastTagN127::CustomMetaDataUnicastTagN127() {

}


CustomMetaDataUnicastTagN127::~CustomMetaDataUnicastTagN127() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN127::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN127")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN127> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN127::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN127::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN127::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN127::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN127::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN127::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN127::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN127::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN127::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN127::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN128 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN128();
	virtual ~CustomMetaDataUnicastTagN128();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN128");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN128);

CustomMetaDataUnicastTagN128::CustomMetaDataUnicastTagN128() {
}


CustomMetaDataUnicastTagN128::~CustomMetaDataUnicastTagN128() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN128::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN128")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN128> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN128::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN128::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN128::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN128::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN128::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN128::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN128::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN128::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN128::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN128::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN129 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN129();
	virtual ~CustomMetaDataUnicastTagN129();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN129");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN129);

CustomMetaDataUnicastTagN129::CustomMetaDataUnicastTagN129() {

}


CustomMetaDataUnicastTagN129::~CustomMetaDataUnicastTagN129() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN129::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN129")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN129> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN129::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN129::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN129::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN129::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN129::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN129::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN129::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN129::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN129::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN129::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1210 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1210();
	virtual ~CustomMetaDataUnicastTagN1210();
private:

	uint32_t m_neighborid[max10+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1210");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1210);

CustomMetaDataUnicastTagN1210::CustomMetaDataUnicastTagN1210() {
	
}


CustomMetaDataUnicastTagN1210::~CustomMetaDataUnicastTagN1210() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1210::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1210")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1210> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1210::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1210::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1210::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1210::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1210::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1210::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1210::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1210::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1210::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1210::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1211 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1211();
	virtual ~CustomMetaDataUnicastTagN1211();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1211");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1211);

CustomMetaDataUnicastTagN1211::CustomMetaDataUnicastTagN1211() {

}


CustomMetaDataUnicastTagN1211::~CustomMetaDataUnicastTagN1211() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1211::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1211")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1211> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1211::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1211::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1211::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1211::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN1211::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1211::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1211::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1211::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1211::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1211::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1212 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1212();

	virtual ~CustomMetaDataUnicastTagN1212();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1212");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1212);

CustomMetaDataUnicastTagN1212::CustomMetaDataUnicastTagN1212() {
}


CustomMetaDataUnicastTagN1212::~CustomMetaDataUnicastTagN1212() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1212::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1212")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1212> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1212::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1212::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1212::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1212::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1212::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1212::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1212::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1212::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1212::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1212::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1213 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1213();
	virtual ~CustomMetaDataUnicastTagN1213();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1213");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1213);

CustomMetaDataUnicastTagN1213::CustomMetaDataUnicastTagN1213() {

}


CustomMetaDataUnicastTagN1213::~CustomMetaDataUnicastTagN1213() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1213::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1213")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1213> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1213::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1213::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN1213::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1213::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1213::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1213::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1213::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1213::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1213::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1213::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1214 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN1214();
	virtual ~CustomMetaDataUnicastTagN1214();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1214");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1214);

CustomMetaDataUnicastTagN1214::CustomMetaDataUnicastTagN1214() {

}


CustomMetaDataUnicastTagN1214::~CustomMetaDataUnicastTagN1214() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1214::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1214")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1214> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1214::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1214::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1214::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1214::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1214::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1214::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN1214::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1214::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1214::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1214::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1215 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1215();
	virtual ~CustomMetaDataUnicastTagN1215();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1215");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1215);

CustomMetaDataUnicastTagN1215::CustomMetaDataUnicastTagN1215() {

}

CustomMetaDataUnicastTagN1215::~CustomMetaDataUnicastTagN1215() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1215::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1215")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1215> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1215::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1215::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1215::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1215::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1215::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1215::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1215::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1215::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1215::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1215::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1216 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1216();
	virtual ~CustomMetaDataUnicastTagN1216();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1216");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1216);

CustomMetaDataUnicastTagN1216::CustomMetaDataUnicastTagN1216() {

}

CustomMetaDataUnicastTagN1216::~CustomMetaDataUnicastTagN1216() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1216::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1216")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1216> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1216::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1216::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1216::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1216::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1216::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1216::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1216::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1216::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1216::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1216::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1217 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1217();
	virtual ~CustomMetaDataUnicastTagN1217();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1217");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1217);

CustomMetaDataUnicastTagN1217::CustomMetaDataUnicastTagN1217() {

}

CustomMetaDataUnicastTagN1217::~CustomMetaDataUnicastTagN1217() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1217::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1217")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1217> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1217::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1217::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1217::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1217::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1217::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1217::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1217::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1217::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1217::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1217::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1218 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1218();
	virtual ~CustomMetaDataUnicastTagN1218();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1218");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1218);

CustomMetaDataUnicastTagN1218::CustomMetaDataUnicastTagN1218() {

}

CustomMetaDataUnicastTagN1218::~CustomMetaDataUnicastTagN1218() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1218::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1218")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1218> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1218::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1218::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1218::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1218::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1218::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1218::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1218::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1218::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1218::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1218::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1219 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1219();
	virtual ~CustomMetaDataUnicastTagN1219();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1219");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1219);

CustomMetaDataUnicastTagN1219::CustomMetaDataUnicastTagN1219() {

}

CustomMetaDataUnicastTagN1219::~CustomMetaDataUnicastTagN1219() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1219::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1219")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1219> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1219::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1219::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1219::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1219::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1219::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1219::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1219::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1219::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1219::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1219::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1220 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1220();
	virtual ~CustomMetaDataUnicastTagN1220();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1220");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1220);

CustomMetaDataUnicastTagN1220::CustomMetaDataUnicastTagN1220() {

}

CustomMetaDataUnicastTagN1220::~CustomMetaDataUnicastTagN1220() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1220::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1220")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1220> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1220::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1220::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1220::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1220::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1220::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1220::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1220::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1220::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1220::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1220::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1221 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1221();
	virtual ~CustomMetaDataUnicastTagN1221();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1221");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1221);

CustomMetaDataUnicastTagN1221::CustomMetaDataUnicastTagN1221() {

}

CustomMetaDataUnicastTagN1221::~CustomMetaDataUnicastTagN1221() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1221::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1221")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1221> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1221::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1221::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1221::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1221::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1221::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1221::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1221::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1221::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1221::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1221::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1222 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1222();
	virtual ~CustomMetaDataUnicastTagN1222();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1222");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1222);

CustomMetaDataUnicastTagN1222::CustomMetaDataUnicastTagN1222() {

}

CustomMetaDataUnicastTagN1222::~CustomMetaDataUnicastTagN1222() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1222::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1222")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1222> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1222::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1222::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1222::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1222::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1222::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1222::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1222::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1222::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1222::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1222::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1223 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1223();
	virtual ~CustomMetaDataUnicastTagN1223();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1223");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1223);

CustomMetaDataUnicastTagN1223::CustomMetaDataUnicastTagN1223() {

}

CustomMetaDataUnicastTagN1223::~CustomMetaDataUnicastTagN1223() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1223::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1223")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1223> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1223::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1223::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1223::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1223::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1223::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1223::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1223::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1223::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1223::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1223::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1224 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1224();
	virtual ~CustomMetaDataUnicastTagN1224();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1224");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1224);

CustomMetaDataUnicastTagN1224::CustomMetaDataUnicastTagN1224() {

}

CustomMetaDataUnicastTagN1224::~CustomMetaDataUnicastTagN1224() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1224::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1224")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1224> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1224::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1224::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1224::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1224::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1224::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1224::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1224::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1224::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1224::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1224::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1225 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1225();
	virtual ~CustomMetaDataUnicastTagN1225();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1225");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1225);

CustomMetaDataUnicastTagN1225::CustomMetaDataUnicastTagN1225() {

}

CustomMetaDataUnicastTagN1225::~CustomMetaDataUnicastTagN1225() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1225::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1225")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1225> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1225::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1225::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1225::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1225::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1225::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1225::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1225::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1225::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1225::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1225::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN13max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN13max();
	virtual ~CustomMetaDataUnicastTagN13max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN13max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN13max);

CustomMetaDataUnicastTagN13max::CustomMetaDataUnicastTagN13max() {

}


CustomMetaDataUnicastTagN13max::~CustomMetaDataUnicastTagN13max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN13max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN13max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN13max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN13max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN13max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN13max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN13max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN13max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN13max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN13max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN13max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN13max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN13max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN131 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN131();
	virtual ~CustomMetaDataUnicastTagN131();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN131");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN131);

CustomMetaDataUnicastTagN131::CustomMetaDataUnicastTagN131() {
}


CustomMetaDataUnicastTagN131::~CustomMetaDataUnicastTagN131() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN131::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN131")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN131> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN131::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN131::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN131::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN131::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN131::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN131::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN131::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN131::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN131::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN131::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN132 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN132();
	virtual ~CustomMetaDataUnicastTagN132();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN132");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN132);

CustomMetaDataUnicastTagN132::CustomMetaDataUnicastTagN132() {

}


CustomMetaDataUnicastTagN132::~CustomMetaDataUnicastTagN132() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN132::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN132")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN132> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN132::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN132::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN132::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN132::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN132::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN132::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN132::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN132::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN132::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN132::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN133 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN133();
	virtual ~CustomMetaDataUnicastTagN133();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN133");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN133);

CustomMetaDataUnicastTagN133::CustomMetaDataUnicastTagN133() {

}


CustomMetaDataUnicastTagN133::~CustomMetaDataUnicastTagN133() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN133::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN133")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN133> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN133::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN133::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN133::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN133::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN133::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN133::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN133::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN133::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN133::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN133::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN134 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN134();
	virtual ~CustomMetaDataUnicastTagN134();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN134");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN134);

CustomMetaDataUnicastTagN134::CustomMetaDataUnicastTagN134() {
	
}


CustomMetaDataUnicastTagN134::~CustomMetaDataUnicastTagN134() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN134::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN134")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN134> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN134::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN134::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN134::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN134::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN134::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN134::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN134::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN134::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN134::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN134::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN135 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN135();
	virtual ~CustomMetaDataUnicastTagN135();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN135");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN135);

CustomMetaDataUnicastTagN135::CustomMetaDataUnicastTagN135() {
}


CustomMetaDataUnicastTagN135::~CustomMetaDataUnicastTagN135() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN135::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN135")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN135> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN135::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN135::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN135::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN135::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN135::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN135::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN135::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN135::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN135::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN135::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN136 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN136();
	virtual ~CustomMetaDataUnicastTagN136();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN136");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN136);

CustomMetaDataUnicastTagN136::CustomMetaDataUnicastTagN136() {

}

CustomMetaDataUnicastTagN136::~CustomMetaDataUnicastTagN136() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN136::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN136")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN136> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN136::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN136::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN136::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN136::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN136::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN136::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN136::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN136::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN136::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN136::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN137 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN137();
	virtual ~CustomMetaDataUnicastTagN137();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN137");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN137);

CustomMetaDataUnicastTagN137::CustomMetaDataUnicastTagN137() {

}


CustomMetaDataUnicastTagN137::~CustomMetaDataUnicastTagN137() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN137::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN137")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN137> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN137::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN137::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN137::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN137::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN137::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN137::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN137::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN137::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN137::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN137::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN138 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN138();
	virtual ~CustomMetaDataUnicastTagN138();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN138");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN138);

CustomMetaDataUnicastTagN138::CustomMetaDataUnicastTagN138() {
}


CustomMetaDataUnicastTagN138::~CustomMetaDataUnicastTagN138() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN138::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN138")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN138> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN138::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN138::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN138::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN138::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN138::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN138::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN138::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN138::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN138::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN138::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN139 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN139();
	virtual ~CustomMetaDataUnicastTagN139();
private:

	uint32_t m_neighborid[max9+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN139");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN139);

CustomMetaDataUnicastTagN139::CustomMetaDataUnicastTagN139() {

}


CustomMetaDataUnicastTagN139::~CustomMetaDataUnicastTagN139() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN139::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN139")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN139> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN139::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN139::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN139::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN139::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN139::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN139::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN139::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN139::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}


uint32_t CustomMetaDataUnicastTagN139::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN139::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1310 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1310();
	virtual ~CustomMetaDataUnicastTagN1310();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1310");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1310);

CustomMetaDataUnicastTagN1310::CustomMetaDataUnicastTagN1310() {
	
}


CustomMetaDataUnicastTagN1310::~CustomMetaDataUnicastTagN1310() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1310::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1310")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1310> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1310::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1310::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1310::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1310::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1310::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1310::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1310::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1310::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1310::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1310::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1311 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1311();
	virtual ~CustomMetaDataUnicastTagN1311();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1311");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1311);

CustomMetaDataUnicastTagN1311::CustomMetaDataUnicastTagN1311() {

}


CustomMetaDataUnicastTagN1311::~CustomMetaDataUnicastTagN1311() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1311::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1311")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1311> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1311::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1311::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1311::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1311::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN1311::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1311::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1311::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1311::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1311::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1311::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1312 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1312();

	virtual ~CustomMetaDataUnicastTagN1312();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1312");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1312);

CustomMetaDataUnicastTagN1312::CustomMetaDataUnicastTagN1312() {
}


CustomMetaDataUnicastTagN1312::~CustomMetaDataUnicastTagN1312() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1312::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1312")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1312> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1312::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1312::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1312::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1312::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1312::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1312::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1312::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1312::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1312::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1312::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1313 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1313();
	virtual ~CustomMetaDataUnicastTagN1313();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1313");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1313);

CustomMetaDataUnicastTagN1313::CustomMetaDataUnicastTagN1313() {

}


CustomMetaDataUnicastTagN1313::~CustomMetaDataUnicastTagN1313() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1313::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1313")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1313> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1313::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1313::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN1313::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1313::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1313::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1313::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1313::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1313::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1313::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1313::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1314 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN1314();
	virtual ~CustomMetaDataUnicastTagN1314();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1314");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1314);

CustomMetaDataUnicastTagN1314::CustomMetaDataUnicastTagN1314() {

}


CustomMetaDataUnicastTagN1314::~CustomMetaDataUnicastTagN1314() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1314::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1314")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1314> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1314::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1314::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1314::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1314::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1314::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1314::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN1314::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1314::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1314::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1314::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1315 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1315();
	virtual ~CustomMetaDataUnicastTagN1315();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1315");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1315);

CustomMetaDataUnicastTagN1315::CustomMetaDataUnicastTagN1315() {

}

CustomMetaDataUnicastTagN1315::~CustomMetaDataUnicastTagN1315() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1315::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1315")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1315> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1315::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1315::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1315::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1315::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1315::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1315::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1315::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1315::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1315::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1315::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1316 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1316();
	virtual ~CustomMetaDataUnicastTagN1316();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1316");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1316);

CustomMetaDataUnicastTagN1316::CustomMetaDataUnicastTagN1316() {

}

CustomMetaDataUnicastTagN1316::~CustomMetaDataUnicastTagN1316() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1316::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1316")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1316> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1316::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1316::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1316::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1316::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1316::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1316::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1316::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1316::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1316::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1316::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1317 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1317();
	virtual ~CustomMetaDataUnicastTagN1317();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1317");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1317);

CustomMetaDataUnicastTagN1317::CustomMetaDataUnicastTagN1317() {

}

CustomMetaDataUnicastTagN1317::~CustomMetaDataUnicastTagN1317() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1317::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1317")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1317> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1317::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1317::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1317::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1317::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1317::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1317::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1317::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1317::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1317::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1317::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1318 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1318();
	virtual ~CustomMetaDataUnicastTagN1318();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1318");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1318);

CustomMetaDataUnicastTagN1318::CustomMetaDataUnicastTagN1318() {

}

CustomMetaDataUnicastTagN1318::~CustomMetaDataUnicastTagN1318() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1318::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1318")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1318> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1318::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1318::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1318::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1318::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1318::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1318::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1318::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1318::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1318::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1318::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1319 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1319();
	virtual ~CustomMetaDataUnicastTagN1319();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1319");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1319);

CustomMetaDataUnicastTagN1319::CustomMetaDataUnicastTagN1319() {

}

CustomMetaDataUnicastTagN1319::~CustomMetaDataUnicastTagN1319() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1319::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1319")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1319> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1319::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1319::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1319::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1319::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1319::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1319::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1319::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1319::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1319::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1319::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1320 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1320();
	virtual ~CustomMetaDataUnicastTagN1320();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1320");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1320);

CustomMetaDataUnicastTagN1320::CustomMetaDataUnicastTagN1320() {

}

CustomMetaDataUnicastTagN1320::~CustomMetaDataUnicastTagN1320() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1320::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1320")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1320> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1320::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1320::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1320::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1320::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1320::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1320::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1320::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1320::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1320::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1320::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1321 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1321();
	virtual ~CustomMetaDataUnicastTagN1321();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1321");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1321);

CustomMetaDataUnicastTagN1321::CustomMetaDataUnicastTagN1321() {

}

CustomMetaDataUnicastTagN1321::~CustomMetaDataUnicastTagN1321() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1321::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1321")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1321> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1321::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1321::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1321::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1321::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1321::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1321::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1321::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1321::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1321::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1321::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1322 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1322();
	virtual ~CustomMetaDataUnicastTagN1322();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1322");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1322);

CustomMetaDataUnicastTagN1322::CustomMetaDataUnicastTagN1322() {

}

CustomMetaDataUnicastTagN1322::~CustomMetaDataUnicastTagN1322() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1322::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1322")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1322> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1322::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1322::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1322::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1322::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1322::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1322::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1322::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1322::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1322::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1322::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1323 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1323();
	virtual ~CustomMetaDataUnicastTagN1323();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1323");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1323);

CustomMetaDataUnicastTagN1323::CustomMetaDataUnicastTagN1323() {

}

CustomMetaDataUnicastTagN1323::~CustomMetaDataUnicastTagN1323() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1323::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1323")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1323> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1323::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1323::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1323::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1323::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1323::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1323::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1323::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1323::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1323::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1323::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1324 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1324();
	virtual ~CustomMetaDataUnicastTagN1324();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1324");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1324);

CustomMetaDataUnicastTagN1324::CustomMetaDataUnicastTagN1324() {

}

CustomMetaDataUnicastTagN1324::~CustomMetaDataUnicastTagN1324() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1324::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1324")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1324> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1324::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1324::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1324::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1324::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1324::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1324::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1324::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1324::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1324::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1324::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1325 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1325();
	virtual ~CustomMetaDataUnicastTagN1325();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1325");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1325);

CustomMetaDataUnicastTagN1325::CustomMetaDataUnicastTagN1325() {

}

CustomMetaDataUnicastTagN1325::~CustomMetaDataUnicastTagN1325() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1325::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1325")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1325> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1325::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1325::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1325::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1325::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1325::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1325::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1325::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1325::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1325::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1325::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN14max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN14max();
	virtual ~CustomMetaDataUnicastTagN14max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN14max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN14max);

CustomMetaDataUnicastTagN14max::CustomMetaDataUnicastTagN14max() {

}


CustomMetaDataUnicastTagN14max::~CustomMetaDataUnicastTagN14max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN14max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN14max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN14max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN14max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN14max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN14max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN14max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN14max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN14max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN14max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN14max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN14max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN14max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN141 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN141();
	virtual ~CustomMetaDataUnicastTagN141();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN141");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN141);

CustomMetaDataUnicastTagN141::CustomMetaDataUnicastTagN141() {
}


CustomMetaDataUnicastTagN141::~CustomMetaDataUnicastTagN141() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN141::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN141")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN141> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN141::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN141::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN141::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN141::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN141::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN141::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN141::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN141::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN141::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN141::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN142 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN142();
	virtual ~CustomMetaDataUnicastTagN142();
private:
	uint32_t m_neighborid[max2+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN142");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN142);

CustomMetaDataUnicastTagN142::CustomMetaDataUnicastTagN142() {

}


CustomMetaDataUnicastTagN142::~CustomMetaDataUnicastTagN142() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN142::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN142")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN142> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN142::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN142::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN142::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN142::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN142::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN142::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN142::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN142::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN142::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN142::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN143 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN143();
	virtual ~CustomMetaDataUnicastTagN143();
private:
	uint32_t m_neighborid[max3+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN143");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN143);

CustomMetaDataUnicastTagN143::CustomMetaDataUnicastTagN143() {

}


CustomMetaDataUnicastTagN143::~CustomMetaDataUnicastTagN143() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN143::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN143")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN143> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN143::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN143::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN143::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN143::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN143::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN143::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN143::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN143::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN143::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN143::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN144 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN144();
	virtual ~CustomMetaDataUnicastTagN144();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN144");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN144);

CustomMetaDataUnicastTagN144::CustomMetaDataUnicastTagN144() {
	
}


CustomMetaDataUnicastTagN144::~CustomMetaDataUnicastTagN144() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN144::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN144")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN144> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN144::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN144::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN144::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN144::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN144::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN144::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN144::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN144::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN144::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN144::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN145 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN145();
	virtual ~CustomMetaDataUnicastTagN145();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN145");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN145);

CustomMetaDataUnicastTagN145::CustomMetaDataUnicastTagN145() {
}


CustomMetaDataUnicastTagN145::~CustomMetaDataUnicastTagN145() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN145::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN145")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN145> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN145::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN145::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN145::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN145::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN145::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN145::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN145::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN145::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN145::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN145::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN146 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN146();
	virtual ~CustomMetaDataUnicastTagN146();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN146");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN146);

CustomMetaDataUnicastTagN146::CustomMetaDataUnicastTagN146() {

}

CustomMetaDataUnicastTagN146::~CustomMetaDataUnicastTagN146() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN146::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN146")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN146> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN146::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN146::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN146::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN146::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN146::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN146::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN146::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN146::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN146::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN146::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN147 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN147();
	virtual ~CustomMetaDataUnicastTagN147();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN147");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN147);

CustomMetaDataUnicastTagN147::CustomMetaDataUnicastTagN147() {

}


CustomMetaDataUnicastTagN147::~CustomMetaDataUnicastTagN147() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN147::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN147")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN147> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN147::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN147::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN147::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN147::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN147::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN147::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN147::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN147::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN147::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN147::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN148 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN148();
	virtual ~CustomMetaDataUnicastTagN148();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN148");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN148);

CustomMetaDataUnicastTagN148::CustomMetaDataUnicastTagN148() {
}


CustomMetaDataUnicastTagN148::~CustomMetaDataUnicastTagN148() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN148::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN148")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN148> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN148::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN148::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN148::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN148::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN148::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN148::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN148::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN148::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN148::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN148::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN149 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN149();
	virtual ~CustomMetaDataUnicastTagN149();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max9+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN149");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN149);

CustomMetaDataUnicastTagN149::CustomMetaDataUnicastTagN149() {

}


CustomMetaDataUnicastTagN149::~CustomMetaDataUnicastTagN149() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN149::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN149")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN149> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN149::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN149::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN149::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN149::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN149::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN149::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN149::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN149::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN149::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN149::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1410 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1410();
	virtual ~CustomMetaDataUnicastTagN1410();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1410");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1410);

CustomMetaDataUnicastTagN1410::CustomMetaDataUnicastTagN1410() {
	
}


CustomMetaDataUnicastTagN1410::~CustomMetaDataUnicastTagN1410() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1410::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1410")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1410> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1410::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1410::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1410::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1410::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1410::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1410::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1410::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1410::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1410::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1410::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1411 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1411();
	virtual ~CustomMetaDataUnicastTagN1411();
private:
	uint32_t m_neighborid[max11+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1411");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1411);

CustomMetaDataUnicastTagN1411::CustomMetaDataUnicastTagN1411() {

}


CustomMetaDataUnicastTagN1411::~CustomMetaDataUnicastTagN1411() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1411::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1411")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1411> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1411::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1411::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1411::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1411::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN1411::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1411::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1411::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1411::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1411::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1411::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1412 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1412();

	virtual ~CustomMetaDataUnicastTagN1412();
private:
	uint32_t m_neighborid[max12+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1412");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1412);

CustomMetaDataUnicastTagN1412::CustomMetaDataUnicastTagN1412() {
}


CustomMetaDataUnicastTagN1412::~CustomMetaDataUnicastTagN1412() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1412::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1412")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1412> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1412::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1412::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1412::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1412::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1412::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1412::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1412::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1412::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1412::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1412::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1413 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1413();
	virtual ~CustomMetaDataUnicastTagN1413();
private:

	uint32_t m_neighborid[max13+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1413");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1413);

CustomMetaDataUnicastTagN1413::CustomMetaDataUnicastTagN1413() {

}


CustomMetaDataUnicastTagN1413::~CustomMetaDataUnicastTagN1413() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1413::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1413")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1413> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1413::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1413::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN1413::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1413::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1413::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1413::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1413::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1413::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1413::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1413::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1414 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN1414();
	virtual ~CustomMetaDataUnicastTagN1414();
private:
	uint32_t m_neighborid[max14+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1414");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1414);

CustomMetaDataUnicastTagN1414::CustomMetaDataUnicastTagN1414() {

}


CustomMetaDataUnicastTagN1414::~CustomMetaDataUnicastTagN1414() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1414::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1414")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1414> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1414::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1414::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1414::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1414::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1414::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1414::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN1414::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1414::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1414::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1414::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1415 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1415();
	virtual ~CustomMetaDataUnicastTagN1415();
private:
	uint32_t m_neighborid[max15+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1415");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1415);

CustomMetaDataUnicastTagN1415::CustomMetaDataUnicastTagN1415() {

}

CustomMetaDataUnicastTagN1415::~CustomMetaDataUnicastTagN1415() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1415::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1415")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1415> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1415::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1415::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1415::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1415::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1415::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1415::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1415::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1415::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1415::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1415::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1416 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1416();
	virtual ~CustomMetaDataUnicastTagN1416();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1416");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1416);

CustomMetaDataUnicastTagN1416::CustomMetaDataUnicastTagN1416() {

}

CustomMetaDataUnicastTagN1416::~CustomMetaDataUnicastTagN1416() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1416::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1416")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1416> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1416::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1416::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1416::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1416::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1416::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1416::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1416::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1416::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1416::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1416::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1417 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1417();
	virtual ~CustomMetaDataUnicastTagN1417();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1417");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1417);

CustomMetaDataUnicastTagN1417::CustomMetaDataUnicastTagN1417() {

}

CustomMetaDataUnicastTagN1417::~CustomMetaDataUnicastTagN1417() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1417::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1417")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1417> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1417::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1417::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1417::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1417::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1417::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1417::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1417::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1417::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1417::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1417::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1418 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1418();
	virtual ~CustomMetaDataUnicastTagN1418();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1418");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1418);

CustomMetaDataUnicastTagN1418::CustomMetaDataUnicastTagN1418() {

}

CustomMetaDataUnicastTagN1418::~CustomMetaDataUnicastTagN1418() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1418::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1418")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1418> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1418::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1418::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1418::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1418::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1418::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1418::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1418::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1418::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1418::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1418::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1419 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1419();
	virtual ~CustomMetaDataUnicastTagN1419();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1419");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1419);

CustomMetaDataUnicastTagN1419::CustomMetaDataUnicastTagN1419() {

}

CustomMetaDataUnicastTagN1419::~CustomMetaDataUnicastTagN1419() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1419::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1419")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1419> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1419::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1419::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1419::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1419::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1419::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1419::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1419::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1419::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1419::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1419::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1420 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1420();
	virtual ~CustomMetaDataUnicastTagN1420();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1420");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1420);

CustomMetaDataUnicastTagN1420::CustomMetaDataUnicastTagN1420() {

}

CustomMetaDataUnicastTagN1420::~CustomMetaDataUnicastTagN1420() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1420::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1420")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1420> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1420::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1420::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1420::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1420::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1420::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1420::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1420::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1420::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1420::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1420::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1421 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1421();
	virtual ~CustomMetaDataUnicastTagN1421();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1421");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1421);

CustomMetaDataUnicastTagN1421::CustomMetaDataUnicastTagN1421() {

}

CustomMetaDataUnicastTagN1421::~CustomMetaDataUnicastTagN1421() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1421::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1421")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1421> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1421::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1421::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1421::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1421::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1421::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1421::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1421::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1421::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1421::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1421::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1422 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1422();
	virtual ~CustomMetaDataUnicastTagN1422();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1422");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1422);

CustomMetaDataUnicastTagN1422::CustomMetaDataUnicastTagN1422() {

}

CustomMetaDataUnicastTagN1422::~CustomMetaDataUnicastTagN1422() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1422::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1422")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1422> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1422::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1422::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1422::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1422::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1422::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1422::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1422::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1422::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1422::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1422::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1423 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1423();
	virtual ~CustomMetaDataUnicastTagN1423();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1423");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1423);

CustomMetaDataUnicastTagN1423::CustomMetaDataUnicastTagN1423() {

}

CustomMetaDataUnicastTagN1423::~CustomMetaDataUnicastTagN1423() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1423::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1423")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1423> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1423::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1423::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1423::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1423::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1423::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1423::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1423::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1423::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1423::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1423::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1424 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1424();
	virtual ~CustomMetaDataUnicastTagN1424();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1424");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1424);

CustomMetaDataUnicastTagN1424::CustomMetaDataUnicastTagN1424() {

}

CustomMetaDataUnicastTagN1424::~CustomMetaDataUnicastTagN1424() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1424::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1424")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1424> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1424::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1424::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1424::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1424::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1424::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1424::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1424::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1424::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1424::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1424::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1425 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1425();
	virtual ~CustomMetaDataUnicastTagN1425();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1425");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1425);

CustomMetaDataUnicastTagN1425::CustomMetaDataUnicastTagN1425() {

}

CustomMetaDataUnicastTagN1425::~CustomMetaDataUnicastTagN1425() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1425::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1425")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1425> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1425::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1425::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1425::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1425::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1425::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1425::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1425::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1425::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1425::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1425::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN15max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN15max();
	virtual ~CustomMetaDataUnicastTagN15max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN15max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN15max);

CustomMetaDataUnicastTagN15max::CustomMetaDataUnicastTagN15max() {

}


CustomMetaDataUnicastTagN15max::~CustomMetaDataUnicastTagN15max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN15max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN15max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN15max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN15max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN15max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN15max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN15max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN15max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN15max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN15max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN15max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN15max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN15max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN16max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN16max();
	virtual ~CustomMetaDataUnicastTagN16max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN16max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN16max);

CustomMetaDataUnicastTagN16max::CustomMetaDataUnicastTagN16max() {

}


CustomMetaDataUnicastTagN16max::~CustomMetaDataUnicastTagN16max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN16max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN16max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN16max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN16max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN16max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN16max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN16max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN16max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN16max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN16max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN16max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN16max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN16max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN17max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN17max();
	virtual ~CustomMetaDataUnicastTagN17max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN17max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN17max);

CustomMetaDataUnicastTagN17max::CustomMetaDataUnicastTagN17max() {

}


CustomMetaDataUnicastTagN17max::~CustomMetaDataUnicastTagN17max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN17max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN17max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN17max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN17max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN17max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN17max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN17max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN17max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN17max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN17max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN17max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN17max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN17max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN18max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN18max();
	virtual ~CustomMetaDataUnicastTagN18max();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN18max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN18max);

CustomMetaDataUnicastTagN18max::CustomMetaDataUnicastTagN18max() {

}


CustomMetaDataUnicastTagN18max::~CustomMetaDataUnicastTagN18max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN18max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN18max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN18max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN18max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN18max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN18max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN18max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN18max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN18max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN18max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN18max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN18max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN18max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN19max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN19max();
	virtual ~CustomMetaDataUnicastTagN19max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN19max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN19max);

CustomMetaDataUnicastTagN19max::CustomMetaDataUnicastTagN19max() {

}


CustomMetaDataUnicastTagN19max::~CustomMetaDataUnicastTagN19max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN19max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN19max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN19max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN19max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN19max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN19max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN19max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN19max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN19max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN19max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN19max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN19max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN19max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN20max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN20max();
	virtual ~CustomMetaDataUnicastTagN20max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN20max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN20max);

CustomMetaDataUnicastTagN20max::CustomMetaDataUnicastTagN20max() {

}


CustomMetaDataUnicastTagN20max::~CustomMetaDataUnicastTagN20max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN20max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN20max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN20max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN20max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN20max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN20max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN20max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN20max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN20max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN20max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN20max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN20max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN20max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN21max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN21max();
	virtual ~CustomMetaDataUnicastTagN21max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN21max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN21max);

CustomMetaDataUnicastTagN21max::CustomMetaDataUnicastTagN21max() {

}


CustomMetaDataUnicastTagN21max::~CustomMetaDataUnicastTagN21max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN21max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN21max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN21max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN21max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN21max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN21max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN21max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN21max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN21max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN21max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN21max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN21max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN21max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN22max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN22max();
	virtual ~CustomMetaDataUnicastTagN22max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN22max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN22max);

CustomMetaDataUnicastTagN22max::CustomMetaDataUnicastTagN22max() {

}


CustomMetaDataUnicastTagN22max::~CustomMetaDataUnicastTagN22max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN22max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN22max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN22max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN22max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN22max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN22max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN22max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN22max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN22max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN22max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN22max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN22max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN22max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN23max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN23max();
	virtual ~CustomMetaDataUnicastTagN23max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN23max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN23max);

CustomMetaDataUnicastTagN23max::CustomMetaDataUnicastTagN23max() {

}


CustomMetaDataUnicastTagN23max::~CustomMetaDataUnicastTagN23max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN23max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN23max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN23max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN23max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN23max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN23max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN23max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN23max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN23max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN23max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN23max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN23max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN23max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN24max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN24max();
	virtual ~CustomMetaDataUnicastTagN24max();
private:
	uint32_t m_nodeid;

	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN24max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN24max);

CustomMetaDataUnicastTagN24max::CustomMetaDataUnicastTagN24max() {

}


CustomMetaDataUnicastTagN24max::~CustomMetaDataUnicastTagN24max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN24max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN24max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN24max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN24max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN24max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN24max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN24max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN24max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN24max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN24max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN24max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN24max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN24max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN25max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN25max();
	virtual ~CustomMetaDataUnicastTagN25max();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN25max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN25max);

CustomMetaDataUnicastTagN25max::CustomMetaDataUnicastTagN25max() {

}


CustomMetaDataUnicastTagN25max::~CustomMetaDataUnicastTagN25max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN25max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN25max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN25max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN25max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN25max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN25max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN25max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN25max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN25max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN25max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN25max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN25max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN25max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN26max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN26max();
	virtual ~CustomMetaDataUnicastTagN26max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN26max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN26max);

CustomMetaDataUnicastTagN26max::CustomMetaDataUnicastTagN26max() {

}


CustomMetaDataUnicastTagN26max::~CustomMetaDataUnicastTagN26max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN26max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN26max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN26max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN26max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN26max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN26max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN26max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN26max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN26max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN26max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN26max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN26max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN26max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN27max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN27max();
	virtual ~CustomMetaDataUnicastTagN27max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN27max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN27max);

CustomMetaDataUnicastTagN27max::CustomMetaDataUnicastTagN27max() {

}


CustomMetaDataUnicastTagN27max::~CustomMetaDataUnicastTagN27max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN27max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN27max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN27max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN27max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN27max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN27max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN27max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN27max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN27max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN27max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN27max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN27max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN27max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN28max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN28max();
	virtual ~CustomMetaDataUnicastTagN28max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN28max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN28max);

CustomMetaDataUnicastTagN28max::CustomMetaDataUnicastTagN28max() {

}


CustomMetaDataUnicastTagN28max::~CustomMetaDataUnicastTagN28max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN28max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN28max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN28max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN28max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN28max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN28max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN28max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN28max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN28max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN28max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN28max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN28max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN28max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN29max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN29max();
	virtual ~CustomMetaDataUnicastTagN29max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN29max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN29max);

CustomMetaDataUnicastTagN29max::CustomMetaDataUnicastTagN29max() {

}


CustomMetaDataUnicastTagN29max::~CustomMetaDataUnicastTagN29max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN29max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN29max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN29max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN29max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN29max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN29max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN29max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN29max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN29max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN29max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN29max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN29max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN29max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN30max : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN30max();
	virtual ~CustomMetaDataUnicastTagN30max();
private:

	uint32_t m_nodeid;
	uint32_t m_neighborid[max+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN30max");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN30max);

CustomMetaDataUnicastTagN30max::CustomMetaDataUnicastTagN30max() {

}


CustomMetaDataUnicastTagN30max::~CustomMetaDataUnicastTagN30max() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN30max::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN30max")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN30max> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN30max::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN30max::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN30max::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN30max::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN30max::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN30max::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN30max::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN30max::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN30max::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN30max::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN151 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN151();
	virtual ~CustomMetaDataUnicastTagN151();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN151");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN151);

CustomMetaDataUnicastTagN151::CustomMetaDataUnicastTagN151() {
}


CustomMetaDataUnicastTagN151::~CustomMetaDataUnicastTagN151() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN151::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN151")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN151> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN151::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN151::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN151::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN151::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN151::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN151::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN151::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN151::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN151::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN151::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN152 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN152();
	virtual ~CustomMetaDataUnicastTagN152();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max2+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN152");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN152);

CustomMetaDataUnicastTagN152::CustomMetaDataUnicastTagN152() {

}


CustomMetaDataUnicastTagN152::~CustomMetaDataUnicastTagN152() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN152::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN152")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN152> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN152::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN152::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN152::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN152::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN152::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN152::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN152::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN152::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN152::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN152::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN153 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN153();
	virtual ~CustomMetaDataUnicastTagN153();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max3+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN153");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN153);

CustomMetaDataUnicastTagN153::CustomMetaDataUnicastTagN153() {

}


CustomMetaDataUnicastTagN153::~CustomMetaDataUnicastTagN153() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN153::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN153")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN153> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN153::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN153::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN153::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN153::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN153::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN153::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN153::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN153::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN153::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN153::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN154 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN154();
	virtual ~CustomMetaDataUnicastTagN154();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN154");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN154);

CustomMetaDataUnicastTagN154::CustomMetaDataUnicastTagN154() {
	
}


CustomMetaDataUnicastTagN154::~CustomMetaDataUnicastTagN154() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN154::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN154")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN154> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN154::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN154::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN154::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN154::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN154::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN154::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN154::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN154::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN154::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN154::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN155 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN155();
	virtual ~CustomMetaDataUnicastTagN155();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN155");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN155);

CustomMetaDataUnicastTagN155::CustomMetaDataUnicastTagN155() {
}


CustomMetaDataUnicastTagN155::~CustomMetaDataUnicastTagN155() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN155::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN155")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN155> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN155::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN155::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN155::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN155::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN155::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN155::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN155::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN155::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN155::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN155::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN156 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN156();
	virtual ~CustomMetaDataUnicastTagN156();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN156");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN156);

CustomMetaDataUnicastTagN156::CustomMetaDataUnicastTagN156() {

}

CustomMetaDataUnicastTagN156::~CustomMetaDataUnicastTagN156() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN156::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN156")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN156> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN156::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN156::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN156::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN156::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN156::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN156::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN156::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN156::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN156::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN156::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN157 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN157();
	virtual ~CustomMetaDataUnicastTagN157();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN157");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN157);

CustomMetaDataUnicastTagN157::CustomMetaDataUnicastTagN157() {

}


CustomMetaDataUnicastTagN157::~CustomMetaDataUnicastTagN157() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN157::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN157")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN157> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN157::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN157::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN157::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN157::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN157::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN157::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN157::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN157::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN157::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN157::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN158 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN158();
	virtual ~CustomMetaDataUnicastTagN158();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN158");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN158);

CustomMetaDataUnicastTagN158::CustomMetaDataUnicastTagN158() {
}


CustomMetaDataUnicastTagN158::~CustomMetaDataUnicastTagN158() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN158::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN158")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN158> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN158::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN158::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN158::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN158::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN158::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN158::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN158::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN158::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN158::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN158::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN159 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN159();
	virtual ~CustomMetaDataUnicastTagN159();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max9+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN159");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN159);

CustomMetaDataUnicastTagN159::CustomMetaDataUnicastTagN159() {

}


CustomMetaDataUnicastTagN159::~CustomMetaDataUnicastTagN159() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN159::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN159")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN159> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN159::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN159::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN159::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN159::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN159::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN159::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN159::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN159::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN159::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN159::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1510 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1510();
	virtual ~CustomMetaDataUnicastTagN1510();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1510");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1510);

CustomMetaDataUnicastTagN1510::CustomMetaDataUnicastTagN1510() {
	
}


CustomMetaDataUnicastTagN1510::~CustomMetaDataUnicastTagN1510() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1510::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1510")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1510> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1510::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1510::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1510::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1510::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1510::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1510::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1510::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1510::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1510::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1510::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1511 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1511();
	virtual ~CustomMetaDataUnicastTagN1511();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max11+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1511");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1511);

CustomMetaDataUnicastTagN1511::CustomMetaDataUnicastTagN1511() {

}


CustomMetaDataUnicastTagN1511::~CustomMetaDataUnicastTagN1511() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1511::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1511")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1511> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1511::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1511::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1511::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1511::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN1511::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1511::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1511::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1511::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1511::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1511::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1512 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1512();

	virtual ~CustomMetaDataUnicastTagN1512();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max12+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1512");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1512);

CustomMetaDataUnicastTagN1512::CustomMetaDataUnicastTagN1512() {
}


CustomMetaDataUnicastTagN1512::~CustomMetaDataUnicastTagN1512() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1512::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1512")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1512> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1512::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1512::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1512::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1512::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1512::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1512::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1512::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1512::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1512::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1512::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1513 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1513();
	virtual ~CustomMetaDataUnicastTagN1513();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max13+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1513");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1513);

CustomMetaDataUnicastTagN1513::CustomMetaDataUnicastTagN1513() {

}


CustomMetaDataUnicastTagN1513::~CustomMetaDataUnicastTagN1513() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1513::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1513")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1513> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1513::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1513::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN1513::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1513::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1513::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1513::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1513::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1513::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1513::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1513::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1514 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN1514();
	virtual ~CustomMetaDataUnicastTagN1514();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max14+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1514");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1514);

CustomMetaDataUnicastTagN1514::CustomMetaDataUnicastTagN1514() {

}


CustomMetaDataUnicastTagN1514::~CustomMetaDataUnicastTagN1514() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1514::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1514")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1514> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1514::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1514::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1514::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1514::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1514::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1514::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN1514::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1514::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1514::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1514::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN1515 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1515();
	virtual ~CustomMetaDataUnicastTagN1515();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max15+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1515");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1515);

CustomMetaDataUnicastTagN1515::CustomMetaDataUnicastTagN1515() {

}

CustomMetaDataUnicastTagN1515::~CustomMetaDataUnicastTagN1515() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1515::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1515")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1515> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1515::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1515::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1515::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1515::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1515::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1515::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1515::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1515::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1515::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1515::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1516 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1516();
	virtual ~CustomMetaDataUnicastTagN1516();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1516");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1516);

CustomMetaDataUnicastTagN1516::CustomMetaDataUnicastTagN1516() {

}

CustomMetaDataUnicastTagN1516::~CustomMetaDataUnicastTagN1516() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1516::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1516")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1516> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1516::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1516::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1516::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1516::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1516::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1516::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1516::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1516::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1516::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1516::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1517 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1517();
	virtual ~CustomMetaDataUnicastTagN1517();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1517");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1517);

CustomMetaDataUnicastTagN1517::CustomMetaDataUnicastTagN1517() {

}

CustomMetaDataUnicastTagN1517::~CustomMetaDataUnicastTagN1517() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1517::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1517")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1517> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1517::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1517::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1517::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1517::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1517::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1517::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1517::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1517::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1517::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1517::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1518 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1518();
	virtual ~CustomMetaDataUnicastTagN1518();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1518");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1518);

CustomMetaDataUnicastTagN1518::CustomMetaDataUnicastTagN1518() {

}

CustomMetaDataUnicastTagN1518::~CustomMetaDataUnicastTagN1518() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1518::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1518")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1518> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1518::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1518::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1518::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1518::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1518::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1518::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1518::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1518::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1518::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1518::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1519 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1519();
	virtual ~CustomMetaDataUnicastTagN1519();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1519");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1519);

CustomMetaDataUnicastTagN1519::CustomMetaDataUnicastTagN1519() {

}

CustomMetaDataUnicastTagN1519::~CustomMetaDataUnicastTagN1519() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1519::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1519")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1519> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1519::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1519::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1519::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1519::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1519::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1519::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1519::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1519::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1519::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1519::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1520 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1520();
	virtual ~CustomMetaDataUnicastTagN1520();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1520");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1520);

CustomMetaDataUnicastTagN1520::CustomMetaDataUnicastTagN1520() {

}

CustomMetaDataUnicastTagN1520::~CustomMetaDataUnicastTagN1520() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1520::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1520")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1520> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1520::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1520::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1520::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1520::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1520::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1520::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1520::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1520::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1520::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1520::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1521 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1521();
	virtual ~CustomMetaDataUnicastTagN1521();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1521");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1521);

CustomMetaDataUnicastTagN1521::CustomMetaDataUnicastTagN1521() {

}

CustomMetaDataUnicastTagN1521::~CustomMetaDataUnicastTagN1521() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1521::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1521")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1521> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1521::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1521::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1521::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1521::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1521::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1521::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1521::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1521::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1521::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1521::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1522 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1522();
	virtual ~CustomMetaDataUnicastTagN1522();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1522");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1522);

CustomMetaDataUnicastTagN1522::CustomMetaDataUnicastTagN1522() {

}

CustomMetaDataUnicastTagN1522::~CustomMetaDataUnicastTagN1522() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1522::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1522")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1522> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1522::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1522::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1522::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1522::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1522::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1522::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1522::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1522::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1522::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1522::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1523 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1523();
	virtual ~CustomMetaDataUnicastTagN1523();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1523");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1523);

CustomMetaDataUnicastTagN1523::CustomMetaDataUnicastTagN1523() {

}

CustomMetaDataUnicastTagN1523::~CustomMetaDataUnicastTagN1523() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1523::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1523")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1523> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1523::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1523::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1523::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1523::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1523::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1523::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1523::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1523::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1523::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1523::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1524 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1524();
	virtual ~CustomMetaDataUnicastTagN1524();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1524");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1524);

CustomMetaDataUnicastTagN1524::CustomMetaDataUnicastTagN1524() {

}

CustomMetaDataUnicastTagN1524::~CustomMetaDataUnicastTagN1524() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1524::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1524")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1524> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1524::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1524::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1524::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1524::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1524::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1524::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1524::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1524::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1524::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1524::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1525 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1525();
	virtual ~CustomMetaDataUnicastTagN1525();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1525");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1525);

CustomMetaDataUnicastTagN1525::CustomMetaDataUnicastTagN1525() {

}

CustomMetaDataUnicastTagN1525::~CustomMetaDataUnicastTagN1525() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1525::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1525")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1525> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1525::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1525::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1525::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1525::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1525::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1525::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1525::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1525::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1525::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1525::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN161 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN161();
	virtual ~CustomMetaDataUnicastTagN161();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN161");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN161);

CustomMetaDataUnicastTagN161::CustomMetaDataUnicastTagN161() {
}


CustomMetaDataUnicastTagN161::~CustomMetaDataUnicastTagN161() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN161::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN161")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN161> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN161::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN161::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN161::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN161::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN161::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN161::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN161::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN161::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN161::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN161::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN162 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN162();
	virtual ~CustomMetaDataUnicastTagN162();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max2+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN162");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN162);

CustomMetaDataUnicastTagN162::CustomMetaDataUnicastTagN162() {

}


CustomMetaDataUnicastTagN162::~CustomMetaDataUnicastTagN162() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN162::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN162")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN162> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN162::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN162::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN162::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN162::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN162::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN162::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN162::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN162::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN162::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN162::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN163 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN163();
	virtual ~CustomMetaDataUnicastTagN163();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max3+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN163");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN163);

CustomMetaDataUnicastTagN163::CustomMetaDataUnicastTagN163() {

}


CustomMetaDataUnicastTagN163::~CustomMetaDataUnicastTagN163() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN163::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN163")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN163> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN163::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN163::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN163::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN163::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN163::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN163::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN163::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN163::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN163::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN163::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN164 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN164();
	virtual ~CustomMetaDataUnicastTagN164();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN164");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN164);

CustomMetaDataUnicastTagN164::CustomMetaDataUnicastTagN164() {
	
}


CustomMetaDataUnicastTagN164::~CustomMetaDataUnicastTagN164() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN164::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN164")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN164> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN164::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN164::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN164::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN164::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN164::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN164::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN164::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN164::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN164::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN164::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN165 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN165();
	virtual ~CustomMetaDataUnicastTagN165();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN165");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN165);

CustomMetaDataUnicastTagN165::CustomMetaDataUnicastTagN165() {
}


CustomMetaDataUnicastTagN165::~CustomMetaDataUnicastTagN165() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN165::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN165")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN165> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN165::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN165::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN165::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN165::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN165::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN165::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN165::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN165::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN165::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN165::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN166 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN166();
	virtual ~CustomMetaDataUnicastTagN166();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN166");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN166);

CustomMetaDataUnicastTagN166::CustomMetaDataUnicastTagN166() {

}

CustomMetaDataUnicastTagN166::~CustomMetaDataUnicastTagN166() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN166::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN166")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN166> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN166::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN166::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN166::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN166::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN166::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN166::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN166::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN166::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN166::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN166::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN167 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN167();
	virtual ~CustomMetaDataUnicastTagN167();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN167");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN167);

CustomMetaDataUnicastTagN167::CustomMetaDataUnicastTagN167() {

}


CustomMetaDataUnicastTagN167::~CustomMetaDataUnicastTagN167() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN167::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN167")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN167> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN167::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN167::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN167::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN167::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN167::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN167::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN167::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN167::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN167::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN167::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN168 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN168();
	virtual ~CustomMetaDataUnicastTagN168();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN168");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN168);

CustomMetaDataUnicastTagN168::CustomMetaDataUnicastTagN168() {
}


CustomMetaDataUnicastTagN168::~CustomMetaDataUnicastTagN168() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN168::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN168")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN168> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN168::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN168::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN168::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN168::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN168::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN168::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN168::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN168::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN168::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN168::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN169 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN169();
	virtual ~CustomMetaDataUnicastTagN169();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max9+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN169");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN169);

CustomMetaDataUnicastTagN169::CustomMetaDataUnicastTagN169() {

}


CustomMetaDataUnicastTagN169::~CustomMetaDataUnicastTagN169() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN169::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN169")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN169> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN169::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN169::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN169::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN169::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN169::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN169::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN169::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN169::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN169::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN169::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1610 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1610();
	virtual ~CustomMetaDataUnicastTagN1610();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1610");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1610);

CustomMetaDataUnicastTagN1610::CustomMetaDataUnicastTagN1610() {
	
}


CustomMetaDataUnicastTagN1610::~CustomMetaDataUnicastTagN1610() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1610::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1610")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1610> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1610::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1610::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1610::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1610::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1610::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1610::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1610::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1610::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1610::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1610::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1611 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1611();
	virtual ~CustomMetaDataUnicastTagN1611();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max11+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1611");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1611);

CustomMetaDataUnicastTagN1611::CustomMetaDataUnicastTagN1611() {

}


CustomMetaDataUnicastTagN1611::~CustomMetaDataUnicastTagN1611() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1611::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1611")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1611> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1611::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1611::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1611::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1611::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN1611::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1611::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1611::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1611::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1611::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1611::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1612 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1612();

	virtual ~CustomMetaDataUnicastTagN1612();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max12+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1612");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1612);

CustomMetaDataUnicastTagN1612::CustomMetaDataUnicastTagN1612() {
}


CustomMetaDataUnicastTagN1612::~CustomMetaDataUnicastTagN1612() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1612::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1612")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1612> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1612::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1612::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1612::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1612::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1612::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1612::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1612::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1612::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1612::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1612::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1613 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1613();
	virtual ~CustomMetaDataUnicastTagN1613();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max13+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1613");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1613);

CustomMetaDataUnicastTagN1613::CustomMetaDataUnicastTagN1613() {

}


CustomMetaDataUnicastTagN1613::~CustomMetaDataUnicastTagN1613() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1613::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1613")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1613> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1613::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1613::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN1613::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1613::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1613::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1613::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1613::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1613::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1613::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1613::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1614 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN1614();
	virtual ~CustomMetaDataUnicastTagN1614();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max14+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1614");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1614);

CustomMetaDataUnicastTagN1614::CustomMetaDataUnicastTagN1614() {

}


CustomMetaDataUnicastTagN1614::~CustomMetaDataUnicastTagN1614() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1614::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1614")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1614> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1614::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1614::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1614::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1614::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1614::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1614::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN1614::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1614::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1614::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1614::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN1615 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1615();
	virtual ~CustomMetaDataUnicastTagN1615();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max15+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1615");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1615);

CustomMetaDataUnicastTagN1615::CustomMetaDataUnicastTagN1615() {

}

CustomMetaDataUnicastTagN1615::~CustomMetaDataUnicastTagN1615() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1615::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1615")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1615> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1615::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1615::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1615::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1615::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1615::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1615::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1615::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1615::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1615::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1615::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1616 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1616();
	virtual ~CustomMetaDataUnicastTagN1616();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1616");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1616);

CustomMetaDataUnicastTagN1616::CustomMetaDataUnicastTagN1616() {

}

CustomMetaDataUnicastTagN1616::~CustomMetaDataUnicastTagN1616() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1616::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1616")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1616> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1616::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1616::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1616::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1616::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1616::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1616::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1616::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1616::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1616::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1616::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1617 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1617();
	virtual ~CustomMetaDataUnicastTagN1617();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1617");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1617);

CustomMetaDataUnicastTagN1617::CustomMetaDataUnicastTagN1617() {

}

CustomMetaDataUnicastTagN1617::~CustomMetaDataUnicastTagN1617() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1617::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1617")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1617> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1617::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1617::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1617::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1617::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1617::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1617::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1617::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1617::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1617::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1617::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1618 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1618();
	virtual ~CustomMetaDataUnicastTagN1618();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1618");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1618);

CustomMetaDataUnicastTagN1618::CustomMetaDataUnicastTagN1618() {

}

CustomMetaDataUnicastTagN1618::~CustomMetaDataUnicastTagN1618() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1618::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1618")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1618> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1618::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1618::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1618::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1618::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1618::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1618::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1618::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1618::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1618::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1618::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1619 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1619();
	virtual ~CustomMetaDataUnicastTagN1619();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1619");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1619);

CustomMetaDataUnicastTagN1619::CustomMetaDataUnicastTagN1619() {

}

CustomMetaDataUnicastTagN1619::~CustomMetaDataUnicastTagN1619() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1619::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1619")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1619> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1619::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1619::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1619::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1619::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1619::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1619::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1619::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1619::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1619::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1619::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1620 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1620();
	virtual ~CustomMetaDataUnicastTagN1620();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1620");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1620);

CustomMetaDataUnicastTagN1620::CustomMetaDataUnicastTagN1620() {

}

CustomMetaDataUnicastTagN1620::~CustomMetaDataUnicastTagN1620() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1620::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1620")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1620> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1620::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1620::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1620::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1620::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1620::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1620::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1620::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1620::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1620::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1620::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1621 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1621();
	virtual ~CustomMetaDataUnicastTagN1621();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1621");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1621);

CustomMetaDataUnicastTagN1621::CustomMetaDataUnicastTagN1621() {

}

CustomMetaDataUnicastTagN1621::~CustomMetaDataUnicastTagN1621() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1621::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1621")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1621> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1621::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1621::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1621::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1621::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1621::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1621::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1621::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1621::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1621::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1621::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1622 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1622();
	virtual ~CustomMetaDataUnicastTagN1622();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1622");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1622);

CustomMetaDataUnicastTagN1622::CustomMetaDataUnicastTagN1622() {

}

CustomMetaDataUnicastTagN1622::~CustomMetaDataUnicastTagN1622() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1622::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1622")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1622> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1622::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1622::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1622::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1622::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1622::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1622::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1622::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1622::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1622::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1622::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1623 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1623();
	virtual ~CustomMetaDataUnicastTagN1623();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1623");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1623);

CustomMetaDataUnicastTagN1623::CustomMetaDataUnicastTagN1623() {

}

CustomMetaDataUnicastTagN1623::~CustomMetaDataUnicastTagN1623() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1623::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1623")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1623> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1623::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1623::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1623::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1623::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1623::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1623::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1623::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1623::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1623::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1623::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1624 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1624();
	virtual ~CustomMetaDataUnicastTagN1624();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1624");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1624);

CustomMetaDataUnicastTagN1624::CustomMetaDataUnicastTagN1624() {

}

CustomMetaDataUnicastTagN1624::~CustomMetaDataUnicastTagN1624() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1624::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1624")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1624> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1624::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1624::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1624::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1624::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1624::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1624::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1624::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1624::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1624::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1624::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1625 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1625();
	virtual ~CustomMetaDataUnicastTagN1625();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1625");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1625);

CustomMetaDataUnicastTagN1625::CustomMetaDataUnicastTagN1625() {

}

CustomMetaDataUnicastTagN1625::~CustomMetaDataUnicastTagN1625() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1625::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1625")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1625> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1625::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1625::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1625::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1625::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1625::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1625::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1625::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1625::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1625::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1625::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN171 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN171();
	virtual ~CustomMetaDataUnicastTagN171();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN171");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN171);

CustomMetaDataUnicastTagN171::CustomMetaDataUnicastTagN171() {
}


CustomMetaDataUnicastTagN171::~CustomMetaDataUnicastTagN171() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN171::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN171")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN171> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN171::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN171::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN171::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN171::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN171::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN171::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN171::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN171::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN171::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN171::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN172 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN172();
	virtual ~CustomMetaDataUnicastTagN172();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max2+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN172");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN172);

CustomMetaDataUnicastTagN172::CustomMetaDataUnicastTagN172() {

}


CustomMetaDataUnicastTagN172::~CustomMetaDataUnicastTagN172() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN172::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN172")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN172> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN172::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN172::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN172::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN172::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN172::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN172::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN172::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN172::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN172::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN172::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN173 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN173();
	virtual ~CustomMetaDataUnicastTagN173();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max3+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN173");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN173);

CustomMetaDataUnicastTagN173::CustomMetaDataUnicastTagN173() {

}


CustomMetaDataUnicastTagN173::~CustomMetaDataUnicastTagN173() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN173::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN173")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN173> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN173::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN173::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN173::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN173::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN173::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN173::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN173::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN173::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN173::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN173::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN174 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN174();
	virtual ~CustomMetaDataUnicastTagN174();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN174");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN174);

CustomMetaDataUnicastTagN174::CustomMetaDataUnicastTagN174() {
	
}


CustomMetaDataUnicastTagN174::~CustomMetaDataUnicastTagN174() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN174::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN174")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN174> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN174::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN174::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN174::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN174::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN174::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN174::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN174::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN174::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN174::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN174::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN175 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN175();
	virtual ~CustomMetaDataUnicastTagN175();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN175");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN175);

CustomMetaDataUnicastTagN175::CustomMetaDataUnicastTagN175() {
}


CustomMetaDataUnicastTagN175::~CustomMetaDataUnicastTagN175() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN175::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN175")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN175> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN175::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN175::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN175::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN175::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN175::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN175::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN175::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN175::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN175::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN175::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN176 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN176();
	virtual ~CustomMetaDataUnicastTagN176();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN176");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN176);

CustomMetaDataUnicastTagN176::CustomMetaDataUnicastTagN176() {

}

CustomMetaDataUnicastTagN176::~CustomMetaDataUnicastTagN176() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN176::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN176")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN176> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN176::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN176::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN176::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN176::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN176::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN176::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN176::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN176::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN176::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN176::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN177 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN177();
	virtual ~CustomMetaDataUnicastTagN177();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN177");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN177);

CustomMetaDataUnicastTagN177::CustomMetaDataUnicastTagN177() {

}


CustomMetaDataUnicastTagN177::~CustomMetaDataUnicastTagN177() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN177::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN177")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN177> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN177::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN177::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN177::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN177::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN177::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN177::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN177::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN177::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN177::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN177::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN178 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN178();
	virtual ~CustomMetaDataUnicastTagN178();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN178");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN178);

CustomMetaDataUnicastTagN178::CustomMetaDataUnicastTagN178() {
}


CustomMetaDataUnicastTagN178::~CustomMetaDataUnicastTagN178() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN178::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN178")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN178> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN178::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN178::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN178::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN178::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN178::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN178::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN178::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN178::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN178::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN178::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN179 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN179();
	virtual ~CustomMetaDataUnicastTagN179();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max9+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN179");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN179);

CustomMetaDataUnicastTagN179::CustomMetaDataUnicastTagN179() {

}


CustomMetaDataUnicastTagN179::~CustomMetaDataUnicastTagN179() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN179::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN179")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN179> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN179::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN179::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN179::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN179::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN179::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN179::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN179::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN179::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN179::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN179::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1710 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1710();
	virtual ~CustomMetaDataUnicastTagN1710();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1710");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1710);

CustomMetaDataUnicastTagN1710::CustomMetaDataUnicastTagN1710() {
	
}


CustomMetaDataUnicastTagN1710::~CustomMetaDataUnicastTagN1710() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1710::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1710")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1710> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1710::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1710::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1710::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1710::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1710::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1710::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1710::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1710::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1710::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1710::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1711 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1711();
	virtual ~CustomMetaDataUnicastTagN1711();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max11+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1711");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1711);

CustomMetaDataUnicastTagN1711::CustomMetaDataUnicastTagN1711() {

}


CustomMetaDataUnicastTagN1711::~CustomMetaDataUnicastTagN1711() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1711::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1711")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1711> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1711::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1711::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1711::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1711::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN1711::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1711::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1711::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1711::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1711::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1711::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1712 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1712();

	virtual ~CustomMetaDataUnicastTagN1712();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max12+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1712");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1712);

CustomMetaDataUnicastTagN1712::CustomMetaDataUnicastTagN1712() {
}


CustomMetaDataUnicastTagN1712::~CustomMetaDataUnicastTagN1712() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1712::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1712")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1712> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1712::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1712::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1712::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1712::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1712::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1712::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1712::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1712::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1712::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1712::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1713 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1713();
	virtual ~CustomMetaDataUnicastTagN1713();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max13+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1713");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1713);

CustomMetaDataUnicastTagN1713::CustomMetaDataUnicastTagN1713() {

}


CustomMetaDataUnicastTagN1713::~CustomMetaDataUnicastTagN1713() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1713::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1713")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1713> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1713::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1713::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN1713::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1713::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1713::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1713::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1713::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1713::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1713::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1713::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1714 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN1714();
	virtual ~CustomMetaDataUnicastTagN1714();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max14+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1714");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1714);

CustomMetaDataUnicastTagN1714::CustomMetaDataUnicastTagN1714() {

}


CustomMetaDataUnicastTagN1714::~CustomMetaDataUnicastTagN1714() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1714::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1714")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1714> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1714::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1714::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1714::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1714::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1714::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1714::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN1714::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1714::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1714::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1714::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN1715 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1715();
	virtual ~CustomMetaDataUnicastTagN1715();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max15+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1715");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1715);

CustomMetaDataUnicastTagN1715::CustomMetaDataUnicastTagN1715() {

}

CustomMetaDataUnicastTagN1715::~CustomMetaDataUnicastTagN1715() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1715::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1715")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1715> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1715::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1715::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1715::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1715::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1715::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1715::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1715::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1715::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1715::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1715::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1716 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1716();
	virtual ~CustomMetaDataUnicastTagN1716();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1716");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1716);

CustomMetaDataUnicastTagN1716::CustomMetaDataUnicastTagN1716() {

}

CustomMetaDataUnicastTagN1716::~CustomMetaDataUnicastTagN1716() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1716::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1716")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1716> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1716::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1716::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1716::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1716::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1716::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1716::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1716::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1716::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1716::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1716::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1717 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1717();
	virtual ~CustomMetaDataUnicastTagN1717();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1717");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1717);

CustomMetaDataUnicastTagN1717::CustomMetaDataUnicastTagN1717() {

}

CustomMetaDataUnicastTagN1717::~CustomMetaDataUnicastTagN1717() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1717::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1717")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1717> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1717::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1717::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1717::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1717::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1717::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1717::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1717::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1717::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1717::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1717::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1718 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1718();
	virtual ~CustomMetaDataUnicastTagN1718();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1718");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1718);

CustomMetaDataUnicastTagN1718::CustomMetaDataUnicastTagN1718() {

}

CustomMetaDataUnicastTagN1718::~CustomMetaDataUnicastTagN1718() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1718::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1718")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1718> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1718::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1718::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1718::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1718::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1718::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1718::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1718::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1718::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1718::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1718::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1719 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1719();
	virtual ~CustomMetaDataUnicastTagN1719();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1719");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1719);

CustomMetaDataUnicastTagN1719::CustomMetaDataUnicastTagN1719() {

}

CustomMetaDataUnicastTagN1719::~CustomMetaDataUnicastTagN1719() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1719::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1719")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1719> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1719::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1719::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1719::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1719::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1719::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1719::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1719::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1719::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1719::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1719::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1720 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1720();
	virtual ~CustomMetaDataUnicastTagN1720();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1720");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1720);

CustomMetaDataUnicastTagN1720::CustomMetaDataUnicastTagN1720() {

}

CustomMetaDataUnicastTagN1720::~CustomMetaDataUnicastTagN1720() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1720::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1720")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1720> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1720::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1720::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1720::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1720::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1720::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1720::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1720::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1720::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1720::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1720::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1721 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1721();
	virtual ~CustomMetaDataUnicastTagN1721();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1721");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1721);

CustomMetaDataUnicastTagN1721::CustomMetaDataUnicastTagN1721() {

}

CustomMetaDataUnicastTagN1721::~CustomMetaDataUnicastTagN1721() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1721::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1721")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1721> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1721::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1721::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1721::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1721::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1721::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1721::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1721::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1721::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1721::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1721::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1722 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1722();
	virtual ~CustomMetaDataUnicastTagN1722();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1722");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1722);

CustomMetaDataUnicastTagN1722::CustomMetaDataUnicastTagN1722() {

}

CustomMetaDataUnicastTagN1722::~CustomMetaDataUnicastTagN1722() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1722::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1722")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1722> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1722::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1722::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1722::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1722::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1722::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1722::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1722::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1722::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1722::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1722::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1723 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1723();
	virtual ~CustomMetaDataUnicastTagN1723();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1723");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1723);

CustomMetaDataUnicastTagN1723::CustomMetaDataUnicastTagN1723() {

}

CustomMetaDataUnicastTagN1723::~CustomMetaDataUnicastTagN1723() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1723::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1723")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1723> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1723::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1723::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1723::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1723::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1723::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1723::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1723::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1723::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1723::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1723::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1724 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1724();
	virtual ~CustomMetaDataUnicastTagN1724();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1724");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1724);

CustomMetaDataUnicastTagN1724::CustomMetaDataUnicastTagN1724() {

}

CustomMetaDataUnicastTagN1724::~CustomMetaDataUnicastTagN1724() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1724::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1724")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1724> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1724::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1724::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1724::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1724::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1724::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1724::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1724::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1724::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1724::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1724::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1725 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1725();
	virtual ~CustomMetaDataUnicastTagN1725();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1725");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1725);

CustomMetaDataUnicastTagN1725::CustomMetaDataUnicastTagN1725() {

}

CustomMetaDataUnicastTagN1725::~CustomMetaDataUnicastTagN1725() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1725::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1725")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1725> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1725::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1725::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1725::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1725::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1725::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1725::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1725::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1725::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1725::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1725::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN181 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN181();
	virtual ~CustomMetaDataUnicastTagN181();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN181");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN181);

CustomMetaDataUnicastTagN181::CustomMetaDataUnicastTagN181() {
}


CustomMetaDataUnicastTagN181::~CustomMetaDataUnicastTagN181() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN181::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN181")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN181> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN181::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN181::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN181::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN181::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN181::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN181::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN181::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN181::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN181::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN181::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN182 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN182();
	virtual ~CustomMetaDataUnicastTagN182();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max2+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN182");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN182);

CustomMetaDataUnicastTagN182::CustomMetaDataUnicastTagN182() {

}


CustomMetaDataUnicastTagN182::~CustomMetaDataUnicastTagN182() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN182::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN182")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN182> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN182::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN182::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN182::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN182::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN182::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN182::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN182::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN182::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN182::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN182::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN183 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN183();
	virtual ~CustomMetaDataUnicastTagN183();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max3+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN183");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN183);

CustomMetaDataUnicastTagN183::CustomMetaDataUnicastTagN183() {

}


CustomMetaDataUnicastTagN183::~CustomMetaDataUnicastTagN183() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN183::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN183")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN183> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN183::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN183::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN183::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN183::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN183::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN183::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN183::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN183::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN183::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN183::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN184 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN184();
	virtual ~CustomMetaDataUnicastTagN184();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN184");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN184);

CustomMetaDataUnicastTagN184::CustomMetaDataUnicastTagN184() {
	
}


CustomMetaDataUnicastTagN184::~CustomMetaDataUnicastTagN184() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN184::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN184")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN184> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN184::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN184::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN184::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN184::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN184::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN184::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN184::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN184::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN184::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN184::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN185 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN185();
	virtual ~CustomMetaDataUnicastTagN185();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN185");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN185);

CustomMetaDataUnicastTagN185::CustomMetaDataUnicastTagN185() {
}


CustomMetaDataUnicastTagN185::~CustomMetaDataUnicastTagN185() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN185::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN185")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN185> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN185::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN185::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN185::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN185::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN185::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN185::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN185::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN185::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN185::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN185::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN186 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN186();
	virtual ~CustomMetaDataUnicastTagN186();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN186");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN186);

CustomMetaDataUnicastTagN186::CustomMetaDataUnicastTagN186() {

}

CustomMetaDataUnicastTagN186::~CustomMetaDataUnicastTagN186() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN186::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN186")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN186> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN186::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN186::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN186::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN186::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN186::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN186::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN186::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN186::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN186::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN186::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN187 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN187();
	virtual ~CustomMetaDataUnicastTagN187();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN187");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN187);

CustomMetaDataUnicastTagN187::CustomMetaDataUnicastTagN187() {

}


CustomMetaDataUnicastTagN187::~CustomMetaDataUnicastTagN187() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN187::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN187")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN187> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN187::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN187::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN187::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN187::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN187::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN187::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN187::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN187::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN187::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN187::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN188 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN188();
	virtual ~CustomMetaDataUnicastTagN188();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN188");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN188);

CustomMetaDataUnicastTagN188::CustomMetaDataUnicastTagN188() {
}


CustomMetaDataUnicastTagN188::~CustomMetaDataUnicastTagN188() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN188::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN188")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN188> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN188::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN188::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN188::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN188::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN188::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN188::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN188::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN188::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN188::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN188::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN189 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN189();
	virtual ~CustomMetaDataUnicastTagN189();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max9+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN189");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN189);

CustomMetaDataUnicastTagN189::CustomMetaDataUnicastTagN189() {

}


CustomMetaDataUnicastTagN189::~CustomMetaDataUnicastTagN189() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN189::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN189")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN189> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN189::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN189::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN189::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN189::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN189::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN189::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN189::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN189::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN189::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN189::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1810 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1810();
	virtual ~CustomMetaDataUnicastTagN1810();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1810");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1810);

CustomMetaDataUnicastTagN1810::CustomMetaDataUnicastTagN1810() {
	
}


CustomMetaDataUnicastTagN1810::~CustomMetaDataUnicastTagN1810() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1810::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1810")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1810> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1810::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1810::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1810::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1810::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1810::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1810::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1810::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1810::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1810::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1810::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1811 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1811();
	virtual ~CustomMetaDataUnicastTagN1811();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max11+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1811");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1811);

CustomMetaDataUnicastTagN1811::CustomMetaDataUnicastTagN1811() {

}


CustomMetaDataUnicastTagN1811::~CustomMetaDataUnicastTagN1811() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1811::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1811")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1811> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1811::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1811::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1811::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1811::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN1811::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1811::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1811::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1811::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1811::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1811::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1812 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1812();

	virtual ~CustomMetaDataUnicastTagN1812();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max12+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1812");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1812);

CustomMetaDataUnicastTagN1812::CustomMetaDataUnicastTagN1812() {
}


CustomMetaDataUnicastTagN1812::~CustomMetaDataUnicastTagN1812() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1812::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1812")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1812> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1812::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1812::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1812::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1812::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1812::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1812::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1812::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1812::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1812::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1812::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1813 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1813();
	virtual ~CustomMetaDataUnicastTagN1813();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max13+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1813");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1813);

CustomMetaDataUnicastTagN1813::CustomMetaDataUnicastTagN1813() {

}


CustomMetaDataUnicastTagN1813::~CustomMetaDataUnicastTagN1813() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1813::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1813")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1813> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1813::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1813::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN1813::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1813::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1813::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1813::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1813::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1813::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1813::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1813::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1814 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN1814();
	virtual ~CustomMetaDataUnicastTagN1814();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max14+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1814");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1814);

CustomMetaDataUnicastTagN1814::CustomMetaDataUnicastTagN1814() {

}


CustomMetaDataUnicastTagN1814::~CustomMetaDataUnicastTagN1814() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1814::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1814")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1814> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1814::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1814::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1814::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1814::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1814::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1814::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN1814::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1814::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1814::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1814::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN1815 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1815();
	virtual ~CustomMetaDataUnicastTagN1815();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max15+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1815");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1815);

CustomMetaDataUnicastTagN1815::CustomMetaDataUnicastTagN1815() {

}

CustomMetaDataUnicastTagN1815::~CustomMetaDataUnicastTagN1815() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1815::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1815")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1815> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1815::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1815::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1815::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1815::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1815::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1815::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1815::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1815::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1815::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1815::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1816 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1816();
	virtual ~CustomMetaDataUnicastTagN1816();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1816");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1816);

CustomMetaDataUnicastTagN1816::CustomMetaDataUnicastTagN1816() {

}

CustomMetaDataUnicastTagN1816::~CustomMetaDataUnicastTagN1816() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1816::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1816")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1816> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1816::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1816::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1816::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1816::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1816::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1816::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1816::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1816::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1816::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1816::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1817 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1817();
	virtual ~CustomMetaDataUnicastTagN1817();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1817");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1817);

CustomMetaDataUnicastTagN1817::CustomMetaDataUnicastTagN1817() {

}

CustomMetaDataUnicastTagN1817::~CustomMetaDataUnicastTagN1817() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1817::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1817")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1817> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1817::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1817::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1817::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1817::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1817::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1817::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1817::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1817::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1817::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1817::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1818 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1818();
	virtual ~CustomMetaDataUnicastTagN1818();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1818");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1818);

CustomMetaDataUnicastTagN1818::CustomMetaDataUnicastTagN1818() {

}

CustomMetaDataUnicastTagN1818::~CustomMetaDataUnicastTagN1818() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1818::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1818")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1818> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1818::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1818::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1818::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1818::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1818::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1818::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1818::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1818::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1818::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1818::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1819 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1819();
	virtual ~CustomMetaDataUnicastTagN1819();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1819");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1819);

CustomMetaDataUnicastTagN1819::CustomMetaDataUnicastTagN1819() {

}

CustomMetaDataUnicastTagN1819::~CustomMetaDataUnicastTagN1819() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1819::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1819")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1819> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1819::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1819::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1819::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1819::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1819::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1819::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1819::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1819::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1819::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1819::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1820 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1820();
	virtual ~CustomMetaDataUnicastTagN1820();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1820");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1820);

CustomMetaDataUnicastTagN1820::CustomMetaDataUnicastTagN1820() {

}

CustomMetaDataUnicastTagN1820::~CustomMetaDataUnicastTagN1820() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1820::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1820")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1820> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1820::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1820::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1820::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1820::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1820::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1820::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1820::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1820::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1820::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1820::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1821 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1821();
	virtual ~CustomMetaDataUnicastTagN1821();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1821");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1821);

CustomMetaDataUnicastTagN1821::CustomMetaDataUnicastTagN1821() {

}

CustomMetaDataUnicastTagN1821::~CustomMetaDataUnicastTagN1821() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1821::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1821")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1821> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1821::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1821::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1821::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1821::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1821::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1821::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1821::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1821::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1821::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1821::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1822 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1822();
	virtual ~CustomMetaDataUnicastTagN1822();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1822");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1822);

CustomMetaDataUnicastTagN1822::CustomMetaDataUnicastTagN1822() {

}

CustomMetaDataUnicastTagN1822::~CustomMetaDataUnicastTagN1822() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1822::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1822")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1822> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1822::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1822::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1822::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1822::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1822::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1822::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1822::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1822::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1822::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1822::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1823 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1823();
	virtual ~CustomMetaDataUnicastTagN1823();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1823");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1823);

CustomMetaDataUnicastTagN1823::CustomMetaDataUnicastTagN1823() {

}

CustomMetaDataUnicastTagN1823::~CustomMetaDataUnicastTagN1823() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1823::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1823")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1823> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1823::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1823::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1823::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1823::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1823::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1823::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1823::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1823::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1823::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1823::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1824 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1824();
	virtual ~CustomMetaDataUnicastTagN1824();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1824");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1824);

CustomMetaDataUnicastTagN1824::CustomMetaDataUnicastTagN1824() {

}

CustomMetaDataUnicastTagN1824::~CustomMetaDataUnicastTagN1824() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1824::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1824")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1824> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1824::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1824::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1824::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1824::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1824::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1824::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1824::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1824::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1824::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1824::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1825 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1825();
	virtual ~CustomMetaDataUnicastTagN1825();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1825");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1825);

CustomMetaDataUnicastTagN1825::CustomMetaDataUnicastTagN1825() {

}

CustomMetaDataUnicastTagN1825::~CustomMetaDataUnicastTagN1825() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1825::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1825")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1825> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1825::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1825::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1825::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1825::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1825::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1825::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1825::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1825::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1825::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1825::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN191 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN191();
	virtual ~CustomMetaDataUnicastTagN191();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN191");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN191);

CustomMetaDataUnicastTagN191::CustomMetaDataUnicastTagN191() {
}


CustomMetaDataUnicastTagN191::~CustomMetaDataUnicastTagN191() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN191::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN191")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN191> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN191::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN191::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN191::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN191::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN191::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN191::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN191::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN191::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN191::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN191::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN192 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN192();
	virtual ~CustomMetaDataUnicastTagN192();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max2+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN192");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN192);

CustomMetaDataUnicastTagN192::CustomMetaDataUnicastTagN192() {

}


CustomMetaDataUnicastTagN192::~CustomMetaDataUnicastTagN192() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN192::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN192")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN192> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN192::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN192::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN192::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN192::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN192::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN192::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN192::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN192::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN192::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN192::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN193 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN193();
	virtual ~CustomMetaDataUnicastTagN193();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max3+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN193");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN193);

CustomMetaDataUnicastTagN193::CustomMetaDataUnicastTagN193() {

}


CustomMetaDataUnicastTagN193::~CustomMetaDataUnicastTagN193() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN193::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN193")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN193> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN193::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN193::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN193::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN193::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN193::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN193::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN193::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN193::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN193::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN193::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN194 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN194();
	virtual ~CustomMetaDataUnicastTagN194();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN194");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN194);

CustomMetaDataUnicastTagN194::CustomMetaDataUnicastTagN194() {
	
}


CustomMetaDataUnicastTagN194::~CustomMetaDataUnicastTagN194() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN194::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN194")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN194> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN194::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN194::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN194::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN194::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN194::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN194::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN194::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN194::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN194::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN194::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN195 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN195();
	virtual ~CustomMetaDataUnicastTagN195();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN195");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN195);

CustomMetaDataUnicastTagN195::CustomMetaDataUnicastTagN195() {
}


CustomMetaDataUnicastTagN195::~CustomMetaDataUnicastTagN195() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN195::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN195")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN195> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN195::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN195::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN195::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN195::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN195::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN195::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN195::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN195::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN195::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN195::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN196 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN196();
	virtual ~CustomMetaDataUnicastTagN196();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN196");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN196);

CustomMetaDataUnicastTagN196::CustomMetaDataUnicastTagN196() {

}

CustomMetaDataUnicastTagN196::~CustomMetaDataUnicastTagN196() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN196::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN196")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN196> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN196::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN196::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN196::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN196::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN196::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN196::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN196::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN196::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN196::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN196::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN197 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN197();
	virtual ~CustomMetaDataUnicastTagN197();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN197");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN197);

CustomMetaDataUnicastTagN197::CustomMetaDataUnicastTagN197() {

}


CustomMetaDataUnicastTagN197::~CustomMetaDataUnicastTagN197() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN197::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN197")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN197> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN197::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN197::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN197::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN197::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN197::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN197::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN197::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN197::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN197::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN197::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN198 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN198();
	virtual ~CustomMetaDataUnicastTagN198();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN198");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN198);

CustomMetaDataUnicastTagN198::CustomMetaDataUnicastTagN198() {
}


CustomMetaDataUnicastTagN198::~CustomMetaDataUnicastTagN198() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN198::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN198")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN198> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN198::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN198::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN198::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN198::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN198::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN198::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN198::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN198::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN198::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN198::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN199 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN199();
	virtual ~CustomMetaDataUnicastTagN199();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max9+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN199");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN199);

CustomMetaDataUnicastTagN199::CustomMetaDataUnicastTagN199() {

}


CustomMetaDataUnicastTagN199::~CustomMetaDataUnicastTagN199() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN199::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN199")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN199> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN199::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN199::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN199::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN199::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN199::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN199::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN199::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN199::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN199::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN199::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1910 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1910();
	virtual ~CustomMetaDataUnicastTagN1910();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1910");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1910);

CustomMetaDataUnicastTagN1910::CustomMetaDataUnicastTagN1910() {
	
}


CustomMetaDataUnicastTagN1910::~CustomMetaDataUnicastTagN1910() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1910::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1910")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1910> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1910::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1910::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1910::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1910::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1910::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1910::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1910::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1910::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1910::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1910::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1911 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1911();
	virtual ~CustomMetaDataUnicastTagN1911();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max11+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1911");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1911);

CustomMetaDataUnicastTagN1911::CustomMetaDataUnicastTagN1911() {

}


CustomMetaDataUnicastTagN1911::~CustomMetaDataUnicastTagN1911() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1911::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1911")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1911> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1911::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1911::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1911::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1911::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN1911::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1911::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN1911::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1911::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1911::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1911::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1912 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1912();

	virtual ~CustomMetaDataUnicastTagN1912();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max12+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1912");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1912);

CustomMetaDataUnicastTagN1912::CustomMetaDataUnicastTagN1912() {
}


CustomMetaDataUnicastTagN1912::~CustomMetaDataUnicastTagN1912() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1912::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1912")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1912> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1912::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1912::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1912::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1912::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1912::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN1912::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1912::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1912::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1912::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1912::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1913 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1913();
	virtual ~CustomMetaDataUnicastTagN1913();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max13+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1913");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1913);

CustomMetaDataUnicastTagN1913::CustomMetaDataUnicastTagN1913() {

}


CustomMetaDataUnicastTagN1913::~CustomMetaDataUnicastTagN1913() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1913::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1913")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1913> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1913::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1913::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN1913::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1913::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1913::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1913::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN1913::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1913::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1913::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1913::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1914 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN1914();
	virtual ~CustomMetaDataUnicastTagN1914();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max14+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1914");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1914);

CustomMetaDataUnicastTagN1914::CustomMetaDataUnicastTagN1914() {

}


CustomMetaDataUnicastTagN1914::~CustomMetaDataUnicastTagN1914() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1914::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1914")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1914> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1914::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1914::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1914::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1914::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1914::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1914::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN1914::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1914::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1914::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1914::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN1915 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN1915();
	virtual ~CustomMetaDataUnicastTagN1915();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max15+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1915");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1915);

CustomMetaDataUnicastTagN1915::CustomMetaDataUnicastTagN1915() {

}

CustomMetaDataUnicastTagN1915::~CustomMetaDataUnicastTagN1915() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1915::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1915")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1915> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1915::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1915::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1915::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1915::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1915::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1915::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1915::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1915::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1915::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1915::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1916 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1916();
	virtual ~CustomMetaDataUnicastTagN1916();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1916");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1916);

CustomMetaDataUnicastTagN1916::CustomMetaDataUnicastTagN1916() {

}

CustomMetaDataUnicastTagN1916::~CustomMetaDataUnicastTagN1916() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1916::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1916")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1916> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1916::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1916::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1916::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1916::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1916::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1916::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1916::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1916::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1916::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1916::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1917 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1917();
	virtual ~CustomMetaDataUnicastTagN1917();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1917");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1917);

CustomMetaDataUnicastTagN1917::CustomMetaDataUnicastTagN1917() {

}

CustomMetaDataUnicastTagN1917::~CustomMetaDataUnicastTagN1917() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1917::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1917")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1917> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1917::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1917::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1917::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1917::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1917::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1917::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1917::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1917::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1917::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1917::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1918 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1918();
	virtual ~CustomMetaDataUnicastTagN1918();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1918");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1918);

CustomMetaDataUnicastTagN1918::CustomMetaDataUnicastTagN1918() {

}

CustomMetaDataUnicastTagN1918::~CustomMetaDataUnicastTagN1918() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1918::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1918")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1918> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1918::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1918::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1918::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1918::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1918::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1918::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1918::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1918::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1918::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1918::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1919 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1919();
	virtual ~CustomMetaDataUnicastTagN1919();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1919");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1919);

CustomMetaDataUnicastTagN1919::CustomMetaDataUnicastTagN1919() {

}

CustomMetaDataUnicastTagN1919::~CustomMetaDataUnicastTagN1919() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1919::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1919")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1919> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1919::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1919::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1919::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1919::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1919::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1919::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1919::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1919::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1919::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1919::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1920 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1920();
	virtual ~CustomMetaDataUnicastTagN1920();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1920");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1920);

CustomMetaDataUnicastTagN1920::CustomMetaDataUnicastTagN1920() {

}

CustomMetaDataUnicastTagN1920::~CustomMetaDataUnicastTagN1920() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1920::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1920")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1920> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1920::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1920::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1920::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1920::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1920::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1920::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1920::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1920::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1920::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1920::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN1921 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1921();
	virtual ~CustomMetaDataUnicastTagN1921();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1921");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1921);

CustomMetaDataUnicastTagN1921::CustomMetaDataUnicastTagN1921() {

}

CustomMetaDataUnicastTagN1921::~CustomMetaDataUnicastTagN1921() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1921::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1921")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1921> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1921::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1921::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1921::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1921::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1921::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1921::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1921::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1921::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1921::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1921::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1922 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1922();
	virtual ~CustomMetaDataUnicastTagN1922();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1922");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1922);

CustomMetaDataUnicastTagN1922::CustomMetaDataUnicastTagN1922() {

}

CustomMetaDataUnicastTagN1922::~CustomMetaDataUnicastTagN1922() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1922::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1922")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1922> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1922::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1922::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1922::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1922::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1922::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1922::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1922::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1922::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1922::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1922::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1923 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1923();
	virtual ~CustomMetaDataUnicastTagN1923();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1923");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1923);

CustomMetaDataUnicastTagN1923::CustomMetaDataUnicastTagN1923() {

}

CustomMetaDataUnicastTagN1923::~CustomMetaDataUnicastTagN1923() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1923::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1923")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1923> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1923::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1923::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1923::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1923::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1923::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1923::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1923::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1923::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1923::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1923::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN1924 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1924();
	virtual ~CustomMetaDataUnicastTagN1924();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1924");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1924);

CustomMetaDataUnicastTagN1924::CustomMetaDataUnicastTagN1924() {

}

CustomMetaDataUnicastTagN1924::~CustomMetaDataUnicastTagN1924() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1924::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1924")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1924> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1924::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1924::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1924::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1924::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1924::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1924::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1924::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1924::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1924::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1924::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN1925 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN1925();
	virtual ~CustomMetaDataUnicastTagN1925();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN1925");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN1925);

CustomMetaDataUnicastTagN1925::CustomMetaDataUnicastTagN1925() {

}

CustomMetaDataUnicastTagN1925::~CustomMetaDataUnicastTagN1925() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN1925::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN1925")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN1925> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN1925::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN1925::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN1925::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN1925::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN1925::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN1925::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN1925::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN1925::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN1925::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN1925::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2001 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2001();
	virtual ~CustomMetaDataUnicastTagN2001();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2001");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2001);

CustomMetaDataUnicastTagN2001::CustomMetaDataUnicastTagN2001() {
}


CustomMetaDataUnicastTagN2001::~CustomMetaDataUnicastTagN2001() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2001::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2001")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2001> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2001::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2001::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2001::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2001::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2001::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2001::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2001::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2001::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2001::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2001::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2002 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2002();
	virtual ~CustomMetaDataUnicastTagN2002();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max2+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2002");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2002);

CustomMetaDataUnicastTagN2002::CustomMetaDataUnicastTagN2002() {

}


CustomMetaDataUnicastTagN2002::~CustomMetaDataUnicastTagN2002() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2002::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2002")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2002> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2002::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2002::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN2002::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2002::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2002::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2002::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN2002::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2002::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2002::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2002::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2003 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2003();
	virtual ~CustomMetaDataUnicastTagN2003();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max3+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2003");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2003);

CustomMetaDataUnicastTagN2003::CustomMetaDataUnicastTagN2003() {

}


CustomMetaDataUnicastTagN2003::~CustomMetaDataUnicastTagN2003() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2003::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2003")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2003> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2003::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2003::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2003::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2003::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2003::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2003::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2003::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2003::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2003::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2003::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2004 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2004();
	virtual ~CustomMetaDataUnicastTagN2004();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2004");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2004);

CustomMetaDataUnicastTagN2004::CustomMetaDataUnicastTagN2004() {
	
}


CustomMetaDataUnicastTagN2004::~CustomMetaDataUnicastTagN2004() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2004::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2004")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2004> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2004::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2004::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN2004::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2004::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2004::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2004::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2004::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2004::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2004::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2004::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2005 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2005();
	virtual ~CustomMetaDataUnicastTagN2005();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2005");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2005);

CustomMetaDataUnicastTagN2005::CustomMetaDataUnicastTagN2005() {
}


CustomMetaDataUnicastTagN2005::~CustomMetaDataUnicastTagN2005() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2005::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2005")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2005> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2005::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2005::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2005::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2005::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2005::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2005::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2005::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2005::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2005::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2005::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2006 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2006();
	virtual ~CustomMetaDataUnicastTagN2006();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2006");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2006);

CustomMetaDataUnicastTagN2006::CustomMetaDataUnicastTagN2006() {

}

CustomMetaDataUnicastTagN2006::~CustomMetaDataUnicastTagN2006() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2006::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2006")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2006> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2006::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2006::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2006::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2006::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2006::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2006::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2006::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2006::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2006::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2006::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2007 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2007();
	virtual ~CustomMetaDataUnicastTagN2007();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2007");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2007);

CustomMetaDataUnicastTagN2007::CustomMetaDataUnicastTagN2007() {

}


CustomMetaDataUnicastTagN2007::~CustomMetaDataUnicastTagN2007() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2007::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2007")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2007> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2007::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2007::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2007::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2007::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN2007::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2007::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2007::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2007::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2007::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2007::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2008 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2008();
	virtual ~CustomMetaDataUnicastTagN2008();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2008");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2008);

CustomMetaDataUnicastTagN2008::CustomMetaDataUnicastTagN2008() {
}


CustomMetaDataUnicastTagN2008::~CustomMetaDataUnicastTagN2008() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2008::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2008")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2008> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2008::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2008::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2008::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2008::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2008::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2008::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2008::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2008::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2008::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2008::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2009 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2009();
	virtual ~CustomMetaDataUnicastTagN2009();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max9+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2009");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2009);

CustomMetaDataUnicastTagN2009::CustomMetaDataUnicastTagN2009() {

}


CustomMetaDataUnicastTagN2009::~CustomMetaDataUnicastTagN2009() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2009::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2009")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2009> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2009::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2009::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2009::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2009::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2009::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2009::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2009::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2009::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2009::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2009::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2010 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2010();
	virtual ~CustomMetaDataUnicastTagN2010();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2010");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2010);

CustomMetaDataUnicastTagN2010::CustomMetaDataUnicastTagN2010() {
	
}


CustomMetaDataUnicastTagN2010::~CustomMetaDataUnicastTagN2010() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2010::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2010")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2010> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2010::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2010::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2010::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2010::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2010::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2010::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2010::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2010::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2010::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2010::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2011 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2011();
	virtual ~CustomMetaDataUnicastTagN2011();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max11+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2011");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2011);

CustomMetaDataUnicastTagN2011::CustomMetaDataUnicastTagN2011() {

}


CustomMetaDataUnicastTagN2011::~CustomMetaDataUnicastTagN2011() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2011::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2011")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2011> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2011::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2011::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2011::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2011::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN2011::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN2011::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2011::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2011::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2011::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2011::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2012 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2012();

	virtual ~CustomMetaDataUnicastTagN2012();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max12+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2012");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2012);

CustomMetaDataUnicastTagN2012::CustomMetaDataUnicastTagN2012() {
}


CustomMetaDataUnicastTagN2012::~CustomMetaDataUnicastTagN2012() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2012::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2012")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2012> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2012::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2012::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2012::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2012::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2012::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN2012::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2012::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2012::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2012::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2012::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2013 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2013();
	virtual ~CustomMetaDataUnicastTagN2013();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max13+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2013");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2013);

CustomMetaDataUnicastTagN2013::CustomMetaDataUnicastTagN2013() {

}


CustomMetaDataUnicastTagN2013::~CustomMetaDataUnicastTagN2013() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2013::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2013")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2013> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2013::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2013::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN2013::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2013::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2013::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2013::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2013::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2013::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2013::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2013::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2014 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN2014();
	virtual ~CustomMetaDataUnicastTagN2014();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max14+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2014");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2014);

CustomMetaDataUnicastTagN2014::CustomMetaDataUnicastTagN2014() {

}


CustomMetaDataUnicastTagN2014::~CustomMetaDataUnicastTagN2014() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2014::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2014")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2014> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2014::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2014::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2014::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2014::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2014::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2014::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN2014::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2014::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2014::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2014::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN2015 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2015();
	virtual ~CustomMetaDataUnicastTagN2015();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max15+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2015");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2015);

CustomMetaDataUnicastTagN2015::CustomMetaDataUnicastTagN2015() {

}

CustomMetaDataUnicastTagN2015::~CustomMetaDataUnicastTagN2015() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2015::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2015")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2015> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2015::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2015::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2015::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2015::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2015::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2015::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2015::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2015::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2015::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2015::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2016 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2016();
	virtual ~CustomMetaDataUnicastTagN2016();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2016");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2016);

CustomMetaDataUnicastTagN2016::CustomMetaDataUnicastTagN2016() {

}

CustomMetaDataUnicastTagN2016::~CustomMetaDataUnicastTagN2016() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2016::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2016")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2016> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2016::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2016::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2016::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2016::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2016::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2016::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2016::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2016::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2016::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2016::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2017 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2017();
	virtual ~CustomMetaDataUnicastTagN2017();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2017");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2017);

CustomMetaDataUnicastTagN2017::CustomMetaDataUnicastTagN2017() {

}

CustomMetaDataUnicastTagN2017::~CustomMetaDataUnicastTagN2017() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2017::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2017")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2017> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2017::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2017::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2017::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2017::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2017::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2017::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2017::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2017::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2017::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2017::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2018 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2018();
	virtual ~CustomMetaDataUnicastTagN2018();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2018");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2018);

CustomMetaDataUnicastTagN2018::CustomMetaDataUnicastTagN2018() {

}

CustomMetaDataUnicastTagN2018::~CustomMetaDataUnicastTagN2018() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2018::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2018")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2018> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2018::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2018::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2018::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2018::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2018::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2018::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2018::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2018::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2018::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2018::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2019 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2019();
	virtual ~CustomMetaDataUnicastTagN2019();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2019");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2019);

CustomMetaDataUnicastTagN2019::CustomMetaDataUnicastTagN2019() {

}

CustomMetaDataUnicastTagN2019::~CustomMetaDataUnicastTagN2019() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2019::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2019")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2019> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2019::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2019::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2019::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2019::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2019::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2019::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2019::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2019::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2019::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2019::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2020 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2020();
	virtual ~CustomMetaDataUnicastTagN2020();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2020");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2020);

CustomMetaDataUnicastTagN2020::CustomMetaDataUnicastTagN2020() {

}

CustomMetaDataUnicastTagN2020::~CustomMetaDataUnicastTagN2020() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2020::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2020")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2020> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2020::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2020::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2020::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2020::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2020::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2020::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2020::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2020::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2020::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2020::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2021 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2021();
	virtual ~CustomMetaDataUnicastTagN2021();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2021");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2021);

CustomMetaDataUnicastTagN2021::CustomMetaDataUnicastTagN2021() {

}

CustomMetaDataUnicastTagN2021::~CustomMetaDataUnicastTagN2021() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2021::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2021")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2021> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2021::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2021::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2021::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2021::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2021::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2021::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2021::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2021::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2021::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2021::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2022 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2022();
	virtual ~CustomMetaDataUnicastTagN2022();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2022");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2022);

CustomMetaDataUnicastTagN2022::CustomMetaDataUnicastTagN2022() {

}

CustomMetaDataUnicastTagN2022::~CustomMetaDataUnicastTagN2022() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2022::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2022")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2022> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2022::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2022::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2022::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2022::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2022::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2022::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2022::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2022::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2022::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2022::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2023 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2023();
	virtual ~CustomMetaDataUnicastTagN2023();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2023");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2023);

CustomMetaDataUnicastTagN2023::CustomMetaDataUnicastTagN2023() {

}

CustomMetaDataUnicastTagN2023::~CustomMetaDataUnicastTagN2023() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2023::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2023")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2023> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2023::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2023::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2023::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2023::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2023::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2023::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2023::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2023::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2023::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2023::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2024 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2024();
	virtual ~CustomMetaDataUnicastTagN2024();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2024");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2024);

CustomMetaDataUnicastTagN2024::CustomMetaDataUnicastTagN2024() {

}

CustomMetaDataUnicastTagN2024::~CustomMetaDataUnicastTagN2024() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2024::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2024")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2024> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2024::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2024::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2024::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2024::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2024::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2024::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2024::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2024::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2024::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2024::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2025 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2025();
	virtual ~CustomMetaDataUnicastTagN2025();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2025");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2025);

CustomMetaDataUnicastTagN2025::CustomMetaDataUnicastTagN2025() {

}

CustomMetaDataUnicastTagN2025::~CustomMetaDataUnicastTagN2025() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2025::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2025")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2025> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2025::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2025::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2025::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2025::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2025::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2025::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2025::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2025::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2025::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2025::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2101 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2101();
	virtual ~CustomMetaDataUnicastTagN2101();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2101");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2101);

CustomMetaDataUnicastTagN2101::CustomMetaDataUnicastTagN2101() {
}


CustomMetaDataUnicastTagN2101::~CustomMetaDataUnicastTagN2101() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2101::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2101")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2101> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2101::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2101::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2101::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2101::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2101::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2101::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2101::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2101::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2101::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2101::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2102 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2102();
	virtual ~CustomMetaDataUnicastTagN2102();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max2+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2102");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2102);

CustomMetaDataUnicastTagN2102::CustomMetaDataUnicastTagN2102() {

}


CustomMetaDataUnicastTagN2102::~CustomMetaDataUnicastTagN2102() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2102::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2102")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2102> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2102::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2102::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN2102::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2102::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2102::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2102::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN2102::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2102::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2102::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2102::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2103 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2103();
	virtual ~CustomMetaDataUnicastTagN2103();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max3+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2103");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2103);

CustomMetaDataUnicastTagN2103::CustomMetaDataUnicastTagN2103() {

}


CustomMetaDataUnicastTagN2103::~CustomMetaDataUnicastTagN2103() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2103::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2103")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2103> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2103::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2103::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2103::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2103::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2103::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2103::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2103::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2103::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2103::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2103::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2104 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2104();
	virtual ~CustomMetaDataUnicastTagN2104();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2104");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2104);

CustomMetaDataUnicastTagN2104::CustomMetaDataUnicastTagN2104() {
	
}


CustomMetaDataUnicastTagN2104::~CustomMetaDataUnicastTagN2104() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2104::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2104")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2104> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2104::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2104::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN2104::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2104::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2104::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2104::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2104::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2104::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2104::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2104::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2105 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2105();
	virtual ~CustomMetaDataUnicastTagN2105();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2105");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2105);

CustomMetaDataUnicastTagN2105::CustomMetaDataUnicastTagN2105() {
}


CustomMetaDataUnicastTagN2105::~CustomMetaDataUnicastTagN2105() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2105::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2105")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2105> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2105::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2105::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2105::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2105::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2105::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2105::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2105::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2105::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2105::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2105::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2106 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2106();
	virtual ~CustomMetaDataUnicastTagN2106();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2106");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2106);

CustomMetaDataUnicastTagN2106::CustomMetaDataUnicastTagN2106() {

}

CustomMetaDataUnicastTagN2106::~CustomMetaDataUnicastTagN2106() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2106::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2106")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2106> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2106::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2106::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2106::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2106::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2106::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2106::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2106::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2106::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2106::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2106::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2107 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2107();
	virtual ~CustomMetaDataUnicastTagN2107();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2107");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2107);

CustomMetaDataUnicastTagN2107::CustomMetaDataUnicastTagN2107() {

}


CustomMetaDataUnicastTagN2107::~CustomMetaDataUnicastTagN2107() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2107::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2107")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2107> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2107::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2107::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2107::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2107::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN2107::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2107::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2107::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2107::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2107::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2107::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2108 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2108();
	virtual ~CustomMetaDataUnicastTagN2108();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2108");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2108);

CustomMetaDataUnicastTagN2108::CustomMetaDataUnicastTagN2108() {
}


CustomMetaDataUnicastTagN2108::~CustomMetaDataUnicastTagN2108() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2108::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2108")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2108> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2108::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2108::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2108::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2108::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2108::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2108::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2108::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2108::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2108::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2108::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2109 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2109();
	virtual ~CustomMetaDataUnicastTagN2109();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max9+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2109");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2109);

CustomMetaDataUnicastTagN2109::CustomMetaDataUnicastTagN2109() {

}


CustomMetaDataUnicastTagN2109::~CustomMetaDataUnicastTagN2109() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2109::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2109")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2109> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2109::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2109::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2109::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2109::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2109::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2109::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2109::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2109::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2109::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2109::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2110 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2110();
	virtual ~CustomMetaDataUnicastTagN2110();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2110");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2110);

CustomMetaDataUnicastTagN2110::CustomMetaDataUnicastTagN2110() {
	
}


CustomMetaDataUnicastTagN2110::~CustomMetaDataUnicastTagN2110() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2110::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2110")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2110> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2110::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2110::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2110::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2110::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2110::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2110::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2110::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2110::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2110::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2110::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2111 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2111();
	virtual ~CustomMetaDataUnicastTagN2111();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max11+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2111");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2111);

CustomMetaDataUnicastTagN2111::CustomMetaDataUnicastTagN2111() {

}


CustomMetaDataUnicastTagN2111::~CustomMetaDataUnicastTagN2111() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2111::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2111")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2111> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2111::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2111::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2111::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2111::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN2111::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN2111::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2111::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2111::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2111::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2111::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2112 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2112();

	virtual ~CustomMetaDataUnicastTagN2112();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max12+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2112");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2112);

CustomMetaDataUnicastTagN2112::CustomMetaDataUnicastTagN2112() {
}


CustomMetaDataUnicastTagN2112::~CustomMetaDataUnicastTagN2112() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2112::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2112")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2112> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2112::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2112::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2112::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2112::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2112::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN2112::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2112::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2112::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2112::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2112::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2113 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2113();
	virtual ~CustomMetaDataUnicastTagN2113();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max13+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2113");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2113);

CustomMetaDataUnicastTagN2113::CustomMetaDataUnicastTagN2113() {

}


CustomMetaDataUnicastTagN2113::~CustomMetaDataUnicastTagN2113() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2113::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2113")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2113> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2113::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2113::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN2113::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2113::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2113::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2113::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2113::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2113::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2113::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2113::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2114 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN2114();
	virtual ~CustomMetaDataUnicastTagN2114();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max14+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2114");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2114);

CustomMetaDataUnicastTagN2114::CustomMetaDataUnicastTagN2114() {

}


CustomMetaDataUnicastTagN2114::~CustomMetaDataUnicastTagN2114() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2114::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2114")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2114> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2114::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2114::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2114::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2114::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2114::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2114::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN2114::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2114::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2114::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2114::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN2115 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2115();
	virtual ~CustomMetaDataUnicastTagN2115();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max15+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2115");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2115);

CustomMetaDataUnicastTagN2115::CustomMetaDataUnicastTagN2115() {

}

CustomMetaDataUnicastTagN2115::~CustomMetaDataUnicastTagN2115() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2115::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2115")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2115> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2115::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2115::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2115::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2115::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2115::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2115::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2115::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2115::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2115::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2115::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2116 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2116();
	virtual ~CustomMetaDataUnicastTagN2116();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2116");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2116);

CustomMetaDataUnicastTagN2116::CustomMetaDataUnicastTagN2116() {

}

CustomMetaDataUnicastTagN2116::~CustomMetaDataUnicastTagN2116() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2116::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2116")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2116> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2116::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2116::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2116::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2116::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2116::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2116::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2116::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2116::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2116::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2116::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2117 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2117();
	virtual ~CustomMetaDataUnicastTagN2117();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2117");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2117);

CustomMetaDataUnicastTagN2117::CustomMetaDataUnicastTagN2117() {

}

CustomMetaDataUnicastTagN2117::~CustomMetaDataUnicastTagN2117() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2117::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2117")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2117> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2117::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2117::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2117::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2117::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2117::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2117::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2117::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2117::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2117::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2117::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2118 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2118();
	virtual ~CustomMetaDataUnicastTagN2118();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2118");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2118);

CustomMetaDataUnicastTagN2118::CustomMetaDataUnicastTagN2118() {

}

CustomMetaDataUnicastTagN2118::~CustomMetaDataUnicastTagN2118() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2118::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2118")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2118> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2118::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2118::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2118::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2118::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2118::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2118::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2118::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2118::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2118::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2118::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2119 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2119();
	virtual ~CustomMetaDataUnicastTagN2119();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2119");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2119);

CustomMetaDataUnicastTagN2119::CustomMetaDataUnicastTagN2119() {

}

CustomMetaDataUnicastTagN2119::~CustomMetaDataUnicastTagN2119() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2119::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2119")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2119> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2119::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2119::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2119::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2119::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2119::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2119::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2119::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2119::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2119::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2119::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2120 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2120();
	virtual ~CustomMetaDataUnicastTagN2120();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2120");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2120);

CustomMetaDataUnicastTagN2120::CustomMetaDataUnicastTagN2120() {

}

CustomMetaDataUnicastTagN2120::~CustomMetaDataUnicastTagN2120() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2120::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2120")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2120> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2120::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2120::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2120::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2120::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2120::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2120::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2120::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2120::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2120::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2120::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2121 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2121();
	virtual ~CustomMetaDataUnicastTagN2121();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2121");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2121);

CustomMetaDataUnicastTagN2121::CustomMetaDataUnicastTagN2121() {

}

CustomMetaDataUnicastTagN2121::~CustomMetaDataUnicastTagN2121() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2121::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2121")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2121> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2121::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2121::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2121::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2121::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2121::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2121::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2121::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2121::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2121::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2121::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2122 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2122();
	virtual ~CustomMetaDataUnicastTagN2122();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2122");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2122);

CustomMetaDataUnicastTagN2122::CustomMetaDataUnicastTagN2122() {

}

CustomMetaDataUnicastTagN2122::~CustomMetaDataUnicastTagN2122() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2122::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2122")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2122> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2122::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2122::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2122::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2122::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2122::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2122::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2122::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2122::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2122::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2122::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2123 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2123();
	virtual ~CustomMetaDataUnicastTagN2123();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2123");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2123);

CustomMetaDataUnicastTagN2123::CustomMetaDataUnicastTagN2123() {

}

CustomMetaDataUnicastTagN2123::~CustomMetaDataUnicastTagN2123() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2123::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2123")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2123> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2123::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2123::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2123::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2123::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2123::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2123::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2123::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2123::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2123::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2123::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2124 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2124();
	virtual ~CustomMetaDataUnicastTagN2124();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2124");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2124);

CustomMetaDataUnicastTagN2124::CustomMetaDataUnicastTagN2124() {

}

CustomMetaDataUnicastTagN2124::~CustomMetaDataUnicastTagN2124() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2124::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2124")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2124> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2124::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2124::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2124::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2124::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2124::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2124::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2124::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2124::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2124::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2124::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2125 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2125();
	virtual ~CustomMetaDataUnicastTagN2125();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2125");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2125);

CustomMetaDataUnicastTagN2125::CustomMetaDataUnicastTagN2125() {

}

CustomMetaDataUnicastTagN2125::~CustomMetaDataUnicastTagN2125() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2125::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2125")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2125> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2125::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2125::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2125::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2125::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2125::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2125::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2125::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2125::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2125::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2125::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2201 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2201();
	virtual ~CustomMetaDataUnicastTagN2201();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2201");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2201);

CustomMetaDataUnicastTagN2201::CustomMetaDataUnicastTagN2201() {
}


CustomMetaDataUnicastTagN2201::~CustomMetaDataUnicastTagN2201() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2201::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2201")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2201> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2201::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2201::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2201::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2201::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2201::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2201::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2201::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2201::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2201::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2201::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2202 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2202();
	virtual ~CustomMetaDataUnicastTagN2202();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max2+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2202");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2202);

CustomMetaDataUnicastTagN2202::CustomMetaDataUnicastTagN2202() {

}


CustomMetaDataUnicastTagN2202::~CustomMetaDataUnicastTagN2202() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2202::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2202")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2202> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2202::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2202::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN2202::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2202::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2202::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2202::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN2202::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2202::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2202::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2202::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2203 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2203();
	virtual ~CustomMetaDataUnicastTagN2203();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max3+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2203");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2203);

CustomMetaDataUnicastTagN2203::CustomMetaDataUnicastTagN2203() {

}


CustomMetaDataUnicastTagN2203::~CustomMetaDataUnicastTagN2203() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2203::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2203")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2203> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2203::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2203::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2203::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2203::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2203::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2203::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2203::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2203::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2203::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2203::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2204 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2204();
	virtual ~CustomMetaDataUnicastTagN2204();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2204");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2204);

CustomMetaDataUnicastTagN2204::CustomMetaDataUnicastTagN2204() {
	
}


CustomMetaDataUnicastTagN2204::~CustomMetaDataUnicastTagN2204() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2204::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2204")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2204> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2204::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2204::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN2204::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2204::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2204::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2204::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2204::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2204::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2204::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2204::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2205 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2205();
	virtual ~CustomMetaDataUnicastTagN2205();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2205");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2205);

CustomMetaDataUnicastTagN2205::CustomMetaDataUnicastTagN2205() {
}


CustomMetaDataUnicastTagN2205::~CustomMetaDataUnicastTagN2205() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2205::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2205")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2205> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2205::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2205::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2205::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2205::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2205::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2205::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2205::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2205::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2205::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2205::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2206 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2206();
	virtual ~CustomMetaDataUnicastTagN2206();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2206");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2206);

CustomMetaDataUnicastTagN2206::CustomMetaDataUnicastTagN2206() {

}

CustomMetaDataUnicastTagN2206::~CustomMetaDataUnicastTagN2206() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2206::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2206")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2206> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2206::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2206::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2206::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2206::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2206::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2206::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2206::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2206::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2206::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2206::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2207 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2207();
	virtual ~CustomMetaDataUnicastTagN2207();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2207");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2207);

CustomMetaDataUnicastTagN2207::CustomMetaDataUnicastTagN2207() {

}


CustomMetaDataUnicastTagN2207::~CustomMetaDataUnicastTagN2207() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2207::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2207")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2207> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2207::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2207::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2207::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2207::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN2207::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2207::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2207::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2207::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2207::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2207::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2208 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2208();
	virtual ~CustomMetaDataUnicastTagN2208();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2208");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2208);

CustomMetaDataUnicastTagN2208::CustomMetaDataUnicastTagN2208() {
}


CustomMetaDataUnicastTagN2208::~CustomMetaDataUnicastTagN2208() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2208::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2208")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2208> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2208::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2208::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2208::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2208::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2208::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2208::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2208::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2208::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2208::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2208::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2209 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2209();
	virtual ~CustomMetaDataUnicastTagN2209();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max9+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2209");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2209);

CustomMetaDataUnicastTagN2209::CustomMetaDataUnicastTagN2209() {

}


CustomMetaDataUnicastTagN2209::~CustomMetaDataUnicastTagN2209() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2209::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2209")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2209> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2209::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2209::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2209::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2209::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2209::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2209::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2209::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2209::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2209::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2209::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2210 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2210();
	virtual ~CustomMetaDataUnicastTagN2210();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2210");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2210);

CustomMetaDataUnicastTagN2210::CustomMetaDataUnicastTagN2210() {
	
}


CustomMetaDataUnicastTagN2210::~CustomMetaDataUnicastTagN2210() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2210::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2210")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2210> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2210::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2210::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2210::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2210::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2210::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2210::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2210::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2210::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2210::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2210::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2211 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2211();
	virtual ~CustomMetaDataUnicastTagN2211();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max11+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2211");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2211);

CustomMetaDataUnicastTagN2211::CustomMetaDataUnicastTagN2211() {

}


CustomMetaDataUnicastTagN2211::~CustomMetaDataUnicastTagN2211() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2211::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2211")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2211> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2211::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2211::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2211::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2211::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN2211::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN2211::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2211::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2211::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2211::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2211::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2212 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2212();

	virtual ~CustomMetaDataUnicastTagN2212();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max12+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2212");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2212);

CustomMetaDataUnicastTagN2212::CustomMetaDataUnicastTagN2212() {
}


CustomMetaDataUnicastTagN2212::~CustomMetaDataUnicastTagN2212() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2212::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2212")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2212> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2212::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2212::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2212::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2212::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2212::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN2212::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2212::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2212::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2212::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2212::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2213 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2213();
	virtual ~CustomMetaDataUnicastTagN2213();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max13+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2213");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2213);

CustomMetaDataUnicastTagN2213::CustomMetaDataUnicastTagN2213() {

}


CustomMetaDataUnicastTagN2213::~CustomMetaDataUnicastTagN2213() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2213::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2213")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2213> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2213::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2213::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN2213::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2213::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2213::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2213::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2213::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2213::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2213::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2213::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2214 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN2214();
	virtual ~CustomMetaDataUnicastTagN2214();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max14+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2214");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2214);

CustomMetaDataUnicastTagN2214::CustomMetaDataUnicastTagN2214() {

}


CustomMetaDataUnicastTagN2214::~CustomMetaDataUnicastTagN2214() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2214::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2214")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2214> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2214::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2214::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2214::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2214::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2214::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2214::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN2214::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2214::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2214::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2214::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN2215 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2215();
	virtual ~CustomMetaDataUnicastTagN2215();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max15+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2215");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2215);

CustomMetaDataUnicastTagN2215::CustomMetaDataUnicastTagN2215() {

}

CustomMetaDataUnicastTagN2215::~CustomMetaDataUnicastTagN2215() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2215::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2215")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2215> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2215::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2215::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2215::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2215::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2215::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2215::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2215::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2215::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2215::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2215::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2216 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2216();
	virtual ~CustomMetaDataUnicastTagN2216();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2216");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2216);

CustomMetaDataUnicastTagN2216::CustomMetaDataUnicastTagN2216() {

}

CustomMetaDataUnicastTagN2216::~CustomMetaDataUnicastTagN2216() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2216::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2216")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2216> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2216::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2216::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2216::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2216::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2216::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2216::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2216::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2216::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2216::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2216::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2217 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2217();
	virtual ~CustomMetaDataUnicastTagN2217();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2217");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2217);

CustomMetaDataUnicastTagN2217::CustomMetaDataUnicastTagN2217() {

}

CustomMetaDataUnicastTagN2217::~CustomMetaDataUnicastTagN2217() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2217::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2217")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2217> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2217::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2217::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2217::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2217::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2217::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2217::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2217::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2217::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2217::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2217::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2218 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2218();
	virtual ~CustomMetaDataUnicastTagN2218();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2218");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2218);

CustomMetaDataUnicastTagN2218::CustomMetaDataUnicastTagN2218() {

}

CustomMetaDataUnicastTagN2218::~CustomMetaDataUnicastTagN2218() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2218::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2218")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2218> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2218::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2218::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2218::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2218::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2218::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2218::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2218::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2218::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2218::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2218::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2219 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2219();
	virtual ~CustomMetaDataUnicastTagN2219();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2219");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2219);

CustomMetaDataUnicastTagN2219::CustomMetaDataUnicastTagN2219() {

}

CustomMetaDataUnicastTagN2219::~CustomMetaDataUnicastTagN2219() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2219::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2219")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2219> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2219::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2219::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2219::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2219::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2219::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2219::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2219::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2219::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2219::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2219::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2220 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2220();
	virtual ~CustomMetaDataUnicastTagN2220();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2220");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2220);

CustomMetaDataUnicastTagN2220::CustomMetaDataUnicastTagN2220() {

}

CustomMetaDataUnicastTagN2220::~CustomMetaDataUnicastTagN2220() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2220::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2220")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2220> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2220::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2220::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2220::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2220::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2220::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2220::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2220::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2220::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2220::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2220::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2221 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2221();
	virtual ~CustomMetaDataUnicastTagN2221();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2221");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2221);

CustomMetaDataUnicastTagN2221::CustomMetaDataUnicastTagN2221() {

}

CustomMetaDataUnicastTagN2221::~CustomMetaDataUnicastTagN2221() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2221::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2221")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2221> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2221::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2221::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2221::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2221::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2221::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2221::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2221::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2221::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2221::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2221::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2222 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2222();
	virtual ~CustomMetaDataUnicastTagN2222();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2222");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2222);

CustomMetaDataUnicastTagN2222::CustomMetaDataUnicastTagN2222() {

}

CustomMetaDataUnicastTagN2222::~CustomMetaDataUnicastTagN2222() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2222::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2222")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2222> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2222::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2222::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2222::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2222::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2222::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2222::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2222::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2222::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2222::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2222::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2223 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2223();
	virtual ~CustomMetaDataUnicastTagN2223();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2223");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2223);

CustomMetaDataUnicastTagN2223::CustomMetaDataUnicastTagN2223() {

}

CustomMetaDataUnicastTagN2223::~CustomMetaDataUnicastTagN2223() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2223::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2223")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2223> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2223::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2223::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2223::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2223::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2223::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2223::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2223::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2223::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2223::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2223::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2224 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2224();
	virtual ~CustomMetaDataUnicastTagN2224();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2224");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2224);

CustomMetaDataUnicastTagN2224::CustomMetaDataUnicastTagN2224() {

}

CustomMetaDataUnicastTagN2224::~CustomMetaDataUnicastTagN2224() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2224::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2224")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2224> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2224::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2224::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2224::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2224::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2224::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2224::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2224::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2224::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2224::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2224::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2225 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2225();
	virtual ~CustomMetaDataUnicastTagN2225();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2225");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2225);

CustomMetaDataUnicastTagN2225::CustomMetaDataUnicastTagN2225() {

}

CustomMetaDataUnicastTagN2225::~CustomMetaDataUnicastTagN2225() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2225::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2225")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2225> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2225::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2225::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2225::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2225::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2225::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2225::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2225::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2225::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2225::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2225::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2301 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2301();
	virtual ~CustomMetaDataUnicastTagN2301();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2301");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2301);

CustomMetaDataUnicastTagN2301::CustomMetaDataUnicastTagN2301() {
}


CustomMetaDataUnicastTagN2301::~CustomMetaDataUnicastTagN2301() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2301::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2301")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2301> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2301::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2301::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2301::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2301::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2301::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2301::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2301::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2301::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2301::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2301::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2302 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2302();
	virtual ~CustomMetaDataUnicastTagN2302();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max2+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2302");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2302);

CustomMetaDataUnicastTagN2302::CustomMetaDataUnicastTagN2302() {

}


CustomMetaDataUnicastTagN2302::~CustomMetaDataUnicastTagN2302() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2302::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2302")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2302> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2302::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2302::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN2302::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2302::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2302::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2302::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN2302::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2302::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2302::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2302::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2303 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2303();
	virtual ~CustomMetaDataUnicastTagN2303();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max3+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2303");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2303);

CustomMetaDataUnicastTagN2303::CustomMetaDataUnicastTagN2303() {

}


CustomMetaDataUnicastTagN2303::~CustomMetaDataUnicastTagN2303() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2303::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2303")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2303> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2303::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2303::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2303::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2303::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2303::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2303::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2303::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2303::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2303::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2303::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2304 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2304();
	virtual ~CustomMetaDataUnicastTagN2304();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2304");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2304);

CustomMetaDataUnicastTagN2304::CustomMetaDataUnicastTagN2304() {
	
}


CustomMetaDataUnicastTagN2304::~CustomMetaDataUnicastTagN2304() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2304::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2304")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2304> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2304::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2304::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN2304::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2304::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2304::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2304::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2304::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2304::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2304::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2304::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2305 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2305();
	virtual ~CustomMetaDataUnicastTagN2305();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2305");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2305);

CustomMetaDataUnicastTagN2305::CustomMetaDataUnicastTagN2305() {
}


CustomMetaDataUnicastTagN2305::~CustomMetaDataUnicastTagN2305() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2305::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2305")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2305> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2305::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2305::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2305::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2305::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2305::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2305::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2305::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2305::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2305::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2305::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2306 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2306();
	virtual ~CustomMetaDataUnicastTagN2306();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2306");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2306);

CustomMetaDataUnicastTagN2306::CustomMetaDataUnicastTagN2306() {

}

CustomMetaDataUnicastTagN2306::~CustomMetaDataUnicastTagN2306() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2306::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2306")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2306> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2306::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2306::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2306::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2306::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2306::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2306::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2306::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2306::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2306::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2306::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2307 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2307();
	virtual ~CustomMetaDataUnicastTagN2307();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2307");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2307);

CustomMetaDataUnicastTagN2307::CustomMetaDataUnicastTagN2307() {

}


CustomMetaDataUnicastTagN2307::~CustomMetaDataUnicastTagN2307() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2307::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2307")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2307> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2307::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2307::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2307::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2307::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN2307::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2307::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2307::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2307::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2307::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2307::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2308 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2308();
	virtual ~CustomMetaDataUnicastTagN2308();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2308");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2308);

CustomMetaDataUnicastTagN2308::CustomMetaDataUnicastTagN2308() {
}


CustomMetaDataUnicastTagN2308::~CustomMetaDataUnicastTagN2308() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2308::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2308")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2308> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2308::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2308::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2308::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2308::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2308::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2308::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2308::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2308::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2308::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2308::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2309 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2309();
	virtual ~CustomMetaDataUnicastTagN2309();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max9+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2309");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2309);

CustomMetaDataUnicastTagN2309::CustomMetaDataUnicastTagN2309() {

}


CustomMetaDataUnicastTagN2309::~CustomMetaDataUnicastTagN2309() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2309::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2309")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2309> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2309::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2309::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2309::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2309::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2309::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2309::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2309::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2309::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2309::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2309::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2310 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2310();
	virtual ~CustomMetaDataUnicastTagN2310();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2310");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2310);

CustomMetaDataUnicastTagN2310::CustomMetaDataUnicastTagN2310() {
	
}


CustomMetaDataUnicastTagN2310::~CustomMetaDataUnicastTagN2310() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2310::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2310")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2310> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2310::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2310::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2310::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2310::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2310::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2310::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2310::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2310::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2310::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2310::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2311 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2311();
	virtual ~CustomMetaDataUnicastTagN2311();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max11+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2311");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2311);

CustomMetaDataUnicastTagN2311::CustomMetaDataUnicastTagN2311() {

}


CustomMetaDataUnicastTagN2311::~CustomMetaDataUnicastTagN2311() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2311::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2311")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2311> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2311::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2311::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2311::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2311::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN2311::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN2311::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2311::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2311::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2311::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2311::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2312 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2312();

	virtual ~CustomMetaDataUnicastTagN2312();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max12+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2312");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2312);

CustomMetaDataUnicastTagN2312::CustomMetaDataUnicastTagN2312() {
}


CustomMetaDataUnicastTagN2312::~CustomMetaDataUnicastTagN2312() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2312::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2312")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2312> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2312::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2312::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2312::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2312::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2312::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN2312::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2312::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2312::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2312::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2312::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2313 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2313();
	virtual ~CustomMetaDataUnicastTagN2313();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max13+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2313");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2313);

CustomMetaDataUnicastTagN2313::CustomMetaDataUnicastTagN2313() {

}


CustomMetaDataUnicastTagN2313::~CustomMetaDataUnicastTagN2313() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2313::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2313")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2313> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2313::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2313::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN2313::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2313::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2313::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2313::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2313::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2313::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2313::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2313::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2314 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN2314();
	virtual ~CustomMetaDataUnicastTagN2314();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max14+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2314");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2314);

CustomMetaDataUnicastTagN2314::CustomMetaDataUnicastTagN2314() {

}


CustomMetaDataUnicastTagN2314::~CustomMetaDataUnicastTagN2314() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2314::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2314")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2314> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2314::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2314::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2314::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2314::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2314::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2314::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN2314::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2314::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2314::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2314::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN2315 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2315();
	virtual ~CustomMetaDataUnicastTagN2315();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max15+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2315");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2315);

CustomMetaDataUnicastTagN2315::CustomMetaDataUnicastTagN2315() {

}

CustomMetaDataUnicastTagN2315::~CustomMetaDataUnicastTagN2315() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2315::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2315")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2315> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2315::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2315::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2315::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2315::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2315::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2315::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2315::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2315::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2315::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2315::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2316 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2316();
	virtual ~CustomMetaDataUnicastTagN2316();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2316");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2316);

CustomMetaDataUnicastTagN2316::CustomMetaDataUnicastTagN2316() {

}

CustomMetaDataUnicastTagN2316::~CustomMetaDataUnicastTagN2316() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2316::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2316")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2316> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2316::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2316::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2316::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2316::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2316::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2316::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2316::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2316::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2316::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2316::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2317 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2317();
	virtual ~CustomMetaDataUnicastTagN2317();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2317");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2317);

CustomMetaDataUnicastTagN2317::CustomMetaDataUnicastTagN2317() {

}

CustomMetaDataUnicastTagN2317::~CustomMetaDataUnicastTagN2317() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2317::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2317")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2317> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2317::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2317::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2317::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2317::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2317::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2317::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2317::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2317::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2317::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2317::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2318 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2318();
	virtual ~CustomMetaDataUnicastTagN2318();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2318");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2318);

CustomMetaDataUnicastTagN2318::CustomMetaDataUnicastTagN2318() {

}

CustomMetaDataUnicastTagN2318::~CustomMetaDataUnicastTagN2318() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2318::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2318")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2318> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2318::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2318::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2318::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2318::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2318::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2318::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2318::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2318::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2318::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2318::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2319 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2319();
	virtual ~CustomMetaDataUnicastTagN2319();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2319");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2319);

CustomMetaDataUnicastTagN2319::CustomMetaDataUnicastTagN2319() {

}

CustomMetaDataUnicastTagN2319::~CustomMetaDataUnicastTagN2319() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2319::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2319")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2319> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2319::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2319::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2319::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2319::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2319::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2319::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2319::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2319::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2319::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2319::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2320 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2320();
	virtual ~CustomMetaDataUnicastTagN2320();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2320");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2320);

CustomMetaDataUnicastTagN2320::CustomMetaDataUnicastTagN2320() {

}

CustomMetaDataUnicastTagN2320::~CustomMetaDataUnicastTagN2320() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2320::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2320")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2320> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2320::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2320::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2320::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2320::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2320::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2320::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2320::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2320::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2320::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2320::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2321 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2321();
	virtual ~CustomMetaDataUnicastTagN2321();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2321");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2321);

CustomMetaDataUnicastTagN2321::CustomMetaDataUnicastTagN2321() {

}

CustomMetaDataUnicastTagN2321::~CustomMetaDataUnicastTagN2321() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2321::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2321")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2321> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2321::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2321::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2321::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2321::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2321::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2321::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2321::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2321::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2321::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2321::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2322 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2322();
	virtual ~CustomMetaDataUnicastTagN2322();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2322");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2322);

CustomMetaDataUnicastTagN2322::CustomMetaDataUnicastTagN2322() {

}

CustomMetaDataUnicastTagN2322::~CustomMetaDataUnicastTagN2322() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2322::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2322")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2322> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2322::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2322::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2322::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2322::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2322::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2322::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2322::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2322::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2322::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2322::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2323 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2323();
	virtual ~CustomMetaDataUnicastTagN2323();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2323");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2323);

CustomMetaDataUnicastTagN2323::CustomMetaDataUnicastTagN2323() {

}

CustomMetaDataUnicastTagN2323::~CustomMetaDataUnicastTagN2323() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2323::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2323")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2323> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2323::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2323::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2323::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2323::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2323::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2323::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2323::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2323::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2323::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2323::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2324 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2324();
	virtual ~CustomMetaDataUnicastTagN2324();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2324");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2324);

CustomMetaDataUnicastTagN2324::CustomMetaDataUnicastTagN2324() {

}

CustomMetaDataUnicastTagN2324::~CustomMetaDataUnicastTagN2324() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2324::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2324")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2324> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2324::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2324::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2324::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2324::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2324::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2324::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2324::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2324::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2324::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2324::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2325 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2325();
	virtual ~CustomMetaDataUnicastTagN2325();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2325");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2325);

CustomMetaDataUnicastTagN2325::CustomMetaDataUnicastTagN2325() {

}

CustomMetaDataUnicastTagN2325::~CustomMetaDataUnicastTagN2325() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2325::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2325")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2325> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2325::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2325::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2325::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2325::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2325::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2325::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2325::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2325::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2325::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2325::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2401 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2401();
	virtual ~CustomMetaDataUnicastTagN2401();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2401");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2401);

CustomMetaDataUnicastTagN2401::CustomMetaDataUnicastTagN2401() {
}


CustomMetaDataUnicastTagN2401::~CustomMetaDataUnicastTagN2401() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2401::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2401")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2401> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2401::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2401::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2401::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2401::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2401::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2401::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2401::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2401::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2401::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2401::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2402 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2402();
	virtual ~CustomMetaDataUnicastTagN2402();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max2+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2402");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2402);

CustomMetaDataUnicastTagN2402::CustomMetaDataUnicastTagN2402() {

}


CustomMetaDataUnicastTagN2402::~CustomMetaDataUnicastTagN2402() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2402::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2402")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2402> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2402::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2402::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN2402::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2402::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2402::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2402::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN2402::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2402::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2402::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2402::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2403 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2403();
	virtual ~CustomMetaDataUnicastTagN2403();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max3+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2403");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2403);

CustomMetaDataUnicastTagN2403::CustomMetaDataUnicastTagN2403() {

}


CustomMetaDataUnicastTagN2403::~CustomMetaDataUnicastTagN2403() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2403::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2403")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2403> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2403::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2403::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2403::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2403::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2403::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2403::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2403::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2403::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2403::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2403::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2404 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2404();
	virtual ~CustomMetaDataUnicastTagN2404();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2404");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2404);

CustomMetaDataUnicastTagN2404::CustomMetaDataUnicastTagN2404() {
	
}


CustomMetaDataUnicastTagN2404::~CustomMetaDataUnicastTagN2404() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2404::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2404")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2404> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2404::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2404::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN2404::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2404::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2404::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2404::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2404::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2404::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2404::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2404::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2405 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2405();
	virtual ~CustomMetaDataUnicastTagN2405();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2405");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2405);

CustomMetaDataUnicastTagN2405::CustomMetaDataUnicastTagN2405() {
}


CustomMetaDataUnicastTagN2405::~CustomMetaDataUnicastTagN2405() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2405::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2405")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2405> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2405::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2405::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2405::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2405::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2405::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2405::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2405::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2405::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2405::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2405::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2406 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2406();
	virtual ~CustomMetaDataUnicastTagN2406();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2406");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2406);

CustomMetaDataUnicastTagN2406::CustomMetaDataUnicastTagN2406() {

}

CustomMetaDataUnicastTagN2406::~CustomMetaDataUnicastTagN2406() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2406::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2406")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2406> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2406::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2406::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2406::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2406::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2406::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2406::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2406::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2406::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2406::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2406::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2407 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2407();
	virtual ~CustomMetaDataUnicastTagN2407();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2407");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2407);

CustomMetaDataUnicastTagN2407::CustomMetaDataUnicastTagN2407() {

}


CustomMetaDataUnicastTagN2407::~CustomMetaDataUnicastTagN2407() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2407::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2407")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2407> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2407::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2407::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2407::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2407::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN2407::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2407::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2407::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2407::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2407::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2407::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2408 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2408();
	virtual ~CustomMetaDataUnicastTagN2408();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2408");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2408);

CustomMetaDataUnicastTagN2408::CustomMetaDataUnicastTagN2408() {
}


CustomMetaDataUnicastTagN2408::~CustomMetaDataUnicastTagN2408() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2408::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2408")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2408> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2408::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2408::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2408::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2408::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2408::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2408::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2408::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2408::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2408::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2408::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2409 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2409();
	virtual ~CustomMetaDataUnicastTagN2409();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max9+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2409");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2409);

CustomMetaDataUnicastTagN2409::CustomMetaDataUnicastTagN2409() {

}


CustomMetaDataUnicastTagN2409::~CustomMetaDataUnicastTagN2409() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2409::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2409")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2409> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2409::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2409::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2409::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2409::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2409::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2409::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2409::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2409::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2409::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2409::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2410 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2410();
	virtual ~CustomMetaDataUnicastTagN2410();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2410");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2410);

CustomMetaDataUnicastTagN2410::CustomMetaDataUnicastTagN2410() {
	
}


CustomMetaDataUnicastTagN2410::~CustomMetaDataUnicastTagN2410() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2410::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2410")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2410> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2410::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2410::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2410::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2410::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2410::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2410::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2410::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2410::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2410::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2410::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2411 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2411();
	virtual ~CustomMetaDataUnicastTagN2411();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max11+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2411");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2411);

CustomMetaDataUnicastTagN2411::CustomMetaDataUnicastTagN2411() {

}


CustomMetaDataUnicastTagN2411::~CustomMetaDataUnicastTagN2411() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2411::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2411")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2411> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2411::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2411::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2411::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2411::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN2411::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN2411::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2411::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2411::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2411::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2411::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2412 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2412();

	virtual ~CustomMetaDataUnicastTagN2412();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max12+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2412");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2412);

CustomMetaDataUnicastTagN2412::CustomMetaDataUnicastTagN2412() {
}


CustomMetaDataUnicastTagN2412::~CustomMetaDataUnicastTagN2412() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2412::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2412")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2412> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2412::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2412::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2412::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2412::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2412::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN2412::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2412::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2412::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2412::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2412::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2413 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2413();
	virtual ~CustomMetaDataUnicastTagN2413();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max13+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2413");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2413);

CustomMetaDataUnicastTagN2413::CustomMetaDataUnicastTagN2413() {

}


CustomMetaDataUnicastTagN2413::~CustomMetaDataUnicastTagN2413() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2413::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2413")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2413> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2413::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2413::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN2413::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2413::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2413::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2413::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2413::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2413::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2413::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2413::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2414 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN2414();
	virtual ~CustomMetaDataUnicastTagN2414();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max14+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2414");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2414);

CustomMetaDataUnicastTagN2414::CustomMetaDataUnicastTagN2414() {

}


CustomMetaDataUnicastTagN2414::~CustomMetaDataUnicastTagN2414() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2414::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2414")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2414> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2414::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2414::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2414::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2414::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2414::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2414::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN2414::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2414::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2414::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2414::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN2415 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2415();
	virtual ~CustomMetaDataUnicastTagN2415();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max15+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2415");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2415);

CustomMetaDataUnicastTagN2415::CustomMetaDataUnicastTagN2415() {

}

CustomMetaDataUnicastTagN2415::~CustomMetaDataUnicastTagN2415() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2415::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2415")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2415> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2415::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2415::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2415::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2415::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2415::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2415::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2415::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2415::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2415::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2415::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2416 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2416();
	virtual ~CustomMetaDataUnicastTagN2416();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2416");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2416);

CustomMetaDataUnicastTagN2416::CustomMetaDataUnicastTagN2416() {

}

CustomMetaDataUnicastTagN2416::~CustomMetaDataUnicastTagN2416() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2416::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2416")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2416> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2416::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2416::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2416::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2416::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2416::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2416::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2416::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2416::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2416::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2416::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2417 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2417();
	virtual ~CustomMetaDataUnicastTagN2417();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2417");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2417);

CustomMetaDataUnicastTagN2417::CustomMetaDataUnicastTagN2417() {

}

CustomMetaDataUnicastTagN2417::~CustomMetaDataUnicastTagN2417() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2417::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2417")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2417> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2417::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2417::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2417::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2417::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2417::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2417::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2417::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2417::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2417::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2417::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2418 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2418();
	virtual ~CustomMetaDataUnicastTagN2418();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2418");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2418);

CustomMetaDataUnicastTagN2418::CustomMetaDataUnicastTagN2418() {

}

CustomMetaDataUnicastTagN2418::~CustomMetaDataUnicastTagN2418() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2418::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2418")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2418> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2418::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2418::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2418::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2418::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2418::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2418::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2418::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2418::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2418::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2418::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2419 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2419();
	virtual ~CustomMetaDataUnicastTagN2419();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2419");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2419);

CustomMetaDataUnicastTagN2419::CustomMetaDataUnicastTagN2419() {

}

CustomMetaDataUnicastTagN2419::~CustomMetaDataUnicastTagN2419() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2419::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2419")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2419> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2419::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2419::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2419::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2419::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2419::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2419::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2419::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2419::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2419::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2419::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2420 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2420();
	virtual ~CustomMetaDataUnicastTagN2420();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2420");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2420);

CustomMetaDataUnicastTagN2420::CustomMetaDataUnicastTagN2420() {

}

CustomMetaDataUnicastTagN2420::~CustomMetaDataUnicastTagN2420() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2420::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2420")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2420> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2420::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2420::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2420::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2420::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2420::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2420::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2420::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2420::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2420::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2420::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2421 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2421();
	virtual ~CustomMetaDataUnicastTagN2421();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2421");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2421);

CustomMetaDataUnicastTagN2421::CustomMetaDataUnicastTagN2421() {

}

CustomMetaDataUnicastTagN2421::~CustomMetaDataUnicastTagN2421() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2421::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2421")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2421> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2421::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2421::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2421::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2421::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2421::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2421::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2421::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2421::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2421::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2421::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2422 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2422();
	virtual ~CustomMetaDataUnicastTagN2422();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2422");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2422);

CustomMetaDataUnicastTagN2422::CustomMetaDataUnicastTagN2422() {

}

CustomMetaDataUnicastTagN2422::~CustomMetaDataUnicastTagN2422() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2422::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2422")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2422> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2422::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2422::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2422::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2422::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2422::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2422::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2422::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2422::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2422::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2422::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2423 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2423();
	virtual ~CustomMetaDataUnicastTagN2423();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2423");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2423);

CustomMetaDataUnicastTagN2423::CustomMetaDataUnicastTagN2423() {

}

CustomMetaDataUnicastTagN2423::~CustomMetaDataUnicastTagN2423() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2423::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2423")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2423> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2423::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2423::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2423::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2423::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2423::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2423::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2423::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2423::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2423::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2423::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2424 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2424();
	virtual ~CustomMetaDataUnicastTagN2424();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2424");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2424);

CustomMetaDataUnicastTagN2424::CustomMetaDataUnicastTagN2424() {

}

CustomMetaDataUnicastTagN2424::~CustomMetaDataUnicastTagN2424() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2424::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2424")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2424> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2424::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2424::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2424::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2424::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2424::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2424::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2424::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2424::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2424::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2424::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2425 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2425();
	virtual ~CustomMetaDataUnicastTagN2425();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2425");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2425);

CustomMetaDataUnicastTagN2425::CustomMetaDataUnicastTagN2425() {

}

CustomMetaDataUnicastTagN2425::~CustomMetaDataUnicastTagN2425() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2425::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2425")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2425> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2425::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2425::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2425::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2425::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2425::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2425::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2425::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2425::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2425::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2425::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2501 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2501();
	virtual ~CustomMetaDataUnicastTagN2501();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max1+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2501");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2501);

CustomMetaDataUnicastTagN2501::CustomMetaDataUnicastTagN2501() {
}


CustomMetaDataUnicastTagN2501::~CustomMetaDataUnicastTagN2501() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2501::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2501")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2501> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2501::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2501::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2501::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2501::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max1;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2501::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max1;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2501::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2501::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2501::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max1;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2501::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2501::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2502 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2502();
	virtual ~CustomMetaDataUnicastTagN2502();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max2+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2502");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2502);

CustomMetaDataUnicastTagN2502::CustomMetaDataUnicastTagN2502() {

}


CustomMetaDataUnicastTagN2502::~CustomMetaDataUnicastTagN2502() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2502::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2502")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2502> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2502::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2502::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN2502::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2502::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max2;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2502::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max2;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2502::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}



uint32_t * CustomMetaDataUnicastTagN2502::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2502::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max2;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2502::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2502::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2503 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2503();
	virtual ~CustomMetaDataUnicastTagN2503();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max3+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2503");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2503);

CustomMetaDataUnicastTagN2503::CustomMetaDataUnicastTagN2503() {

}


CustomMetaDataUnicastTagN2503::~CustomMetaDataUnicastTagN2503() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2503::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2503")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2503> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2503::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2503::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2503::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2503::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max3;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2503::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max3;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2503::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2503::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2503::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max3;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2503::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2503::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2504 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2504();
	virtual ~CustomMetaDataUnicastTagN2504();
private:
	uint32_t m_neighborid[max4+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2504");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2504);

CustomMetaDataUnicastTagN2504::CustomMetaDataUnicastTagN2504() {
	
}


CustomMetaDataUnicastTagN2504::~CustomMetaDataUnicastTagN2504() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2504::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2504")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2504> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2504::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2504::GetTypeId ();
}

 
uint32_t CustomMetaDataUnicastTagN2504::GetSerializedSize (void) const
{

	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2504::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max4;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2504::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max4;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2504::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2504::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2504::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max4;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2504::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2504::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2505 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2505();
	virtual ~CustomMetaDataUnicastTagN2505();
private:
	uint32_t m_neighborid[max5+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2505");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2505);

CustomMetaDataUnicastTagN2505::CustomMetaDataUnicastTagN2505() {
}


CustomMetaDataUnicastTagN2505::~CustomMetaDataUnicastTagN2505() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2505::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2505")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2505> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2505::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2505::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2505::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2505::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max5;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2505::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max5;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2505::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2505::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2505::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max5;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2505::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2505::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2506 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2506();
	virtual ~CustomMetaDataUnicastTagN2506();
private:
	uint32_t m_neighborid[max6+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2506");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2506);

CustomMetaDataUnicastTagN2506::CustomMetaDataUnicastTagN2506() {

}

CustomMetaDataUnicastTagN2506::~CustomMetaDataUnicastTagN2506() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2506::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2506")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2506> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2506::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2506::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2506::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2506::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max6;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2506::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max6;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2506::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2506::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2506::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max6;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2506::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2506::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2507 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2507();
	virtual ~CustomMetaDataUnicastTagN2507();
private:
	uint32_t m_neighborid[max7+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2507");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2507);

CustomMetaDataUnicastTagN2507::CustomMetaDataUnicastTagN2507() {

}


CustomMetaDataUnicastTagN2507::~CustomMetaDataUnicastTagN2507() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2507::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2507")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2507> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2507::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2507::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2507::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2507::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max7;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);

}



void CustomMetaDataUnicastTagN2507::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max7;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2507::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2507::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2507::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max7;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2507::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2507::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2508 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2508();
	virtual ~CustomMetaDataUnicastTagN2508();
private:
	uint32_t m_neighborid[max8+1];
	uint32_t m_nodeid;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2508");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2508);

CustomMetaDataUnicastTagN2508::CustomMetaDataUnicastTagN2508() {
}


CustomMetaDataUnicastTagN2508::~CustomMetaDataUnicastTagN2508() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2508::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2508")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2508> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2508::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2508::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2508::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2508::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max8;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2508::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max8;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2508::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2508::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2508::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max8;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2508::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2508::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2509 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2509();
	virtual ~CustomMetaDataUnicastTagN2509();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max9+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2509");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2509);

CustomMetaDataUnicastTagN2509::CustomMetaDataUnicastTagN2509() {

}


CustomMetaDataUnicastTagN2509::~CustomMetaDataUnicastTagN2509() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2509::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2509")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2509> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2509::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2509::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2509::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2509::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max9;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2509::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max9;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2509::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2509::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2509::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max9;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2509::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2509::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2510 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2510();
	virtual ~CustomMetaDataUnicastTagN2510();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max10+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2510");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2510);

CustomMetaDataUnicastTagN2510::CustomMetaDataUnicastTagN2510() {
	
}


CustomMetaDataUnicastTagN2510::~CustomMetaDataUnicastTagN2510() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2510::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2510")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2510> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2510::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2510::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2510::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2510::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max10;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2510::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max10;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2510::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2510::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2510::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max10;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2510::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2510::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2511 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2511();
	virtual ~CustomMetaDataUnicastTagN2511();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max11+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2511");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2511);

CustomMetaDataUnicastTagN2511::CustomMetaDataUnicastTagN2511() {

}


CustomMetaDataUnicastTagN2511::~CustomMetaDataUnicastTagN2511() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2511::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2511")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2511> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2511::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2511::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2511::GetSerializedSize (void) const
{
	
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2511::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max11;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}

void CustomMetaDataUnicastTagN2511::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max11;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN2511::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 


uint32_t * CustomMetaDataUnicastTagN2511::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2511::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max11;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2511::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2511::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2512 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2512();

	virtual ~CustomMetaDataUnicastTagN2512();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max12+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2512");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2512);

CustomMetaDataUnicastTagN2512::CustomMetaDataUnicastTagN2512() {
}


CustomMetaDataUnicastTagN2512::~CustomMetaDataUnicastTagN2512() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2512::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2512")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2512> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2512::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2512::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2512::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);	
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2512::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max12;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2512::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max12;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}


void CustomMetaDataUnicastTagN2512::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2512::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2512::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max12;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2512::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2512::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2513 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions

	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2513();
	virtual ~CustomMetaDataUnicastTagN2513();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max13+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2513");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2513);

CustomMetaDataUnicastTagN2513::CustomMetaDataUnicastTagN2513() {

}


CustomMetaDataUnicastTagN2513::~CustomMetaDataUnicastTagN2513() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2513::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2513")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2513> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2513::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2513::GetTypeId ();
}
 
uint32_t CustomMetaDataUnicastTagN2513::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2513::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<max13;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2513::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max13;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2513::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 

uint32_t * CustomMetaDataUnicastTagN2513::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2513::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max13;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2513::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2513::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2514 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	CustomMetaDataUnicastTagN2514();
	virtual ~CustomMetaDataUnicastTagN2514();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max14+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2514");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2514);

CustomMetaDataUnicastTagN2514::CustomMetaDataUnicastTagN2514() {

}


CustomMetaDataUnicastTagN2514::~CustomMetaDataUnicastTagN2514() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2514::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2514")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2514> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2514::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2514::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2514::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2514::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max14;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2514::Deserialize (TagBuffer i)
{

	for(uint32_t j=0;j<max14;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2514::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :";
}

//Your accessor and mutator functions 



uint32_t * CustomMetaDataUnicastTagN2514::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2514::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max14;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2514::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2514::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}




class CustomMetaDataUnicastTagN2515 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;


	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);
		uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);

	CustomMetaDataUnicastTagN2515();
	virtual ~CustomMetaDataUnicastTagN2515();
private:
	uint32_t m_nodeid;
	uint32_t m_neighborid[max15+1];

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2515");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2515);

CustomMetaDataUnicastTagN2515::CustomMetaDataUnicastTagN2515() {

}

CustomMetaDataUnicastTagN2515::~CustomMetaDataUnicastTagN2515() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2515::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2515")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2515> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2515::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2515::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2515::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2515::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max15;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2515::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max15;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2515::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2515::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2515::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max15;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2515::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2515::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2516 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2516();
	virtual ~CustomMetaDataUnicastTagN2516();
private:
	uint32_t m_neighborid[max16+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2516");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2516);

CustomMetaDataUnicastTagN2516::CustomMetaDataUnicastTagN2516() {

}

CustomMetaDataUnicastTagN2516::~CustomMetaDataUnicastTagN2516() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2516::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2516")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2516> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2516::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2516::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2516::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2516::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max16;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2516::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max16;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2516::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2516::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2516::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max16;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2516::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2516::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2517 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2517();
	virtual ~CustomMetaDataUnicastTagN2517();
private:
	uint32_t m_neighborid[max17+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2517");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2517);

CustomMetaDataUnicastTagN2517::CustomMetaDataUnicastTagN2517() {

}

CustomMetaDataUnicastTagN2517::~CustomMetaDataUnicastTagN2517() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2517::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2517")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2517> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2517::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2517::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2517::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2517::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max17;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2517::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max17;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2517::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2517::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2517::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max17;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2517::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2517::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2518 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2518();
	virtual ~CustomMetaDataUnicastTagN2518();
private:
	uint32_t m_neighborid[max18+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2518");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2518);

CustomMetaDataUnicastTagN2518::CustomMetaDataUnicastTagN2518() {

}

CustomMetaDataUnicastTagN2518::~CustomMetaDataUnicastTagN2518() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2518::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2518")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2518> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2518::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2518::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2518::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2518::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max18;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2518::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max18;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2518::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2518::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2518::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max18;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2518::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2518::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2519 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2519();
	virtual ~CustomMetaDataUnicastTagN2519();
private:
	uint32_t m_neighborid[max19+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2519");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2519);

CustomMetaDataUnicastTagN2519::CustomMetaDataUnicastTagN2519() {

}

CustomMetaDataUnicastTagN2519::~CustomMetaDataUnicastTagN2519() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2519::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2519")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2519> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2519::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2519::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2519::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2519::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max19;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2519::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max19;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2519::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2519::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2519::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max19;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2519::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2519::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2520 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2520();
	virtual ~CustomMetaDataUnicastTagN2520();
private:
	uint32_t m_neighborid[max20+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2520");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2520);

CustomMetaDataUnicastTagN2520::CustomMetaDataUnicastTagN2520() {

}

CustomMetaDataUnicastTagN2520::~CustomMetaDataUnicastTagN2520() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2520::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2520")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2520> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2520::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2520::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2520::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2520::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max20;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2520::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max20;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2520::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2520::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2520::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max20;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2520::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2520::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataUnicastTagN2521 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2521();
	virtual ~CustomMetaDataUnicastTagN2521();
private:
	uint32_t m_neighborid[max21+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2521");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2521);

CustomMetaDataUnicastTagN2521::CustomMetaDataUnicastTagN2521() {

}

CustomMetaDataUnicastTagN2521::~CustomMetaDataUnicastTagN2521() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2521::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2521")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2521> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2521::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2521::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2521::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2521::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max21;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2521::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max21;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2521::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2521::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2521::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max21;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2521::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2521::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2522 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2522();
	virtual ~CustomMetaDataUnicastTagN2522();
private:
	uint32_t m_neighborid[max22+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2522");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2522);

CustomMetaDataUnicastTagN2522::CustomMetaDataUnicastTagN2522() {

}

CustomMetaDataUnicastTagN2522::~CustomMetaDataUnicastTagN2522() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2522::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2522")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2522> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2522::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2522::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2522::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2522::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max22;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2522::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max22;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2522::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2522::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2522::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max22;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2522::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2522::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2523 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2523();
	virtual ~CustomMetaDataUnicastTagN2523();
private:
	uint32_t m_neighborid[max23+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2523");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2523);

CustomMetaDataUnicastTagN2523::CustomMetaDataUnicastTagN2523() {

}

CustomMetaDataUnicastTagN2523::~CustomMetaDataUnicastTagN2523() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2523::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2523")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2523> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2523::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2523::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2523::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2523::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max23;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2523::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max23;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2523::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2523::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2523::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max23;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2523::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2523::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}


class CustomMetaDataUnicastTagN2524 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2524();
	virtual ~CustomMetaDataUnicastTagN2524();
private:
	uint32_t m_neighborid[max24+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2524");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2524);

CustomMetaDataUnicastTagN2524::CustomMetaDataUnicastTagN2524() {

}

CustomMetaDataUnicastTagN2524::~CustomMetaDataUnicastTagN2524() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2524::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2524")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2524> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2524::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2524::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2524::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2524::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max24;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2524::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max24;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2524::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2524::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2524::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max24;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2524::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2524::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}



class CustomMetaDataUnicastTagN2525 : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	uint32_t Getnodeid();
	void Setnodeid(uint32_t nodeid);
	uint32_t * Getneighborid();
	void Setneighborid (uint32_t * neighborid);

	CustomMetaDataUnicastTagN2525();
	virtual ~CustomMetaDataUnicastTagN2525();
private:
	uint32_t m_neighborid[max25+1];
	uint32_t m_nodeid;

};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataUnicastTagN2525");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataUnicastTagN2525);

CustomMetaDataUnicastTagN2525::CustomMetaDataUnicastTagN2525() {

}

CustomMetaDataUnicastTagN2525::~CustomMetaDataUnicastTagN2525() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataUnicastTagN2525::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataUnicastTagN2525")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataUnicastTagN2525> ();
  return tid;
}
TypeId CustomMetaDataUnicastTagN2525::GetInstanceTypeId (void) const
{
  return CustomMetaDataUnicastTagN2525::GetTypeId ();
}

 

 
uint32_t CustomMetaDataUnicastTagN2525::GetSerializedSize (void) const
{
	return sizeof(m_neighborid)+sizeof(uint32_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataUnicastTagN2525::Serialize (TagBuffer i) const
{
	//we store timestamp first

	for(uint32_t j=0;j<max25;j++)
	{
		i.WriteU32(m_neighborid[j]);
	}
	i.WriteU32(m_nodeid);
}



void CustomMetaDataUnicastTagN2525::Deserialize (TagBuffer i)
{
	for(uint32_t j=0;j<max25;j++)
	{
		m_neighborid[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
}




void CustomMetaDataUnicastTagN2525::Print (std::ostream &os) const
{
  os << "Custom Data --- Node ";
}

uint32_t * CustomMetaDataUnicastTagN2525::Getneighborid()
{
	return m_neighborid;
}

void CustomMetaDataUnicastTagN2525::Setneighborid (uint32_t * neighborid)
{
	for (uint32_t i=0; i< max25;i++)
	{
		m_neighborid[i] = *(neighborid+i);
	}
}

uint32_t CustomMetaDataUnicastTagN2525::Getnodeid()
{
	return m_nodeid;
}
void CustomMetaDataUnicastTagN2525::Setnodeid(uint32_t nodeid)
{
	m_nodeid = nodeid;
}

class CustomMetaDataDownlinkUnicastTag : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	uint32_t GetNodeId();
	bool GetZ();
	bool GetX();


	void SetNodeId (uint32_t node_id);
	void SetX (bool x);
	void SetZ (bool z);

	CustomMetaDataDownlinkUnicastTag();
	CustomMetaDataDownlinkUnicastTag(uint32_t node_id);
	virtual ~CustomMetaDataDownlinkUnicastTag();
private:

	uint32_t m_nodeId;
	uint8_t m_x;
	uint8_t m_z;
};


//NS_LOG_COMPONENT_DEFINE("CustomMetaDataDownlinkUnicastTag");
NS_OBJECT_ENSURE_REGISTERED (CustomMetaDataDownlinkUnicastTag);

CustomMetaDataDownlinkUnicastTag::CustomMetaDataDownlinkUnicastTag() {
	m_nodeId = -1;
}
CustomMetaDataDownlinkUnicastTag::CustomMetaDataDownlinkUnicastTag(uint32_t node_id) {
	m_nodeId = node_id;
}

CustomMetaDataDownlinkUnicastTag::~CustomMetaDataDownlinkUnicastTag() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomMetaDataDownlinkUnicastTag::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomMetaDataDownlinkUnicastTag")
    .SetParent<Tag> ()
    .AddConstructor<CustomMetaDataDownlinkUnicastTag> ();
  return tid;
}
TypeId CustomMetaDataDownlinkUnicastTag::GetInstanceTypeId (void) const
{
  return CustomMetaDataDownlinkUnicastTag::GetTypeId ();
}

 

 
uint32_t CustomMetaDataDownlinkUnicastTag::GetSerializedSize (void) const
{
	return sizeof(uint32_t) + sizeof(uint8_t) + sizeof(uint8_t);
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomMetaDataDownlinkUnicastTag::Serialize (TagBuffer i) const
{
	i.WriteU8(m_x);
	i.WriteU8(m_z);
	i.WriteU32(m_nodeId);
}



void CustomMetaDataDownlinkUnicastTag::Deserialize (TagBuffer i)
{

	m_x = i.ReadU8();	
	m_z = i.ReadU8();
	m_nodeId = i.ReadU32();

}

void CustomMetaDataDownlinkUnicastTag::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" << m_nodeId <<  "\t";
}

//Your accessor and mutator functions 
uint32_t CustomMetaDataDownlinkUnicastTag::GetNodeId() {
	return m_nodeId;
}

void CustomMetaDataDownlinkUnicastTag::SetNodeId(uint32_t node_id) {
	m_nodeId = node_id;
}


bool CustomMetaDataDownlinkUnicastTag::GetX()
{ 
	return bool(m_x);
}

void CustomMetaDataDownlinkUnicastTag::SetX (bool x)
{
	m_x = uint8_t(x);
}

bool CustomMetaDataDownlinkUnicastTag::GetZ()
{ 
	return bool(m_z);
}

void CustomMetaDataDownlinkUnicastTag::SetZ (bool z)
{
	m_z = uint8_t(z);
}


class CustomDeltavaluesDownlinkUnicastTag : public Tag {
public:

	//Functions inherited from ns3::Tag that you have to implement. 
	static TypeId GetTypeId(void);
	virtual TypeId GetInstanceTypeId(void) const;
	virtual uint32_t GetSerializedSize(void) const;
	virtual void Serialize (TagBuffer i) const;
	virtual void Deserialize (TagBuffer i);
	virtual void Print (std::ostream & os) const;

	//These are custom accessor & mutator functions
	double (*Getdeltas())[total_size] ;
	uint32_t * Getsources();
	uint32_t * Getdestinations();
	uint32_t * Getflow_ids();
	uint32_t * Getflow_sizes();
	uint32_t Getnodeid();
	double * Getload();


	void Setdeltas (double (*deltas)[total_size]);
	void Setsources (uint32_t * sources);
	void Setdestinations (uint32_t * destinations);
	void Setflow_ids (uint32_t * flowids);
	void Setflow_sizes (uint32_t * flowsizes);
	void Setnodeid(uint32_t nodeid);
	void Setload (double * load);

	CustomDeltavaluesDownlinkUnicastTag();
	//CustomDeltavaluesDownlinkUnicastTag(uint32_t node_id);
	virtual ~CustomDeltavaluesDownlinkUnicastTag();
private:

	double m_deltas[2*flows][total_size];
 	uint32_t m_source_f[2*flows];
 	uint32_t m_destination_f[2*flows];
 	uint32_t m_flow_id[2*flows];
 	uint32_t m_flow_sizes[2*flows];
 	uint32_t m_nodeid;
 	double m_load[2*flows];
};


//NS_LOG_COMPONENT_DEFINE("CustomDeltavaluesDownlinkUnicastTag");
NS_OBJECT_ENSURE_REGISTERED (CustomDeltavaluesDownlinkUnicastTag);

CustomDeltavaluesDownlinkUnicastTag::CustomDeltavaluesDownlinkUnicastTag() {
	//m_nodeId = -1;
}
/*
CustomDeltavaluesDownlinkUnicastTag::CustomDeltavaluesDownlinkUnicastTag(uint32_t node_id) {
	m_nodeId = node_id;
}
*/

CustomDeltavaluesDownlinkUnicastTag::~CustomDeltavaluesDownlinkUnicastTag() {
}

//Almost all custom tags will have similar implementation of GetTypeId and GetInstanceTypeId
TypeId CustomDeltavaluesDownlinkUnicastTag::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::CustomDeltavaluesDownlinkUnicastTag")
    .SetParent<Tag> ()
    .AddConstructor<CustomDeltavaluesDownlinkUnicastTag> ();
  return tid;
}
TypeId CustomDeltavaluesDownlinkUnicastTag::GetInstanceTypeId (void) const
{
  return CustomDeltavaluesDownlinkUnicastTag::GetTypeId ();
}

 

 
uint32_t CustomDeltavaluesDownlinkUnicastTag::GetSerializedSize (void) const
{
	return ((((total_size*2*flows)+1)*sizeof(double)) + ((2*flows+1)*sizeof(uint32_t)) + ((2*flows+1)*sizeof(uint32_t)) + ((2*flows+1)*sizeof(uint32_t)) + ((2*flows+1)*sizeof(uint32_t))+ sizeof(uint32_t) + (((2*flows)+1)*sizeof(double)));
}

/*
  The order of how you do Serialize() should match the order of Deserialize()
 
*/
 

void CustomDeltavaluesDownlinkUnicastTag::Serialize (TagBuffer i) const
{
	for(uint32_t j=0;j<2*flows;j++)
	{
		for(uint32_t k=0;k<total_size;k++)
		{
			i.WriteDouble(m_deltas[j][k]);
		}
	}
	for(uint32_t j=0;j<2*flows;j++)
	{
		i.WriteU32(m_source_f[j]);
	}
	for(uint32_t j=0;j<2*flows;j++)
	{
		i.WriteU32(m_destination_f[j]);
	}
	for(uint32_t j=0;j<2*flows;j++)
	{
		i.WriteU32(m_flow_id[j]);
	}
	for(uint32_t j=0;j<2*flows;j++)
	{
		i.WriteU32(m_flow_sizes[j]);
	}
	i.WriteU32(m_nodeid);
	for(uint32_t j=0;j<2*flows;j++)
	{
		i.WriteDouble(m_load[j]);
	}

}



void CustomDeltavaluesDownlinkUnicastTag::Deserialize (TagBuffer i)
{
	
	for(uint32_t j=0;j<2*flows;j++)
	{
		for(uint32_t k=0;k<total_size;k++)
		{
			m_deltas[j][k] = i.ReadDouble();
		}
	}
	
	for(uint32_t j=0;j<2*flows;j++)
	{
		m_source_f[j] = i.ReadU32();
	}
	for(uint32_t j=0;j<2*flows;j++)
	{
		m_destination_f[j] = i.ReadU32();
	}
	for(uint32_t j=0;j<2*flows;j++)
	{
		m_flow_id[j] = i.ReadU32();
	}
	for(uint32_t j=0;j<2*flows;j++)
	{
		m_flow_sizes[j] = i.ReadU32();
	}
	m_nodeid = i.ReadU32();
	for(uint32_t j=0;j<2*flows;j++)
	{
		m_load[j] = i.ReadDouble();
	}
}


void CustomDeltavaluesDownlinkUnicastTag::Print (std::ostream &os) const
{
  os << "Custom Data --- Node :" <<  "\t";
}

//Your accessor and mutator functions 


double (*CustomDeltavaluesDownlinkUnicastTag::Getdeltas())[total_size]  {
	return m_deltas;
}

void CustomDeltavaluesDownlinkUnicastTag::Setdeltas(double (*deltas)[total_size]) {
    for (int i = 0; i < 2*flows; ++i) {
        for (int j = 0; j < total_size; ++j) {
            m_deltas[i][j] = deltas[i][j];
        }
    }
}




uint32_t * CustomDeltavaluesDownlinkUnicastTag::Getsources()
{ 
	return m_source_f;
}

void CustomDeltavaluesDownlinkUnicastTag::Setsources (uint32_t * sources)
{
	for (uint32_t i=0; i< 2*flows;i++)
	{
		m_source_f[i] = *(sources+i);
	}
}

uint32_t * CustomDeltavaluesDownlinkUnicastTag::Getdestinations()
{ 
	return m_destination_f;
}

void CustomDeltavaluesDownlinkUnicastTag::Setdestinations (uint32_t * destinations)
{	
	for (uint32_t i=0; i< 2*flows;i++)
	{
		m_destination_f[i] = *(destinations+i);
	}
}

uint32_t * CustomDeltavaluesDownlinkUnicastTag::Getflow_ids()
{ 
	return m_flow_id;
}

void CustomDeltavaluesDownlinkUnicastTag::Setflow_ids (uint32_t * flowids)
{
	for (uint32_t i=0; i< 2*flows;i++)
	{
		m_flow_id[i] = *(flowids+i);
	}
}

uint32_t * CustomDeltavaluesDownlinkUnicastTag::Getflow_sizes()
{ 
	return m_flow_sizes;
}

void CustomDeltavaluesDownlinkUnicastTag::Setflow_sizes (uint32_t * flowsizes)
{
	for (uint32_t i=0; i< 2*flows;i++)
	{
		m_flow_sizes[i] = *(flowsizes+i);
	}
}

uint32_t CustomDeltavaluesDownlinkUnicastTag::Getnodeid()
{ 
	return m_nodeid;
}

void CustomDeltavaluesDownlinkUnicastTag::Setnodeid (uint32_t nodeid)
{
	m_nodeid = nodeid;
	
}

double * CustomDeltavaluesDownlinkUnicastTag::Getload()
{ 
	return m_load;
}

void CustomDeltavaluesDownlinkUnicastTag::Setload (double * load)
{
	for (uint32_t i=0; i< 2*flows;i++)
	{
		m_load[i] = *(load+i);
	}
}



#ifndef NS3_UDP_ARQ_APPLICATION_H
#define NS3_UDP_ARQ_APPLICATION_H


double dsrc_utilization_time = 0.0;
double lte_utilization_time = 0.0;
double ethernet_utilization_time = 0.0;
double packet_delay[total_size+2];
double packet_delay_dsrc[total_size+2];

double dsrc_packet_initial_timestamp[total_size+2];
double packet_initial_timestamp[total_size+2];
double dsrc_initial_timestamp;
double lte_initial_timestamp;
double ethernet_initial_timestamp;
double aodv_initial_timestamp[total_size+2];

double dsrc_packet_final_timestamp[total_size+2];
double packet_final_timestamp[total_size+2];
double dsrc_final_timestamp;
double dsrc_total_received_packets = 0.0;
double lte_final_timestamp;
double ethernet_final_timestamp;
double aodv_final_timestamp[total_size+2];

double max_distance[total_size+2];

struct Q_fi
{
	double Q_values[total_size];
};

struct Q_f
{
 	struct Q_fi Q_fi_inst[total_size];
 	uint32_t source_f;
 	uint32_t destination_f;
 	uint32_t flow_id;
};

struct Q_f Q_at_controller_inst[2*flows];


struct L_fi
{
	double L_values[total_size];
};

struct L_f
{
 	struct L_fi L_fi_inst[total_size];
 	uint32_t source_f;
 	uint32_t destination_f;
 	uint32_t flow_id;
};

struct L_f L_at_controller_inst[2*flows];


struct W_fi
{
	double W_values[total_size];
};

struct W_f
{
 	struct W_fi W_fi_inst[total_size];
 	uint32_t source_f;
 	uint32_t destination_f;
 	uint32_t flow_id;
};

struct W_f W_at_controller_inst[2*flows];



struct Omega_fi
{
	double Omega_values[total_size];
};

struct Omega_f
{
 	struct Omega_fi Omega_fi_inst[total_size];
 	uint32_t source_f;
 	uint32_t destination_f;
 	uint32_t flow_id;
};

struct Omega_f Omega_at_controller_inst[2*flows];


struct Theta_fi
{
	double Theta_values[total_size];
};

struct Theta_f
{
 	struct Theta_fi Theta_fi_inst[total_size];
 	uint32_t source_f;
 	uint32_t destination_f;
 	uint32_t flow_id;
};

struct Theta_f Theta_at_controller_inst[2*flows];


struct T_fi
{
	double T_values[total_size];
};

struct T_f
{
 	struct T_fi T_fi_inst[total_size];
 	uint32_t source_f;
 	uint32_t destination_f;
 	uint32_t flow_id;
};

struct T_f T_at_controller_inst[2*flows];


struct t_fi
{
	double t_values[total_size];
};

struct t_f
{
 	struct t_fi t_fi_inst[total_size];
 	uint32_t source_f;
 	uint32_t destination_f;
 	uint32_t flow_id;
};

struct t_f t_at_controller_inst[2*flows];

struct U_fi
{
	double U_values[total_size];
};

struct U_f
{
 	struct U_fi U_fi_inst[total_size];
 	uint32_t source_f;
 	uint32_t destination_f;
 	uint32_t flow_id;
};

struct U_f U_at_controller_inst[2*flows];


struct Y_fi
{
	double Y_values[total_size];
};

struct Y_f
{
 	struct Y_fi Y_fi_inst[total_size];
 	uint32_t source_f;
 	uint32_t destination_f;
 	uint32_t flow_id;
};

struct Y_f Y_at_controller_inst[2*flows];

struct delta_fi
{
	double delta_values[total_size];
};

struct delta_f
{
 	struct delta_fi delta_fi_inst[total_size];
 	uint32_t source_f;
 	uint32_t destination_f;
 	uint32_t flow_id;
};

struct delta_f delta_at_controller_inst[2*flows];
struct delta_f delta_at_nodes_inst[2*flows];


struct load_f
{
	double load_f[total_size];
};

struct load_f load_at_nodes[2*flows];


void clear_delta_at_controller(struct delta_f * nd1)
{
	for(uint32_t i=0; i<2*flows;i++)
	{
		(nd1+i)->source_f = 0;
		(nd1+i)->destination_f = 0;
		(nd1+i)->flow_id = 0;
		for(uint32_t j=0;j<total_size;j++)
		{
			for(uint32_t k=0;k<total_size;k++)
			{
				(nd1+i)->delta_fi_inst[j].delta_values[k] = 0.0;
			}
		}
	}
	cout<<"Solution at controller cleared"<<endl;
}

void clear_delta_at_nodes(struct delta_f * nd1)
{
	for(uint32_t i=0; i<2*flows;i++)
	{
		(nd1+i)->source_f = 0;
		(nd1+i)->destination_f = 0;
		(nd1+i)->flow_id = 0;
		for(uint32_t j=0;j<total_size;j++)
		{
			for(uint32_t k=0;k<total_size;k++)
			{
				(nd1+i)->delta_fi_inst[j].delta_values[k] = 0.0;
			}
		}
	}
	cout<<"Solution at nodes cleared at "<<Now().GetSeconds()<<endl;
}

struct demanding_flow_struct_nodes
{
	uint32_t source;
	uint32_t destination;
	uint32_t f_size;
	uint32_t p_size;
	uint32_t qos;
};

struct demanding_flow_struct_controller
{
	uint32_t source;
	uint32_t destination;
	uint32_t f_size;
	uint32_t p_size;
	uint32_t qos;
};

struct controller_data
{
	uint32_t B;
	uint32_t neighborsize;
	//double frequency;
	//uint32_t datasize;
	uint32_t neighborid[max];
	double lastupdated;
	//uint32_t combined_cost[max];
};


struct routing_data_at_nodes
{
	Vector acceleration;
	Vector velocity;
	Vector position;
	uint32_t nodeid;
};

struct routing_data_at_controller
{
	Vector acceleration;
	Vector velocity;
	Vector position;
	uint32_t nodeid;
};


struct neighbor_data
{
	uint32_t neighborid[max];
	//uint32_t combined_cost[max];
	Time timestamp[max];
};

struct set_of_neighbors
{
	uint32_t neighbors[max];
};

struct data_at_nodes
{
	Time timestamp[max];
	Vector acceleration[max];
	Vector velocity[max];
	Vector position[max];
	uint32_t nodeid[max];
	struct set_of_neighbors neighbor_set[max];
	bool neighbors_changed[max];
};

struct data_at_manager
{
	Time timestamp;
	Vector acceleration;
	Vector velocity;
	Vector position;
	uint32_t nodeid;
};

struct demanding_flow_struct_nodes demanding_flow_struct_nodes_inst[2*flows];
struct demanding_flow_struct_controller demanding_flow_struct_controller_inst[2*flows];

struct routing_data_at_nodes routing_data_at_nodes_inst[total_size];
struct routing_data_at_controller routing_data_at_controller_inst[total_size];


struct data_at_nodes data_at_nodes_inst[total_size+2];
struct data_at_manager data_at_manager_inst[total_size+2];

void print_management_data()
{
	for(uint32_t i=0;i<total_size+2;i++)
	{
		cout<<"i ="<<i<<"node id "<<(data_at_manager_inst+i)->nodeid<<"acceleration "<<(data_at_manager_inst+i)->acceleration<<"velocity "<<(data_at_manager_inst+i)->velocity<<"position "<<(data_at_manager_inst+i)->position<<"timestamp "<<(data_at_manager_inst+i)->timestamp<<endl;
	}
}

void clear_routing_data_at_nodes(struct routing_data_at_nodes * nd1)
{
	nd1->acceleration = Vector(0,0,0);
	nd1->velocity = Vector(0,0,0);
	nd1->position = Vector(0,0,0);
	nd1->nodeid = large;
}

void clear_data_at_nodes(struct data_at_nodes * nd1)
{
	for(uint32_t i=0; i<max;i++)
	{
		nd1->timestamp[i] = Simulator::Now();
		nd1->acceleration[i] = Vector(0,0,0);
		nd1->velocity[i] = Vector(0,0,0);
		nd1->position[i] = Vector(0,0,0);
		nd1->nodeid[i] = large;
		for(uint32_t j=0;j<max;j++)
		{
			nd1->neighbor_set[i].neighbors[j] = large;
		}
		nd1->neighbors_changed[i] = false;
	}
}

Vector previous_velocity_dsrc[total_size];

Vector calculate_acceleration (Vector initial_vel, Vector final_vel, double time)
{
	double ax = (final_vel.x - initial_vel.x)/time;
	double ay = (final_vel.y - initial_vel.y)/time;
	double az = (final_vel.z - initial_vel.z)/time;
	Vector acceleration;
	acceleration.x = ax;
	acceleration.y = ay;
	acceleration.z = az;
	return acceleration;
}

void update_previous_velocity(Ptr <NetDevice> nd, Ptr <Node> node)
{
	
	Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (nd);
	Ptr <Node> ni = DynamicCast <Node> (node);
	//CustomDataTag tag;
	uint32_t nid = uint32_t(ni->GetId()) - 2;
	//packet_initial_timestamp[nid] = Simulator::Now().GetSeconds();
	//cout<<"updating data from node "<<nid<<endl;
	Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (node->GetObject<MobilityModel>());
	Vector current_velocity = mdl->GetVelocity();
	previous_velocity_dsrc[nid] = current_velocity;
	//cout<<"updating velocity of node "<<nid<<"as "<<previous_velocity_dsrc[nid]<<"at time "<<Now().GetSeconds()<<endl;
}

void add_routing_data_at_nodes(struct routing_data_at_nodes * nd1, Ptr <NetDevice> nd, Ptr <Node> node)
{	
	//routing_time = false;
	//uint32_t nid = node->GetId();
	//Mac48Address dest = Mac48Address::GetBroadcast();
  	//uint16_t protocolwave = 0x88dc;//ethertype for WAVE is set here.
	Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (nd);
	Ptr <Node> ni = DynamicCast <Node> (node);
	//CustomDataTag tag;
	uint32_t nid = uint32_t(ni->GetId()) - 2;
	//packet_initial_timestamp[nid] = Simulator::Now().GetSeconds();
	//cout<<"updating data from node "<<nid<<endl;
	Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (node->GetObject<MobilityModel>());
	Vector posi = mdl->GetPosition();
	Vector current_velocity = mdl->GetVelocity();
	double delta_t = 0.000200;
	
	Vector acceleration;
	acceleration = calculate_acceleration(previous_velocity_dsrc[nid],current_velocity,delta_t);
	//cout<<"calculating acceleration for nid "<<nid<<"with previous velocity "<<previous_velocity_dsrc[nid]<<"current velocity "<<current_velocity<<" is "<<acceleration<<endl;
	
	//Ptr <Packet> packet_i = Create<Packet> (0);
	//tag.SetNodeId(nid);
	/*
	tag.SetPosition(posi);
	tag.SetVelocity(current_velocity);
	tag.SetAcceleration(acceleration);
	tag.SetTimestamp(ti);
	packet_i->AddPacketTag(tag);
	dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
	//Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);	
	cout<<"dsrc total size is "<<dsrc_total_packet_size<<endl;
	*/
	//previous_velocity_dsrc[nid] = current_velocity;
	
	nd1->acceleration = acceleration;
	nd1->velocity = current_velocity;
	nd1->position = posi;
	nd1->nodeid = nid;
	//cout<<"updating data from node "<<nid<< "updated as acceleration"<<nd1->acceleration<<"velocity: "<<nd1->velocity<< "position"<<nd1->position<<endl;
}


void add_demanding_flow_struct_nodes(struct demanding_flow_struct_nodes * nd1, uint32_t source, uint32_t destination, uint32_t x, uint32_t z, uint32_t q)
{	

	nd1->source = source;
	nd1->destination = destination;
	nd1->f_size = x;
	nd1->p_size = z;
	nd1->qos = q;
	//cout<<"updating flow with source as: "<<nd1->source<<"destination: "<<nd1->destination<<endl;
}	


void refresh_data_at_nodes(struct data_at_nodes * nd1)//If data is old, remove them
{
	for(uint32_t i=0; i<max;i++)
	{
		double elapsed_time = Simulator::Now().GetSeconds() - nd1->timestamp[i].GetSeconds();
		if(elapsed_time > (2.0*data_transmission_period))
		{
			nd1->timestamp[i] = Simulator::Now();
			nd1->acceleration[i] = Vector(0,0,0);
			nd1->velocity[i] = Vector(0,0,0);
			nd1->position[i] = Vector(0,0,0);
			nd1->nodeid[i] = large;
			for(uint32_t j=0;j<max;j++)
			{	
				if((nd1->neighbor_set[i].neighbors[j]) != large)//If existing neighbor data is deleted, set neighbor changed to true.
				{
					nd1->neighbors_changed[i] = true;
				}
				nd1->neighbor_set[i].neighbors[j] = large;
			}
		}
	}
}

// ============================================================================
// WORMHOLE ATTACK IMPLEMENTATION (INLINE)
// ============================================================================

namespace {

void WormholeVerificationReceive(Ptr<Socket> socket) {
    Ptr<Packet> packet;
    Address from;
    while ((packet = socket->RecvFrom(from))) {
        // Consume packet; statistics handled elsewhere.
    }
}

void ScheduleWormholeVerificationSend(Ptr<Socket> socket,
                                      uint32_t packetSize,
                                      Time interval,
                                      Time stopTime) {
    if (Simulator::Now() >= stopTime) {
        return;
    }
    Ptr<Packet> packet = Create<Packet>(packetSize);
    socket->Send(packet);
    Simulator::Schedule(interval, &ScheduleWormholeVerificationSend,
                        socket, packetSize, interval, stopTime);
}

} // anonymous namespace

namespace ns3 {

// WormholeEndpointApp Implementation
NS_OBJECT_ENSURE_REGISTERED(WormholeEndpointApp);

TypeId WormholeEndpointApp::GetTypeId(void) {
    static TypeId tid = TypeId("ns3::WormholeEndpointApp")
        .SetParent<Application>()
        .SetGroupName("Applications")
        .AddConstructor<WormholeEndpointApp>();
    return tid;
}

WormholeEndpointApp::WormholeEndpointApp()
    : m_peer(nullptr),
      m_peerAddress(Ipv4Address::GetZero()),
      m_tunnelSocket(nullptr),
      m_tunnelId(0),
      m_dropPackets(false),
      m_tunnelRoutingPackets(true),
      m_tunnelDataPackets(true)
{
}

WormholeEndpointApp::~WormholeEndpointApp() {
}

void WormholeEndpointApp::SetPeer(Ptr<Node> peer, Ipv4Address peerAddress) {
    m_peer = peer;
    m_peerAddress = peerAddress;
}

void WormholeEndpointApp::SetTunnelId(uint32_t id) {
    m_tunnelId = id;
}

void WormholeEndpointApp::SetDropPackets(bool drop) {
    m_dropPackets = drop;
}

void WormholeEndpointApp::SetSelectiveTunneling(bool routing, bool data) {
    m_tunnelRoutingPackets = routing;
    m_tunnelDataPackets = data;
}

void WormholeEndpointApp::StartApplication(void) {
    std::cout << "\n=== WORMHOLE ATTACK STARTING on Node " << GetNode()->GetId() 
              << " (Tunnel " << m_tunnelId << ") ===" << std::endl;
    std::cout << "Attack Type: AODV Route Poisoning (WAVE-compatible)" << std::endl;
    std::cout << "Peer Node: " << m_peer->GetId() << " @ " << m_peerAddress << std::endl;
    
    if (m_peerAddress != Ipv4Address::GetZero()) {
        TypeId tid = TypeId::LookupByName("ns3::UdpSocketFactory");
        m_tunnelSocket = Socket::CreateSocket(GetNode(), tid);
        InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 9999);
        if (m_tunnelSocket->Bind(local) < 0) {
            std::cerr << "ERROR: Failed to bind tunnel socket on node " << GetNode()->GetId() << std::endl;
        }
        m_tunnelSocket->SetRecvCallback(MakeCallback(&WormholeEndpointApp::HandleTunneledPacket, this));
        std::cout << " Tunnel socket created and bound to port 9999" << std::endl;
    }
    
    Ptr<Ipv4> ipv4 = GetNode()->GetObject<Ipv4>();
    if (!ipv4) {
        std::cerr << "ERROR: No IPv4 on node " << GetNode()->GetId() << std::endl;
        return;
    }
    
    m_aodvSocket = Socket::CreateSocket(GetNode(), TypeId::LookupByName("ns3::UdpSocketFactory"));
    if (m_aodvSocket->Bind() < 0) {
        std::cerr << "ERROR: Failed to bind AODV injection socket on node "
                  << GetNode()->GetId() << std::endl;
    }
    m_aodvSocket->SetAllowBroadcast(true);

    std::cout << " AODV socket ready for broadcasting fake RREPs" << std::endl;
    
    // Install promiscuous mode to intercept packets attracted by fake routes
    std::cout << "Installing packet interception on " << GetNode()->GetNDevices() << " devices..." << std::endl;
    for (uint32_t i = 0; i < GetNode()->GetNDevices(); ++i) {
        Ptr<NetDevice> device = GetNode()->GetDevice(i);
        if (device) {
            // Set promiscuous callback to intercept ALL packets
            device->SetPromiscReceiveCallback(
                MakeCallback(&WormholeEndpointApp::InterceptPacket, this));
            std::cout << "   Interception enabled on device " << i << std::endl;
        }
    }
    
    // Send IMMEDIATE test broadcast to verify it works
    std::cout << "Sending immediate test broadcast..." << std::endl;
    BroadcastFakeRREP();
    
    // Schedule periodic broadcasts
    double broadcastInterval = 2.0; // Broadcast every 2 seconds
    Simulator::Schedule(Seconds(broadcastInterval), &WormholeEndpointApp::PeriodicBroadcast, this);
    
    std::cout << " Fake RREP broadcast scheduled (interval: " << broadcastInterval << "s)" << std::endl;
    std::cout << "=== Wormhole attack ACTIVE on node " << GetNode()->GetId() << " ===" << std::endl << std::endl;
}

void WormholeEndpointApp::StopApplication(void) {
    std::cout << "\n=== WORMHOLE STOPPING on Node " << GetNode()->GetId() << " ===" << std::endl;
    std::cout << "Final Stats - Intercepted: " << m_stats.packetsIntercepted 
              << ", Tunneled: " << m_stats.packetsTunneled << std::endl;
    
    if (m_tunnelSocket) {
        m_tunnelSocket->Close();
        m_tunnelSocket = nullptr;
    }
    if (m_aodvSocket) {
        m_aodvSocket->Close();
        m_aodvSocket = nullptr;
    }
}

bool WormholeEndpointApp::ReceivePacket(Ptr<NetDevice> device,
                                        Ptr<const Packet> packet,
                                        uint16_t protocol, 
                                        const Address &from,
                                        const Address &to,
                                        NetDevice::PacketType packetType) {
    // Debug: Count all packets received (only first 50 to avoid spam)
    static int totalPackets = 0;
    totalPackets++;
    if (totalPackets <= 50) {
        std::cout << "[WORMHOLE-DEBUG] Node " << GetNode()->GetId()
                  << " callback #" << totalPackets
                  << ": protocol=0x" << std::hex << protocol << std::dec
                  << " size=" << packet->GetSize()
                  << " type=" << (int)packetType << std::endl;
    }
    
    // Only process IPv4 packets
    if (protocol != 0x0800) {
        return false;
    }    Ptr<Packet> copy = packet->Copy();
    Ipv4Header ipHeader;
    
    if (copy->GetSize() < 20) {
        return false;
    }
    
    copy->RemoveHeader(ipHeader);
    
    // Only process UDP packets
    if (ipHeader.GetProtocol() != 17) {
        return false;
    }
    
    UdpHeader udpHeader;
    if (copy->GetSize() < 8) {
        return false;
    }
    
    copy->RemoveHeader(udpHeader);
    
    // Debug: Log all UDP packets to see if AODV port 654 is being used
    static int udpCount = 0;
    udpCount++;
    if (udpCount <= 30) {
        std::cout << "[WORMHOLE-DEBUG] Node " << GetNode()->GetId()
                  << " UDP #" << udpCount
                  << ": src=" << udpHeader.GetSourcePort()
                  << " dst=" << udpHeader.GetDestinationPort()
                  << " size=" << copy->GetSize() << std::endl;
    }
    
    // Only process AODV packets (port 654)
    if (udpHeader.GetDestinationPort() != 654) {
        return false;
    }
    
    if (copy->GetSize() == 0) {
        return false;
    }
    
    uint8_t buffer[1500];
    uint32_t payloadSize = (copy->GetSize() < sizeof(buffer)) ? copy->GetSize() : sizeof(buffer);
    copy->CopyData(buffer, payloadSize);
    uint8_t msgType = buffer[0];
    Ipv4Address sourceAddr = ipHeader.GetSource();
    
    // Don't intercept our own packets
    Ptr<Ipv4> ipv4 = GetNode()->GetObject<Ipv4>();
    if (ipv4) {
        for (uint32_t i = 0; i < ipv4->GetNInterfaces(); ++i) {
            for (uint32_t j = 0; j < ipv4->GetNAddresses(i); ++j) {
                if (ipv4->GetAddress(i, j).GetLocal() == sourceAddr) {
                    return false; // Our own packet, don't intercept
                }
            }
        }
    }
    
    m_stats.routingPacketsAffected++;
    
    std::cout << "[WORMHOLE-DEBUG] Node " << GetNode()->GetId()
              << " Processing AODV packet: msgType=" << (int)msgType
              << " from " << sourceAddr << std::endl;
    
    if (msgType == 1) {  // RREQ intercepted
        // Extract RREQ originator address (bytes 5-8 in AODV RREQ format)
        if (payloadSize < 9) {
            std::cout << "[WORMHOLE-DEBUG] RREQ too small, ignoring" << std::endl;
            return false;
        }
        
        uint32_t originatorIp;
        memcpy(&originatorIp, &buffer[5], 4);
        Ipv4Address originator(originatorIp);
        
        m_stats.packetsIntercepted++;
        std::cout << "[WORMHOLE] Node " << GetNode()->GetId()
                  << " intercepted AODV RREQ from originator " << originator
                  << " (forwarded by " << sourceAddr << ")"
                  << " (Total intercepted: " << m_stats.packetsIntercepted << ")" << std::endl;
        
        // Send fake RREP to the originator
        SendFakeRREP(originator);
        
        // Tunnel the RREQ to peer
        if (m_tunnelSocket && m_peerAddress != Ipv4Address::GetZero()) {
            Ptr<Packet> forwardCopy = packet->Copy();
            m_tunnelSocket->SendTo(forwardCopy, 0, InetSocketAddress(m_peerAddress, 9999));
            m_stats.packetsTunneled++;
            std::cout << "[WORMHOLE] Node " << GetNode()->GetId()
                      << " tunneled RREQ to peer " << m_peer->GetId()
                      << " (Total tunneled: " << m_stats.packetsTunneled << ")" << std::endl;
        }
        
        // DROP the packet if configured, otherwise let it continue
        if (m_dropPackets) {
            m_stats.packetsDropped++;
            std::cout << "[WORMHOLE] Node " << GetNode()->GetId()
                      << " DROPPED RREQ (Total dropped: " << m_stats.packetsDropped << ")" << std::endl;
            return true; // Consume packet (drop it)
        } else {
            return false; // Let packet continue (observe-only mode)
        }
    } else if (msgType == 2) {
        // RREP - just observe, don't intercept
        std::cout << "[WORMHOLE] Node " << GetNode()->GetId()
                  << " observed AODV RREP from " << sourceAddr << std::endl;
        return false; // Let RREP continue normally
    }
    
    return false; // Let other packets continue
}

void WormholeEndpointApp::SendFakeRREP(Ipv4Address requester) {
    uint8_t fakeRREP[32];
    memset(fakeRREP, 0, sizeof(fakeRREP));
    fakeRREP[0] = 2;  // RREP type
    fakeRREP[4] = 1;  // Hop count = 1
    uint32_t peerIp = m_peerAddress.Get();
    memcpy(&fakeRREP[5], &peerIp, 4);
    uint32_t reqIp = requester.Get();
    memcpy(&fakeRREP[13], &reqIp, 4);
    uint32_t lifetime = 10000;
    memcpy(&fakeRREP[17], &lifetime, 4);
    Ptr<Packet> replyPacket = Create<Packet>(fakeRREP, 24);
    if (m_aodvSocket) {
        m_aodvSocket->SendTo(replyPacket, 0, InetSocketAddress(requester, 654));
    }
}

void WormholeEndpointApp::SendFakeRouteAdvertisement() {
    if (!m_peer || m_peerAddress == Ipv4Address::GetZero()) return;
    std::cout << "Node " << GetNode()->GetId() << " advertising fake route to " 
              << m_peerAddress << " (peer node " << m_peer->GetId() << ")" << std::endl;
    Ptr<Ipv4> ipv4 = GetNode()->GetObject<Ipv4>();
    if (!ipv4) return;
    uint8_t fakeRREP[32];
    memset(fakeRREP, 0, sizeof(fakeRREP));
    fakeRREP[0] = 2;  // RREP
    fakeRREP[4] = 1;  // Hop count = 1
    uint32_t peerIp = m_peerAddress.Get();
    memcpy(&fakeRREP[5], &peerIp, 4);
    Ptr<Packet> advPacket = Create<Packet>(fakeRREP, 24);
    if (m_aodvSocket) {
        m_aodvSocket->SendTo(advPacket, 0, 
            InetSocketAddress(Ipv4Address("255.255.255.255"), 654));
    }
    m_stats.routingPacketsAffected++;
}

void WormholeEndpointApp::BroadcastFakeRREP() {
    if (!m_peer) {
        std::cerr << "[WORMHOLE-ERROR] Node " << GetNode()->GetId() << " has no peer!" << std::endl;
        return;
    }
    
    if (m_peerAddress == Ipv4Address::GetZero()) {
        std::cerr << "[WORMHOLE-ERROR] Node " << GetNode()->GetId() << " peer address is 0.0.0.0!" << std::endl;
        return;
    }
    
    if (!m_aodvSocket) {
        std::cerr << "[WORMHOLE-ERROR] Node " << GetNode()->GetId() << " AODV socket is NULL!" << std::endl;
        return;
    }
    
    m_stats.packetsIntercepted++; // Count broadcasts as "interceptions"
    
    std::cout << "[WORMHOLE] Node " << GetNode()->GetId() 
              << " broadcasting fake RREP for peer " << m_peer->GetId()
              << " @ " << m_peerAddress 
              << " (Broadcast #" << m_stats.packetsIntercepted << ")" << std::endl;
    
    // Create AODV RREP packet advertising 1-hop route to peer
    uint8_t fakeRREP[24];
    memset(fakeRREP, 0, sizeof(fakeRREP));
    fakeRREP[0] = 2;   // Type: RREP
    fakeRREP[1] = 0;   // Flags
    fakeRREP[2] = 0;   // Prefix size
    fakeRREP[3] = 0;   // Reserved
    fakeRREP[4] = 1;   // Hop count = 1 (fake short path!)
    
    // Destination IP (bytes 5-8): our peer's address
    uint32_t peerIp = m_peerAddress.Get();
    memcpy(&fakeRREP[5], &peerIp, 4);
    
    // Destination sequence number (bytes 9-12): high value to look fresh
    uint32_t destSeq = 999999;
    memcpy(&fakeRREP[9], &destSeq, 4);
    
    // Originator IP (bytes 13-16): broadcast to all
    uint32_t originIp = Ipv4Address("0.0.0.0").Get();
    memcpy(&fakeRREP[13], &originIp, 4);
    
    // Lifetime (bytes 17-20): long lifetime
    uint32_t lifetime = 10000;
    memcpy(&fakeRREP[17], &lifetime, 4);
    
    Ptr<Packet> replyPacket = Create<Packet>(fakeRREP, 24);
    
    // Broadcast to all nodes on AODV port
    int sent = m_aodvSocket->SendTo(replyPacket, 0, InetSocketAddress(Ipv4Address("255.255.255.255"), 654));
    
    if (sent < 0) {
        std::cerr << "[WORMHOLE-ERROR] Failed to send broadcast! Error code: " << sent << std::endl;
    } else {
        m_stats.routingPacketsAffected++;
        std::cout << "[WORMHOLE] Fake RREP broadcast sent successfully (" << sent << " bytes)" << std::endl;
    }
}

void WormholeEndpointApp::PeriodicBroadcast() {
    BroadcastFakeRREP();
    Simulator::Schedule(Seconds(2.0), &WormholeEndpointApp::PeriodicBroadcast, this);
}

bool WormholeEndpointApp::InterceptPacket(Ptr<NetDevice> device,
                                          Ptr<const Packet> packet,
                                          uint16_t protocol,
                                          const Address &from,
                                          const Address &to,
                                          NetDevice::PacketType packetType) {
    // Only intercept IPv4 packets
    if (protocol != 0x0800) {
        return false; // Not IPv4, let it through
    }
    
    // Don't intercept packets on the tunnel interface (P2P link to peer)
    if (device && device->IsPointToPoint()) {
        return false; // This is tunnel traffic, let it through
    }
    
    Ptr<Packet> copy = packet->Copy();
    if (copy->GetSize() < 20) {
        return false;
    }
    
    Ipv4Header ipHeader;
    copy->RemoveHeader(ipHeader);
    
    Ipv4Address srcAddr = ipHeader.GetSource();
    Ipv4Address dstAddr = ipHeader.GetDestination();
    
    // Don't intercept packets we originated
    Ptr<Ipv4> ipv4 = GetNode()->GetObject<Ipv4>();
    if (ipv4) {
        for (uint32_t i = 0; i < ipv4->GetNInterfaces(); ++i) {
            for (uint32_t j = 0; j < ipv4->GetNAddresses(i); ++j) {
                if (ipv4->GetAddress(i, j).GetLocal() == srcAddr) {
                    return false; // Our own packet
                }
            }
        }
    }
    
    // Check if packet is destined for our peer (or going through us to reach peer)
    // This means the fake route is working!
    bool shouldTunnel = false;
    
    // Tunnel if destination is near our peer's subnet
    if (m_peerAddress != Ipv4Address::GetZero()) {
        // Simple heuristic: if packet is not for us, tunnel it to peer
        // The fake RREP makes nodes think we're the best path
        shouldTunnel = true;
        
        // But don't tunnel AODV routing packets
        if (ipHeader.GetProtocol() == 17) { // UDP
            UdpHeader udpHeader;
            if (copy->GetSize() >= 8) {
                copy->PeekHeader(udpHeader);
                if (udpHeader.GetDestinationPort() == 654) {
                    shouldTunnel = false; // Don't tunnel AODV
                }
            }
        }
    }
    
    if (shouldTunnel) {
        m_stats.packetsIntercepted++;
        m_stats.dataPacketsAffected++;
        
        if (m_stats.packetsIntercepted <= 10) {
            std::cout << "[WORMHOLE] Node " << GetNode()->GetId()
                      << " intercepted packet: " << srcAddr << " -> " << dstAddr
                      << " (Intercept #" << m_stats.packetsIntercepted << ")" << std::endl;
        }
        
        // Tunnel the packet to peer
        if (m_tunnelSocket && m_peerAddress != Ipv4Address::GetZero()) {
            Ptr<Packet> tunnelCopy = packet->Copy();
            int sent = m_tunnelSocket->SendTo(tunnelCopy, 0, InetSocketAddress(m_peerAddress, 9999));
            
            if (sent > 0) {
                m_stats.packetsTunneled++;
                if (m_stats.packetsTunneled <= 10) {
                    std::cout << "[WORMHOLE] Node " << GetNode()->GetId()
                              << " tunneled packet to peer (Tunnel #" << m_stats.packetsTunneled << ")" << std::endl;
                }
            }
        }
        
        // Drop the packet (don't let it route normally)
        if (m_dropPackets) {
            m_stats.packetsDropped++;
            return true; // Consume packet
        }
    }
    
    return false; // Let packet continue normally
}

void WormholeEndpointApp::PeriodicAttack() {
    SendFakeRouteAdvertisement();
    Simulator::Schedule(Seconds(0.5), &WormholeEndpointApp::PeriodicAttack, this);
}

void WormholeEndpointApp::HandleTunneledPacket(Ptr<Socket> socket) {
    Ptr<Packet> packet;
    Address from;
    while ((packet = socket->RecvFrom(from))) {
        m_stats.packetsTunneled++;
        
        if (m_stats.packetsTunneled <= 10) {
            std::cout << "[WORMHOLE] Node " << GetNode()->GetId() 
                      << " received tunneled packet from peer #" 
                      << m_stats.packetsTunneled << " - re-injecting into network" << std::endl;
        }
        
        // Re-inject the packet into the local network
        // This completes the wormhole: packet enters at one end, exits at the other
        Ptr<Ipv4> ipv4 = GetNode()->GetObject<Ipv4>();
        if (ipv4) {
            // Get the first non-loopback interface
            for (uint32_t i = 1; i < ipv4->GetNInterfaces(); ++i) {
                Ptr<NetDevice> device = ipv4->GetNetDevice(i);
                if (device && !device->IsPointToPoint()) {
                    // Send the packet out on this interface
                    // This makes it appear as if the packet originated from this node
                    Mac48Address dest = Mac48Address::GetBroadcast();
                    device->Send(packet, dest, 0x0800); // 0x0800 = IPv4
                    
                    if (m_stats.packetsTunneled <= 10) {
                        std::cout << "[WORMHOLE] Packet re-injected on interface " << i << std::endl;
                    }
                    break;
                }
            }
        }
    }
}

bool WormholeEndpointApp::ShouldTunnelPacket(Ptr<const Packet> packet,
                                              uint16_t protocol) {
    bool tunnelByDefault = (m_tunnelRoutingPackets && m_tunnelDataPackets);
    if (protocol == 0x0800) {
        Ptr<Packet> copy = packet->Copy();
        if (copy->GetSize() < 20) return tunnelByDefault;
        Ipv4Header ipHeader;
        uint32_t bytesRead = copy->RemoveHeader(ipHeader);
        if (bytesRead == 0) return tunnelByDefault;
        uint8_t ipProtocol = ipHeader.GetProtocol();
        if (ipProtocol == 17) {
            if (copy->GetSize() < 8) {
                m_stats.dataPacketsAffected++;
                return m_tunnelDataPackets;
            }
            UdpHeader udpHeader;
            uint32_t udpBytes = copy->PeekHeader(udpHeader);
            if (udpBytes == 0) {
                m_stats.dataPacketsAffected++;
                return m_tunnelDataPackets;
            }
            uint16_t port = udpHeader.GetDestinationPort();
            if (port == 654 || port == 520) {
                m_stats.routingPacketsAffected++;
                return m_tunnelRoutingPackets;
            } else {
                m_stats.dataPacketsAffected++;
                return m_tunnelDataPackets;
            }
        } else if (ipProtocol == 6) {
            m_stats.dataPacketsAffected++;
            return m_tunnelDataPackets;
        } else {
            m_stats.dataPacketsAffected++;
            return m_tunnelDataPackets;
        }
    }
    return tunnelByDefault;
}

void WormholeEndpointApp::TunnelPacket(Ptr<Packet> packet, uint16_t protocol) {
    if (!m_tunnelSocket) {
        m_stats.packetsDropped++;
        return;
    }
    Time startTime = Simulator::Now();
    int sent = m_tunnelSocket->Send(packet);
    if (sent > 0) {
        Time endTime = Simulator::Now();
        m_stats.totalTunnelingDelay += (endTime - startTime).GetSeconds();
    } else {
        m_stats.packetsDropped++;
    }
}

// WormholeAttackManager Implementation
WormholeAttackManager::WormholeAttackManager()
    : m_dropPackets(false),
      m_tunnelRoutingPackets(true),
      m_tunnelDataPackets(true),
      m_totalNodes(0),
      m_defaultBandwidth("1000Mbps"),
      m_defaultDelay(MicroSeconds(1)),
      m_enableVerificationTraffic(true),
      m_verificationFlowCount(3),
      m_verificationPacketRate(40.0),
      m_verificationPacketSize(512),
      m_verificationStartOffset(0.5),
      m_verificationBasePort(50000)
{
}

WormholeAttackManager::~WormholeAttackManager() {
    for (auto& socket : m_testSourceSockets) {
        if (socket) socket->Close();
    }
    m_testSourceSockets.clear();
    for (auto& socket : m_testSinkSockets) {
        if (socket) socket->Close();
    }
    m_testSinkSockets.clear();
}

void WormholeAttackManager::Initialize(std::vector<bool>& maliciousNodes, 
                                       double attackPercentage,
                                       uint32_t totalNodes) {
    m_totalNodes = totalNodes;
    m_maliciousNodes.resize(totalNodes, false);
    if (maliciousNodes.size() == totalNodes) {
        m_maliciousNodes = maliciousNodes;
    } else {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_real_distribution<> dis(0.0, 1.0);
        for (uint32_t i = 0; i < totalNodes; ++i) {
            m_maliciousNodes[i] = (dis(gen) < attackPercentage);
            maliciousNodes.push_back(m_maliciousNodes[i]);
        }
    }
}

void WormholeAttackManager::CreateWormholeTunnels(std::string tunnelBandwidth,
                                                  Time tunnelDelay,
                                                  bool selectRandom) {
    m_defaultBandwidth = tunnelBandwidth;
    m_defaultDelay = tunnelDelay;
    std::vector<uint32_t> maliciousNodeIds;
    for (uint32_t i = 0; i < m_maliciousNodes.size(); ++i) {
        if (m_maliciousNodes[i]) {
            maliciousNodeIds.push_back(i);
        }
    }
    if (maliciousNodeIds.size() < 2) return;
    if (selectRandom) {
        SelectRandomPairs(maliciousNodeIds);
    } else {
        SelectSequentialPairs(maliciousNodeIds);
    }
}

void WormholeAttackManager::SelectSequentialPairs(
    std::vector<uint32_t>& maliciousNodeIds) {
    for (size_t i = 0; i + 1 < maliciousNodeIds.size(); i += 2) {
        CreateWormholeTunnel(maliciousNodeIds[i], maliciousNodeIds[i+1],
                            m_defaultBandwidth, m_defaultDelay);
    }
}

void WormholeAttackManager::SelectRandomPairs(
    std::vector<uint32_t>& maliciousNodeIds) {
    std::random_device rd;
    std::mt19937 g(rd());
    std::shuffle(maliciousNodeIds.begin(), maliciousNodeIds.end(), g);
    SelectSequentialPairs(maliciousNodeIds);
}

uint32_t WormholeAttackManager::CreateWormholeTunnel(uint32_t nodeIdA, 
                                                     uint32_t nodeIdB,
                                                     std::string bandwidth,
                                                     Time delay) {
    WormholeTunnel tunnel;
    tunnel.nodeIdA = nodeIdA;
    tunnel.nodeIdB = nodeIdB;
    tunnel.endpointA = NodeList::GetNode(nodeIdA);
    tunnel.endpointB = NodeList::GetNode(nodeIdB);
    PointToPointHelper p2p;
    p2p.SetDeviceAttribute("DataRate", StringValue(bandwidth));
    p2p.SetChannelAttribute("Delay", TimeValue(delay));
    tunnel.tunnelDevices = p2p.Install(tunnel.endpointA, tunnel.endpointB);
    Ipv4AddressHelper address;
    std::ostringstream subnet;
    subnet << "100." << (m_tunnels.size() / 254) << "."
           << (m_tunnels.size() % 254) << ".0";
    address.SetBase(subnet.str().c_str(), "255.255.255.0");
    tunnel.tunnelInterfaces = address.Assign(tunnel.tunnelDevices);
    tunnel.isActive = false;
    uint32_t tunnelId = m_tunnels.size();
    m_tunnels.push_back(tunnel);
    return tunnelId;
}

void WormholeAttackManager::ActivateAttack(Time startTime, Time stopTime) {
    std::cout << "=== ACTIVATING " << m_tunnels.size() << " WORMHOLE TUNNELS ===" << std::endl;
    std::cout << "Start time: " << startTime.GetSeconds() << "s, Stop time: " << stopTime.GetSeconds() << "s" << std::endl;
    
    for (size_t i = 0; i < m_tunnels.size(); ++i) {
        WormholeTunnel& tunnel = m_tunnels[i];
        Ptr<WormholeEndpointApp> appA = CreateObject<WormholeEndpointApp>();
        Ptr<WormholeEndpointApp> appB = CreateObject<WormholeEndpointApp>();
        
        // Store app pointers in tunnel structure for easy access
        tunnel.appA = appA;
        tunnel.appB = appB;
        
        Ipv4Address addrB = tunnel.tunnelInterfaces.GetAddress(1);
        Ipv4Address addrA = tunnel.tunnelInterfaces.GetAddress(0);
        appA->SetPeer(tunnel.endpointB, addrB);
        appA->SetTunnelId(i);
        appA->SetDropPackets(m_dropPackets);
        appA->SetSelectiveTunneling(m_tunnelRoutingPackets, m_tunnelDataPackets);
        appB->SetPeer(tunnel.endpointA, addrA);
        appB->SetTunnelId(i);
        appB->SetDropPackets(m_dropPackets);
        appB->SetSelectiveTunneling(m_tunnelRoutingPackets, m_tunnelDataPackets);
        tunnel.endpointA->AddApplication(appA);
        tunnel.endpointB->AddApplication(appB);
        appA->SetStartTime(startTime);
        appA->SetStopTime(stopTime);
        appB->SetStartTime(startTime);
        appB->SetStopTime(stopTime);
        tunnel.isActive = true;
        tunnel.activationTime = startTime;
        tunnel.deactivationTime = stopTime;
    }
    double startSeconds = startTime.GetSeconds();
    double stopSeconds = stopTime.GetSeconds();
    if (stopSeconds <= startSeconds) stopSeconds = startSeconds + 5.0;
    DeployVerificationTraffic(startSeconds + m_verificationStartOffset, stopSeconds);
}

void WormholeAttackManager::DeactivateAttack() {
    for (auto& tunnel : m_tunnels) {
        tunnel.isActive = false;
    }
}

void WormholeAttackManager::ConfigureVisualization(AnimationInterface& anim,
                                                   uint8_t r, uint8_t g, uint8_t b) {
    for (const auto& tunnel : m_tunnels) {
        anim.UpdateNodeColor(tunnel.endpointA, r, g, b);
        anim.UpdateNodeColor(tunnel.endpointB, r, g, b);
        anim.UpdateNodeSize(tunnel.nodeIdA, 15.0, 15.0);
        anim.UpdateNodeSize(tunnel.nodeIdB, 15.0, 15.0);
        std::ostringstream desc;
        desc << "Wormhole Node " << tunnel.nodeIdA;
        anim.UpdateNodeDescription(tunnel.nodeIdA, desc.str());
        desc.str("");
        desc << "Wormhole Node " << tunnel.nodeIdB;
        anim.UpdateNodeDescription(tunnel.nodeIdB, desc.str());
    }
}

void WormholeAttackManager::SetWormholeBehavior(bool dropPackets, 
                                                bool tunnelRouting,
                                                bool tunnelData) {
    m_dropPackets = dropPackets;
    m_tunnelRoutingPackets = tunnelRouting;
    m_tunnelDataPackets = tunnelData;
}

void WormholeAttackManager::CollectStatisticsFromApps() {
    // Collect current statistics from all running wormhole applications
    for (auto& tunnel : m_tunnels) {
        // Reset tunnel stats before collecting fresh data
        tunnel.stats = WormholeStatistics();
        
        // Get statistics from endpoint A
        if (tunnel.appA) {
            WormholeStatistics statsA = tunnel.appA->GetStatistics();
            tunnel.stats.packetsIntercepted += statsA.packetsIntercepted;
            tunnel.stats.packetsTunneled += statsA.packetsTunneled;
            tunnel.stats.packetsDropped += statsA.packetsDropped;
            tunnel.stats.routingPacketsAffected += statsA.routingPacketsAffected;
            tunnel.stats.dataPacketsAffected += statsA.dataPacketsAffected;
        }
        
        // Get statistics from endpoint B
        if (tunnel.appB) {
            WormholeStatistics statsB = tunnel.appB->GetStatistics();
            tunnel.stats.packetsIntercepted += statsB.packetsIntercepted;
            tunnel.stats.packetsTunneled += statsB.packetsTunneled;
            tunnel.stats.packetsDropped += statsB.packetsDropped;
            tunnel.stats.routingPacketsAffected += statsB.routingPacketsAffected;
            tunnel.stats.dataPacketsAffected += statsB.dataPacketsAffected;
        }
    }
}

void WormholeAttackManager::ConfigureVerificationTraffic(bool enable,
                                                         uint32_t flowCount,
                                                         double packetRate,
                                                         uint32_t packetSize,
                                                         double startOffsetSec,
                                                         uint16_t basePort) {
    m_enableVerificationTraffic = enable;
    m_verificationFlowCount = flowCount;
    m_verificationPacketRate = packetRate;
    m_verificationPacketSize = packetSize;
    m_verificationStartOffset = (startOffsetSec > 0.0) ? startOffsetSec : 0.0;
    m_verificationBasePort = (basePort == 0) ? 50000 : basePort;
}

WormholeStatistics WormholeAttackManager::GetTunnelStatistics(
    uint32_t tunnelId) const {
    if (tunnelId >= m_tunnels.size()) {
        return WormholeStatistics();
    }
    return m_tunnels[tunnelId].stats;
}

WormholeStatistics WormholeAttackManager::GetAggregateStatistics() const {
    WormholeStatistics aggregate;
    for (const auto& tunnel : m_tunnels) {
        aggregate.packetsIntercepted += tunnel.stats.packetsIntercepted;
        aggregate.packetsTunneled += tunnel.stats.packetsTunneled;
        aggregate.packetsDropped += tunnel.stats.packetsDropped;
        aggregate.routingPacketsAffected += tunnel.stats.routingPacketsAffected;
        aggregate.dataPacketsAffected += tunnel.stats.dataPacketsAffected;
        aggregate.totalTunnelingDelay += tunnel.stats.totalTunnelingDelay;
    }
    return aggregate;
}

void WormholeAttackManager::ExportStatistics(std::string filename) const {
    std::ofstream outFile(filename);
    if (!outFile.is_open()) return;
    outFile << "TunnelID,NodeA,NodeB,PacketsIntercepted,PacketsTunneled,"
            << "PacketsDropped,RoutingAffected,DataAffected,AvgDelay\n";
    for (size_t i = 0; i < m_tunnels.size(); ++i) {
        const auto& tunnel = m_tunnels[i];
        const auto& stats = tunnel.stats;
        double avgDelay = (stats.packetsTunneled > 0) 
            ? stats.totalTunnelingDelay / stats.packetsTunneled : 0.0;
        outFile << i << "," << tunnel.nodeIdA << "," << tunnel.nodeIdB << ","
                << stats.packetsIntercepted << "," << stats.packetsTunneled << ","
                << stats.packetsDropped << "," << stats.routingPacketsAffected << ","
                << stats.dataPacketsAffected << "," << avgDelay << "\n";
    }
    WormholeStatistics aggregate = GetAggregateStatistics();
    double avgDelay = (aggregate.packetsTunneled > 0)
        ? aggregate.totalTunnelingDelay / aggregate.packetsTunneled : 0.0;
    outFile << "TOTAL,ALL,ALL," << aggregate.packetsIntercepted << ","
            << aggregate.packetsTunneled << "," << aggregate.packetsDropped << ","
            << aggregate.routingPacketsAffected << "," << aggregate.dataPacketsAffected << ","
            << avgDelay << "\n";
    outFile.close();
}

void WormholeAttackManager::PrintStatistics() const {
    // First, collect current statistics from all running applications
    const_cast<WormholeAttackManager*>(this)->CollectStatisticsFromApps();
    
    std::cout << "\n========== WORMHOLE ATTACK STATISTICS ==========\n";
    std::cout << "Total Tunnels: " << m_tunnels.size() << "\n\n";
    for (size_t i = 0; i < m_tunnels.size(); ++i) {
        const auto& tunnel = m_tunnels[i];
        const auto& stats = tunnel.stats;
        std::cout << "Tunnel " << i << " (Node " << tunnel.nodeIdA 
                  << " <-> Node " << tunnel.nodeIdB << "):\n";
        std::cout << "  Packets Intercepted: " << stats.packetsIntercepted << "\n";
        std::cout << "  Packets Tunneled: " << stats.packetsTunneled << "\n";
        std::cout << "  Packets Dropped: " << stats.packetsDropped << "\n";
        std::cout << "  Routing Packets Affected: " << stats.routingPacketsAffected << "\n";
        std::cout << "  Data Packets Affected: " << stats.dataPacketsAffected << "\n";
        if (stats.packetsTunneled > 0) {
            double avgDelay = stats.totalTunnelingDelay / stats.packetsTunneled;
            std::cout << "  Avg Tunneling Delay: " << avgDelay << " s\n";
        }
        std::cout << "\n";
    }
    WormholeStatistics aggregate = GetAggregateStatistics();
    std::cout << "AGGREGATE STATISTICS:\n";
    std::cout << "  Total Packets Intercepted: " << aggregate.packetsIntercepted << "\n";
    std::cout << "  Total Packets Tunneled: " << aggregate.packetsTunneled << "\n";
    std::cout << "  Total Packets Dropped: " << aggregate.packetsDropped << "\n";
    std::cout << "  Total Routing Packets Affected: " << aggregate.routingPacketsAffected << "\n";
    std::cout << "  Total Data Packets Affected: " << aggregate.dataPacketsAffected << "\n";
    if (aggregate.packetsTunneled > 0) {
        double avgDelay = aggregate.totalTunnelingDelay / aggregate.packetsTunneled;
        std::cout << "  Overall Avg Tunneling Delay: " << avgDelay << " s\n";
    }
    std::cout << "================================================\n\n";
}

Ipv4Address WormholeAttackManager::GetPrimaryAddress(Ptr<Node> node) {
    if (!node) return Ipv4Address::GetZero();
    Ptr<Ipv4> ipv4 = node->GetObject<Ipv4>();
    if (!ipv4) return Ipv4Address::GetZero();
    for (uint32_t i = 0; i < ipv4->GetNInterfaces(); ++i) {
        for (uint32_t j = 0; j < ipv4->GetNAddresses(i); ++j) {
            Ipv4InterfaceAddress iface = ipv4->GetAddress(i, j);
            Ipv4Address address = iface.GetLocal();
            if (address != Ipv4Address::GetLoopback() && address != Ipv4Address::GetZero()) {
                return address;
            }
        }
    }
    return Ipv4Address::GetZero();
}

void WormholeAttackManager::DeployVerificationTraffic(double startTimeSec,
                                                      double stopTimeSec) {
    if (stopTimeSec <= startTimeSec) stopTimeSec = startTimeSec + 5.0;
    for (auto& socket : m_testSourceSockets) {
        if (socket) socket->Close();
    }
    m_testSourceSockets.clear();
    for (auto& socket : m_testSinkSockets) {
        if (socket) socket->Close();
    }
    m_testSinkSockets.clear();
    if (!m_enableVerificationTraffic) {
        std::cout << "[WORMHOLE] Verification traffic disabled per configuration." << std::endl;
        return;
    }
    std::vector<uint32_t> innocents;
    for (uint32_t i = 0; i < m_totalNodes; ++i) {
        if (i >= m_maliciousNodes.size() || !m_maliciousNodes[i]) {
            innocents.push_back(i);
        }
    }
    if (innocents.size() < 2) {
        std::cout << "[WORMHOLE] Skipping verification traffic (not enough non-malicious nodes)." << std::endl;
        return;
    }
    if (m_verificationFlowCount == 0) {
        std::cout << "[WORMHOLE] Verification flow count set to 0, skipping traffic." << std::endl;
        return;
    }
    uint32_t availablePairs = innocents.size() / 2;
    uint32_t desiredPairs = std::min<uint32_t>(m_verificationFlowCount, availablePairs);
    if (desiredPairs == 0) {
        std::cout << "[WORMHOLE] Unable to allocate verification flows." << std::endl;
        return;
    }
    Time startTime = Seconds(startTimeSec);
    Time stopTime = Seconds(stopTimeSec);
    bool scheduleTraffic = (m_verificationPacketRate > 0.0);
    Time interval = Seconds(scheduleTraffic ? (1.0 / m_verificationPacketRate) : 0.5);
    uint32_t packetSize = (m_verificationPacketSize > 64) ? m_verificationPacketSize : 64;
    uint16_t basePort = m_verificationBasePort;
    for (uint32_t i = 0; i < desiredPairs; ++i) {
        uint32_t srcIndex = innocents[i % innocents.size()];
        uint32_t dstIndex = innocents[(i + innocents.size() / 2) % innocents.size()];
        if (srcIndex == dstIndex) {
            dstIndex = innocents[(i + 1) % innocents.size()];
            if (srcIndex == dstIndex) continue;
        }
        Ptr<Node> srcNode = NodeList::GetNode(srcIndex);
        Ptr<Node> dstNode = NodeList::GetNode(dstIndex);
        if (!srcNode || !dstNode) continue;
        Ipv4Address dstAddress = GetPrimaryAddress(dstNode);
        if (dstAddress == Ipv4Address::GetZero()) continue;
        uint16_t port = basePort + i;
        Ptr<Socket> sink = Socket::CreateSocket(dstNode, TypeId::LookupByName("ns3::UdpSocketFactory"));
        if (sink->Bind(InetSocketAddress(Ipv4Address::GetAny(), port)) < 0) continue;
        sink->SetRecvCallback(MakeCallback(&WormholeVerificationReceive));
        m_testSinkSockets.push_back(sink);
        Ptr<Socket> source = Socket::CreateSocket(srcNode, TypeId::LookupByName("ns3::UdpSocketFactory"));
        if (source->Bind() < 0) continue;
        source->Connect(InetSocketAddress(dstAddress, port));
        m_testSourceSockets.push_back(source);
        if (scheduleTraffic) {
            Simulator::Schedule(startTime, &ScheduleWormholeVerificationSend,
                                source, packetSize, interval, stopTime);
        }
        std::cout << "[WORMHOLE] Verification flow " << i
                  << ": node " << srcIndex << " -> node " << dstIndex
                  << " targeting " << dstAddress << ":" << port << std::endl;
    }
    if (!m_testSourceSockets.empty()) {
        std::cout << "[WORMHOLE] Installed " << m_testSourceSockets.size()
                  << " verification flow(s) to stimulate routing activity." << std::endl;
        if (!scheduleTraffic) {
            std::cout << "[WORMHOLE] Verification packet rate <= 0, sockets created without scheduled transmissions." << std::endl;
        }
    } else {
        std::cout << "[WORMHOLE] Verification traffic setup produced no active flows." << std::endl;
    }
}

std::vector<uint32_t> WormholeAttackManager::GetMaliciousNodeIds() const {
    std::vector<uint32_t> nodeIds;
    for (uint32_t i = 0; i < m_maliciousNodes.size(); ++i) {
        if (m_maliciousNodes[i]) {
            nodeIds.push_back(i);
        }
    }
    return nodeIds;
}

// ============================================================================
// Wormhole Detector Implementation
// ============================================================================

WormholeDetector::WormholeDetector()
    : m_detectionEnabled(false),
      m_mitigationEnabled(false),
      m_totalNodes(0),
      m_latencyThresholdMultiplier(2.0),
      m_baselineLatency(0.001) // Default 1ms baseline
{
}

WormholeDetector::~WormholeDetector() {
}

void WormholeDetector::Initialize(uint32_t totalNodes, double latencyThreshold) {
    m_totalNodes = totalNodes;
    m_latencyThresholdMultiplier = latencyThreshold;
    m_detectionStartTime = Simulator::Now();
    m_lastDetectionCheck = Simulator::Now();
    
    std::cout << "[DETECTOR] Wormhole detector initialized for " << totalNodes 
              << " nodes with threshold multiplier " << latencyThreshold << "\n";
}

void WormholeDetector::EnableDetection(bool enable) {
    m_detectionEnabled = enable;
    std::cout << "[DETECTOR] Detection " << (enable ? "ENABLED" : "DISABLED") << "\n";
}

void WormholeDetector::EnableMitigation(bool enable) {
    m_mitigationEnabled = enable;
    std::cout << "[DETECTOR] Mitigation " << (enable ? "ENABLED" : "DISABLED") << "\n";
}

void WormholeDetector::SetLatencyThreshold(double multiplier) {
    m_latencyThresholdMultiplier = multiplier;
}

std::string WormholeDetector::GetFlowKey(Ipv4Address src, Ipv4Address dst) const {
    std::ostringstream oss;
    oss << src << "->" << dst;
    return oss.str();
}

void WormholeDetector::RecordPacketSent(Ipv4Address src, Ipv4Address dst, 
                                        Time txTime, uint32_t packetId) {
    m_packetSendTimes[packetId] = txTime;
}

void WormholeDetector::RecordPacketReceived(Ipv4Address src, Ipv4Address dst, 
                                            Time rxTime, uint32_t packetId) {
    auto it = m_packetSendTimes.find(packetId);
    if (it != m_packetSendTimes.end()) {
        double latency = (rxTime - it->second).GetSeconds();
        UpdateFlowLatency(src, dst, latency);
        m_packetSendTimes.erase(it); // Clean up
    }
}

void WormholeDetector::UpdateFlowLatency(Ipv4Address src, Ipv4Address dst, double latency) {
    if (!m_detectionEnabled) return;
    
    std::string flowKey = GetFlowKey(src, dst);
    FlowLatencyRecord& flow = m_flowRecords[flowKey];
    
    // Initialize flow if this is the first packet
    if (flow.packetCount == 0) {
        flow.srcAddr = src;
        flow.dstAddr = dst;
        flow.firstPacketTime = Simulator::Now();
        m_metrics.totalFlows++;
    }
    
    flow.totalLatency += latency;
    flow.packetCount++;
    flow.avgLatency = flow.totalLatency / flow.packetCount;
    flow.lastPacketTime = Simulator::Now();
    
    // Check if this flow shows wormhole characteristics
    if (IsFlowSuspicious(flow) && !flow.suspectedWormhole) {
        flow.suspectedWormhole = true;
        m_metrics.flowsDetected++;
        m_metrics.flowsAffected++;
        
        std::cout << "[DETECTOR] Wormhole suspected in flow " << src << " -> " << dst 
                  << " (avg latency: " << (flow.avgLatency * 1000.0) << " ms, "
                  << "threshold: " << (m_baselineLatency * m_latencyThresholdMultiplier * 1000.0) 
                  << " ms)\n";
        
        if (m_mitigationEnabled) {
            TriggerRouteChange(src, dst);
        }
    }
}

bool WormholeDetector::IsFlowSuspicious(const FlowLatencyRecord& flow) {
    // Need at least a few packets to make a determination
    if (flow.packetCount < 3) return false;
    
    // Calculate baseline if not set
    if (m_baselineLatency < 0.0001 && !m_flowRecords.empty()) {
        const_cast<WormholeDetector*>(this)->CalculateBaselineLatency();
    }
    
    // Flow is suspicious if latency exceeds threshold
    double threshold = m_baselineLatency * m_latencyThresholdMultiplier;
    return flow.avgLatency > threshold;
}

void WormholeDetector::CalculateBaselineLatency() {
    if (m_flowRecords.empty()) {
        m_baselineLatency = 0.001; // Default 1ms
        return;
    }
    
    // Calculate average latency across all flows
    double totalLatency = 0.0;
    uint32_t flowCount = 0;
    
    for (const auto& pair : m_flowRecords) {
        const FlowLatencyRecord& flow = pair.second;
        if (flow.packetCount >= 3 && !flow.suspectedWormhole) {
            totalLatency += flow.avgLatency;
            flowCount++;
        }
    }
    
    if (flowCount > 0) {
        m_baselineLatency = totalLatency / flowCount;
        m_metrics.avgNormalLatency = m_baselineLatency;
        std::cout << "[DETECTOR] Baseline latency calculated: " 
                  << (m_baselineLatency * 1000.0) << " ms (from " 
                  << flowCount << " flows)\n";
    }
}

bool WormholeDetector::DetectWormholeInFlow(Ipv4Address src, Ipv4Address dst) {
    std::string flowKey = GetFlowKey(src, dst);
    auto it = m_flowRecords.find(flowKey);
    if (it == m_flowRecords.end()) return false;
    
    return it->second.suspectedWormhole;
}

void WormholeDetector::PeriodicDetectionCheck() {
    if (!m_detectionEnabled) return;
    
    m_lastDetectionCheck = Simulator::Now();
    UpdateDetectionMetrics();
    
    std::cout << "[DETECTOR] Periodic check - Flows monitored: " << m_flowRecords.size()
              << ", Suspicious flows: " << m_metrics.flowsDetected << "\n";
}

void WormholeDetector::UpdateDetectionMetrics() {
    // Recalculate metrics
    uint32_t suspiciousCount = 0;
    double normalLatencySum = 0.0;
    double wormholeLatencySum = 0.0;
    uint32_t normalCount = 0;
    uint32_t wormholeCount = 0;
    
    for (const auto& pair : m_flowRecords) {
        const FlowLatencyRecord& flow = pair.second;
        if (flow.packetCount >= 3) {
            if (flow.suspectedWormhole) {
                wormholeLatencySum += flow.avgLatency;
                wormholeCount++;
                suspiciousCount++;
            } else {
                normalLatencySum += flow.avgLatency;
                normalCount++;
            }
        }
    }
    
    m_metrics.flowsDetected = suspiciousCount;
    
    if (normalCount > 0) {
        m_metrics.avgNormalLatency = normalLatencySum / normalCount;
    }
    
    if (wormholeCount > 0) {
        m_metrics.avgWormholeLatency = wormholeLatencySum / wormholeCount;
        
        if (m_metrics.avgNormalLatency > 0) {
            m_metrics.avgLatencyIncrease = 
                ((m_metrics.avgWormholeLatency - m_metrics.avgNormalLatency) / 
                 m_metrics.avgNormalLatency) * 100.0;
        }
    }
}

void WormholeDetector::BlacklistNode(uint32_t nodeId) {
    m_blacklistedNodes.insert(nodeId);
    std::cout << "[DETECTOR] Node " << nodeId << " blacklisted\n";
}

void WormholeDetector::UnblacklistNode(uint32_t nodeId) {
    m_blacklistedNodes.erase(nodeId);
    std::cout << "[DETECTOR] Node " << nodeId << " removed from blacklist\n";
}

bool WormholeDetector::IsNodeBlacklisted(uint32_t nodeId) const {
    return m_blacklistedNodes.find(nodeId) != m_blacklistedNodes.end();
}

void WormholeDetector::TriggerRouteChange(Ipv4Address src, Ipv4Address dst) {
    m_metrics.routeChanges++;
    std::cout << "[DETECTOR] Triggering route change for flow " << src << " -> " << dst << "\n";
    // Note: Actual route invalidation would require AODV routing table access
    // This is a placeholder for the mitigation action
}

void WormholeDetector::PrintDetectionReport() const {
    std::cout << "\n========== WORMHOLE DETECTION REPORT ==========\n";
    std::cout << "Detection Status: " << (m_detectionEnabled ? "ENABLED" : "DISABLED") << "\n";
    std::cout << "Mitigation Status: " << (m_mitigationEnabled ? "ENABLED" : "DISABLED") << "\n";
    std::cout << "Latency Threshold Multiplier: " << m_latencyThresholdMultiplier << "x\n";
    std::cout << "Baseline Latency: " << (m_baselineLatency * 1000.0) << " ms\n\n";
    
    std::cout << "FLOW STATISTICS:\n";
    std::cout << "  Total Flows Monitored: " << m_metrics.totalFlows << "\n";
    std::cout << "  Flows Affected by Wormhole: " << m_metrics.flowsAffected << "\n";
    std::cout << "  Flows with Detection: " << m_metrics.flowsDetected << "\n";
    
    if (m_metrics.totalFlows > 0) {
        double affectedPercentage = (m_metrics.flowsAffected * 100.0) / m_metrics.totalFlows;
        std::cout << "  Percentage of Flows Affected: " << affectedPercentage << "%\n";
    }
    
    std::cout << "\nLATENCY ANALYSIS:\n";
    std::cout << "  Average Normal Flow Latency: " << (m_metrics.avgNormalLatency * 1000.0) << " ms\n";
    std::cout << "  Average Wormhole Flow Latency: " << (m_metrics.avgWormholeLatency * 1000.0) << " ms\n";
    std::cout << "  Average Latency Increase: " << m_metrics.avgLatencyIncrease << "%\n";
    
    std::cout << "\nMITIGATION ACTIONS:\n";
    std::cout << "  Route Changes Triggered: " << m_metrics.routeChanges << "\n";
    std::cout << "  Nodes Blacklisted: " << m_blacklistedNodes.size() << "\n";
    
    std::cout << "===============================================\n\n";
}

void WormholeDetector::ExportDetectionResults(std::string filename) const {
    std::ofstream outFile(filename);
    if (!outFile.is_open()) {
        std::cerr << "[DETECTOR] Failed to open file: " << filename << std::endl;
        return;
    }
    
    // CSV Header
    outFile << "Metric,Value\n";
    outFile << "DetectionEnabled," << (m_detectionEnabled ? "true" : "false") << "\n";
    outFile << "MitigationEnabled," << (m_mitigationEnabled ? "true" : "false") << "\n";
    outFile << "LatencyThresholdMultiplier," << m_latencyThresholdMultiplier << "\n";
    outFile << "BaselineLatency_ms," << (m_baselineLatency * 1000.0) << "\n";
    outFile << "TotalFlows," << m_metrics.totalFlows << "\n";
    outFile << "FlowsAffected," << m_metrics.flowsAffected << "\n";
    outFile << "FlowsDetected," << m_metrics.flowsDetected << "\n";
    outFile << "AffectedPercentage," << (m_metrics.totalFlows > 0 ? (m_metrics.flowsAffected * 100.0 / m_metrics.totalFlows) : 0.0) << "\n";
    outFile << "AvgNormalLatency_ms," << (m_metrics.avgNormalLatency * 1000.0) << "\n";
    outFile << "AvgWormholeLatency_ms," << (m_metrics.avgWormholeLatency * 1000.0) << "\n";
    outFile << "AvgLatencyIncrease_percent," << m_metrics.avgLatencyIncrease << "\n";
    outFile << "RouteChangesTriggered," << m_metrics.routeChanges << "\n";
    outFile << "NodesBlacklisted," << m_blacklistedNodes.size() << "\n";
    
    outFile.close();
    std::cout << "[DETECTOR] Detection results exported to " << filename << "\n";
}

} // namespace ns3

// End of inline wormhole attack implementation
// ============================================================================

uint32_t empty_neighborset[max];

void initialize_empty()
{
	for (uint32_t i =0; i < max; i++)
	{
		empty_neighborset[i] = large;
	}
}


uint32_t get_size_of_data_at_nodes(struct data_at_nodes * nd1)
{
	uint32_t size = 0;
	for(uint32_t i=0; i<max;i++)
	{
		if((nd1->nodeid[i] != large) and (nd1->nodeid[i] < (total_size+2)) and (nd1->nodeid[i]>1))
		{
			size++;
		}
	}
	return size;
}

void add_received_data_at_nodes(struct data_at_nodes * nd1,Vector pos, Vector vel, Vector acc, uint32_t nid, uint32_t * neighbor_set,uint32_t size)
{
	bool found = false;
	bool set = false;
	for(uint32_t i=0; i<max;i++)
	{
		//if node id is found, update it
		if ((found == false) and (nd1->nodeid[i]==nid))
		{
			nd1->timestamp[i] = Simulator::Now();
			nd1->acceleration[i] = acc;
			nd1->velocity[i] = vel;
			nd1->position[i] = pos;
			nd1->nodeid[i] = nid;
			for(uint32_t j=0;j<max;j++)
			{
				if(j< size)
				{
					if((nd1->neighbor_set[i].neighbors[j]) != neighbor_set[j])//check whether any neighbor changed
					{
						nd1->neighbors_changed[i] = true;
					}
					nd1->neighbor_set[i].neighbors[j] = neighbor_set[j];
				}
				else
				{
					nd1->neighbor_set[i].neighbors[j] = large;
				}
			}
			found = true;
		}
	}
	
	for(uint32_t i=0; i<max;i++)
	{
		//if node id is not found, add at the first empty location
		if ((found==false) and (set == false) and (nd1->nodeid[i]==large))
		{
			nd1->timestamp[i] = Simulator::Now();
			nd1->acceleration[i] = acc;
			nd1->velocity[i] = vel;
			nd1->position[i] = pos;
			nd1->nodeid[i] = nid;
			nd1->neighbors_changed[i] = true;
			for(uint32_t j=0;j<max;j++)
			{
				if(j< size)
				{
					nd1->neighbor_set[i].neighbors[j] = neighbor_set[j];
				}
				else
				{
					nd1->neighbor_set[i].neighbors[j] = large;
				}
			}
			set = true;
		}
	}	
}

void clear_data_at_manager(struct data_at_manager * nd1)
{
	nd1->timestamp = Simulator::Now();
	nd1->acceleration = Vector(0,0,0);
	nd1->velocity = Vector(0,0,0);
	nd1->position = Vector(0,0,0);
	nd1->nodeid = large;
}

void clear_controllerdata(struct controller_data * nd1)
{
	nd1->B = large;
	nd1->neighborsize = large;
	//nd1->frequency = large;
	//nd1->datasize = large;
	for(uint32_t i=0; i<max;i++)
	{
		nd1->neighborid[i] = large;
		//nd1->combined_cost[i] = large;
	}
	nd1->lastupdated = Simulator::Now().GetSeconds();
}

struct neighbor_data neighbordata_inst[total_size+2];
struct controller_data con_data_inst[total_size+2];

double sum_of_nodeids = 0;
void nodeid_sum()
{
	sum_of_nodeids = 0;
	for (uint32_t i=2;i<total_size+2;i++)
	{
		sum_of_nodeids = sum_of_nodeids + i;
	}
}

double last_optimized_entropy = 0.0;

double calculate_network_entropy()
{
	double summation_veh = 0.0;
	double summation_rsu = 0.0;
	for (uint32_t i=0;i<total_size; i++)
	{
		if( con_data_inst[i+2].neighborsize != 0)
		{
			int vehicle_neighbors = 0;
			int rsu_neighbors = 0;
			for (uint32_t j=0;j<max;j++)
			{
				if((con_data_inst[i+2].neighborid[j]) != large)
				{
					if ((con_data_inst[i+2].neighborid[j]) < (N_Vehicles+2))
					{
						vehicle_neighbors++;
					}
					else if ((con_data_inst[i+2].neighborid[j]) < (total_size+2))
					{
						rsu_neighbors++;
					}
					
				}
			}
			if (vehicle_neighbors != 0)
			{
				summation_veh = summation_veh + log(vehicle_neighbors);
			}
			if (rsu_neighbors != 0)
			{
				summation_rsu = summation_rsu + log(rsu_neighbors);
			}
		}
	}
	double rsu_deno = 0.0;
	double entropy_rsu = 0.0;
	double veh_deno = 0.0;
	double entropy_veh = 0.0;
	if (N_RSUs >1)
	{
		rsu_deno = (N_RSUs*log(N_RSUs-1)) + (N_Vehicles*log(N_RSUs));
		entropy_rsu = (summation_rsu)/(rsu_deno);
	}
	if (N_Vehicles > 1)
	{
		veh_deno = (N_RSUs*log(N_Vehicles)) + (N_Vehicles*log(N_Vehicles-1));
		entropy_veh = (summation_veh)/(veh_deno);
	}
	double final_entropy = 0.5*(entropy_veh + entropy_rsu);
	return final_entropy;
		
}

void clear_neighbordata(struct neighbor_data * nd1)
{
	for(uint32_t i=0; i<max;i++)
	{
		nd1->neighborid[i] = large;
		//nd1->combined_cost[i] = large;
		nd1->timestamp[i] = Simulator::Now();
	}
}

void add_neighbor_info(struct neighbor_data * nd1, uint32_t node_id)
{
	bool setter = false;
	bool found = false;
	for(uint32_t i=0; i<max;i++)
	{
		if((nd1->neighborid[i] == node_id) and (found==false))//If node is already a neighbor, update timestamp and cost
		{
			nd1->timestamp[i] = Simulator::Now();
			nd1->neighborid[i] = node_id;
			//nd1->combined_cost[i] = combined_cost;
			found = true;
			//cout<<"found neighbor at index"<<i<<endl;
		}
	}
	
	for(uint32_t j=0; j<max;j++)
	{
		if((setter == false) and (found==false) and (nd1->neighborid[j] == large))// If node is not found, add it at the first empty location
		{
			nd1->timestamp[j] = Simulator::Now();
			nd1->neighborid[j] = node_id;
			//nd1->combined_cost[j] = combined_cost;
			setter = true;
			//cout<<"neighbor not found setting at index"<<j<<endl;
		}
	}

}

void refresh_neighbors(struct neighbor_data * nd1)
{
	uint32_t now = Simulator::Now().GetMilliSeconds();
	for(uint32_t i=0; i<max;i++)
	{
		uint32_t last_timestamp = nd1->timestamp[i].GetMilliSeconds();
		uint32_t difference = now - last_timestamp;
		double update_frequency = data_transmission_frequency;
		uint32_t period = 1.5*uint32_t(1000/update_frequency);
		//cout<<"difference"<<difference<<"period"<<period<<endl;
		if (difference > period)//If difference is greater than update period, we remove the node.
		{	
			//cout<<"removing old neighbor at index "<<i<<endl;
			nd1->neighborid[i] = large;
			//nd1->combined_cost[i] = large;
		}
	}
}

uint32_t getNeighborsize(struct neighbor_data * nd1)
{
	uint32_t  neighborsize = 0;
	for(uint32_t i=0; i<max;i++)
	{
		if((nd1->neighborid[i] != large) and (nd1->neighborid[i] > 1) and (nd1->neighborid[i] < (total_size+2)))
		{
			neighborsize++;	
		}
	}
	return neighborsize;
}

uint32_t getcontrollerNeighborsize(struct controller_data * nd1)
{
	uint32_t  neighborsize = 0;
	for(uint32_t i=0; i<max;i++)
	{
		if(nd1->neighborid[i] != large)
		{
			neighborsize++;	
		}
	}
	return neighborsize;
}

void refresh_controller_data(struct controller_data * nd1)//To clear neighbors when updates are not received
{
	double time_difference = Simulator::Now().GetSeconds() - (nd1->lastupdated);
	if((time_difference) > (1.5*data_transmission_period))
	{
		nd1->neighborsize = 0;
		for(uint32_t i=0; i<max;i++)
		{
			nd1->neighborid[i] = large;
		}
		nd1->lastupdated = Simulator::Now().GetSeconds();
	}
}


struct proposed_routing_table_row
{
	uint32_t source_node;
	uint32_t destination_node;
	uint32_t path[total_size];
};

struct routing_table_row
{
	uint32_t source_node;
	uint32_t destination_node;
	uint32_t next_hop;
};

struct routing_table
{
	struct routing_table_row rows[total_size];
};

struct proposed_routing_table
{
	struct proposed_routing_table_row rows[total_size];
};

struct proposed_routing_table proposed_routing_tables[total_size];
struct routing_table routing_tables[total_size];

void initialize_all_routing_tables()
{
	for (uint32_t i=0;i<total_size;i++)
	{
		for(uint32_t j=0;j<total_size;j++)
		{
			routing_tables[i].rows[j].source_node = large;
			proposed_routing_tables[i].rows[j].source_node = large;
			routing_tables[i].rows[j].destination_node = large;
			proposed_routing_tables[i].rows[j].destination_node = large;
			routing_tables[i].rows[j].next_hop = large;
			for(uint32_t k=0;k<total_size;k++)
			{
				proposed_routing_tables[i].rows[j].path[k] = large;
			}
		}
	}
}

void update_route(uint32_t source, uint32_t destination, uint32_t next_hop)
{
	routing_tables[source].rows[destination].source_node = source;
	routing_tables[source].rows[destination].destination_node = destination;
	routing_tables[source].rows[destination].next_hop = next_hop;
}

void update_proposed_route(uint32_t source, uint32_t destination, uint32_t * path)
{
	proposed_routing_tables[source].rows[destination].source_node = source;
	proposed_routing_tables[source].rows[destination].destination_node = destination;
	for(uint32_t k=0;k<total_size;k++)
	{
		//cout<<path[0]<<endl;
		proposed_routing_tables[source].rows[destination].path[k] = *(path+k);
	}
}

uint32_t find_next_hop(uint32_t source, uint32_t destination, uint32_t current_hop)
{
	bool found = false;
	uint32_t k=0;
	uint32_t next_hop=0;
	while(found==false)
	{
		uint32_t this_hop = proposed_routing_tables[source].rows[destination].path[k];
		if (current_hop == this_hop)
		{
			next_hop = proposed_routing_tables[source].rows[destination].path[k+1];
			found = true;
		}
		k++;
	}
	return next_hop;
}

long dsrc_total_packet_size = 0;
long ethernet_total_packet_size = 0;
long lte_total_packet_size = 0;

ApplicationContainer apps;
ApplicationContainer RSU_apps;
NodeContainer controller_Node;
NodeContainer management_Node;
NodeContainer Vehicle_Nodes;
NodeContainer RSU_Nodes;
//NodeContainer Custom_Nodes;
bool routing_test = true;

NetDeviceContainer wifidevices;
NetDeviceContainer wifidevices_172;
NetDeviceContainer wifidevices_174;
NetDeviceContainer wifidevices_176;
NetDeviceContainer wifidevices_180;
NetDeviceContainer wifidevices_182;
NetDeviceContainer wifidevices_184;


NodeContainer dsrc_Nodes;

double data_gathering_cycle_number = 1.0;
double M;
uint32_t Y[total_size];
double R[total_size];
double Q[total_size];
double N_WL[total_size];
double N_WI[total_size];
double Q_nei[total_size];
double Q_bar;
double D_wl_bar[total_size];
double D_wi_bar[total_size];
double one_hop_delay_training_wl[total_size];
double packets_received_wl[total_size];
double one_hop_delay_training_wi[total_size];
double packets_received_wi[total_size];
double d_cont_wl_bar;
double d_cont_wl_max;
double d_cont_wi_bar;
double d_cont_wi_max;
double contention;
double base_packet_size = 204;
double packet_additional_size = 0;
double packet_size;
double rts;
double cts;
double ack;
double DR_WL = 12.0;
double DR_WI = 1000.0;
double SIFS = 12;
double E = 6;
double T_c;
double T_slot = 20.0;
double rho_wl;
double rho_wi;
double CW_min = 15.0;

void reset_delays_and_packets()
{
	for(uint32_t i=0;i<total_size;i++)
	{
		one_hop_delay_training_wl[i] = 0.0;
		packets_received_wl[i] = 0.0;
		one_hop_delay_training_wi[i] = 0.0;
		packets_received_wi[i] = 0.0;
	}
}

void write_csv_delay_training(uint32_t index, uint32_t mode)
{
	fstream fout;
	fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/delay_training_data.csv",ios::out|ios::app);
	fout << mode << ", "
	     << mode*D_wl_bar[index] << ", "
	     <<	(1-mode)*D_wi_bar[index] << ", "
	     << R[index]<< ", "
	     << mode*N_WL[index] << ", "
	     << (1-mode)*N_WI[index] << ", "
	     << Q_nei[index] << ", "
	     << packet_size*8 << ", "
	     << mode*rts*8 << ", "
	     << mode*cts*8 << ", "
	     << mode*ack*8 << ", "
	     << (mode*DR_WL) + ((1-mode)*(DR_WI))<< ", "
	     << SIFS << ", "
	     << E << ", "
	     << (1-mode)*T_c << ", "
	     << CW_min*T_slot << ", "
	     << mode*rho_wl << ", "
	     << (1-mode)*rho_wi << ", "
	     << (mode*one_hop_delay_training_wl[index]) + ((1-mode)*(one_hop_delay_training_wi[index])) << ", "
	     << "\n";
	fout.close();
}


void write_csv_delay_prediction()
{
	fstream fout;
	fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/delay_data_for_prediction.csv",ios::out|ios::trunc);
	for (uint32_t index=0;index<total_size;index++)
	{
		for(double mode=0.0;mode < 2.0;mode++)
		{
			fout << mode << ", "
			     << mode*D_wl_bar[index] << ", "
			     <<	(1-mode)*D_wi_bar[index] << ", "
			     << R[index]<< ", "
			     << mode*N_WL[index] << ", "
			     << (1-mode)*N_WI[index] << ", "
			     << Q_nei[index] << ", "
			     << packet_size*8 << ", "
			     << mode*rts*8 << ", "
			     << mode*cts*8 << ", "
			     << mode*ack*8 << ", "
			     << (mode*DR_WL) + ((1-mode)*(DR_WI))<< ", "
			     << SIFS << ", "
			     << E << ", "
			     << (1-mode)*T_c << ", "
			     << CW_min*T_slot << ", "
			     << mode*rho_wl << ", "
			     << (1-mode)*rho_wi << ", "
			     << "\n";
		} 
	}
	
	fout.close();
}

void compute_1hop_delay()
{
	for(uint32_t i=0;i<total_size;i++)
	{
		if (packets_received_wl[i] > 0)
		{
			one_hop_delay_training_wl[i] = one_hop_delay_training_wl[i]/packets_received_wl[i];
			if ((training_delay == true) && (data_gathering_cycle_number > 2))
			{
				write_csv_delay_training(i, 1);
			}	
		}
		cout<<"delay wireless at node "<<i<<" is "<< one_hop_delay_training_wl[i]<<endl;
		if (packets_received_wi[i] > 0)
		{
			one_hop_delay_training_wi[i] = one_hop_delay_training_wi[i]/packets_received_wi[i];
			if ((training_delay == true) && (data_gathering_cycle_number > 2))
			{
				write_csv_delay_training(i, 0);
			}
		}
		cout<<"delay wired at node "<<i<<" is "<< one_hop_delay_training_wi[i]<<endl;
	}
}

double calculate_wireless_entropy()
{
	double summation_wl = 0.0;
	for (uint32_t i=0;i<total_size; i++)
	{
		int wireless_neighbors = 0;
		if( con_data_inst[i+2].neighborsize != 0)
		{
			for (uint32_t j=0;j<max;j++)
			{
				if((con_data_inst[i+2].neighborid[j]) != large)
				{
					if (i<N_Vehicles)
					{
						wireless_neighbors++;
					}
					else
					{
						if ((con_data_inst[i+2].neighborid[j]) < (N_Vehicles+2))
						{
							wireless_neighbors++;
						}
						else if ((con_data_inst[i+2].neighborid[j]) < (total_size+2))
						{
						
						}
					}
				}
			}
			if (wireless_neighbors != 0)
			{
				summation_wl = summation_wl + log(wireless_neighbors);
			}
		}
		N_WL[i] = wireless_neighbors;
	}
	
	double rsu_deno = 0.0;
	double total_deno = 0.0;
	double entropy_wl = 0.0;
	if (N_RSUs >1)
	{
		rsu_deno = (N_RSUs*log(N_RSUs-1));
	}
	if (total_size > 1)
	{
		total_deno =  (total_size*log(total_size-1));	
	}
	entropy_wl = (summation_wl)/(total_deno-rsu_deno);
	return entropy_wl;		
}

double calculate_wired_entropy()
{
	double summation_wi = 0.0;
	for (uint32_t i=0;i<total_size; i++)
	{	
		int wired_neighbors = 0;
		if(i>(N_Vehicles-1))
		{
			wired_neighbors = N_RSUs-1;
			summation_wi = summation_wi + log(wired_neighbors);
		}
		N_WI[i] = wired_neighbors;
	}
	
	double rsu_deno = 0.0;
	double entropy_wi = 0.0;
	if (N_RSUs >1)
	{
		rsu_deno = (N_RSUs*log(N_RSUs-1));
	}	
	
	entropy_wi = (summation_wi)/(rsu_deno);
	return entropy_wi;		
}

void compute_Qbar()
{
	double sum = 0.0;
	for (uint32_t i=0;i<total_size;i++)
	{
		sum = sum + Q[i];
	}
	Q_bar = sum/total_size;
}

void compute_Qnei()
{
	for (uint32_t i=0;i<total_size; i++)
	{
		double neighbors = 0;
		double Q_sum = 0.0;
		if(con_data_inst[i+2].neighborsize != 0)
		{
			for (uint32_t j=0;j<max;j++)
			{
				if((con_data_inst[i+2].neighborid[j]) != large)
				{
					uint32_t nei_index = con_data_inst[i+2].neighborid[j] - 2;
					Q_sum = Q_sum + Q[nei_index];
					neighbors++;
				}
			}
		}
		if (neighbors != 0)
		{
			Q_nei[i] = (Q[i]*Q_sum)/neighbors;
		}
		else
		{
			Q_nei[i] = 0;
		}
	}
}

void compute_wireless_average_delay(uint32_t nodeID)
{
	packet_size = base_packet_size + packet_additional_size;
	rts = 20.0;
	cts = 14.0;
	ack = 14.0;
	double datarate = 27.0;
	double d_trans = (8*packet_size)/datarate;
	double d_prop = 4.0*333/380;
	double d_proc = 4*12;
	double d_rts = 8*rts/datarate;
	double d_cts = 8*cts/datarate;
	double d_ack = 8*ack/datarate;
	double DIFS = 50;
	compute_Qbar();
	double wireless_entropy = calculate_wireless_entropy();
	rho_wl = wireless_entropy*Q_bar;
	CW_min = 15.0;
	T_slot = 20.0;
	d_cont_wl_bar = (DIFS) + T_slot*(CW_min/8.0)*((2-(2*rho_wl)-pow((2*rho_wl),6))/(1-(2*rho_wl)));
	d_cont_wl_max = (DIFS) + T_slot*(CW_min)*(8);
	D_wl_bar[nodeID] = R[nodeID]*(d_trans + d_prop + d_proc + d_rts + d_cts + d_ack + d_cont_wl_bar);
	cout<<"wireless average delay at node "<<nodeID<<" is "<<D_wl_bar[nodeID]<<endl;
}

void compute_wired_average_delay(uint32_t nodeID)
{
	packet_size = base_packet_size + packet_additional_size;
	double datarate = 1000.0;
	double d_trans = (8*packet_size)/datarate;
	double d_prop = 10.0;
	double d_proc = 12.0;
	compute_Qbar();
	double wired_entropy = calculate_wired_entropy();
	rho_wi = wired_entropy*Q_bar;
	double E_bar = 0.0;
	for (uint32_t k=1;k<6;k++)
	{
		E_bar = E_bar + (k*(pow((rho_wi),k))*(1 - rho_wi));	
	}
	E_bar = E_bar + (6*(pow((rho_wi),6)));
	double IFG = 9.6;
	T_c = (8.0*packet_size)/DR_WI;
	CW_min = 15.0;
	T_slot = 20.0;
	d_cont_wi_bar = (E_bar*(IFG+d_trans)) + T_slot*rho_wi*(CW_min/4.0)*((2-(2*rho_wi)-(pow((2*rho_wi),6)))/(1-(2*rho_wi)));
	d_cont_wi_max = (6*(IFG+d_trans)) + T_slot*(CW_min)*(16);
	D_wi_bar[nodeID] = R[nodeID]*(d_trans + d_prop + d_proc + d_cont_wi_bar);
	cout<<"wired average delay at node "<<nodeID<<" is "<<D_wi_bar[nodeID]<<endl;
}

void compute_average_delays()
{
	for(uint32_t i=0;i<total_size;i++)
	{
		compute_wireless_average_delay(i);
		compute_wired_average_delay(i);
	}
	compute_Qnei();
}

void calculate_contention()
{
	double contention_wl = (d_cont_wl_bar)/(d_cont_wl_max);
	double contention_wi = (d_cont_wi_bar)/(d_cont_wi_max);
	contention = ((N_Vehicles*contention_wl)+(N_RSUs*contention_wi))/(total_size);
	//contention = contention_wl;
}


class SimpleUdpApplication : public Application 
  {
    public:
      SimpleUdpApplication ();
      virtual ~SimpleUdpApplication ();

      static TypeId GetTypeId ();
      virtual TypeId GetInstanceTypeId () const;

      /** \brief handles incoming packets on port 7777
       */
      void HandleReadOne (Ptr<Socket> socket);

      /** \brief handles incoming packets on port 9999
       */
      void HandleReadTwo (Ptr<Socket> socket);

      /** \brief Send an outgoing packet. This creates a new socket every time (not the best solution)
      */
      void SendPacket (Ptr<Packet> packet, Ipv4Address destination, uint16_t port);
      void test();

    private:
      
      
      void SetupReceiveSocket (Ptr<Socket> socket, uint16_t port);
      virtual void StartApplication ();


      Ptr<Socket> m_recv_socket1; /**< A socket to receive on a specific port */
      Ptr<Socket> m_recv_socket2; /**< A socket to receive on a specific port */
      uint16_t m_port1; 
      uint16_t m_port2;

      Ptr<Socket> m_send_socket; /**< A socket to listen on a specific port */
  };

#endif

#define PURPLE_CODE "\033[95m"
#define CYAN_CODE "\033[96m"
#define TEAL_CODE "\033[36m"
#define BLUE_CODE "\033[94m"
#define GREEN_CODE "\033[32m"
#define YELLOW_CODE "\033[33m"
#define LIGHT_YELLOW_CODE "\033[93m"
#define RED_CODE "\033[91m"
#define BOLD_CODE "\033[1m"
#define END_CODE "\033[0m"


bool Z_gurobi[total_size+2];
bool X_gurobi[total_size+2];

bool Z_nodes[total_size+2];
bool X_nodes[total_size+2];


  //NS_LOG_COMPONENT_DEFINE("SimpleUdpApplication");
  NS_OBJECT_ENSURE_REGISTERED(SimpleUdpApplication);

  TypeId
  SimpleUdpApplication::GetTypeId()
  {
    static TypeId tid = TypeId("ns3::SimpleUdpApplication")
                            .AddConstructor<SimpleUdpApplication>()
                            .SetParent<Application>();
    return tid;
  }

  TypeId
  SimpleUdpApplication::GetInstanceTypeId() const
  {
    return SimpleUdpApplication::GetTypeId();
  }

  SimpleUdpApplication::SimpleUdpApplication()
  {
    m_port1 = 7777;
    m_port2 = 9999;
  }
  SimpleUdpApplication::~SimpleUdpApplication()
  {
  }
  void SimpleUdpApplication::SetupReceiveSocket(Ptr<Socket> socket, uint16_t port)
  {
    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), port);
    if (socket->Bind(local) == -1)
    {
      NS_FATAL_ERROR("Failed to bind socket");
    }
  }
  void SimpleUdpApplication::StartApplication()
  {
    //Receive sockets
    TypeId tid = TypeId::LookupByName("ns3::UdpSocketFactory");
    m_recv_socket1 = Socket::CreateSocket(GetNode(), tid);
    m_recv_socket2 = Socket::CreateSocket(GetNode(), tid);

    SetupReceiveSocket(m_recv_socket1, m_port1);
    SetupReceiveSocket(m_recv_socket2, m_port2);

    m_recv_socket1->SetRecvCallback(MakeCallback(&SimpleUdpApplication::HandleReadOne, this));
    m_recv_socket2->SetRecvCallback(MakeCallback(&SimpleUdpApplication::HandleReadTwo, this));

    //Send Socket
    m_send_socket = Socket::CreateSocket(GetNode(), tid);
    
    m_recv_socket1->SetAllowBroadcast(true);
    m_recv_socket2->SetAllowBroadcast(true);
    m_send_socket->SetAllowBroadcast(true);
  }

  void SimpleUdpApplication::HandleReadOne(Ptr<Socket> socket)
  {
    //NS_LOG_FUNCTION(this << socket);
    //cout<<"Received a packet";
    Ptr<Packet> packet;
    Address from;
    Address localAddress;
    Ptr <Node> no = DynamicCast <Node> (socket->GetNode());
    uint32_t nid = uint32_t(no->GetId());
    while ((packet = socket->RecvFrom(from)))
    {
      //NS_LOG_INFO(PURPLE_CODE << "HandleReadOne : Received a Packet of size: " << packet->GetSize() << " at time " << Now().GetSeconds() << END_CODE);
      NS_LOG_INFO(packet->ToString());
      
      
      CustomDataUnicastTag_Routing tag_routing;
	if (!((paper == 1) && (architecture == 1)))
	{
		if(packet->PeekPacketTag(tag_routing))
		{
			uint32_t node_index = tag_routing.GetsenderId();
			uint32_t destination = tag_routing.GetdestinationId() + 2;
			uint32_t * source = tag_routing.GetNodeId();
			Y[*source - 2] = Y[*source - 2] - 1;
			packets_received_wi[*source - 2] = packets_received_wi[*source - 2] + 1;
			double delay = Now().GetMicroSeconds()-tag_routing.GetTimestamp()->GetMicroSeconds();
			one_hop_delay_training_wi[*source - 2] = one_hop_delay_training_wi[*source - 2] + delay;
			cout<<"1-hop delay wired is "<<delay<<endl;
			
			if (nid != destination)
			{
				//uint32_t next_hop = routing_tables[nid -2].rows[destination-2].next_hop;
				uint32_t next_hop = find_next_hop(node_index,destination-2,nid -2);
				cout<<endl<<"next hop from routing table is "<< next_hop <<endl;
				if (next_hop == (*source -2))
				{
					cout<<"routing loop. stopping routing"<<endl;
				}
				else if (next_hop < total_size)
				{
					Ptr <Packet> packet_i = Create<Packet> (packet_additional_size);
					tag_routing.SetNodeId(&nid);
					Time ti = MicroSeconds(Simulator::Now().GetMicroSeconds());
					tag_routing.SetTimestamp(&ti);
					packet_i->AddPacketTag(tag_routing);
					
					if (((nid-2) > N_Vehicles) && (next_hop > N_Vehicles))
					{
						Ptr <Node> nu = DynamicCast <Node> (RSU_Nodes.Get(nid-2-N_Vehicles));	
				  		Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (RSU_apps.Get(nid-2-N_Vehicles));
				  		cout<<"Ethernet data Unicasting from node "<<nid - 2<<endl;
						
						Ptr <Ipv4> ipv4;  	
					  	ipv4 = RSU_Nodes.Get(next_hop-N_Vehicles)->GetObject<Ipv4>();
					  	Ipv4InterfaceAddress iaddr;
					  	if(N_Vehicles > 0)
					  	{
							iaddr = ipv4->GetAddress(1,0);//2nd IPv4 interface,0th address index
						}
						else if (N_Vehicles == 0)
						{
							iaddr = ipv4->GetAddress(0,0);//1st IPv4 interface,0th address index
						}
						Ipv4Address dest_ip = iaddr.GetLocal();	
						ethernet_total_packet_size = ethernet_total_packet_size + packet_i->GetSerializedSize();
						Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet_i,dest_ip,7777);
					}
					
					else
					{
						Ptr <NetDevice> destination_nd = wifidevices.Get(next_hop);
						Address addr = destination_nd->GetAddress();
						Mac48Address dest_address = Mac48Address::ConvertFrom(addr);
						//cout <<endl<<"MAC address of next hop node "<<next_hop<<" is "<<dest_address<<endl;
					  	uint16_t protocolwave = 0x88dc;//
						Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (wifidevices.Get(nid -2));
						cout<<"DSRC data Unicasting from node "<<nid - 2<<endl;
						dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
						Simulator::Schedule (Seconds(0.000000) , &WifiNetDevice::Send, wdi, packet_i, dest_address, protocolwave);
					}
					
					Y[nid - 2] = Y[nid - 2] + 1;	
					//cout<<"dsrc total size is "<<dsrc_total_packet_size<<endl;
				}
			}
			if (nid == destination)
			{
				cout<<"packet successfully delivered to destination node"<<nid - 2<<endl;
				dsrc_packet_final_timestamp[node_index+2] = Simulator::Now().GetSeconds();
				std::cout << "Received data unicasted packet from "<< tag_routing.GetsenderId()<<"to node "<<nid -2 <<"of size "<<tag_routing.GetSerializedSize()<<" at position "<< *tag_routing.Getposition()<<"with velocity "<<*tag_routing.Getvelocity()<<"with acceleration "<<*tag_routing.Getacceleration()<<"packet timestamp "<< tag_routing.GetTimestamp()->GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tag_routing.GetTimestamp()->GetMicroSeconds()<<"us"<<std::endl;
			}
		}
	}
	
	CustomDeltavaluesDownlinkUnicastTag tagroutingsolution;
	if(packet->PeekPacketTag(tagroutingsolution))
	{	
		double (*delta_Set)[total_size];
		uint32_t * sources;
		uint32_t * destinations;
		uint32_t * flow_ids;
		uint32_t * flow_sizes;
		double * load_sum;
		uint32_t nodeid = tagroutingsolution.Getnodeid();
		delta_Set = tagroutingsolution.Getdeltas();
		sources = tagroutingsolution.Getsources();
		destinations = tagroutingsolution.Getdestinations();
		flow_ids = tagroutingsolution.Getflow_ids();
		flow_sizes = tagroutingsolution.Getflow_sizes();
		load_sum = tagroutingsolution.Getload();
		for(uint32_t i=0;i<2*flows;i++)
		{
			for(uint32_t j=0;j<total_size;j++)	
			{
				(delta_at_nodes_inst+i)->delta_fi_inst[nodeid].delta_values[j] = delta_Set[i][j];
				//cout<< "i = "<<i<<"nid = "<<nid<<"j= "<<j<<"value="<<(delta_at_controller_inst+i)->delta_fi_inst[nid-2].delta_values[j]<<endl;
			}
		       (delta_at_nodes_inst+i)->source_f = sources[i];
		       (delta_at_nodes_inst+i)->destination_f = destinations[i];
		       (delta_at_nodes_inst+i)->flow_id = flow_ids[i];
		       (demanding_flow_struct_nodes_inst+i)->f_size = flow_sizes[i];
		       (load_at_nodes+i)->load_f[nodeid] = load_sum[i];
		}
		
		//cout<<"Received deltas and load values at node: "<<nodeid<<"at timestamp: "<<Now().GetMilliSeconds()<<endl;
		
	
		//cout<<"delta value of flow "<< (delta_at_nodes_inst+0)->flow_id<<"node id "<<nodeid<<", next hop 1 with flow size "<<(demanding_flow_struct_nodes_inst+0)->f_size<<" is "<<(delta_at_nodes_inst+0)->delta_fi_inst[nodeid].delta_values[1]<<"and Load sum is "<< (load_at_nodes+0)->load_f[nodeid]<<"source is "<<(delta_at_nodes_inst+0)->source_f<<"destination is "<<(delta_at_nodes_inst+0)->destination_f<<endl;
	 //cout<<"delta value of flow "<< (delta_at_nodes_inst+1)->flow_id<<"node id "<<nodeid<<", next hop 10 with flow size "<<(demanding_flow_struct_nodes_inst+1)->f_size<<" is "<<(delta_at_nodes_inst+1)->delta_fi_inst[nodeid].delta_values[10]<<"and Load sum is "<< (load_at_nodes+1)->load_f[nodeid]<<"source is "<<(delta_at_nodes_inst+1)->source_f<<"destination is "<<(delta_at_nodes_inst+1)->destination_f<<endl;
	

	}

      	CustomStatusDataUplinkTag1 tagstatusdata;
      	
      	if(packet->PeekPacketTag(tagstatusdata))
	{		  
	          	uint32_t * nid = tagstatusdata.GetNodeId();
			Vector * posn = tagstatusdata.Getposition();
			Vector * veln = tagstatusdata.Getvelocity();
			Vector * accn = tagstatusdata.Getacceleration();

		  	(routing_data_at_controller_inst+nid[0])->nodeid = nid[0];
			(routing_data_at_controller_inst+nid[0])->acceleration = accn[0];
		  	(routing_data_at_controller_inst+nid[0])->position = posn[0];
		  	(routing_data_at_controller_inst+nid[0])->velocity = veln[0];
		 
		//std::cout << "At controller: updated nodeID "<<(routing_data_at_controller_inst+nid[0])->nodeid<<"as position "<< (routing_data_at_controller_inst+nid[0])->position<<", velocity "<<(routing_data_at_controller_inst+nid[0])->velocity<<"acceleration "<< (routing_data_at_controller_inst+nid[0])->acceleration<<"at timestamp: "<<Now().GetMilliSeconds()<<std::endl;
	}
		
	
	 CustomFlowDataUplinkTag1 tagflowstatusdata;
      	
      	if(packet->PeekPacketTag(tagflowstatusdata))
	{		  
	          	uint32_t * source = tagflowstatusdata.Getsource();
			uint32_t * destination = tagflowstatusdata.Getdestination();
			uint32_t * X = tagflowstatusdata.GetX();
			uint32_t * P = tagflowstatusdata.GetP();
			uint32_t * Q = tagflowstatusdata.GetQ();
			
			for(uint32_t i=0;i< (2*flows);i++)
			{
		  		(demanding_flow_struct_controller_inst+i)->source = source[i];
				(demanding_flow_struct_controller_inst+i)->destination = destination[i];
				
		  		(demanding_flow_struct_controller_inst+i)->f_size = X[i];
		  		(demanding_flow_struct_controller_inst+i)->p_size = P[i];
		  		(demanding_flow_struct_controller_inst+i)->qos = Q[i];
		  		
		  	
		  		std::cout << "At controller: updated flow source "<<(demanding_flow_struct_controller_inst+i)->source<<"to destination "<< (demanding_flow_struct_controller_inst+i)->destination<<"flow size "<<(demanding_flow_struct_controller_inst+i)->f_size<<"packet size "<< (demanding_flow_struct_controller_inst+i)->p_size<<"QoS "<<(demanding_flow_struct_controller_inst+i)->qos <<std::endl;
		  	}
		 	

	}
      	

      
      CustomDataTag tag;
	if(packet->PeekPacketTag(tag))
	{
		std::cout << "Received packet from "<< tag.GetNodeId()<<"to node "<<nid <<"of total size"<<packet->GetSerializedSize()<<"at position "<< tag.GetPosition()<<"with velocity "<<tag.GetVelocity()<<"and acceleration"<<tag.GetAcceleration()<<"packet timestamp "<< tag.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMilliSeconds()-tag.GetTimestamp().GetMilliSeconds()<<"ms"<<std::endl;
	}
	
	CustomMetaDataBroadcastTag tag2;
	if(packet->PeekPacketTag(tag2))
	{
		std::cout << "Received packet from "<< tag2.GetNodeId()<<"to node "<<nid <<"of total size"<<packet->GetSerializedSize()<<"packet timestamp "<< tag2.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMilliSeconds()-tag2.GetTimestamp().GetMilliSeconds()<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag0 tag30;
	if(packet->PeekPacketTag(tag30))
	{		  
	          uint32_t source_node_id = tag30.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag30.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag30.GetTimestamp().GetMilliSeconds())/10);
		  }
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  //cout<<"nid is "<<source_node_id<<"frequency is "<< tag3.Getfrequency()<<" datasize "<<tag3.Getdatasize()<<"serialized size" <<tag3.GetSerializedSize()<<endl;
		  //(con_data_inst+source_node_id)->frequency = tag30.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag30.Getdatasize();

		 (con_data_inst+source_node_id)->neighborsize = 0;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag30.GetNodeId()<<" of size "<<tag30.GetSerializedSize()<<"packet timestamp "<< tag30.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	CustomMetaDataUnicastTag1 tag31;
	if(packet->PeekPacketTag(tag31))
	{		  
	          uint32_t source_node_id = tag31.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag31.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag31.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag31.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag31.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max1; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag31.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag31.Getcombinedcost()+i);
		  }
		 (con_data_inst+source_node_id)->neighborsize = 1;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag31.GetNodeId()<<" of size "<<tag31.GetSerializedSize()<<"packet timestamp "<< tag31.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag2 tag32;
	if(packet->PeekPacketTag(tag32))
	{		  
	          uint32_t source_node_id = tag32.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag32.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag32.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag32.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag32.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max2; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag32.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag32.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 2;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag32.GetNodeId()<<" of size "<<tag32.GetSerializedSize()<<"packet timestamp "<< tag32.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag3 tag33;
	if(packet->PeekPacketTag(tag33))
	{		  
	          uint32_t source_node_id = tag33.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag33.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag33.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag33.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag33.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max3; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag33.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag33.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 3;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag33.GetNodeId()<<" of size "<<tag33.GetSerializedSize()<<"packet timestamp "<< tag33.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag4 tag34;
	if(packet->PeekPacketTag(tag34))
	{		  
	          uint32_t source_node_id = tag34.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag34.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag34.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag34.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag34.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max4; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag34.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag34.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 4;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag34.GetNodeId()<<" of size "<<tag34.GetSerializedSize()<<"packet timestamp "<< tag34.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag5 tag35;
	if(packet->PeekPacketTag(tag35))
	{		  
	          uint32_t source_node_id = tag35.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag35.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag35.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag35.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag35.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max5; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag35.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag35.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 5;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag35.GetNodeId()<<" of size "<<tag35.GetSerializedSize()<<"packet timestamp "<< tag35.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag6 tag36;
	if(packet->PeekPacketTag(tag36))
	{		  
	          uint32_t source_node_id = tag36.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag36.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag36.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag36.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag36.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max6; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag36.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag36.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 6;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag36.GetNodeId()<<" of size "<<tag36.GetSerializedSize()<<"packet timestamp "<< tag36.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag7 tag37;
	if(packet->PeekPacketTag(tag37))
	{		  
	          uint32_t source_node_id = tag37.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag37.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag37.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag37.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag37.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max7; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag37.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag37.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 7;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag37.GetNodeId()<<" of size "<<tag37.GetSerializedSize()<<"packet timestamp "<< tag37.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag8 tag38;
	if(packet->PeekPacketTag(tag38))
	{		  
	          uint32_t source_node_id = tag38.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag38.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag38.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag38.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag38.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max8; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag38.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag38.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 8;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag38.GetNodeId()<<" of size "<<tag38.GetSerializedSize()<<"packet timestamp "<< tag38.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag9 tag39;
	if(packet->PeekPacketTag(tag39))
	{		  
	          uint32_t source_node_id = tag39.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag39.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag39.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag39.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag39.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max9; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag39.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag39.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 9;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag39.GetNodeId()<<" of size "<<tag39.GetSerializedSize()<<"packet timestamp "<< tag39.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag10 tag310;
	if(packet->PeekPacketTag(tag310))
	{		  
	          uint32_t source_node_id = tag310.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag310.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag310.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag310.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag310.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max10; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag310.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag310.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 10;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag310.GetNodeId()<<" of size "<<tag310.GetSerializedSize()<<"packet timestamp "<< tag310.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag11 tag311;
	if(packet->PeekPacketTag(tag311))
	{		  
	          uint32_t source_node_id = tag311.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag311.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag311.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag311.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag311.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max11; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag311.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag311.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 11;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag311.GetNodeId()<<" of size "<<tag311.GetSerializedSize()<<"packet timestamp "<< tag311.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag12 tag312;
	if(packet->PeekPacketTag(tag312))
	{		  
	          uint32_t source_node_id = tag312.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag312.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag312.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag312.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag312.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max12; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag312.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag312.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 12;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag312.GetNodeId()<<" of size "<<tag312.GetSerializedSize()<<"packet timestamp "<< tag312.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag13 tag313;
	if(packet->PeekPacketTag(tag313))
	{		  
	          uint32_t source_node_id = tag313.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag313.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag313.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag313.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag313.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max13; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag313.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag313.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 13;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag313.GetNodeId()<<" of size "<<tag313.GetSerializedSize()<<"packet timestamp "<< tag313.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag14 tag314;
	if(packet->PeekPacketTag(tag314))
	{		  
	          uint32_t source_node_id = tag314.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag314.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag314.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag314.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag314.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max14; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag314.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag314.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 14;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag314.GetNodeId()<<" of size "<<tag314.GetSerializedSize()<<"packet timestamp "<< tag314.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag15 tag315;
	if(packet->PeekPacketTag(tag315))
	{		  
	          uint32_t source_node_id = tag315.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag315.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag315.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag315.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag315.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max15; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag315.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag315.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 15;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag315.GetNodeId()<<" of size "<<tag315.GetSerializedSize()<<"packet timestamp "<< tag315.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag16 tag316;
	if(packet->PeekPacketTag(tag316))
	{		  
	          uint32_t source_node_id = tag316.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag316.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag316.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag316.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag316.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max16; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag316.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag316.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 16;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag316.GetNodeId()<<" of size "<<tag316.GetSerializedSize()<<"packet timestamp "<< tag316.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag17 tag317;
	if(packet->PeekPacketTag(tag317))
	{		  
	          uint32_t source_node_id = tag317.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag317.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag317.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag317.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag317.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max17; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag317.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag317.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 17;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag317.GetNodeId()<<" of size "<<tag317.GetSerializedSize()<<"packet timestamp "<< tag317.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	CustomMetaDataUnicastTag18 tag318;
	if(packet->PeekPacketTag(tag318))
	{		  
	          uint32_t source_node_id = tag318.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag318.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag318.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag318.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag318.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max18; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag318.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag318.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 18;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag318.GetNodeId()<<" of size "<<tag318.GetSerializedSize()<<"packet timestamp "<< tag318.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag19 tag319;
	if(packet->PeekPacketTag(tag319))
	{		  
	          uint32_t source_node_id = tag319.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag319.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag319.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag319.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag319.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max19; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag319.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag319.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 19;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag319.GetNodeId()<<" of size "<<tag319.GetSerializedSize()<<"packet timestamp "<< tag319.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag20 tag320;
	if(packet->PeekPacketTag(tag320))
	{		  
	          uint32_t source_node_id = tag320.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag320.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag320.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag320.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag320.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max20; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag320.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag320.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 20;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag320.GetNodeId()<<" of size "<<tag320.GetSerializedSize()<<"packet timestamp "<< tag320.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	
	CustomMetaDataUnicastTag21 tag321;
	if(packet->PeekPacketTag(tag321))
	{		  
	          uint32_t source_node_id = tag321.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag321.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag321.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag321.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag321.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max21; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag321.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag321.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 21;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag321.GetNodeId()<<" of size "<<tag321.GetSerializedSize()<<"packet timestamp "<< tag321.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag22 tag322;
	if(packet->PeekPacketTag(tag322))
	{		  
	          uint32_t source_node_id = tag322.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag322.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag322.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag322.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag322.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max22; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag322.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag322.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 22;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag322.GetNodeId()<<" of size "<<tag322.GetSerializedSize()<<"packet timestamp "<< tag322.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	
	CustomMetaDataUnicastTag23 tag323;
	if(packet->PeekPacketTag(tag323))
	{		  
	          uint32_t source_node_id = tag323.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag323.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag323.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag323.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag323.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max23; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag323.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag323.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 23;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag323.GetNodeId()<<" of size "<<tag323.GetSerializedSize()<<"packet timestamp "<< tag323.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	
	CustomMetaDataUnicastTag24 tag324;
	if(packet->PeekPacketTag(tag324))
	{		  
	          uint32_t source_node_id = tag324.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag324.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag324.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag324.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag324.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max24; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag324.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag324.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 24;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag324.GetNodeId()<<" of size "<<tag324.GetSerializedSize()<<"packet timestamp "<< tag324.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	
	CustomMetaDataUnicastTag25 tag325;
	if(packet->PeekPacketTag(tag325))
	{		  
	          uint32_t source_node_id = tag325.GetNodeId();
		  if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag325.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + uint32_t((Now().GetMilliSeconds()-tag325.GetTimestamp().GetMilliSeconds())/10);
		  }
		  //(con_data_inst+source_node_id)->frequency = tag325.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag325.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  for(int i=0; i<max25; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag325.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag325.Getcombinedcost()+i);

		  }
		 (con_data_inst+source_node_id)->neighborsize = 25;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag325.GetNodeId()<<" of size "<<tag325.GetSerializedSize()<<"packet timestamp "<< tag325.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTag tag3;
	if(packet->PeekPacketTag(tag3))
	{		  
	          uint32_t source_node_id = tag3.GetNodeId();
	          if (source_node_id < (2 + N_Vehicles))
	          {
	          	lte_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 40 + (Now().GetMilliSeconds()-tag3.GetTimestamp().GetMilliSeconds());
		  }
		  else if (source_node_id < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
	          	packet_final_timestamp[source_node_id] = Simulator::Now().GetSeconds();
		  	(con_data_inst+source_node_id)->B = 1 + (Now().GetMilliSeconds()-tag3.GetTimestamp().GetMilliSeconds());
		  }
		  //(con_data_inst+source_node_id)->frequency = tag3.Getfrequency();
		  //(con_data_inst+source_node_id)->datasize = tag3.Getdatasize();
		  (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tag3.Getneighborid()+i);
		  	//(con_data_inst+source_node_id)->combined_cost[i] = *(tag3.Getcombinedcost()+i);
		  	if (*(tag3.Getneighborid()+i) != large)
		  	{
		  		neighborsize++;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received packet from "<< tag3.GetNodeId()<<" of size "<<tag3.GetSerializedSize()<<"packet timestamp "<< tag3.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< (con_data_inst+source_node_id)->B<<"ms"<<std::endl;
	}
	
	CustomMetaDataUnicastTagN011 tagN011;

	
	if(packet->PeekPacketTag(tagN011))
	{		  
	          uint32_t source_node_id = tagN011.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN011.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN011.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN012 tagN012;
	
	if(packet->PeekPacketTag(tagN012))
	{		  
	          uint32_t source_node_id = tagN012.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN012.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN012.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN013 tagN013;

	
	if(packet->PeekPacketTag(tagN013))
	{		  
	          uint32_t source_node_id = tagN013.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN013.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN013.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN014 tagN014;

	
	if(packet->PeekPacketTag(tagN014))
	{		  
	          uint32_t source_node_id = tagN014.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN014.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN014.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN015 tagN015;

	
	if(packet->PeekPacketTag(tagN015))
	{		  
	          uint32_t source_node_id = tagN015.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN015.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN015.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN016 tagN016;

	
	if(packet->PeekPacketTag(tagN016))
	{		  
	          uint32_t source_node_id = tagN016.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN016.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN016.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN017 tagN017;

	
	if(packet->PeekPacketTag(tagN017))
	{		  
	          uint32_t source_node_id = tagN017.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN017.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN017.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN018 tagN018;

	
	if(packet->PeekPacketTag(tagN018))
	{		  
	          uint32_t source_node_id = tagN018.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN018.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN018.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN019 tagN019;

	
	if(packet->PeekPacketTag(tagN019))
	{		  
	          uint32_t source_node_id = tagN019.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN019.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN019.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0110 tagN0110;

	
	if(packet->PeekPacketTag(tagN0110))
	{		  
	          uint32_t source_node_id = tagN0110.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0110.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0110.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0111 tagN0111;

	
	if(packet->PeekPacketTag(tagN0111))
	{		  
	          uint32_t source_node_id = tagN0111.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0111.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0111.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0112 tagN0112;

	
	if(packet->PeekPacketTag(tagN0112))
	{		  
	          uint32_t source_node_id = tagN0112.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0112.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0112.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0113 tagN0113;

	
	if(packet->PeekPacketTag(tagN0113))
	{		  
	          uint32_t source_node_id = tagN0113.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0113.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0113.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0114 tagN0114;

	
	if(packet->PeekPacketTag(tagN0114))
	{		  
	          uint32_t source_node_id = tagN0114.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0114.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0114.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0115 tagN0115;
	
	
	if(packet->PeekPacketTag(tagN0115))
	{		  
	          uint32_t source_node_id = tagN0115.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0115.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0115.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0116 tagN0116;
	
	
	if(packet->PeekPacketTag(tagN0116))
	{		  
	          uint32_t source_node_id = tagN0116.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0116.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0116.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0117 tagN0117;
	
	
	if(packet->PeekPacketTag(tagN0117))
	{		  
	          uint32_t source_node_id = tagN0117.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0117.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0117.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN0118 tagN0118;
	
	
	if(packet->PeekPacketTag(tagN0118))
	{		  
	          uint32_t source_node_id = tagN0118.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0118.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0118.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN0119 tagN0119;
	
	
	if(packet->PeekPacketTag(tagN0119))
	{		  
	          uint32_t source_node_id = tagN0119.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0119.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0119.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0120 tagN0120;
	if(packet->PeekPacketTag(tagN0120))
	{		  
	          uint32_t source_node_id = tagN0120.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0120.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0120.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0121 tagN0121;
	if(packet->PeekPacketTag(tagN0121))
	{		  
	          uint32_t source_node_id = tagN0121.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0121.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0121.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN0122 tagN0122;
	if(packet->PeekPacketTag(tagN0122))
	{		  
	          uint32_t source_node_id = tagN0122.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0122.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0122.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0123 tagN0123;
	if(packet->PeekPacketTag(tagN0123))
	{		  
	          uint32_t source_node_id = tagN0123.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0123.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0123.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0124 tagN0124;
	if(packet->PeekPacketTag(tagN0124))
	{		  
	          uint32_t source_node_id = tagN0124.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0124.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0124.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0125 tagN0125;
	if(packet->PeekPacketTag(tagN0125))
	{		  
	          uint32_t source_node_id = tagN0125.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0125.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0125.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN01max tagN01max;
	
	if(packet->PeekPacketTag(tagN01max))
	{		  
	          uint32_t source_node_id = tagN01max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN01max.Getneighborid()+i) != large) and (*(tagN01max.Getneighborid()+i) > 1) and (*(tagN01max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN01max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();		
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN01max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN021 tagN021;

	
	if(packet->PeekPacketTag(tagN021))
	{		  
	          uint32_t source_node_id = tagN021.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN021.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN021.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN022 tagN022;
	
	if(packet->PeekPacketTag(tagN022))
	{		  
	          uint32_t source_node_id = tagN022.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN022.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN022.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN023 tagN023;

	
	if(packet->PeekPacketTag(tagN023))
	{		  
	          uint32_t source_node_id = tagN023.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN023.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN023.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN024 tagN024;

	
	if(packet->PeekPacketTag(tagN024))
	{		  
	          uint32_t source_node_id = tagN024.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN024.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN024.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN025 tagN025;

	
	if(packet->PeekPacketTag(tagN025))
	{		  
	          uint32_t source_node_id = tagN025.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN025.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN025.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN026 tagN026;

	
	if(packet->PeekPacketTag(tagN026))
	{		  
	          uint32_t source_node_id = tagN026.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN026.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN026.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN027 tagN027;

	
	if(packet->PeekPacketTag(tagN027))
	{		  
	          uint32_t source_node_id = tagN027.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN027.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN027.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN028 tagN028;

	
	if(packet->PeekPacketTag(tagN028))
	{		  
	          uint32_t source_node_id = tagN028.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN028.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN028.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN029 tagN029;

	
	if(packet->PeekPacketTag(tagN029))
	{		  
	          uint32_t source_node_id = tagN029.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN029.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN029.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0210 tagN0210;

	
	if(packet->PeekPacketTag(tagN0210))
	{		  
	          uint32_t source_node_id = tagN0210.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0210.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0210.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0211 tagN0211;

	
	if(packet->PeekPacketTag(tagN0211))
	{		  
	          uint32_t source_node_id = tagN0211.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0211.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0211.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0212 tagN0212;

	
	if(packet->PeekPacketTag(tagN0212))
	{		  
	          uint32_t source_node_id = tagN0212.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0212.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0212.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0213 tagN0213;

	
	if(packet->PeekPacketTag(tagN0213))
	{		  
	          uint32_t source_node_id = tagN0213.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0213.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0213.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0214 tagN0214;

	
	if(packet->PeekPacketTag(tagN0214))
	{		  
	          uint32_t source_node_id = tagN0214.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0214.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0214.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0215 tagN0215;
	
	
	if(packet->PeekPacketTag(tagN0215))
	{		  
	          uint32_t source_node_id = tagN0215.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0215.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0215.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0216 tagN0216;
	
	
	if(packet->PeekPacketTag(tagN0216))
	{		  
	          uint32_t source_node_id = tagN0216.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0216.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0216.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0217 tagN0217;
	
	
	if(packet->PeekPacketTag(tagN0217))
	{		  
	          uint32_t source_node_id = tagN0217.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0217.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0217.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN0218 tagN0218;
	
	
	if(packet->PeekPacketTag(tagN0218))
	{		  
	          uint32_t source_node_id = tagN0218.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0218.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0218.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN0219 tagN0219;
	
	
	if(packet->PeekPacketTag(tagN0219))
	{		  
	          uint32_t source_node_id = tagN0219.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0219.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0219.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN0220 tagN0220;
	
	
	if(packet->PeekPacketTag(tagN0220))
	{		  
	          uint32_t source_node_id = tagN0220.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0220.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0220.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0221 tagN0221;
	if(packet->PeekPacketTag(tagN0221))
	{		  
	          uint32_t source_node_id = tagN0221.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0221.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0221.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN0222 tagN0222;
	if(packet->PeekPacketTag(tagN0222))
	{		  
	          uint32_t source_node_id = tagN0222.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0222.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0222.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0223 tagN0223;
	if(packet->PeekPacketTag(tagN0223))
	{		  
	          uint32_t source_node_id = tagN0223.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0223.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0223.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0224 tagN0224;
	if(packet->PeekPacketTag(tagN0224))
	{		  
	          uint32_t source_node_id = tagN0224.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0224.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0224.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN0225 tagN0225;
	if(packet->PeekPacketTag(tagN0225))
	{		  
	          uint32_t source_node_id = tagN0225.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN0225.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN0225.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2max tagN2max;
	
	if(packet->PeekPacketTag(tagN2max))
	{		  
	          uint32_t source_node_id = tagN2max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN2max.Getneighborid()+i) != large) and (*(tagN2max.Getneighborid()+i) > 1) and (*(tagN2max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();		
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN31 tagN31;

	
	if(packet->PeekPacketTag(tagN31))
	{		  
	          uint32_t source_node_id = tagN31.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN31.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN31.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN32 tagN32;
	
	if(packet->PeekPacketTag(tagN32))
	{		  
	          uint32_t source_node_id = tagN32.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN32.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN32.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN33 tagN33;

	
	if(packet->PeekPacketTag(tagN33))
	{		  
	          uint32_t source_node_id = tagN33.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN33.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN33.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN34 tagN34;

	
	if(packet->PeekPacketTag(tagN34))
	{		  
	          uint32_t source_node_id = tagN34.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN34.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN34.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN35 tagN35;

	
	if(packet->PeekPacketTag(tagN35))
	{		  
	          uint32_t source_node_id = tagN35.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN35.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN35.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN36 tagN36;

	
	if(packet->PeekPacketTag(tagN36))
	{		  
	          uint32_t source_node_id = tagN36.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN36.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN36.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN37 tagN37;

	
	if(packet->PeekPacketTag(tagN37))
	{		  
	          uint32_t source_node_id = tagN37.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN37.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN37.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN38 tagN38;

	
	if(packet->PeekPacketTag(tagN38))
	{		  
	          uint32_t source_node_id = tagN38.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN38.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN38.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN39 tagN39;

	
	if(packet->PeekPacketTag(tagN39))
	{		  
	          uint32_t source_node_id = tagN39.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN39.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN39.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN310 tagN310;

	
	if(packet->PeekPacketTag(tagN310))
	{		  
	          uint32_t source_node_id = tagN310.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN310.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN310.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN311 tagN311;

	
	if(packet->PeekPacketTag(tagN311))
	{		  
	          uint32_t source_node_id = tagN311.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN311.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN311.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN312 tagN312;

	
	if(packet->PeekPacketTag(tagN312))
	{		  
	          uint32_t source_node_id = tagN312.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN312.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN312.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN313 tagN313;

	
	if(packet->PeekPacketTag(tagN313))
	{		  
	          uint32_t source_node_id = tagN313.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN313.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN313.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN314 tagN314;

	
	if(packet->PeekPacketTag(tagN314))
	{		  
	          uint32_t source_node_id = tagN314.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN314.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN314.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN315 tagN315;
	
	
	if(packet->PeekPacketTag(tagN315))
	{		  
	          uint32_t source_node_id = tagN315.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN315.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN315.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN316 tagN316;
	
	
	if(packet->PeekPacketTag(tagN316))
	{		  
	          uint32_t source_node_id = tagN316.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN316.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN316.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN317 tagN317;
	
	
	if(packet->PeekPacketTag(tagN317))
	{		  
	          uint32_t source_node_id = tagN317.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN317.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN317.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN318 tagN318;
	
	
	if(packet->PeekPacketTag(tagN318))
	{		  
	          uint32_t source_node_id = tagN318.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN318.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN318.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN319 tagN319;
	
	
	if(packet->PeekPacketTag(tagN319))
	{		  
	          uint32_t source_node_id = tagN319.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN319.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN319.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN320 tagN320;
	
	
	if(packet->PeekPacketTag(tagN320))
	{		  
	          uint32_t source_node_id = tagN320.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN320.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN320.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN321 tagN321;
	if(packet->PeekPacketTag(tagN321))
	{		  
	          uint32_t source_node_id = tagN321.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN321.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN321.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN322 tagN322;
	if(packet->PeekPacketTag(tagN322))
	{		  
	          uint32_t source_node_id = tagN322.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN322.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN322.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN323 tagN323;
	if(packet->PeekPacketTag(tagN323))
	{		  
	          uint32_t source_node_id = tagN323.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN323.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN323.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN324 tagN324;
	if(packet->PeekPacketTag(tagN324))
	{		  
	          uint32_t source_node_id = tagN324.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN324.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN324.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN325 tagN325;
	if(packet->PeekPacketTag(tagN325))
	{		  
	          uint32_t source_node_id = tagN325.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN325.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN325.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN3max tagN3max;
	
	if(packet->PeekPacketTag(tagN3max))
	{		  
	          uint32_t source_node_id = tagN3max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN3max.Getneighborid()+i) != large) and (*(tagN3max.Getneighborid()+i) > 1) and (*(tagN3max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN3max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();		
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN3max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN41 tagN41;

	
	if(packet->PeekPacketTag(tagN41))
	{		  
	          uint32_t source_node_id = tagN41.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN41.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN41.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN42 tagN42;
	
	if(packet->PeekPacketTag(tagN42))
	{		  
	          uint32_t source_node_id = tagN42.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN42.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN42.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN43 tagN43;

	
	if(packet->PeekPacketTag(tagN43))
	{		  
	          uint32_t source_node_id = tagN43.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN43.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN43.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN44 tagN44;

	
	if(packet->PeekPacketTag(tagN44))
	{		  
	          uint32_t source_node_id = tagN44.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN44.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN44.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN45 tagN45;

	
	if(packet->PeekPacketTag(tagN45))
	{		  
	          uint32_t source_node_id = tagN45.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN45.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN45.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN46 tagN46;

	
	if(packet->PeekPacketTag(tagN46))
	{		  
	          uint32_t source_node_id = tagN46.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN46.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN46.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN47 tagN47;

	
	if(packet->PeekPacketTag(tagN47))
	{		  
	          uint32_t source_node_id = tagN47.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN47.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN47.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN48 tagN48;

	
	if(packet->PeekPacketTag(tagN48))
	{		  
	          uint32_t source_node_id = tagN48.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN48.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN48.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN49 tagN49;

	
	if(packet->PeekPacketTag(tagN49))
	{		  
	          uint32_t source_node_id = tagN49.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN49.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN49.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN410 tagN410;

	
	if(packet->PeekPacketTag(tagN410))
	{		  
	          uint32_t source_node_id = tagN410.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN410.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN410.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN411 tagN411;

	
	if(packet->PeekPacketTag(tagN411))
	{		  
	          uint32_t source_node_id = tagN411.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN411.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN411.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN412 tagN412;

	
	if(packet->PeekPacketTag(tagN412))
	{		  
	          uint32_t source_node_id = tagN412.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN412.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN412.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN413 tagN413;

	
	if(packet->PeekPacketTag(tagN413))
	{		  
	          uint32_t source_node_id = tagN413.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN413.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN413.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN414 tagN414;

	
	if(packet->PeekPacketTag(tagN414))
	{		  
	          uint32_t source_node_id = tagN414.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN414.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN414.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN415 tagN415;
	
	
	if(packet->PeekPacketTag(tagN415))
	{		  
	          uint32_t source_node_id = tagN415.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN415.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN415.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN416 tagN416;
	
	
	if(packet->PeekPacketTag(tagN416))
	{		  
	          uint32_t source_node_id = tagN416.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN416.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN416.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN417 tagN417;
	
	
	if(packet->PeekPacketTag(tagN417))
	{		  
	          uint32_t source_node_id = tagN417.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN417.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN417.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN418 tagN418;
	
	
	if(packet->PeekPacketTag(tagN418))
	{		  
	          uint32_t source_node_id = tagN418.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN418.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN418.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN419 tagN419;
	
	
	if(packet->PeekPacketTag(tagN419))
	{		  
	          uint32_t source_node_id = tagN419.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN419.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN419.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN420 tagN420;
	
	
	if(packet->PeekPacketTag(tagN420))
	{		  
	          uint32_t source_node_id = tagN420.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN420.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN420.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN421 tagN421;
	if(packet->PeekPacketTag(tagN421))
	{		  
	          uint32_t source_node_id = tagN421.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN421.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN421.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN422 tagN422;
	if(packet->PeekPacketTag(tagN422))
	{		  
	          uint32_t source_node_id = tagN422.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN422.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN422.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN423 tagN423;
	if(packet->PeekPacketTag(tagN423))
	{		  
	          uint32_t source_node_id = tagN423.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN423.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN423.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN424 tagN424;
	if(packet->PeekPacketTag(tagN424))
	{		  
	          uint32_t source_node_id = tagN424.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN424.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN424.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN425 tagN425;
	if(packet->PeekPacketTag(tagN425))
	{		  
	          uint32_t source_node_id = tagN425.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN425.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN425.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN4max tagN4max;
	
	if(packet->PeekPacketTag(tagN4max))
	{		  
	          uint32_t source_node_id = tagN4max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN4max.Getneighborid()+i) != large) and (*(tagN4max.Getneighborid()+i) > 1) and (*(tagN4max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN4max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN4max.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN51 tagN51;

	
	if(packet->PeekPacketTag(tagN51))
	{		  
	          uint32_t source_node_id = tagN51.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN51.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN51.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN52 tagN52;
	
	if(packet->PeekPacketTag(tagN52))
	{		  
	          uint32_t source_node_id = tagN52.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN52.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN52.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN53 tagN53;

	
	if(packet->PeekPacketTag(tagN53))
	{		  
	          uint32_t source_node_id = tagN53.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN53.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN53.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN54 tagN54;

	
	if(packet->PeekPacketTag(tagN54))
	{		  
	          uint32_t source_node_id = tagN54.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN54.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN54.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN55 tagN55;

	
	if(packet->PeekPacketTag(tagN55))
	{		  
	          uint32_t source_node_id = tagN55.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN55.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN55.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN56 tagN56;

	
	if(packet->PeekPacketTag(tagN56))
	{		  
	          uint32_t source_node_id = tagN56.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN56.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN56.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN57 tagN57;

	
	if(packet->PeekPacketTag(tagN57))
	{		  
	          uint32_t source_node_id = tagN57.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN57.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN57.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN58 tagN58;

	
	if(packet->PeekPacketTag(tagN58))
	{		  
	          uint32_t source_node_id = tagN58.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN58.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN58.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN59 tagN59;

	
	if(packet->PeekPacketTag(tagN59))
	{		  
	          uint32_t source_node_id = tagN59.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN59.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN59.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN510 tagN510;

	
	if(packet->PeekPacketTag(tagN510))
	{		  
	          uint32_t source_node_id = tagN510.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN510.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN510.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN511 tagN511;

	
	if(packet->PeekPacketTag(tagN511))
	{		  
	          uint32_t source_node_id = tagN511.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN511.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN511.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN512 tagN512;

	
	if(packet->PeekPacketTag(tagN512))
	{		  
	          uint32_t source_node_id = tagN512.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN512.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN512.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN513 tagN513;

	
	if(packet->PeekPacketTag(tagN513))
	{		  
	          uint32_t source_node_id = tagN513.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN513.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN513.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN514 tagN514;

	
	if(packet->PeekPacketTag(tagN514))
	{		  
	          uint32_t source_node_id = tagN514.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN514.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN514.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN515 tagN515;
	
	
	if(packet->PeekPacketTag(tagN515))
	{		  
	          uint32_t source_node_id = tagN515.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN515.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN515.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN516 tagN516;
	
	
	if(packet->PeekPacketTag(tagN516))
	{		  
	          uint32_t source_node_id = tagN516.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN516.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN516.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN517 tagN517;
	
	
	if(packet->PeekPacketTag(tagN517))
	{		  
	          uint32_t source_node_id = tagN517.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN517.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN517.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN518 tagN518;
	
	
	if(packet->PeekPacketTag(tagN518))
	{		  
	          uint32_t source_node_id = tagN518.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN518.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN518.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN519 tagN519;
	
	
	if(packet->PeekPacketTag(tagN519))
	{		  
	          uint32_t source_node_id = tagN519.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN519.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN519.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN520 tagN520;
	
	
	if(packet->PeekPacketTag(tagN520))
	{		  
	          uint32_t source_node_id = tagN520.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN520.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN520.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN521 tagN521;
	if(packet->PeekPacketTag(tagN521))
	{		  
	          uint32_t source_node_id = tagN521.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN521.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN521.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN522 tagN522;
	if(packet->PeekPacketTag(tagN522))
	{		  
	          uint32_t source_node_id = tagN522.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN522.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN522.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN523 tagN523;
	if(packet->PeekPacketTag(tagN523))
	{		  
	          uint32_t source_node_id = tagN523.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN523.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN523.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN524 tagN524;
	if(packet->PeekPacketTag(tagN524))
	{		  
	          uint32_t source_node_id = tagN524.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN524.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN524.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN525 tagN525;
	if(packet->PeekPacketTag(tagN525))
	{		  
	          uint32_t source_node_id = tagN525.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN525.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN525.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN5max tagN5max;
	
	if(packet->PeekPacketTag(tagN5max))
	{		  
	          uint32_t source_node_id = tagN5max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN5max.Getneighborid()+i) != large) and (*(tagN5max.Getneighborid()+i) > 1) and (*(tagN5max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN5max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();		
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN5max.Getnodeid()<<std::endl;
	}


	CustomMetaDataUnicastTagN61 tagN61;

	
	if(packet->PeekPacketTag(tagN61))
	{		  
	          uint32_t source_node_id = tagN61.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN61.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN61.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN62 tagN62;
	
	if(packet->PeekPacketTag(tagN62))
	{		  
	          uint32_t source_node_id = tagN62.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN62.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN62.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN63 tagN63;

	
	if(packet->PeekPacketTag(tagN63))
	{		  
	          uint32_t source_node_id = tagN63.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN63.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN63.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN64 tagN64;

	
	if(packet->PeekPacketTag(tagN64))
	{		  
	          uint32_t source_node_id = tagN64.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN64.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN64.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN65 tagN65;

	
	if(packet->PeekPacketTag(tagN65))
	{		  
	          uint32_t source_node_id = tagN65.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN65.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN65.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN66 tagN66;

	
	if(packet->PeekPacketTag(tagN66))
	{		  
	          uint32_t source_node_id = tagN66.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN66.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN66.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN67 tagN67;

	
	if(packet->PeekPacketTag(tagN67))
	{		  
	          uint32_t source_node_id = tagN67.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN67.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN67.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN68 tagN68;

	
	if(packet->PeekPacketTag(tagN68))
	{		  
	          uint32_t source_node_id = tagN68.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN68.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN68.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN69 tagN69;

	
	if(packet->PeekPacketTag(tagN69))
	{		  
	          uint32_t source_node_id = tagN69.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN69.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN69.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN610 tagN610;

	
	if(packet->PeekPacketTag(tagN610))
	{		  
	          uint32_t source_node_id = tagN610.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN610.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN610.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN611 tagN611;

	
	if(packet->PeekPacketTag(tagN611))
	{		  
	          uint32_t source_node_id = tagN611.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN611.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN611.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN612 tagN612;

	
	if(packet->PeekPacketTag(tagN612))
	{		  
	          uint32_t source_node_id = tagN612.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN612.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN612.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN613 tagN613;

	
	if(packet->PeekPacketTag(tagN613))
	{		  
	          uint32_t source_node_id = tagN613.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN613.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN613.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN614 tagN614;

	
	if(packet->PeekPacketTag(tagN614))
	{		  
	          uint32_t source_node_id = tagN614.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN614.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN614.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN615 tagN615;
	
	
	if(packet->PeekPacketTag(tagN615))
	{		  
	          uint32_t source_node_id = tagN615.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN615.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN615.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN616 tagN616;
	
	
	if(packet->PeekPacketTag(tagN616))
	{		  
	          uint32_t source_node_id = tagN616.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN616.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN616.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN617 tagN617;
	
	
	if(packet->PeekPacketTag(tagN617))
	{		  
	          uint32_t source_node_id = tagN617.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN617.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN617.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN618 tagN618;
	
	
	if(packet->PeekPacketTag(tagN618))
	{		  
	          uint32_t source_node_id = tagN618.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN618.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN618.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN619 tagN619;
	
	
	if(packet->PeekPacketTag(tagN619))
	{		  
	          uint32_t source_node_id = tagN619.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN619.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN619.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN620 tagN620;
	
	
	if(packet->PeekPacketTag(tagN620))
	{		  
	          uint32_t source_node_id = tagN620.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN620.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN620.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN621 tagN621;
	if(packet->PeekPacketTag(tagN621))
	{		  
	          uint32_t source_node_id = tagN621.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN621.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN621.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN622 tagN622;
	if(packet->PeekPacketTag(tagN622))
	{		  
	          uint32_t source_node_id = tagN622.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN622.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN622.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN623 tagN623;
	if(packet->PeekPacketTag(tagN623))
	{		  
	          uint32_t source_node_id = tagN623.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN623.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN623.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN624 tagN624;
	if(packet->PeekPacketTag(tagN624))
	{		  
	          uint32_t source_node_id = tagN624.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN624.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN624.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN625 tagN625;
	if(packet->PeekPacketTag(tagN625))
	{		  
	          uint32_t source_node_id = tagN625.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN625.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN625.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN6max tagN6max;
	
	if(packet->PeekPacketTag(tagN6max))
	{		  
	          uint32_t source_node_id = tagN6max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN6max.Getneighborid()+i) != large) and (*(tagN6max.Getneighborid()+i) > 1) and (*(tagN6max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN6max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();		
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN6max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN71 tagN71;

	
	if(packet->PeekPacketTag(tagN71))
	{		  
	          uint32_t source_node_id = tagN71.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN71.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN71.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN72 tagN72;
	
	if(packet->PeekPacketTag(tagN72))
	{		  
	          uint32_t source_node_id = tagN72.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN72.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN72.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN73 tagN73;

	
	if(packet->PeekPacketTag(tagN73))
	{		  
	          uint32_t source_node_id = tagN73.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN73.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN73.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN74 tagN74;

	
	if(packet->PeekPacketTag(tagN74))
	{		  
	          uint32_t source_node_id = tagN74.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN74.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN74.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN75 tagN75;

	
	if(packet->PeekPacketTag(tagN75))
	{		  
	          uint32_t source_node_id = tagN75.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN75.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN75.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN76 tagN76;

	
	if(packet->PeekPacketTag(tagN76))
	{		  
	          uint32_t source_node_id = tagN76.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN76.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN76.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN77 tagN77;

	
	if(packet->PeekPacketTag(tagN77))
	{		  
	          uint32_t source_node_id = tagN77.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN77.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN77.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN78 tagN78;

	
	if(packet->PeekPacketTag(tagN78))
	{		  
	          uint32_t source_node_id = tagN78.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN78.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN78.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN79 tagN79;

	
	if(packet->PeekPacketTag(tagN79))
	{		  
	          uint32_t source_node_id = tagN79.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN79.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN79.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN710 tagN710;

	
	if(packet->PeekPacketTag(tagN710))
	{		  
	          uint32_t source_node_id = tagN710.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN710.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN710.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN711 tagN711;

	
	if(packet->PeekPacketTag(tagN711))
	{		  
	          uint32_t source_node_id = tagN711.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN711.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN711.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN712 tagN712;

	
	if(packet->PeekPacketTag(tagN712))
	{		  
	          uint32_t source_node_id = tagN712.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN712.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN712.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN713 tagN713;

	
	if(packet->PeekPacketTag(tagN713))
	{		  
	          uint32_t source_node_id = tagN713.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN713.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN713.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN714 tagN714;

	
	if(packet->PeekPacketTag(tagN714))
	{		  
	          uint32_t source_node_id = tagN714.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN714.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN714.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN715 tagN715;
	
	
	if(packet->PeekPacketTag(tagN715))
	{		  
	          uint32_t source_node_id = tagN715.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN715.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN715.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN716 tagN716;
	
	
	if(packet->PeekPacketTag(tagN716))
	{		  
	          uint32_t source_node_id = tagN716.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN716.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN716.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN717 tagN717;
	
	
	if(packet->PeekPacketTag(tagN717))
	{		  
	          uint32_t source_node_id = tagN717.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN717.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN717.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN718 tagN718;
	
	
	if(packet->PeekPacketTag(tagN718))
	{		  
	          uint32_t source_node_id = tagN718.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN718.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN718.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN719 tagN719;
	
	
	if(packet->PeekPacketTag(tagN719))
	{		  
	          uint32_t source_node_id = tagN719.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN719.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN719.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN720 tagN720;
	
	
	if(packet->PeekPacketTag(tagN720))
	{		  
	          uint32_t source_node_id = tagN720.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN720.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN720.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN721 tagN721;
	if(packet->PeekPacketTag(tagN721))
	{		  
	          uint32_t source_node_id = tagN721.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN721.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN721.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN722 tagN722;
	if(packet->PeekPacketTag(tagN722))
	{		  
	          uint32_t source_node_id = tagN722.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN722.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN722.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN723 tagN723;
	if(packet->PeekPacketTag(tagN723))
	{		  
	          uint32_t source_node_id = tagN723.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN723.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN723.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN724 tagN724;
	if(packet->PeekPacketTag(tagN724))
	{		  
	          uint32_t source_node_id = tagN724.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN724.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN724.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN725 tagN725;
	if(packet->PeekPacketTag(tagN725))
	{		  
	          uint32_t source_node_id = tagN725.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN725.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN725.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN7max tagN7max;
	
	if(packet->PeekPacketTag(tagN7max))
	{		  
	          uint32_t source_node_id = tagN7max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN7max.Getneighborid()+i) != large) and (*(tagN7max.Getneighborid()+i) > 1) and (*(tagN7max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN7max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN7max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN81 tagN81;

	
	if(packet->PeekPacketTag(tagN81))
	{		  
	          uint32_t source_node_id = tagN81.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN81.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN81.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN82 tagN82;
	
	if(packet->PeekPacketTag(tagN82))
	{		  
	          uint32_t source_node_id = tagN82.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN82.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN82.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN83 tagN83;

	
	if(packet->PeekPacketTag(tagN83))
	{		  
	          uint32_t source_node_id = tagN83.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN83.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN83.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN84 tagN84;

	
	if(packet->PeekPacketTag(tagN84))
	{		  
	          uint32_t source_node_id = tagN84.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN84.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN84.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN85 tagN85;

	
	if(packet->PeekPacketTag(tagN85))
	{		  
	          uint32_t source_node_id = tagN85.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN85.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN85.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN86 tagN86;

	
	if(packet->PeekPacketTag(tagN86))
	{		  
	          uint32_t source_node_id = tagN86.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN86.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN86.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN87 tagN87;

	
	if(packet->PeekPacketTag(tagN87))
	{		  
	          uint32_t source_node_id = tagN87.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN87.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN87.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN88 tagN88;

	
	if(packet->PeekPacketTag(tagN88))
	{		  
	          uint32_t source_node_id = tagN88.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN88.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN88.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN89 tagN89;

	
	if(packet->PeekPacketTag(tagN89))
	{		  
	          uint32_t source_node_id = tagN89.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN89.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN89.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN810 tagN810;

	
	if(packet->PeekPacketTag(tagN810))
	{		  
	          uint32_t source_node_id = tagN810.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN810.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN810.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN811 tagN811;

	
	if(packet->PeekPacketTag(tagN811))
	{		  
	          uint32_t source_node_id = tagN811.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN811.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN811.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN812 tagN812;

	
	if(packet->PeekPacketTag(tagN812))
	{		  
	          uint32_t source_node_id = tagN812.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN812.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN812.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN813 tagN813;

	
	if(packet->PeekPacketTag(tagN813))
	{		  
	          uint32_t source_node_id = tagN813.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN813.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN813.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN814 tagN814;

	
	if(packet->PeekPacketTag(tagN814))
	{		  
	          uint32_t source_node_id = tagN814.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN814.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN814.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN815 tagN815;
	
	
	if(packet->PeekPacketTag(tagN815))
	{		  
	          uint32_t source_node_id = tagN815.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN815.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN815.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN816 tagN816;
	
	
	if(packet->PeekPacketTag(tagN816))
	{		  
	          uint32_t source_node_id = tagN816.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN816.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN816.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN817 tagN817;
	
	
	if(packet->PeekPacketTag(tagN817))
	{		  
	          uint32_t source_node_id = tagN817.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN817.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN817.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN818 tagN818;
	
	
	if(packet->PeekPacketTag(tagN818))
	{		  
	          uint32_t source_node_id = tagN818.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN818.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN818.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN819 tagN819;
	
	
	if(packet->PeekPacketTag(tagN819))
	{		  
	          uint32_t source_node_id = tagN819.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN819.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN819.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN820 tagN820;
	
	
	if(packet->PeekPacketTag(tagN820))
	{		  
	          uint32_t source_node_id = tagN820.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN820.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN820.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN821 tagN821;
	if(packet->PeekPacketTag(tagN821))
	{		  
	          uint32_t source_node_id = tagN821.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN821.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN821.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN822 tagN822;
	if(packet->PeekPacketTag(tagN822))
	{		  
	          uint32_t source_node_id = tagN822.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN822.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN822.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN823 tagN823;
	if(packet->PeekPacketTag(tagN823))
	{		  
	          uint32_t source_node_id = tagN823.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN823.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN823.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN824 tagN824;
	if(packet->PeekPacketTag(tagN824))
	{		  
	          uint32_t source_node_id = tagN824.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN824.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN824.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN825 tagN825;
	if(packet->PeekPacketTag(tagN825))
	{		  
	          uint32_t source_node_id = tagN825.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN825.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN825.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN8max tagN8max;
	
	if(packet->PeekPacketTag(tagN8max))
	{		  
	          uint32_t source_node_id = tagN8max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN8max.Getneighborid()+i) != large) and (*(tagN8max.Getneighborid()+i) > 1) and (*(tagN8max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN8max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();		
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN8max.Getnodeid()<<std::endl;
	}

	CustomMetaDataUnicastTagN91 tagN91;

	
	if(packet->PeekPacketTag(tagN91))
	{		  
	          uint32_t source_node_id = tagN91.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN91.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN91.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN92 tagN92;
	
	if(packet->PeekPacketTag(tagN92))
	{		  
	          uint32_t source_node_id = tagN92.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN92.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN92.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN93 tagN93;

	
	if(packet->PeekPacketTag(tagN93))
	{		  
	          uint32_t source_node_id = tagN93.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN93.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN93.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN94 tagN94;

	
	if(packet->PeekPacketTag(tagN94))
	{		  
	          uint32_t source_node_id = tagN94.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN94.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN94.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN95 tagN95;

	
	if(packet->PeekPacketTag(tagN95))
	{		  
	          uint32_t source_node_id = tagN95.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN95.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN95.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN96 tagN96;

	
	if(packet->PeekPacketTag(tagN96))
	{		  
	          uint32_t source_node_id = tagN96.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN96.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN96.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN97 tagN97;

	
	if(packet->PeekPacketTag(tagN97))
	{		  
	          uint32_t source_node_id = tagN97.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN97.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN97.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN98 tagN98;

	
	if(packet->PeekPacketTag(tagN98))
	{		  
	          uint32_t source_node_id = tagN98.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN98.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN98.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN99 tagN99;

	
	if(packet->PeekPacketTag(tagN99))
	{		  
	          uint32_t source_node_id = tagN99.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN99.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN99.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN910 tagN910;

	
	if(packet->PeekPacketTag(tagN910))
	{		  
	          uint32_t source_node_id = tagN910.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN910.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN910.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN911 tagN911;

	
	if(packet->PeekPacketTag(tagN911))
	{		  
	          uint32_t source_node_id = tagN911.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN911.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN911.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN912 tagN912;

	
	if(packet->PeekPacketTag(tagN912))
	{		  
	          uint32_t source_node_id = tagN912.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN912.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN912.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN913 tagN913;

	
	if(packet->PeekPacketTag(tagN913))
	{		  
	          uint32_t source_node_id = tagN913.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN913.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN913.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN914 tagN914;

	
	if(packet->PeekPacketTag(tagN914))
	{		  
	          uint32_t source_node_id = tagN914.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN914.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN914.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN915 tagN915;
	
	
	if(packet->PeekPacketTag(tagN915))
	{		  
	          uint32_t source_node_id = tagN915.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN915.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN915.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN916 tagN916;
	
	
	if(packet->PeekPacketTag(tagN916))
	{		  
	          uint32_t source_node_id = tagN916.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN916.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN916.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN917 tagN917;
	
	
	if(packet->PeekPacketTag(tagN917))
	{		  
	          uint32_t source_node_id = tagN917.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN917.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN917.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN918 tagN918;
	
	
	if(packet->PeekPacketTag(tagN918))
	{		  
	          uint32_t source_node_id = tagN918.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN918.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN918.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN919 tagN919;
	
	
	if(packet->PeekPacketTag(tagN919))
	{		  
	          uint32_t source_node_id = tagN919.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN919.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN919.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN920 tagN920;
	
	
	if(packet->PeekPacketTag(tagN920))
	{		  
	          uint32_t source_node_id = tagN920.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN920.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN920.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN921 tagN921;
	if(packet->PeekPacketTag(tagN921))
	{		  
	          uint32_t source_node_id = tagN921.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN921.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN921.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN922 tagN922;
	if(packet->PeekPacketTag(tagN922))
	{		  
	          uint32_t source_node_id = tagN922.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN922.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN922.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN923 tagN923;
	if(packet->PeekPacketTag(tagN923))
	{		  
	          uint32_t source_node_id = tagN923.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN923.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN923.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN924 tagN924;
	if(packet->PeekPacketTag(tagN924))
	{		  
	          uint32_t source_node_id = tagN924.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN924.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN924.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN925 tagN925;
	if(packet->PeekPacketTag(tagN925))
	{		  
	          uint32_t source_node_id = tagN925.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN925.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN925.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN9max tagN9max;
	
	if(packet->PeekPacketTag(tagN9max))
	{		  
	          uint32_t source_node_id = tagN9max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN9max.Getneighborid()+i) != large) and (*(tagN9max.Getneighborid()+i) > 1) and (*(tagN9max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN9max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();		
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN9max.Getnodeid()<<std::endl;
	}

	CustomMetaDataUnicastTagN101 tagN101;

	
	if(packet->PeekPacketTag(tagN101))
	{		  
	          uint32_t source_node_id = tagN101.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN101.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN101.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN102 tagN102;
	
	if(packet->PeekPacketTag(tagN102))
	{		  
	          uint32_t source_node_id = tagN102.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN102.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN102.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN103 tagN103;

	
	if(packet->PeekPacketTag(tagN103))
	{		  
	          uint32_t source_node_id = tagN103.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN103.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN103.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN104 tagN104;

	
	if(packet->PeekPacketTag(tagN104))
	{		  
	          uint32_t source_node_id = tagN104.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN104.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN104.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN105 tagN105;

	
	if(packet->PeekPacketTag(tagN105))
	{		  
	          uint32_t source_node_id = tagN105.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN105.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN105.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN106 tagN106;

	
	if(packet->PeekPacketTag(tagN106))
	{		  
	          uint32_t source_node_id = tagN106.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN106.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN106.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN107 tagN107;

	
	if(packet->PeekPacketTag(tagN107))
	{		  
	          uint32_t source_node_id = tagN107.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN107.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN107.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN108 tagN108;

	
	if(packet->PeekPacketTag(tagN108))
	{		  
	          uint32_t source_node_id = tagN108.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN108.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN108.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN109 tagN109;

	
	if(packet->PeekPacketTag(tagN109))
	{		  
	          uint32_t source_node_id = tagN109.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN109.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN109.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1010 tagN1010;

	
	if(packet->PeekPacketTag(tagN1010))
	{		  
	          uint32_t source_node_id = tagN1010.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1010.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1010.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1011 tagN1011;

	
	if(packet->PeekPacketTag(tagN1011))
	{		  
	          uint32_t source_node_id = tagN1011.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1011.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1011.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1012 tagN1012;

	
	if(packet->PeekPacketTag(tagN1012))
	{		  
	          uint32_t source_node_id = tagN1012.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1012.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1012.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1013 tagN1013;

	
	if(packet->PeekPacketTag(tagN1013))
	{		  
	          uint32_t source_node_id = tagN1013.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1013.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1013.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1014 tagN1014;

	
	if(packet->PeekPacketTag(tagN1014))
	{		  
	          uint32_t source_node_id = tagN1014.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1014.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1014.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1015 tagN1015;
	
	
	if(packet->PeekPacketTag(tagN1015))
	{		  
	          uint32_t source_node_id = tagN1015.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1015.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1015.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1016 tagN1016;
	
	
	if(packet->PeekPacketTag(tagN1016))
	{		  
	          uint32_t source_node_id = tagN1016.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1016.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1016.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1017 tagN1017;
	
	
	if(packet->PeekPacketTag(tagN1017))
	{		  
	          uint32_t source_node_id = tagN1017.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1017.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1017.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1018 tagN1018;
	
	
	if(packet->PeekPacketTag(tagN1018))
	{		  
	          uint32_t source_node_id = tagN1018.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1018.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1018.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1019 tagN1019;
	
	
	if(packet->PeekPacketTag(tagN1019))
	{		  
	          uint32_t source_node_id = tagN1019.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1019.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1019.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1020 tagN1020;
	
	
	if(packet->PeekPacketTag(tagN1020))
	{		  
	          uint32_t source_node_id = tagN1020.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1020.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1020.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1021 tagN1021;
	if(packet->PeekPacketTag(tagN1021))
	{		  
	          uint32_t source_node_id = tagN1021.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1021.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1021.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN1022 tagN1022;
	if(packet->PeekPacketTag(tagN1022))
	{		  
	          uint32_t source_node_id = tagN1022.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1022.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1022.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1023 tagN1023;
	if(packet->PeekPacketTag(tagN1023))
	{		  
	          uint32_t source_node_id = tagN1023.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1023.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1023.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1024 tagN1024;
	if(packet->PeekPacketTag(tagN1024))
	{		  
	          uint32_t source_node_id = tagN1024.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1024.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1024.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1025 tagN1025;
	if(packet->PeekPacketTag(tagN1025))
	{		  
	          uint32_t source_node_id = tagN1025.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1025.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1025.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN10max tagN10max;
	
	if(packet->PeekPacketTag(tagN10max))
	{		  
	          uint32_t source_node_id = tagN10max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	(con_data_inst+source_node_id)->neighborid[i] = *(tagN10max.Getneighborid()+i);
		  	if ((*(tagN10max.Getneighborid()+i) != large) and (*(tagN10max.Getneighborid()+i) > 1) and (*(tagN10max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN10max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN10max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN111 tagN111;

	
	if(packet->PeekPacketTag(tagN111))
	{		  
	          uint32_t source_node_id = tagN111.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN111.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN111.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN112 tagN112;
	
	if(packet->PeekPacketTag(tagN112))
	{		  
	          uint32_t source_node_id = tagN112.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN112.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN112.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN113 tagN113;

	
	if(packet->PeekPacketTag(tagN113))
	{		  
	          uint32_t source_node_id = tagN113.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN113.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN113.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN114 tagN114;

	
	if(packet->PeekPacketTag(tagN114))
	{		  
	          uint32_t source_node_id = tagN114.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN114.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN114.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN115 tagN115;

	
	if(packet->PeekPacketTag(tagN115))
	{		  
	          uint32_t source_node_id = tagN115.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN115.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN115.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN116 tagN116;

	
	if(packet->PeekPacketTag(tagN116))
	{		  
	          uint32_t source_node_id = tagN116.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN116.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN116.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN117 tagN117;

	
	if(packet->PeekPacketTag(tagN117))
	{		  
	          uint32_t source_node_id = tagN117.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN117.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN117.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN118 tagN118;

	
	if(packet->PeekPacketTag(tagN118))
	{		  
	          uint32_t source_node_id = tagN118.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN118.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN118.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN119 tagN119;

	
	if(packet->PeekPacketTag(tagN119))
	{		  
	          uint32_t source_node_id = tagN119.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN119.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN119.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1110 tagN1110;

	
	if(packet->PeekPacketTag(tagN1110))
	{		  
	          uint32_t source_node_id = tagN1110.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1110.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1110.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1111 tagN1111;

	
	if(packet->PeekPacketTag(tagN1111))
	{		  
	          uint32_t source_node_id = tagN1111.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1111.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1111.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1112 tagN1112;

	
	if(packet->PeekPacketTag(tagN1112))
	{		  
	          uint32_t source_node_id = tagN1112.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1112.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1112.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1113 tagN1113;

	
	if(packet->PeekPacketTag(tagN1113))
	{		  
	          uint32_t source_node_id = tagN1113.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1113.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1113.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1114 tagN1114;

	
	if(packet->PeekPacketTag(tagN1114))
	{		  
	          uint32_t source_node_id = tagN1114.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1114.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1114.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1115 tagN1115;
	
	
	if(packet->PeekPacketTag(tagN1115))
	{		  
	          uint32_t source_node_id = tagN1115.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1115.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1115.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1116 tagN1116;
	
	
	if(packet->PeekPacketTag(tagN1116))
	{		  
	          uint32_t source_node_id = tagN1116.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1116.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1116.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1117 tagN1117;
	
	
	if(packet->PeekPacketTag(tagN1117))
	{		  
	          uint32_t source_node_id = tagN1117.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1117.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1117.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1118 tagN1118;
	
	
	if(packet->PeekPacketTag(tagN1118))
	{		  
	          uint32_t source_node_id = tagN1118.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1118.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1118.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1119 tagN1119;
	
	
	if(packet->PeekPacketTag(tagN1119))
	{		  
	          uint32_t source_node_id = tagN1119.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1119.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1119.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1120 tagN1120;
	
	
	if(packet->PeekPacketTag(tagN1120))
	{		  
	          uint32_t source_node_id = tagN1120.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1120.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1120.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1121 tagN1121;
	if(packet->PeekPacketTag(tagN1121))
	{		  
	          uint32_t source_node_id = tagN1121.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1121.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1121.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN1122 tagN1122;
	if(packet->PeekPacketTag(tagN1122))
	{		  
	          uint32_t source_node_id = tagN1122.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1122.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1122.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1123 tagN1123;
	if(packet->PeekPacketTag(tagN1123))
	{		  
	          uint32_t source_node_id = tagN1123.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1123.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1123.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1124 tagN1124;
	if(packet->PeekPacketTag(tagN1124))
	{		  
	          uint32_t source_node_id = tagN1124.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1124.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1124.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1125 tagN1125;
	if(packet->PeekPacketTag(tagN1125))
	{		  
	          uint32_t source_node_id = tagN1125.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1125.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1125.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN11max tagN11max;
	
	if(packet->PeekPacketTag(tagN11max))
	{		  
	          uint32_t source_node_id = tagN11max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN11max.Getneighborid()+i) != large) and (*(tagN11max.Getneighborid()+i) > 1) and (*(tagN11max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN11max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();		
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN11max.Getnodeid()<<std::endl;
	}

	CustomMetaDataUnicastTagN121 tagN121;

	
	if(packet->PeekPacketTag(tagN121))
	{		  
	          uint32_t source_node_id = tagN121.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN121.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN121.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN122 tagN122;
	
	if(packet->PeekPacketTag(tagN122))
	{		  
	          uint32_t source_node_id = tagN122.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN122.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN122.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN123 tagN123;

	
	if(packet->PeekPacketTag(tagN123))
	{		  
	          uint32_t source_node_id = tagN123.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN123.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN123.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN124 tagN124;

	
	if(packet->PeekPacketTag(tagN124))
	{		  
	          uint32_t source_node_id = tagN124.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN124.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN124.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN125 tagN125;

	
	if(packet->PeekPacketTag(tagN125))
	{		  
	          uint32_t source_node_id = tagN125.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN125.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN125.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN126 tagN126;

	
	if(packet->PeekPacketTag(tagN126))
	{		  
	          uint32_t source_node_id = tagN126.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN126.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN126.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN127 tagN127;

	
	if(packet->PeekPacketTag(tagN127))
	{		  
	          uint32_t source_node_id = tagN127.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN127.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN127.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN128 tagN128;

	
	if(packet->PeekPacketTag(tagN128))
	{		  
	          uint32_t source_node_id = tagN128.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN128.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN128.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN129 tagN129;

	
	if(packet->PeekPacketTag(tagN129))
	{		  
	          uint32_t source_node_id = tagN129.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN129.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN129.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1210 tagN1210;

	
	if(packet->PeekPacketTag(tagN1210))
	{		  
	          uint32_t source_node_id = tagN1210.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1210.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1210.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1211 tagN1211;

	
	if(packet->PeekPacketTag(tagN1211))
	{		  
	          uint32_t source_node_id = tagN1211.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1211.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1211.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1212 tagN1212;

	
	if(packet->PeekPacketTag(tagN1212))
	{		  
	          uint32_t source_node_id = tagN1212.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1212.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1212.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1213 tagN1213;

	
	if(packet->PeekPacketTag(tagN1213))
	{		  
	          uint32_t source_node_id = tagN1213.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1213.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1213.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1214 tagN1214;

	
	if(packet->PeekPacketTag(tagN1214))
	{		  
	          uint32_t source_node_id = tagN1214.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1214.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1214.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1215 tagN1215;
	
	
	if(packet->PeekPacketTag(tagN1215))
	{		  
	          uint32_t source_node_id = tagN1215.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1215.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1215.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1216 tagN1216;
	
	
	if(packet->PeekPacketTag(tagN1216))
	{		  
	          uint32_t source_node_id = tagN1216.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1216.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1216.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1217 tagN1217;
	
	
	if(packet->PeekPacketTag(tagN1217))
	{		  
	          uint32_t source_node_id = tagN1217.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1217.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1217.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1218 tagN1218;
	
	
	if(packet->PeekPacketTag(tagN1218))
	{		  
	          uint32_t source_node_id = tagN1218.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1218.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1218.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1219 tagN1219;
	
	
	if(packet->PeekPacketTag(tagN1219))
	{		  
	          uint32_t source_node_id = tagN1219.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1219.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1219.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1220 tagN1220;
	
	
	if(packet->PeekPacketTag(tagN1220))
	{		  
	          uint32_t source_node_id = tagN1220.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1220.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1220.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1221 tagN1221;
	if(packet->PeekPacketTag(tagN1221))
	{		  
	          uint32_t source_node_id = tagN1221.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1221.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1221.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN1222 tagN1222;
	if(packet->PeekPacketTag(tagN1222))
	{		  
	          uint32_t source_node_id = tagN1222.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1222.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1222.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1223 tagN1223;
	if(packet->PeekPacketTag(tagN1223))
	{		  
	          uint32_t source_node_id = tagN1223.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1223.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1223.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1224 tagN1224;
	if(packet->PeekPacketTag(tagN1224))
	{		  
	          uint32_t source_node_id = tagN1224.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1224.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1224.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1225 tagN1225;
	if(packet->PeekPacketTag(tagN1225))
	{		  
	          uint32_t source_node_id = tagN1225.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1225.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1225.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN12max tagN12max;
	
	if(packet->PeekPacketTag(tagN12max))
	{		  
	          uint32_t source_node_id = tagN12max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN12max.Getneighborid()+i) != large) and (*(tagN12max.Getneighborid()+i) > 1) and (*(tagN12max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN12max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;		
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN12max.Getnodeid()<<std::endl;
	}

	CustomMetaDataUnicastTagN131 tagN131;

	
	if(packet->PeekPacketTag(tagN131))
	{		  
	          uint32_t source_node_id = tagN131.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN131.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN131.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN132 tagN132;
	
	if(packet->PeekPacketTag(tagN132))
	{		  
	          uint32_t source_node_id = tagN132.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN132.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN132.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN133 tagN133;

	
	if(packet->PeekPacketTag(tagN133))
	{		  
	          uint32_t source_node_id = tagN133.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN133.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN133.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN134 tagN134;

	
	if(packet->PeekPacketTag(tagN134))
	{		  
	          uint32_t source_node_id = tagN134.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN134.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN134.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN135 tagN135;

	
	if(packet->PeekPacketTag(tagN135))
	{		  
	          uint32_t source_node_id = tagN135.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN135.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN135.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN136 tagN136;

	
	if(packet->PeekPacketTag(tagN136))
	{		  
	          uint32_t source_node_id = tagN136.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN136.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN136.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN137 tagN137;

	
	if(packet->PeekPacketTag(tagN137))
	{		  
	          uint32_t source_node_id = tagN137.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN137.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN137.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN138 tagN138;

	
	if(packet->PeekPacketTag(tagN138))
	{		  
	          uint32_t source_node_id = tagN138.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN138.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN138.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN139 tagN139;

	
	if(packet->PeekPacketTag(tagN139))
	{		  
	          uint32_t source_node_id = tagN139.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN139.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN139.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1310 tagN1310;

	
	if(packet->PeekPacketTag(tagN1310))
	{		  
	          uint32_t source_node_id = tagN1310.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1310.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1310.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1311 tagN1311;

	
	if(packet->PeekPacketTag(tagN1311))
	{		  
	          uint32_t source_node_id = tagN1311.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1311.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1311.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1312 tagN1312;

	
	if(packet->PeekPacketTag(tagN1312))
	{		  
	          uint32_t source_node_id = tagN1312.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1312.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1312.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1313 tagN1313;

	
	if(packet->PeekPacketTag(tagN1313))
	{		  
	          uint32_t source_node_id = tagN1313.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1313.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1313.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1314 tagN1314;

	
	if(packet->PeekPacketTag(tagN1314))
	{		  
	          uint32_t source_node_id = tagN1314.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1314.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1314.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1315 tagN1315;
	
	
	if(packet->PeekPacketTag(tagN1315))
	{		  
	          uint32_t source_node_id = tagN1315.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1315.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1315.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1316 tagN1316;
	
	
	if(packet->PeekPacketTag(tagN1316))
	{		  
	          uint32_t source_node_id = tagN1316.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1316.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1316.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1317 tagN1317;
	
	
	if(packet->PeekPacketTag(tagN1317))
	{		  
	          uint32_t source_node_id = tagN1317.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1317.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1317.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1318 tagN1318;
	
	
	if(packet->PeekPacketTag(tagN1318))
	{		  
	          uint32_t source_node_id = tagN1318.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1318.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1318.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1319 tagN1319;
	
	
	if(packet->PeekPacketTag(tagN1319))
	{		  
	          uint32_t source_node_id = tagN1319.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1319.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1319.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1320 tagN1320;
	
	
	if(packet->PeekPacketTag(tagN1320))
	{		  
	          uint32_t source_node_id = tagN1320.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1320.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1320.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1321 tagN1321;
	if(packet->PeekPacketTag(tagN1321))
	{		  
	          uint32_t source_node_id = tagN1321.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1321.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1321.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN1322 tagN1322;
	if(packet->PeekPacketTag(tagN1322))
	{		  
	          uint32_t source_node_id = tagN1322.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1322.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1322.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1323 tagN1323;
	if(packet->PeekPacketTag(tagN1323))
	{		  
	          uint32_t source_node_id = tagN1323.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1323.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1323.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1324 tagN1324;
	if(packet->PeekPacketTag(tagN1324))
	{		  
	          uint32_t source_node_id = tagN1324.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1324.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1324.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1325 tagN1325;
	if(packet->PeekPacketTag(tagN1325))
	{		  
	          uint32_t source_node_id = tagN1325.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1325.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1325.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN13max tagN13max;
	
	if(packet->PeekPacketTag(tagN13max))
	{		  
	          uint32_t source_node_id = tagN13max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN13max.Getneighborid()+i) != large) and (*(tagN13max.Getneighborid()+i) > 1) and (*(tagN13max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN13max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN13max.Getnodeid()<<std::endl;
	}

	CustomMetaDataUnicastTagN141 tagN141;

	
	if(packet->PeekPacketTag(tagN141))
	{		  
	          uint32_t source_node_id = tagN141.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN141.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN141.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN142 tagN142;
	
	if(packet->PeekPacketTag(tagN142))
	{		  
	          uint32_t source_node_id = tagN142.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN142.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN142.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN143 tagN143;

	
	if(packet->PeekPacketTag(tagN143))
	{		  
	          uint32_t source_node_id = tagN143.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN143.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN143.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN144 tagN144;

	
	if(packet->PeekPacketTag(tagN144))
	{		  
	          uint32_t source_node_id = tagN144.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN144.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN144.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN145 tagN145;

	
	if(packet->PeekPacketTag(tagN145))
	{		  
	          uint32_t source_node_id = tagN145.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN145.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN145.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN146 tagN146;

	
	if(packet->PeekPacketTag(tagN146))
	{		  
	          uint32_t source_node_id = tagN146.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN146.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN146.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN147 tagN147;

	
	if(packet->PeekPacketTag(tagN147))
	{		  
	          uint32_t source_node_id = tagN147.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN147.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN147.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN148 tagN148;

	
	if(packet->PeekPacketTag(tagN148))
	{		  
	          uint32_t source_node_id = tagN148.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN148.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN148.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN149 tagN149;

	
	if(packet->PeekPacketTag(tagN149))
	{		  
	          uint32_t source_node_id = tagN149.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN149.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN149.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1410 tagN1410;

	
	if(packet->PeekPacketTag(tagN1410))
	{		  
	          uint32_t source_node_id = tagN1410.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1410.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1410.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1411 tagN1411;

	
	if(packet->PeekPacketTag(tagN1411))
	{		  
	          uint32_t source_node_id = tagN1411.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1411.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1411.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1412 tagN1412;

	
	if(packet->PeekPacketTag(tagN1412))
	{		  
	          uint32_t source_node_id = tagN1412.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1412.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1412.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1413 tagN1413;

	
	if(packet->PeekPacketTag(tagN1413))
	{		  
	          uint32_t source_node_id = tagN1413.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1413.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1413.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1414 tagN1414;

	
	if(packet->PeekPacketTag(tagN1414))
	{		  
	          uint32_t source_node_id = tagN1414.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1414.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1414.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1415 tagN1415;
	
	
	if(packet->PeekPacketTag(tagN1415))
	{		  
	          uint32_t source_node_id = tagN1415.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1415.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1415.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1416 tagN1416;
	
	
	if(packet->PeekPacketTag(tagN1416))
	{		  
	          uint32_t source_node_id = tagN1416.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1416.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1416.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1417 tagN1417;
	
	
	if(packet->PeekPacketTag(tagN1417))
	{		  
	          uint32_t source_node_id = tagN1417.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1417.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1417.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1418 tagN1418;
	
	
	if(packet->PeekPacketTag(tagN1418))
	{		  
	          uint32_t source_node_id = tagN1418.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1418.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1418.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1419 tagN1419;
	
	
	if(packet->PeekPacketTag(tagN1419))
	{		  
	          uint32_t source_node_id = tagN1419.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1419.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1419.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1420 tagN1420;
	
	
	if(packet->PeekPacketTag(tagN1420))
	{		  
	          uint32_t source_node_id = tagN1420.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1420.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1420.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1421 tagN1421;
	if(packet->PeekPacketTag(tagN1421))
	{		  
	          uint32_t source_node_id = tagN1421.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1421.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1421.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN1422 tagN1422;
	if(packet->PeekPacketTag(tagN1422))
	{		  
	          uint32_t source_node_id = tagN1422.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1422.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1422.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1423 tagN1423;
	if(packet->PeekPacketTag(tagN1423))
	{		  
	          uint32_t source_node_id = tagN1423.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1423.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1423.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1424 tagN1424;
	if(packet->PeekPacketTag(tagN1424))
	{		  
	          uint32_t source_node_id = tagN1424.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1424.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1424.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1425 tagN1425;
	if(packet->PeekPacketTag(tagN1425))
	{		  
	          uint32_t source_node_id = tagN1425.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1425.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1425.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN14max tagN14max;
	
	if(packet->PeekPacketTag(tagN14max))
	{		  
	          uint32_t source_node_id = tagN14max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN14max.Getneighborid()+i) != large) and (*(tagN14max.Getneighborid()+i) > 1) and (*(tagN14max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN14max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;		
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN14max.Getnodeid()<<std::endl;
	}

	CustomMetaDataUnicastTagN151 tagN151;

	
	if(packet->PeekPacketTag(tagN151))
	{		  
	          uint32_t source_node_id = tagN151.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN151.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN151.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN152 tagN152;
	
	if(packet->PeekPacketTag(tagN152))
	{		  
	          uint32_t source_node_id = tagN152.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN152.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN152.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN153 tagN153;

	
	if(packet->PeekPacketTag(tagN153))
	{		  
	          uint32_t source_node_id = tagN153.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN153.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN153.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN154 tagN154;

	
	if(packet->PeekPacketTag(tagN154))
	{		  
	          uint32_t source_node_id = tagN154.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN154.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN154.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN155 tagN155;

	
	if(packet->PeekPacketTag(tagN155))
	{		  
	          uint32_t source_node_id = tagN155.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN155.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN155.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN156 tagN156;

	
	if(packet->PeekPacketTag(tagN156))
	{		  
	          uint32_t source_node_id = tagN156.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN156.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN156.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN157 tagN157;

	
	if(packet->PeekPacketTag(tagN157))
	{		  
	          uint32_t source_node_id = tagN157.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN157.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN157.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN158 tagN158;

	
	if(packet->PeekPacketTag(tagN158))
	{		  
	          uint32_t source_node_id = tagN158.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN158.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN158.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN159 tagN159;

	
	if(packet->PeekPacketTag(tagN159))
	{		  
	          uint32_t source_node_id = tagN159.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN159.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN159.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1510 tagN1510;

	
	if(packet->PeekPacketTag(tagN1510))
	{		  
	          uint32_t source_node_id = tagN1510.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1510.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1510.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1511 tagN1511;

	
	if(packet->PeekPacketTag(tagN1511))
	{		  
	          uint32_t source_node_id = tagN1511.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1511.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1511.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1512 tagN1512;

	
	if(packet->PeekPacketTag(tagN1512))
	{		  
	          uint32_t source_node_id = tagN1512.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1512.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1512.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1513 tagN1513;

	
	if(packet->PeekPacketTag(tagN1513))
	{		  
	          uint32_t source_node_id = tagN1513.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1513.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1513.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1514 tagN1514;

	
	if(packet->PeekPacketTag(tagN1514))
	{		  
	          uint32_t source_node_id = tagN1514.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1514.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1514.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1515 tagN1515;
	
	
	if(packet->PeekPacketTag(tagN1515))
	{		  
	          uint32_t source_node_id = tagN1515.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1515.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1515.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1516 tagN1516;
	
	
	if(packet->PeekPacketTag(tagN1516))
	{		  
	          uint32_t source_node_id = tagN1516.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1516.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1516.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1517 tagN1517;
	
	
	if(packet->PeekPacketTag(tagN1517))
	{		  
	          uint32_t source_node_id = tagN1517.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1517.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1517.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1518 tagN1518;
	
	
	if(packet->PeekPacketTag(tagN1518))
	{		  
	          uint32_t source_node_id = tagN1518.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1518.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1518.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1519 tagN1519;
	
	
	if(packet->PeekPacketTag(tagN1519))
	{		  
	          uint32_t source_node_id = tagN1519.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1519.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1519.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1520 tagN1520;
	
	
	if(packet->PeekPacketTag(tagN1520))
	{		  
	          uint32_t source_node_id = tagN1520.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1520.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1520.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1521 tagN1521;
	if(packet->PeekPacketTag(tagN1521))
	{		  
	          uint32_t source_node_id = tagN1521.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1521.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1521.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN1522 tagN1522;
	if(packet->PeekPacketTag(tagN1522))
	{		  
	          uint32_t source_node_id = tagN1522.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1522.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1522.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1523 tagN1523;
	if(packet->PeekPacketTag(tagN1523))
	{		  
	          uint32_t source_node_id = tagN1523.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1523.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1523.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1524 tagN1524;
	if(packet->PeekPacketTag(tagN1524))
	{		  
	          uint32_t source_node_id = tagN1524.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1524.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1524.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1525 tagN1525;
	if(packet->PeekPacketTag(tagN1525))
	{		  
	          uint32_t source_node_id = tagN1525.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1525.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1525.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN15max tagN15max;
	
	if(packet->PeekPacketTag(tagN15max))
	{		  
	          uint32_t source_node_id = tagN15max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN15max.Getneighborid()+i) != large) and (*(tagN15max.Getneighborid()+i) > 1) and (*(tagN15max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN15max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN15max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN161 tagN161;
	
	if(packet->PeekPacketTag(tagN161))
	{		  
	          uint32_t source_node_id = tagN161.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN161.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN161.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN162 tagN162;
	
	if(packet->PeekPacketTag(tagN162))
	{		  
	          uint32_t source_node_id = tagN162.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN162.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN162.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN163 tagN163;

	
	if(packet->PeekPacketTag(tagN163))
	{		  
	          uint32_t source_node_id = tagN163.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN163.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN163.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN164 tagN164;

	
	if(packet->PeekPacketTag(tagN164))
	{		  
	          uint32_t source_node_id = tagN164.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN164.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN164.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN165 tagN165;

	
	if(packet->PeekPacketTag(tagN165))
	{		  
	          uint32_t source_node_id = tagN165.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN165.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN165.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN166 tagN166;

	
	if(packet->PeekPacketTag(tagN166))
	{		  
	          uint32_t source_node_id = tagN166.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN166.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN166.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN167 tagN167;

	
	if(packet->PeekPacketTag(tagN167))
	{		  
	          uint32_t source_node_id = tagN167.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN167.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN167.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN168 tagN168;

	
	if(packet->PeekPacketTag(tagN168))
	{		  
	          uint32_t source_node_id = tagN168.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN168.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN168.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN169 tagN169;

	
	if(packet->PeekPacketTag(tagN169))
	{		  
	          uint32_t source_node_id = tagN169.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN169.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN169.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1610 tagN1610;

	
	if(packet->PeekPacketTag(tagN1610))
	{		  
	          uint32_t source_node_id = tagN1610.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1610.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1610.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1611 tagN1611;

	
	if(packet->PeekPacketTag(tagN1611))
	{		  
	          uint32_t source_node_id = tagN1611.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1611.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1611.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1612 tagN1612;

	
	if(packet->PeekPacketTag(tagN1612))
	{		  
	          uint32_t source_node_id = tagN1612.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1612.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1612.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1613 tagN1613;

	
	if(packet->PeekPacketTag(tagN1613))
	{		  
	          uint32_t source_node_id = tagN1613.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1613.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1613.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1614 tagN1614;

	
	if(packet->PeekPacketTag(tagN1614))
	{		  
	          uint32_t source_node_id = tagN1614.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1614.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1614.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1615 tagN1615;
	
	
	if(packet->PeekPacketTag(tagN1615))
	{		  
	          uint32_t source_node_id = tagN1615.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1615.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1615.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1616 tagN1616;
	
	
	if(packet->PeekPacketTag(tagN1616))
	{		  
	          uint32_t source_node_id = tagN1616.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1616.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1616.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1617 tagN1617;
	
	
	if(packet->PeekPacketTag(tagN1617))
	{		  
	          uint32_t source_node_id = tagN1617.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1617.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1617.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1618 tagN1618;
	
	
	if(packet->PeekPacketTag(tagN1618))
	{		  
	          uint32_t source_node_id = tagN1618.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1618.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1618.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1619 tagN1619;
	
	
	if(packet->PeekPacketTag(tagN1619))
	{		  
	          uint32_t source_node_id = tagN1619.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1619.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1619.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1620 tagN1620;
	
	
	if(packet->PeekPacketTag(tagN1620))
	{		  
	          uint32_t source_node_id = tagN1620.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1620.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1620.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1621 tagN1621;
	if(packet->PeekPacketTag(tagN1621))
	{		  
	          uint32_t source_node_id = tagN1621.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1621.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1621.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN1622 tagN1622;
	if(packet->PeekPacketTag(tagN1622))
	{		  
	          uint32_t source_node_id = tagN1622.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1622.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1622.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1623 tagN1623;
	if(packet->PeekPacketTag(tagN1623))
	{		  
	          uint32_t source_node_id = tagN1623.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1623.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1623.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1624 tagN1624;
	if(packet->PeekPacketTag(tagN1624))
	{		  
	          uint32_t source_node_id = tagN1624.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1624.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1624.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1625 tagN1625;
	if(packet->PeekPacketTag(tagN1625))
	{		  
	          uint32_t source_node_id = tagN1625.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1625.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1625.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN16max tagN16max;
	
	if(packet->PeekPacketTag(tagN16max))
	{		  
	          uint32_t source_node_id = tagN16max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN16max.Getneighborid()+i) != large) and (*(tagN16max.Getneighborid()+i) > 1) and (*(tagN16max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN16max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN16max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN171 tagN171;

	
	if(packet->PeekPacketTag(tagN171))
	{		  
	          uint32_t source_node_id = tagN171.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN171.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN171.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN172 tagN172;
	
	if(packet->PeekPacketTag(tagN172))
	{		  
	          uint32_t source_node_id = tagN172.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN172.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN172.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN173 tagN173;

	
	if(packet->PeekPacketTag(tagN173))
	{		  
	          uint32_t source_node_id = tagN173.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN173.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN173.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN174 tagN174;

	
	if(packet->PeekPacketTag(tagN174))
	{		  
	          uint32_t source_node_id = tagN174.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN174.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN174.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN175 tagN175;

	
	if(packet->PeekPacketTag(tagN175))
	{		  
	          uint32_t source_node_id = tagN175.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN175.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN175.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN176 tagN176;

	
	if(packet->PeekPacketTag(tagN176))
	{		  
	          uint32_t source_node_id = tagN176.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN176.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN176.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN177 tagN177;

	
	if(packet->PeekPacketTag(tagN177))
	{		  
	          uint32_t source_node_id = tagN177.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN177.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN177.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN178 tagN178;

	
	if(packet->PeekPacketTag(tagN178))
	{		  
	          uint32_t source_node_id = tagN178.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN178.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN178.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN179 tagN179;

	
	if(packet->PeekPacketTag(tagN179))
	{		  
	          uint32_t source_node_id = tagN179.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN179.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN179.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1710 tagN1710;

	
	if(packet->PeekPacketTag(tagN1710))
	{		  
	          uint32_t source_node_id = tagN1710.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1710.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1710.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1711 tagN1711;

	
	if(packet->PeekPacketTag(tagN1711))
	{		  
	          uint32_t source_node_id = tagN1711.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1711.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1711.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1712 tagN1712;

	
	if(packet->PeekPacketTag(tagN1712))
	{		  
	          uint32_t source_node_id = tagN1712.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1712.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1712.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1713 tagN1713;

	
	if(packet->PeekPacketTag(tagN1713))
	{		  
	          uint32_t source_node_id = tagN1713.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1713.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1713.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1714 tagN1714;

	
	if(packet->PeekPacketTag(tagN1714))
	{		  
	          uint32_t source_node_id = tagN1714.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1714.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1714.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1715 tagN1715;
	
	
	if(packet->PeekPacketTag(tagN1715))
	{		  
	          uint32_t source_node_id = tagN1715.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1715.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1715.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1716 tagN1716;
	
	
	if(packet->PeekPacketTag(tagN1716))
	{		  
	          uint32_t source_node_id = tagN1716.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1716.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1716.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1717 tagN1717;
	
	
	if(packet->PeekPacketTag(tagN1717))
	{		  
	          uint32_t source_node_id = tagN1717.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1717.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1717.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1718 tagN1718;
	
	
	if(packet->PeekPacketTag(tagN1718))
	{		  
	          uint32_t source_node_id = tagN1718.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1718.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1718.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1719 tagN1719;
	
	
	if(packet->PeekPacketTag(tagN1719))
	{		  
	          uint32_t source_node_id = tagN1719.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1719.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1719.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1720 tagN1720;
	
	
	if(packet->PeekPacketTag(tagN1720))
	{		  
	          uint32_t source_node_id = tagN1720.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1720.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1720.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1721 tagN1721;
	if(packet->PeekPacketTag(tagN1721))
	{		  
	          uint32_t source_node_id = tagN1721.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1721.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1721.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN1722 tagN1722;
	if(packet->PeekPacketTag(tagN1722))
	{		  
	          uint32_t source_node_id = tagN1722.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1722.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1722.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1723 tagN1723;
	if(packet->PeekPacketTag(tagN1723))
	{		  
	          uint32_t source_node_id = tagN1723.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1723.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1723.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1724 tagN1724;
	if(packet->PeekPacketTag(tagN1724))
	{		  
	          uint32_t source_node_id = tagN1724.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1724.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1724.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1725 tagN1725;
	if(packet->PeekPacketTag(tagN1725))
	{		  
	          uint32_t source_node_id = tagN1725.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1725.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1725.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN181 tagN181;
	if(packet->PeekPacketTag(tagN181))
	{		  
	          uint32_t source_node_id = tagN181.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN181.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN181.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN182 tagN182;
	
	if(packet->PeekPacketTag(tagN182))
	{		  
	          uint32_t source_node_id = tagN182.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN182.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN182.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN183 tagN183;

	
	if(packet->PeekPacketTag(tagN183))
	{		  
	          uint32_t source_node_id = tagN183.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN183.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN183.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN184 tagN184;

	
	if(packet->PeekPacketTag(tagN184))
	{		  
	          uint32_t source_node_id = tagN184.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN184.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN184.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN185 tagN185;

	
	if(packet->PeekPacketTag(tagN185))
	{		  
	          uint32_t source_node_id = tagN185.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN185.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN185.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN186 tagN186;

	
	if(packet->PeekPacketTag(tagN186))
	{		  
	          uint32_t source_node_id = tagN186.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN186.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN186.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN187 tagN187;

	
	if(packet->PeekPacketTag(tagN187))
	{		  
	          uint32_t source_node_id = tagN187.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN187.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN187.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN188 tagN188;

	
	if(packet->PeekPacketTag(tagN188))
	{		  
	          uint32_t source_node_id = tagN188.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN188.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN188.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN189 tagN189;

	
	if(packet->PeekPacketTag(tagN189))
	{		  
	          uint32_t source_node_id = tagN189.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN189.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN189.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1810 tagN1810;

	
	if(packet->PeekPacketTag(tagN1810))
	{		  
	          uint32_t source_node_id = tagN1810.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1810.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1810.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1811 tagN1811;

	
	if(packet->PeekPacketTag(tagN1811))
	{		  
	          uint32_t source_node_id = tagN1811.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1811.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1811.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1812 tagN1812;

	
	if(packet->PeekPacketTag(tagN1812))
	{		  
	          uint32_t source_node_id = tagN1812.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1812.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1812.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1813 tagN1813;

	
	if(packet->PeekPacketTag(tagN1813))
	{		  
	          uint32_t source_node_id = tagN1813.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1813.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1813.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1814 tagN1814;

	
	if(packet->PeekPacketTag(tagN1814))
	{		  
	          uint32_t source_node_id = tagN1814.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1814.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1814.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1815 tagN1815;
	
	
	if(packet->PeekPacketTag(tagN1815))
	{		  
	          uint32_t source_node_id = tagN1815.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1815.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1815.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1816 tagN1816;
	
	
	if(packet->PeekPacketTag(tagN1816))
	{		  
	          uint32_t source_node_id = tagN1816.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1816.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1816.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1817 tagN1817;
	
	
	if(packet->PeekPacketTag(tagN1817))
	{		  
	          uint32_t source_node_id = tagN1817.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1817.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1817.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1818 tagN1818;
	
	
	if(packet->PeekPacketTag(tagN1818))
	{		  
	          uint32_t source_node_id = tagN1818.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1818.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1818.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1819 tagN1819;
	
	
	if(packet->PeekPacketTag(tagN1819))
	{		  
	          uint32_t source_node_id = tagN1819.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1819.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1819.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1820 tagN1820;
	
	
	if(packet->PeekPacketTag(tagN1820))
	{		  
	          uint32_t source_node_id = tagN1820.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1820.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1820.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1821 tagN1821;
	if(packet->PeekPacketTag(tagN1821))
	{		  
	          uint32_t source_node_id = tagN1821.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1821.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1821.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN1822 tagN1822;
	if(packet->PeekPacketTag(tagN1822))
	{		  
	          uint32_t source_node_id = tagN1822.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1822.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1822.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1823 tagN1823;
	if(packet->PeekPacketTag(tagN1823))
	{		  
	          uint32_t source_node_id = tagN1823.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1823.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1823.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1824 tagN1824;
	if(packet->PeekPacketTag(tagN1824))
	{		  
	          uint32_t source_node_id = tagN1824.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1824.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1824.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1825 tagN1825;
	if(packet->PeekPacketTag(tagN1825))
	{		  
	          uint32_t source_node_id = tagN1825.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1825.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1825.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN17max tagN17max;
	
	if(packet->PeekPacketTag(tagN17max))
	{		  
	          uint32_t source_node_id = tagN17max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN17max.Getneighborid()+i) != large) and (*(tagN17max.Getneighborid()+i) > 1) and (*(tagN17max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN17max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN17max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN18max tagN18max;
	
	if(packet->PeekPacketTag(tagN18max))
	{		  
	          uint32_t source_node_id = tagN18max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN18max.Getneighborid()+i) != large) and (*(tagN18max.Getneighborid()+i) > 1) and (*(tagN18max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN18max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN18max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN191 tagN191;
	
	if(packet->PeekPacketTag(tagN191))
	{		  
	          uint32_t source_node_id = tagN191.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN151.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN191.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN192 tagN192;
	
	if(packet->PeekPacketTag(tagN192))
	{		  
	          uint32_t source_node_id = tagN192.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN192.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN192.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN193 tagN193;

	
	if(packet->PeekPacketTag(tagN193))
	{		  
	          uint32_t source_node_id = tagN193.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN193.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN193.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN194 tagN194;

	
	if(packet->PeekPacketTag(tagN194))
	{		  
	          uint32_t source_node_id = tagN194.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN194.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN194.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN195 tagN195;

	
	if(packet->PeekPacketTag(tagN195))
	{		  
	          uint32_t source_node_id = tagN195.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN195.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN195.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN196 tagN196;

	
	if(packet->PeekPacketTag(tagN196))
	{		  
	          uint32_t source_node_id = tagN196.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN196.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN196.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN197 tagN197;

	
	if(packet->PeekPacketTag(tagN197))
	{		  
	          uint32_t source_node_id = tagN197.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN197.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN197.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN198 tagN198;

	
	if(packet->PeekPacketTag(tagN198))
	{		  
	          uint32_t source_node_id = tagN198.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN198.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN198.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN199 tagN199;

	
	if(packet->PeekPacketTag(tagN199))
	{		  
	          uint32_t source_node_id = tagN199.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN199.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN199.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1910 tagN1910;

	
	if(packet->PeekPacketTag(tagN1910))
	{		  
	          uint32_t source_node_id = tagN1910.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1910.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1910.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1911 tagN1911;

	
	if(packet->PeekPacketTag(tagN1911))
	{		  
	          uint32_t source_node_id = tagN1911.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1911.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1911.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1912 tagN1912;

	
	if(packet->PeekPacketTag(tagN1912))
	{		  
	          uint32_t source_node_id = tagN1912.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1912.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1912.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1913 tagN1913;

	
	if(packet->PeekPacketTag(tagN1913))
	{		  
	          uint32_t source_node_id = tagN1913.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1913.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1913.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1914 tagN1914;

	
	if(packet->PeekPacketTag(tagN1914))
	{		  
	          uint32_t source_node_id = tagN1914.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1914.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1914.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1915 tagN1915;
	
	
	if(packet->PeekPacketTag(tagN1915))
	{		  
	          uint32_t source_node_id = tagN1915.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1915.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1915.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1916 tagN1916;
	
	
	if(packet->PeekPacketTag(tagN1916))
	{		  
	          uint32_t source_node_id = tagN1916.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1916.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1916.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1917 tagN1917;
	
	
	if(packet->PeekPacketTag(tagN1917))
	{		  
	          uint32_t source_node_id = tagN1917.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1917.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1917.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1918 tagN1918;
	
	
	if(packet->PeekPacketTag(tagN1918))
	{		  
	          uint32_t source_node_id = tagN1918.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1918.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1918.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1919 tagN1919;
	
	
	if(packet->PeekPacketTag(tagN1919))
	{		  
	          uint32_t source_node_id = tagN1919.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1919.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1919.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN1920 tagN1920;
	
	
	if(packet->PeekPacketTag(tagN1920))
	{		  
	          uint32_t source_node_id = tagN1920.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1920.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1920.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1921 tagN1921;
	if(packet->PeekPacketTag(tagN1921))
	{		  
	          uint32_t source_node_id = tagN1921.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1921.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1921.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN1922 tagN1922;
	if(packet->PeekPacketTag(tagN1922))
	{		  
	          uint32_t source_node_id = tagN1922.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1922.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1922.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1923 tagN1923;
	if(packet->PeekPacketTag(tagN1923))
	{		  
	          uint32_t source_node_id = tagN1923.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1923.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1923.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1924 tagN1924;
	if(packet->PeekPacketTag(tagN1924))
	{		  
	          uint32_t source_node_id = tagN1924.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1924.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1924.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN1925 tagN1925;
	if(packet->PeekPacketTag(tagN1925))
	{		  
	          uint32_t source_node_id = tagN1925.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1925.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN1925.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN19max tagN19max;
	
	if(packet->PeekPacketTag(tagN19max))
	{		  
	          uint32_t source_node_id = tagN19max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN19max.Getneighborid()+i) != large) and (*(tagN19max.Getneighborid()+i) > 1) and (*(tagN19max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN19max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN19max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2001 tagN2001;

	
	if(packet->PeekPacketTag(tagN2001))
	{		  
	          uint32_t source_node_id = tagN2001.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2001.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2001.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2002 tagN2002;
	
	if(packet->PeekPacketTag(tagN2002))
	{		  
	          uint32_t source_node_id = tagN2002.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN152.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2002.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2003 tagN2003;

	
	if(packet->PeekPacketTag(tagN2003))
	{		  
	          uint32_t source_node_id = tagN2003.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN153.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2003.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2004 tagN2004;

	
	if(packet->PeekPacketTag(tagN2004))
	{		  
	          uint32_t source_node_id = tagN2004.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2004.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2004.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2005 tagN2005;

	
	if(packet->PeekPacketTag(tagN2005))
	{		  
	          uint32_t source_node_id = tagN2005.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2005.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2005.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2006 tagN2006;

	
	if(packet->PeekPacketTag(tagN2006))
	{		  
	          uint32_t source_node_id = tagN2006.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2006.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2006.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2007 tagN2007;

	
	if(packet->PeekPacketTag(tagN2007))
	{		  
	          uint32_t source_node_id = tagN2007.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2007.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2007.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2008 tagN2008;

	
	if(packet->PeekPacketTag(tagN2008))
	{		  
	          uint32_t source_node_id = tagN2008.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2008.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2008.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2009 tagN2009;

	
	if(packet->PeekPacketTag(tagN2009))
	{		  
	          uint32_t source_node_id = tagN2009.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2009.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2009.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2010 tagN2010;

	
	if(packet->PeekPacketTag(tagN2010))
	{		  
	          uint32_t source_node_id = tagN2010.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2010.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2010.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2011 tagN2011;

	
	if(packet->PeekPacketTag(tagN2011))
	{		  
	          uint32_t source_node_id = tagN2011.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2011.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2011.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2012 tagN2012;

	
	if(packet->PeekPacketTag(tagN2012))
	{		  
	          uint32_t source_node_id = tagN2012.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2012.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2012.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2013 tagN2013;

	
	if(packet->PeekPacketTag(tagN2013))
	{		  
	          uint32_t source_node_id = tagN2013.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2013.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2013.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2014 tagN2014;

	
	if(packet->PeekPacketTag(tagN2014))
	{		  
	          uint32_t source_node_id = tagN2014.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2014.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2014.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2015 tagN2015;
	
	
	if(packet->PeekPacketTag(tagN2015))
	{		  
	          uint32_t source_node_id = tagN2015.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2015.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2015.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2016 tagN2016;
	
	
	if(packet->PeekPacketTag(tagN2016))
	{		  
	          uint32_t source_node_id = tagN2016.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2016.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2016.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2017 tagN2017;
	
	
	if(packet->PeekPacketTag(tagN2017))
	{		  
	          uint32_t source_node_id = tagN2017.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2017.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2017.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2018 tagN2018;
	
	
	if(packet->PeekPacketTag(tagN2018))
	{		  
	          uint32_t source_node_id = tagN2018.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1518.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2018.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2019 tagN2019;
	
	
	if(packet->PeekPacketTag(tagN2019))
	{		  
	          uint32_t source_node_id = tagN2019.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2019.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2019.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2020 tagN2020;
	
	
	if(packet->PeekPacketTag(tagN2020))
	{		  
	          uint32_t source_node_id = tagN2020.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2020.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2020.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2021 tagN2021;
	if(packet->PeekPacketTag(tagN2021))
	{		  
	          uint32_t source_node_id = tagN2021.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2021.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2021.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN2022 tagN2022;
	if(packet->PeekPacketTag(tagN2022))
	{		  
	          uint32_t source_node_id = tagN2022.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2022.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2022.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2023 tagN2023;
	if(packet->PeekPacketTag(tagN2023))
	{		  
	          uint32_t source_node_id = tagN2023.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2023.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2023.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2024 tagN2024;
	if(packet->PeekPacketTag(tagN2024))
	{		  
	          uint32_t source_node_id = tagN2024.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2024.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2024.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2025 tagN2025;
	if(packet->PeekPacketTag(tagN2025))
	{		  
	          uint32_t source_node_id = tagN2025.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2025.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2025.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN20max tagN20max;
	
	if(packet->PeekPacketTag(tagN20max))
	{		  
	          uint32_t source_node_id = tagN20max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN20max.Getneighborid()+i) != large) and (*(tagN20max.Getneighborid()+i) > 1) and (*(tagN20max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN20max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN20max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2101 tagN2101;

	
	if(packet->PeekPacketTag(tagN2101))
	{		  
	          uint32_t source_node_id = tagN2101.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2101.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2101.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2102 tagN2102;
	
	if(packet->PeekPacketTag(tagN2102))
	{		  
	          uint32_t source_node_id = tagN2102.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN152.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2102.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2103 tagN2103;

	
	if(packet->PeekPacketTag(tagN2103))
	{		  
	          uint32_t source_node_id = tagN2103.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN153.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2103.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2104 tagN2104;

	
	if(packet->PeekPacketTag(tagN2104))
	{		  
	          uint32_t source_node_id = tagN2104.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2104.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2104.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2105 tagN2105;

	
	if(packet->PeekPacketTag(tagN2105))
	{		  
	          uint32_t source_node_id = tagN2105.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2105.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2105.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2106 tagN2106;

	
	if(packet->PeekPacketTag(tagN2106))
	{		  
	          uint32_t source_node_id = tagN2106.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2106.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2106.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2107 tagN2107;

	
	if(packet->PeekPacketTag(tagN2107))
	{		  
	          uint32_t source_node_id = tagN2107.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2107.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2107.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2108 tagN2108;

	
	if(packet->PeekPacketTag(tagN2108))
	{		  
	          uint32_t source_node_id = tagN2108.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2108.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2108.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2109 tagN2109;

	
	if(packet->PeekPacketTag(tagN2109))
	{		  
	          uint32_t source_node_id = tagN2109.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2109.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2109.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2110 tagN2110;

	
	if(packet->PeekPacketTag(tagN2110))
	{		  
	          uint32_t source_node_id = tagN2110.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2110.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2110.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2111 tagN2111;

	
	if(packet->PeekPacketTag(tagN2111))
	{		  
	          uint32_t source_node_id = tagN2111.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2111.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2111.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2112 tagN2112;

	
	if(packet->PeekPacketTag(tagN2112))
	{		  
	          uint32_t source_node_id = tagN2112.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2112.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2112.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2113 tagN2113;

	
	if(packet->PeekPacketTag(tagN2113))
	{		  
	          uint32_t source_node_id = tagN2113.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2113.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2113.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2114 tagN2114;

	
	if(packet->PeekPacketTag(tagN2114))
	{		  
	          uint32_t source_node_id = tagN2114.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2114.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2114.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2115 tagN2115;
	
	
	if(packet->PeekPacketTag(tagN2115))
	{		  
	          uint32_t source_node_id = tagN2115.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2115.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2115.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2116 tagN2116;
	
	
	if(packet->PeekPacketTag(tagN2116))
	{		  
	          uint32_t source_node_id = tagN2116.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2116.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2116.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2117 tagN2117;
	
	
	if(packet->PeekPacketTag(tagN2117))
	{		  
	          uint32_t source_node_id = tagN2117.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2117.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2117.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2118 tagN2118;
	
	
	if(packet->PeekPacketTag(tagN2118))
	{		  
	          uint32_t source_node_id = tagN2118.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1518.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2118.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2119 tagN2119;
	
	
	if(packet->PeekPacketTag(tagN2119))
	{		  
	          uint32_t source_node_id = tagN2119.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2119.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2119.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2120 tagN2120;
	
	
	if(packet->PeekPacketTag(tagN2120))
	{		  
	          uint32_t source_node_id = tagN2120.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2120.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2120.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2121 tagN2121;
	if(packet->PeekPacketTag(tagN2121))
	{		  
	          uint32_t source_node_id = tagN2121.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2121.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2121.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN2122 tagN2122;
	if(packet->PeekPacketTag(tagN2122))
	{		  
	          uint32_t source_node_id = tagN2122.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2122.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2122.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2123 tagN2123;
	if(packet->PeekPacketTag(tagN2123))
	{		  
	          uint32_t source_node_id = tagN2123.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2123.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2123.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2124 tagN2124;
	if(packet->PeekPacketTag(tagN2124))
	{		  
	          uint32_t source_node_id = tagN2124.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2124.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2124.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2125 tagN2125;
	if(packet->PeekPacketTag(tagN2125))
	{		  
	          uint32_t source_node_id = tagN2125.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2125.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2125.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN21max tagN21max;
	
	if(packet->PeekPacketTag(tagN21max))
	{		  
	          uint32_t source_node_id = tagN21max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN21max.Getneighborid()+i) != large) and (*(tagN21max.Getneighborid()+i) > 1) and (*(tagN21max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN21max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;		
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN21max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2201 tagN2201;

	
	if(packet->PeekPacketTag(tagN2201))
	{		  
	          uint32_t source_node_id = tagN2201.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2201.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2201.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2202 tagN2202;
	
	if(packet->PeekPacketTag(tagN2202))
	{		  
	          uint32_t source_node_id = tagN2202.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN152.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2202.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2203 tagN2203;

	
	if(packet->PeekPacketTag(tagN2203))
	{		  
	          uint32_t source_node_id = tagN2203.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN153.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2203.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2204 tagN2204;

	
	if(packet->PeekPacketTag(tagN2204))
	{		  
	          uint32_t source_node_id = tagN2204.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2204.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2204.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2205 tagN2205;

	
	if(packet->PeekPacketTag(tagN2205))
	{		  
	          uint32_t source_node_id = tagN2205.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2205.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2205.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2206 tagN2206;

	
	if(packet->PeekPacketTag(tagN2206))
	{		  
	          uint32_t source_node_id = tagN2206.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2206.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2206.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2207 tagN2207;

	
	if(packet->PeekPacketTag(tagN2207))
	{		  
	          uint32_t source_node_id = tagN2207.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2207.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2207.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2208 tagN2208;

	
	if(packet->PeekPacketTag(tagN2208))
	{		  
	          uint32_t source_node_id = tagN2208.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2208.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2208.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2209 tagN2209;

	
	if(packet->PeekPacketTag(tagN2209))
	{		  
	          uint32_t source_node_id = tagN2209.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2209.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2209.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2210 tagN2210;

	
	if(packet->PeekPacketTag(tagN2210))
	{		  
	          uint32_t source_node_id = tagN2210.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2210.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2210.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2211 tagN2211;

	
	if(packet->PeekPacketTag(tagN2211))
	{		  
	          uint32_t source_node_id = tagN2211.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2211.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2211.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2212 tagN2212;

	
	if(packet->PeekPacketTag(tagN2212))
	{		  
	          uint32_t source_node_id = tagN2212.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2212.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2212.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2213 tagN2213;

	
	if(packet->PeekPacketTag(tagN2213))
	{		  
	          uint32_t source_node_id = tagN2213.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2213.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2213.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2214 tagN2214;

	
	if(packet->PeekPacketTag(tagN2214))
	{		  
	          uint32_t source_node_id = tagN2214.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2214.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2214.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2215 tagN2215;
	
	
	if(packet->PeekPacketTag(tagN2215))
	{		  
	          uint32_t source_node_id = tagN2215.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2215.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2215.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2216 tagN2216;
	
	
	if(packet->PeekPacketTag(tagN2216))
	{		  
	          uint32_t source_node_id = tagN2216.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2216.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2216.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2217 tagN2217;
	
	
	if(packet->PeekPacketTag(tagN2217))
	{		  
	          uint32_t source_node_id = tagN2217.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2217.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2217.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2218 tagN2218;
	
	
	if(packet->PeekPacketTag(tagN2218))
	{		  
	          uint32_t source_node_id = tagN2218.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1518.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2218.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2219 tagN2219;
	
	
	if(packet->PeekPacketTag(tagN2219))
	{		  
	          uint32_t source_node_id = tagN2219.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2219.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2219.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2220 tagN2220;
	
	
	if(packet->PeekPacketTag(tagN2220))
	{		  
	          uint32_t source_node_id = tagN2220.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2220.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2220.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2221 tagN2221;
	if(packet->PeekPacketTag(tagN2221))
	{		  
	          uint32_t source_node_id = tagN2221.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2221.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2221.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN2222 tagN2222;
	if(packet->PeekPacketTag(tagN2222))
	{		  
	          uint32_t source_node_id = tagN2222.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2222.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2222.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2223 tagN2223;
	if(packet->PeekPacketTag(tagN2223))
	{		  
	          uint32_t source_node_id = tagN2223.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2223.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2223.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2224 tagN2224;
	if(packet->PeekPacketTag(tagN2224))
	{		  
	          uint32_t source_node_id = tagN2224.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2224.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2224.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2225 tagN2225;
	if(packet->PeekPacketTag(tagN2225))
	{		  
	          uint32_t source_node_id = tagN2225.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2225.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2225.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN22max tagN22max;
	
	if(packet->PeekPacketTag(tagN22max))
	{		  
	          uint32_t source_node_id = tagN22max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN22max.Getneighborid()+i) != large) and (*(tagN22max.Getneighborid()+i) > 1) and (*(tagN22max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN22max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN22max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2301 tagN2301;

	
	if(packet->PeekPacketTag(tagN2301))
	{		  
	          uint32_t source_node_id = tagN2301.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2301.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2301.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2302 tagN2302;
	
	if(packet->PeekPacketTag(tagN2302))
	{		  
	          uint32_t source_node_id = tagN2302.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN152.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2302.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2303 tagN2303;

	
	if(packet->PeekPacketTag(tagN2303))
	{		  
	          uint32_t source_node_id = tagN2303.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN153.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2303.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2304 tagN2304;

	
	if(packet->PeekPacketTag(tagN2304))
	{		  
	          uint32_t source_node_id = tagN2304.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2304.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2304.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2305 tagN2305;

	
	if(packet->PeekPacketTag(tagN2305))
	{		  
	          uint32_t source_node_id = tagN2305.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2305.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2305.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2306 tagN2306;

	
	if(packet->PeekPacketTag(tagN2306))
	{		  
	          uint32_t source_node_id = tagN2306.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2306.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2306.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2307 tagN2307;

	
	if(packet->PeekPacketTag(tagN2307))
	{		  
	          uint32_t source_node_id = tagN2307.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2307.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2307.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2308 tagN2308;

	
	if(packet->PeekPacketTag(tagN2308))
	{		  
	          uint32_t source_node_id = tagN2308.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2308.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2308.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2309 tagN2309;

	
	if(packet->PeekPacketTag(tagN2309))
	{		  
	          uint32_t source_node_id = tagN2309.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2309.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2309.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2310 tagN2310;

	
	if(packet->PeekPacketTag(tagN2310))
	{		  
	          uint32_t source_node_id = tagN2310.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2310.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2310.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2311 tagN2311;

	
	if(packet->PeekPacketTag(tagN2311))
	{		  
	          uint32_t source_node_id = tagN2311.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2311.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2311.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2312 tagN2312;

	
	if(packet->PeekPacketTag(tagN2312))
	{		  
	          uint32_t source_node_id = tagN2312.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2312.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2312.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2313 tagN2313;

	
	if(packet->PeekPacketTag(tagN2313))
	{		  
	          uint32_t source_node_id = tagN2313.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2313.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2313.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2314 tagN2314;

	
	if(packet->PeekPacketTag(tagN2314))
	{		  
	          uint32_t source_node_id = tagN2314.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2314.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2314.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2315 tagN2315;
	
	
	if(packet->PeekPacketTag(tagN2315))
	{		  
	          uint32_t source_node_id = tagN2315.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2315.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2315.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2316 tagN2316;
	
	
	if(packet->PeekPacketTag(tagN2316))
	{		  
	          uint32_t source_node_id = tagN2316.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2316.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2316.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2317 tagN2317;
	
	
	if(packet->PeekPacketTag(tagN2317))
	{		  
	          uint32_t source_node_id = tagN2317.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2317.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2317.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2318 tagN2318;
	
	
	if(packet->PeekPacketTag(tagN2318))
	{		  
	          uint32_t source_node_id = tagN2318.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1518.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2318.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2319 tagN2319;
	
	
	if(packet->PeekPacketTag(tagN2319))
	{		  
	          uint32_t source_node_id = tagN2319.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2319.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2319.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2320 tagN2320;
	
	
	if(packet->PeekPacketTag(tagN2320))
	{		  
	          uint32_t source_node_id = tagN2320.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2320.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2320.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2321 tagN2321;
	if(packet->PeekPacketTag(tagN2321))
	{		  
	          uint32_t source_node_id = tagN2321.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2321.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2321.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN2322 tagN2322;
	if(packet->PeekPacketTag(tagN2322))
	{		  
	          uint32_t source_node_id = tagN2322.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2322.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2322.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2323 tagN2323;
	if(packet->PeekPacketTag(tagN2323))
	{		  
	          uint32_t source_node_id = tagN2323.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2323.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2323.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2324 tagN2324;
	if(packet->PeekPacketTag(tagN2324))
	{		  
	          uint32_t source_node_id = tagN2324.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2324.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2324.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2325 tagN2325;
	if(packet->PeekPacketTag(tagN2325))
	{		  
	          uint32_t source_node_id = tagN2325.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2325.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2325.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN23max tagN23max;
	
	if(packet->PeekPacketTag(tagN23max))
	{		  
	          uint32_t source_node_id = tagN23max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN23max.Getneighborid()+i) != large) and (*(tagN23max.Getneighborid()+i) > 1) and (*(tagN23max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN23max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();		
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN23max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2401 tagN2401;

	
	if(packet->PeekPacketTag(tagN2401))
	{		  
	          uint32_t source_node_id = tagN2401.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2401.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2401.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2402 tagN2402;
	
	if(packet->PeekPacketTag(tagN2402))
	{		  
	          uint32_t source_node_id = tagN2402.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN152.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2402.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2403 tagN2403;

	
	if(packet->PeekPacketTag(tagN2403))
	{		  
	          uint32_t source_node_id = tagN2403.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN153.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2403.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2404 tagN2404;

	
	if(packet->PeekPacketTag(tagN2404))
	{		  
	          uint32_t source_node_id = tagN2404.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2404.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2404.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2405 tagN2405;

	
	if(packet->PeekPacketTag(tagN2405))
	{		  
	          uint32_t source_node_id = tagN2405.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2405.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2405.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2406 tagN2406;

	
	if(packet->PeekPacketTag(tagN2406))
	{		  
	          uint32_t source_node_id = tagN2406.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2406.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2406.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2407 tagN2407;

	
	if(packet->PeekPacketTag(tagN2407))
	{		  
	          uint32_t source_node_id = tagN2407.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2407.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2407.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2408 tagN2408;

	
	if(packet->PeekPacketTag(tagN2408))
	{		  
	          uint32_t source_node_id = tagN2408.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2408.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2408.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2409 tagN2409;

	
	if(packet->PeekPacketTag(tagN2409))
	{		  
	          uint32_t source_node_id = tagN2409.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2409.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2409.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2410 tagN2410;

	
	if(packet->PeekPacketTag(tagN2410))
	{		  
	          uint32_t source_node_id = tagN2410.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2410.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2410.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2411 tagN2411;

	
	if(packet->PeekPacketTag(tagN2411))
	{		  
	          uint32_t source_node_id = tagN2411.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2411.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2411.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2412 tagN2412;

	
	if(packet->PeekPacketTag(tagN2412))
	{		  
	          uint32_t source_node_id = tagN2412.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2412.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2412.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2413 tagN2413;

	
	if(packet->PeekPacketTag(tagN2413))
	{		  
	          uint32_t source_node_id = tagN2413.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2413.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2413.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2414 tagN2414;

	
	if(packet->PeekPacketTag(tagN2414))
	{		  
	          uint32_t source_node_id = tagN2414.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2414.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2414.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2415 tagN2415;
	
	
	if(packet->PeekPacketTag(tagN2415))
	{		  
	          uint32_t source_node_id = tagN2415.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2415.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2415.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2416 tagN2416;
	
	
	if(packet->PeekPacketTag(tagN2416))
	{		  
	          uint32_t source_node_id = tagN2416.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2416.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2416.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2417 tagN2417;
	
	
	if(packet->PeekPacketTag(tagN2417))
	{		  
	          uint32_t source_node_id = tagN2417.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2417.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2417.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2418 tagN2418;
	
	
	if(packet->PeekPacketTag(tagN2418))
	{		  
	          uint32_t source_node_id = tagN2418.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1518.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2418.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2419 tagN2419;
	
	
	if(packet->PeekPacketTag(tagN2419))
	{		  
	          uint32_t source_node_id = tagN2419.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2419.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2419.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2420 tagN2420;
	
	
	if(packet->PeekPacketTag(tagN2420))
	{		  
	          uint32_t source_node_id = tagN2420.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2420.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2420.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2421 tagN2421;
	if(packet->PeekPacketTag(tagN2421))
	{		  
	          uint32_t source_node_id = tagN2421.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2421.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2421.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN2422 tagN2422;
	if(packet->PeekPacketTag(tagN2422))
	{		  
	          uint32_t source_node_id = tagN2422.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2422.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2422.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2423 tagN2423;
	if(packet->PeekPacketTag(tagN2423))
	{		  
	          uint32_t source_node_id = tagN2423.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2423.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2423.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2424 tagN2424;
	if(packet->PeekPacketTag(tagN2424))
	{		  
	          uint32_t source_node_id = tagN2424.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2424.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2424.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2425 tagN2425;
	if(packet->PeekPacketTag(tagN2425))
	{		  
	          uint32_t source_node_id = tagN2425.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2425.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2425.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN24max tagN24max;
	
	if(packet->PeekPacketTag(tagN24max))
	{		  
	          uint32_t source_node_id = tagN24max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN24max.Getneighborid()+i) != large) and (*(tagN24max.Getneighborid()+i) > 1) and (*(tagN24max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN24max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN24max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2501 tagN2501;

	
	if(packet->PeekPacketTag(tagN2501))
	{		  
	          uint32_t source_node_id = tagN2501.Getnodeid();
		  uint32_t neighborsize = 1;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2501.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2501.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2502 tagN2502;
	
	if(packet->PeekPacketTag(tagN2502))
	{		  
	          uint32_t source_node_id = tagN2502.Getnodeid();
		  uint32_t neighborsize = 2;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN152.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2502.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2503 tagN2503;

	
	if(packet->PeekPacketTag(tagN2503))
	{		  
	          uint32_t source_node_id = tagN2503.Getnodeid();
		  uint32_t neighborsize = 3;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN153.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2503.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2504 tagN2504;

	
	if(packet->PeekPacketTag(tagN2504))
	{		  
	          uint32_t source_node_id = tagN2504.Getnodeid();
		  uint32_t neighborsize = 4;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2504.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2504.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2505 tagN2505;

	
	if(packet->PeekPacketTag(tagN2505))
	{		  
	          uint32_t source_node_id = tagN2505.Getnodeid();
		  uint32_t neighborsize = 5;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2505.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2505.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2506 tagN2506;

	
	if(packet->PeekPacketTag(tagN2506))
	{		  
	          uint32_t source_node_id = tagN2506.Getnodeid();
		  uint32_t neighborsize = 6;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2506.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2506.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2507 tagN2507;

	
	if(packet->PeekPacketTag(tagN2507))
	{		  
	          uint32_t source_node_id = tagN2507.Getnodeid();
		  uint32_t neighborsize = 7;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2507.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2507.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2508 tagN2508;

	
	if(packet->PeekPacketTag(tagN2508))
	{		  
	          uint32_t source_node_id = tagN2508.Getnodeid();
		  uint32_t neighborsize = 8;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2508.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2508.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2509 tagN2509;

	
	if(packet->PeekPacketTag(tagN2509))
	{		  
	          uint32_t source_node_id = tagN2509.Getnodeid();
		  uint32_t neighborsize = 9;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2509.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2509.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2510 tagN2510;

	
	if(packet->PeekPacketTag(tagN2510))
	{		  
	          uint32_t source_node_id = tagN2510.Getnodeid();
		  uint32_t neighborsize = 10;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2510.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2510.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2511 tagN2511;

	
	if(packet->PeekPacketTag(tagN2511))
	{		  
	          uint32_t source_node_id = tagN2511.Getnodeid();
		  uint32_t neighborsize = 11;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2511.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2511.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2512 tagN2512;

	
	if(packet->PeekPacketTag(tagN2512))
	{		  
	          uint32_t source_node_id = tagN2512.Getnodeid();
		  uint32_t neighborsize = 12;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2512.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2512.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2513 tagN2513;

	
	if(packet->PeekPacketTag(tagN2513))
	{		  
	          uint32_t source_node_id = tagN2513.Getnodeid();
		  uint32_t neighborsize = 13;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2513.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2513.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2514 tagN2514;

	
	if(packet->PeekPacketTag(tagN2514))
	{		  
	          uint32_t source_node_id = tagN2514.Getnodeid();
		  uint32_t neighborsize = 14;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2514.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2514.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2515 tagN2515;
	
	
	if(packet->PeekPacketTag(tagN2515))
	{		  
	          uint32_t source_node_id = tagN2515.Getnodeid();
		  uint32_t neighborsize = 15;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2515.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2515.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2516 tagN2516;
	
	
	if(packet->PeekPacketTag(tagN2516))
	{		  
	          uint32_t source_node_id = tagN2516.Getnodeid();
		  uint32_t neighborsize = 16;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2516.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2516.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2517 tagN2517;
	
	
	if(packet->PeekPacketTag(tagN2517))
	{		  
	          uint32_t source_node_id = tagN2517.Getnodeid();
		  uint32_t neighborsize = 17;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2517.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2517.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2518 tagN2518;
	
	
	if(packet->PeekPacketTag(tagN2518))
	{		  
	          uint32_t source_node_id = tagN2518.Getnodeid();
		  uint32_t neighborsize = 18;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN1518.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2518.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2519 tagN2519;
	
	
	if(packet->PeekPacketTag(tagN2519))
	{		  
	          uint32_t source_node_id = tagN2519.Getnodeid();
		  uint32_t neighborsize = 19;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2519.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2519.Getnodeid()<<std::endl;
	}
	
		CustomMetaDataUnicastTagN2520 tagN2520;
	
	
	if(packet->PeekPacketTag(tagN2520))
	{		  
	          uint32_t source_node_id = tagN2520.Getnodeid();
		  uint32_t neighborsize = 20;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2520.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2520.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2521 tagN2521;
	if(packet->PeekPacketTag(tagN2521))
	{		  
	          uint32_t source_node_id = tagN2521.Getnodeid();
		  uint32_t neighborsize = 21;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2521.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2521.Getnodeid()<<std::endl;
	}
	
	
	CustomMetaDataUnicastTagN2522 tagN2522;
	if(packet->PeekPacketTag(tagN2522))
	{		  
	          uint32_t source_node_id = tagN2522.Getnodeid();
		  uint32_t neighborsize = 22;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2522.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2522.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2523 tagN2523;
	if(packet->PeekPacketTag(tagN2523))
	{		  
	          uint32_t source_node_id = tagN2523.Getnodeid();
		  uint32_t neighborsize = 23;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2523.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2523.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2524 tagN2524;
	if(packet->PeekPacketTag(tagN2524))
	{		  
	          uint32_t source_node_id = tagN2524.Getnodeid();
		  uint32_t neighborsize = 24;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2524.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2524.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN2525 tagN2525;
	if(packet->PeekPacketTag(tagN2525))
	{		  
	          uint32_t source_node_id = tagN2525.Getnodeid();
		  uint32_t neighborsize = 25;
		  for(uint32_t i=0; i<max; i++)
		  {
		  	if(i<neighborsize)
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN2525.Getneighborid()+i);
			}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN2525.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN25max tagN25max;
	
	if(packet->PeekPacketTag(tagN25max))
	{		  
	          uint32_t source_node_id = tagN25max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN25max.Getneighborid()+i) != large) and (*(tagN25max.Getneighborid()+i) > 1) and (*(tagN25max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN25max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN25max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN26max tagN26max;
	
	if(packet->PeekPacketTag(tagN26max))
	{		  
	          uint32_t source_node_id = tagN26max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN26max.Getneighborid()+i) != large) and (*(tagN26max.Getneighborid()+i) > 1) and (*(tagN26max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN26max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN26max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN27max tagN27max;
	
	if(packet->PeekPacketTag(tagN27max))
	{		  
	          uint32_t source_node_id = tagN27max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN27max.Getneighborid()+i) != large) and (*(tagN27max.Getneighborid()+i) > 1) and (*(tagN27max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN27max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN27max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN28max tagN28max;
	
	if(packet->PeekPacketTag(tagN28max))
	{		  
	          uint32_t source_node_id = tagN28max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN28max.Getneighborid()+i) != large) and (*(tagN28max.Getneighborid()+i) > 1) and (*(tagN28max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN28max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN28max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN29max tagN29max;
	
	if(packet->PeekPacketTag(tagN29max))
	{		  
	          uint32_t source_node_id = tagN29max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN29max.Getneighborid()+i) != large) and (*(tagN29max.Getneighborid()+i) > 1) and (*(tagN29max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN29max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN29max.Getnodeid()<<std::endl;
	}
	
	CustomMetaDataUnicastTagN30max tagN30max;
	
	if(packet->PeekPacketTag(tagN30max))
	{		  
	          uint32_t source_node_id = tagN30max.Getnodeid();
		  uint32_t neighborsize = 0;
		  for(int i=0; i<max; i++)
		  {
		  	if ((*(tagN30max.Getneighborid()+i) != large) and (*(tagN30max.Getneighborid()+i) > 1) and (*(tagN30max.Getneighborid()+i) < (total_size+2)))
		  	{
		  		neighborsize++;
		  		(con_data_inst+source_node_id)->neighborid[i] = *(tagN30max.Getneighborid()+i);
		  	}
		  	else
		  	{
		  		(con_data_inst+source_node_id)->neighborid[i] = large;
		  	}
		  }
		 (con_data_inst+source_node_id)->neighborsize = neighborsize;	
		 (con_data_inst+source_node_id)->lastupdated = Simulator::Now().GetSeconds();	
		std::cout << "Current neighbor size is "<<(con_data_inst+source_node_id)->neighborsize<<"Received neighborset from "<< tagN30max.Getnodeid()<<std::endl;
	}

	
	CustomMetaDataDownlinkUnicastTag tag4;
	if(packet->PeekPacketTag(tag4))
	{
		if (nid == tag4.GetNodeId())
		{
			
			Z_nodes[nid] = tag4.GetZ();
			X_nodes[nid] = tag4.GetX();
			cout<<"At node id "<<nid<<"Z value is "<<Z_nodes[nid]<<"X value is "<<X_nodes[nid]<<"at time "<<Simulator::Now()<<endl;
		}
	}
	
	CustomDataUnicastTag_Routing tag_routing2;
	if(packet->PeekPacketTag(tag_routing2))
	{		  
	  	uint32_t sender_id = tag_routing2.GetsenderId();
	  	uint32_t destination = tag_routing2.GetdestinationId();
	  	if (nid == destination)
	  	{
	  		dsrc_final_timestamp = Simulator::Now().GetSeconds();
	  		aodv_final_timestamp[sender_id] = Simulator::Now().GetSeconds();
	  		cout<<"Received packet from "<<sender_id<<endl;
	  	}
	}
	
	CustomDataUnicastTag1 tag51;
	if(packet->PeekPacketTag(tag51))
	{		  
		  uint32_t * source_node_id = tag51.GetNodeId();
		  cout<<"This is tag1. Serialized size is "<< tag51.GetSerializedSize()<<endl;
		  uint32_t real_source = tag51.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<1; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag51.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag51.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag51.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag51.GetTimestamp()+i);
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag51.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag51.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag2 tag52;
	if(packet->PeekPacketTag(tag52))
	{		  
	          uint32_t * source_node_id = tag52.GetNodeId();
		  cout<<"This is tag2. Serialized size is "<< tag52.GetSerializedSize()<<endl;
		  uint32_t real_source = tag52.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<2; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag52.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag52.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag52.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag52.GetTimestamp()+i);
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag52.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag52.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	CustomDataUnicastTag3 tag53;
	if(packet->PeekPacketTag(tag53))
	{		  
	          uint32_t * source_node_id = tag53.GetNodeId();
		  cout<<"This is tag3. Serialized size is "<< tag53.GetSerializedSize()<<endl;
		  uint32_t real_source = tag53.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<3; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag53.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag53.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag53.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag53.GetTimestamp()+i);
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag53.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag53.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag4 tag54;
	if(packet->PeekPacketTag(tag54))
	{		  
	          uint32_t * source_node_id = tag54.GetNodeId();
		  cout<<"This is tag4. Serialized size is "<< tag54.GetSerializedSize()<<endl;
		  uint32_t real_source = tag54.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<4; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag54.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag54.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag54.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag54.GetTimestamp()+i);
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag54.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag54.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag5 tag55;
	if(packet->PeekPacketTag(tag55))
	{		  
	          uint32_t * source_node_id = tag55.GetNodeId();
		  cout<<"This is tag5. Serialized size is "<< tag55.GetSerializedSize()<<endl;
		  uint32_t real_source = tag55.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<5; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag55.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag55.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag55.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag55.GetTimestamp()+i);
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag55.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag55.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
	  		
		  }
	}
	
	CustomDataUnicastTag6 tag56;
	if(packet->PeekPacketTag(tag56))
	{		  
	          uint32_t * source_node_id = tag56.GetNodeId();
		  cout<<"This is tag6. Serialized size is "<< tag56.GetSerializedSize()<<endl;
		  uint32_t real_source = tag56.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<6; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag56.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag56.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag56.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag56.GetTimestamp()+i);
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag56.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag56.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag7 tag57;
	if(packet->PeekPacketTag(tag57))
	{		  
	          uint32_t * source_node_id = tag57.GetNodeId();
		  cout<<"This is tag7. Serialized size is "<< tag57.GetSerializedSize()<<endl;
		  uint32_t real_source = tag57.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<7; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag57.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag57.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag57.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag57.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag57.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag57.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag8 tag58;
	if(packet->PeekPacketTag(tag58))
	{		  
	          uint32_t * source_node_id = tag58.GetNodeId();
		  cout<<"This is tag8. Serialized size is "<< tag58.GetSerializedSize()<<endl;
		  uint32_t real_source = tag58.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<8; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag58.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag58.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag58.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag58.GetTimestamp()+i);
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag58.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag58.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag9 tag59;
	if(packet->PeekPacketTag(tag59))
	{		  
	          uint32_t * source_node_id = tag59.GetNodeId();
		  cout<<"This is tag9. Serialized size is "<< tag59.GetSerializedSize()<<endl;
		  uint32_t real_source = tag59.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<9; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag59.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag59.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag59.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag59.GetTimestamp()+i);
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag59.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag59.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag10 tag510;
	if(packet->PeekPacketTag(tag510))
	{		  
	          uint32_t * source_node_id = tag510.GetNodeId();
		  cout<<"This is tag10. Serialized size is "<< tag510.GetSerializedSize()<<endl;
		  uint32_t real_source = tag510.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<10; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag510.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag510.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag510.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag510.GetTimestamp()+i);
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag510.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag510.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag11 tag511;
	if(packet->PeekPacketTag(tag511))
	{		  
	          uint32_t * source_node_id = tag511.GetNodeId();
		  cout<<"This is tag11. Serialized size is "<< tag511.GetSerializedSize()<<endl;
		  uint32_t real_source = tag511.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<11; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag511.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag511.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag511.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag511.GetTimestamp()+i);
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag511.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag511.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag12 tag512;
	if(packet->PeekPacketTag(tag512))
	{		  
	          uint32_t * source_node_id = tag512.GetNodeId();
		  cout<<"This is tag12. Serialized size is "<< tag512.GetSerializedSize()<<endl;
		  uint32_t real_source = tag512.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<12; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag512.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag512.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag512.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag512.GetTimestamp()+i);
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag512.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag512.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag13 tag513;
	if(packet->PeekPacketTag(tag513))
	{		  
	          uint32_t * source_node_id = tag513.GetNodeId();
		  cout<<"This is tag13. Serialized size is "<< tag513.GetSerializedSize()<<endl;
		  uint32_t real_source = tag513.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<13; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag513.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag513.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag513.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag513.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag513.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag513.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag14 tag514;
	if(packet->PeekPacketTag(tag514))
	{		  
	          uint32_t * source_node_id = tag514.GetNodeId();
		  cout<<"This is tag14. Serialized size is "<< tag514.GetSerializedSize()<<endl;
		  uint32_t real_source = tag514.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<14; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag514.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag514.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag514.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag514.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag514.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag514.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag15 tag515;
	if(packet->PeekPacketTag(tag515))
	{		  
	          uint32_t * source_node_id = tag515.GetNodeId();
		  cout<<"This is tag15. Serialized size is "<< tag515.GetSerializedSize()<<endl;
		  uint32_t real_source = tag515.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<15; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag515.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag515.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag515.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag515.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag515.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag515.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag16 tag516;
	if(packet->PeekPacketTag(tag516))
	{		  
	          uint32_t * source_node_id = tag516.GetNodeId();
		  cout<<"This is tag16. Serialized size is "<< tag516.GetSerializedSize()<<endl;
		  uint32_t real_source = tag516.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<16; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag516.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag516.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag516.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag516.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag516.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag516.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag17 tag517;
	if(packet->PeekPacketTag(tag517))
	{		  
	          uint32_t * source_node_id = tag517.GetNodeId();
		  cout<<"This is tag17. Serialized size is "<< tag517.GetSerializedSize()<<endl;
		  uint32_t real_source = tag517.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<17; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag517.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag517.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag517.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag517.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag517.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag517.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag18 tag518;
	if(packet->PeekPacketTag(tag518))
	{		  
	          uint32_t * source_node_id = tag518.GetNodeId();
		  cout<<"This is tag18. Serialized size is "<< tag518.GetSerializedSize()<<endl;
		  uint32_t real_source = tag518.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<18; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag518.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag518.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag518.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag518.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag518.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag518.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag19 tag519;
	if(packet->PeekPacketTag(tag519))
	{		  
	          uint32_t * source_node_id = tag519.GetNodeId();
		  cout<<"This is tag19. Serialized size is "<< tag519.GetSerializedSize()<<endl;
		  uint32_t real_source = tag519.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<19; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag519.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag519.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag519.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag519.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag519.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag519.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag20 tag520;
	if(packet->PeekPacketTag(tag520))
	{		  
	          uint32_t * source_node_id = tag520.GetNodeId();
		  cout<<"This is tag20. Serialized size is "<< tag520.GetSerializedSize()<<endl;
		  uint32_t real_source = tag520.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<20; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag520.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag520.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag520.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag520.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag520.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag520.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag21 tag521;
	if(packet->PeekPacketTag(tag521))
	{		  
	          uint32_t * source_node_id = tag521.GetNodeId();
		  cout<<"This is tag21. Serialized size is "<< tag521.GetSerializedSize()<<endl;
		  uint32_t real_source = tag521.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<21; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag521.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag521.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag521.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag521.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag521.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag521.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag22 tag522;
	if(packet->PeekPacketTag(tag522))
	{		  
	          uint32_t * source_node_id = tag522.GetNodeId();
		  cout<<"This is tag22. Serialized size is "<< tag522.GetSerializedSize()<<endl;
		  uint32_t real_source = tag522.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<22; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag522.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag522.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag522.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag522.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag522.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag522.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag23 tag523;
	if(packet->PeekPacketTag(tag523))
	{		  
	          uint32_t * source_node_id = tag523.GetNodeId();
		  cout<<"This is tag23. Serialized size is "<< tag523.GetSerializedSize()<<endl;
		  uint32_t real_source = tag523.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<23; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag523.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag523.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag523.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag523.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag523.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag523.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag24 tag524;
	if(packet->PeekPacketTag(tag524))
	{		  
	          uint32_t * source_node_id = tag524.GetNodeId();
		  cout<<"This is tag24. Serialized size is "<< tag524.GetSerializedSize()<<endl;
		  uint32_t real_source = tag524.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<24; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag524.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag524.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag524.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag524.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag524.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag524.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag25 tag525;
	if(packet->PeekPacketTag(tag525))
	{		  
	          uint32_t * source_node_id = tag525.GetNodeId();
		  cout<<"This is tag25. Serialized size is "<< tag525.GetSerializedSize()<<endl;
		  uint32_t real_source = tag525.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<25; i++)
		  {
		  	//cout<<"source node id "<<source_node_id[i]<<endl;
	  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag525.Getacceleration()+i);
	  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag525.Getvelocity()+i);
	  		(data_at_manager_inst+source_node_id[i])->position = *(tag525.Getposition()+i);
	  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
	  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag525.GetTimestamp()+i);
	  		
	  		if (source_node_id[i] < (2 + N_Vehicles))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag525.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
			else if (source_node_id[i]< (2+total_size))
			{
				packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
			  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag525.GetTimestamp()+i)->GetMilliSeconds())/10);
			}
		  }
	}
	
	CustomDataUnicastTag tag5;
	if(packet->PeekPacketTag(tag5))
	{	
		  cout<<"maximum data size exceeded"<<endl;
	          uint32_t * source_node_id = tag5.GetNodeId();
		  cout<<"Serialized size is "<< tag5.GetSerializedSize()<<endl;
		  uint32_t real_source = tag5.GetsenderId();
		  if(real_source < (2+N_Vehicles))
		  {
		  	lte_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  else if (real_source < (2+total_size))
		  {
		  	ethernet_final_timestamp = Simulator::Now().GetSeconds();
		  }
		  for(uint8_t i=0; i<max; i++)
		  {
		  	if(source_node_id[i] != 50000)
		  	{
			  	//cout<<"source node id "<<source_node_id[i]<<endl;
		  		(data_at_manager_inst+source_node_id[i])->acceleration = *(tag5.Getacceleration()+i);
		  		(data_at_manager_inst+source_node_id[i])->velocity = *(tag5.Getvelocity()+i);
		  		(data_at_manager_inst+source_node_id[i])->position = *(tag5.Getposition()+i);
		  		(data_at_manager_inst+source_node_id[i])->nodeid = source_node_id[i];
		  		(data_at_manager_inst+source_node_id[i])->timestamp = *(tag5.GetTimestamp()+i);
		  		
		  		if (source_node_id[i] < (2 + N_Vehicles))
				{
					packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
				  	(con_data_inst+source_node_id[i])->B = 40 + uint32_t((Now().GetMilliSeconds()-(tag5.GetTimestamp()+i)->GetMilliSeconds())/10);
				}
				else if (source_node_id[i]< (2+total_size))
				{
					packet_final_timestamp[source_node_id[i]] = Simulator::Now().GetSeconds();
				  	(con_data_inst+source_node_id[i])->B = 1 + uint32_t((Now().GetMilliSeconds()-(tag5.GetTimestamp()+i)->GetMilliSeconds())/10);
				}
			}
		  }
	}
    }
    
  }
  
  void SimpleUdpApplication::test()
  {
 	cout<<"Test function"<<endl;
  }

  void SimpleUdpApplication::HandleReadTwo(Ptr<Socket> socket)
  {
    NS_LOG_FUNCTION(this << socket);
    Ptr<Packet> packet;
    Address from;
    Address localAddress;
    while ((packet = socket->RecvFrom(from)))
    {
      NS_LOG_INFO(PURPLE_CODE << "HandleReadTwo : Received a Packet of size: " << packet->GetSize() << " at time " << Now().GetSeconds() << END_CODE);
      NS_LOG_INFO("Content: " << packet->ToString());
    }
  }

  void SimpleUdpApplication::SendPacket(Ptr<Packet> packet, Ipv4Address destination, uint16_t port)
  {
    //cout<<m_send_socket<<endl;
    NS_LOG_FUNCTION (this << packet << destination << port);
    m_send_socket->Connect(InetSocketAddress(Ipv4Address::ConvertFrom(destination), port));
    int x = m_send_socket->Send(packet);
    if (x == -1)
    {
    	cout<<"An Error occured in sending"<<endl;
    }
  }



/**
 * \brief Shared memory to store a and b.
 *
 * This struct is the environment (in this example, contain 'a' and 'b')
 * shared between ns-3 and python with the same shared memory
 * using the ns3-ai model.
 */
/*
struct Env
{
    int a;
    int b;
}Packed;
*/
/**
 * \brief Shared memory to store action c.
 *
 * This struct is the result (in this example, contain 'c')
 * calculated by python and put back to ns-3 with the shared memory.
 */
 
/*
struct Act
{
    int c;
}Packed;

*/

/**
 * \brief A class to calculate 
  (a plus b).
 *
 * This class shared memory with python by the same id,
 * and got two variable a and b, and then put them into the shared memory
 * using python to calculate c=a+b, and got c from python.
 */
/*
class APB : public Ns3AIRL<Env, Act>
{
public:
    APB(uint16_t id);
    int Func(int a, int b);
};
*/
/**
 * \brief Link the shared memory with the id and set the operation lock
 *
 * \param[in] id  shared memory id, should be the same in python and ns-3
 */
 
/*
APB::APB(uint16_t id) : Ns3AIRL<Env, Act>(id) {
    SetCond(2, 0);      ///< Set the operation lock (even for ns-3 and odd for python).
}
*/
/**
 * \param[in] a  a number to be added.
 *
 * \param[in] b  another number to be added.
 *
 * \returns the result of a+b.
 *
 * put a and b into the shared memory;
 * wait for the python to calculate the result c = a + b;
 * get the result c from shared memory;
 */
/*
int APB::Func(int a, int b)
{
    auto env = EnvSetterCond();     ///< Acquire the Env memory for writing
    env->a = a;
    env->b = b;
    SetCompleted();                 ///< Release the memory and update conters
    NS_LOG_DEBUG ("Ver:" << (int)SharedMemoryPool::Get()->GetMemoryVersion(m_id));
    auto act = ActionGetterCond();  ///< Acquire the Act memory for reading
    int ret = act->c;
    GetCompleted();                 ///< Release the memory, roll back memory version and update conters
    NS_LOG_DEBUG ("Ver:" << (int)SharedMemoryPool::Get()->GetMemoryVersion(m_id));
    return ret;
}
*/
//int memblock_key = 2333; //< memory block key, need to keep the same in the python script
//APB apb(memblock_key);


bool routing_time = false;
double average_cost = 0.0;
double average_lte_utilization = 0.0;
double average_ethernet_utilization = 0.0;
double average_dsrc_utilization = 0.0;
double average_latency = 0.0;
double average_latency_dsrc = 0.0;


void clear_solution()
{
	for (int i=0;i<(total_size+2);i++)
	{
		Z_gurobi[i] = 1;
		X_gurobi[i] = 1;
		Z_nodes[i] = 1;
		X_nodes[i] = 1;
	}
}



void send_LTE_metadata_uplink_alone(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> node_source, Ptr <Node> destination_node, uint32_t node_index)
{

  	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
	Ipv4InterfaceAddress iaddr = ipv4->GetAddress(2,0);//2nd IPv4 interface,0th address index
	Ipv4Address dest_ip = iaddr.GetLocal();
	Ptr <Node> nu = DynamicCast <Node> (node_source);
	uint32_t nid = uint32_t(nu->GetId());
	if (nid == 2)
	{
		lte_total_packet_size = 0;
		lte_initial_timestamp = Simulator::Now().GetSeconds(); 	
	}
	uint32_t size = getNeighborsize((neighbordata_inst+nid));
	//cout<<"sending vehicle data of neighborsize "<<size<<endl;
	uint32_t neighborid[size];
	//uint32_t combined_cost[size];
	for (uint32_t i=0;i<size;i++)
	{
		neighborid[i] = large;
	  	//combined_cost[i] = large;
	}
	CustomMetaDataUnicastTag0 tag0;
	CustomMetaDataUnicastTag1 tag1;
	CustomMetaDataUnicastTag2 tag2;
	CustomMetaDataUnicastTag3 tag3;
	CustomMetaDataUnicastTag4 tag4;
	CustomMetaDataUnicastTag5 tag5;
	CustomMetaDataUnicastTag6 tag6;
	CustomMetaDataUnicastTag7 tag7;
	CustomMetaDataUnicastTag8 tag8;
	CustomMetaDataUnicastTag9 tag9;
	CustomMetaDataUnicastTag10 tag10;
	CustomMetaDataUnicastTag11 tag11;
	CustomMetaDataUnicastTag12 tag12;
	CustomMetaDataUnicastTag13 tag13;
	CustomMetaDataUnicastTag14 tag14;
	CustomMetaDataUnicastTag15 tag15;
	CustomMetaDataUnicastTag16 tag16;
	CustomMetaDataUnicastTag17 tag17;
	CustomMetaDataUnicastTag18 tag18;
	CustomMetaDataUnicastTag19 tag19;
	CustomMetaDataUnicastTag20 tag20;
	CustomMetaDataUnicastTag21 tag21;
	CustomMetaDataUnicastTag22 tag22;
	CustomMetaDataUnicastTag23 tag23;
	CustomMetaDataUnicastTag24 tag24;
	CustomMetaDataUnicastTag25 tag25;
	CustomMetaDataUnicastTag tag;
	
	Time ti = Seconds(Simulator::Now().GetSeconds());
	Ptr <Packet> packet1 = Create <Packet> (0);
	uint32_t j = 0;
	for (uint32_t i=0;i<max;i++)
	{
		if ((((neighbordata_inst+nid)->neighborid[i]) != large) and (j<size))
		{
			neighborid[j] = (neighbordata_inst+nid)->neighborid[i];
	  		//combined_cost[i] = (neighbordata_inst+nid)->combined_cost[i];
	  		j++;
	  	}
	}
	switch (size)
	{
		case 0:
			tag0.SetNodeId(nid);
			//tag0.Setfrequency (data_transmission_frequency);
			//tag0.Setdatasize (84);
			tag0.SetTimestamp(ti);
			packet1->AddPacketTag(tag0);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 1:
			tag1.SetNodeId(nid);
			//tag1.Setfrequency (data_transmission_frequency);
			tag1.Setneighborid (neighborid);
			//tag1.Setcombinedcost (combined_cost);
			//tag1.Setdatasize (84);
			tag1.SetTimestamp(ti);
			packet1->AddPacketTag(tag1);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 2:
			tag2.SetNodeId(nid);
			//tag2.Setfrequency (data_transmission_frequency);
			tag2.Setneighborid (neighborid);
			//tag2.Setcombinedcost (combined_cost);
			//tag2.Setdatasize (84);
			tag2.SetTimestamp(ti);
			packet1->AddPacketTag(tag2);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 3:
			tag3.SetNodeId(nid);
			//tag3.Setfrequency (data_transmission_frequency);
			tag3.Setneighborid (neighborid);
			//tag3.Setcombinedcost (combined_cost);
			//tag3.Setdatasize (84);
			tag3.SetTimestamp(ti);
			packet1->AddPacketTag(tag3);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 4:
			tag4.SetNodeId(nid);
			//tag4.Setfrequency (data_transmission_frequency);
			tag4.Setneighborid (neighborid);
			//tag4.Setcombinedcost (combined_cost);
			//tag4.Setdatasize (84);
			tag4.SetTimestamp(ti);
			packet1->AddPacketTag(tag4);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 5:
			tag5.SetNodeId(nid);
			//tag5.Setfrequency (data_transmission_frequency);
			tag5.Setneighborid (neighborid);
			//tag5.Setcombinedcost (combined_cost);
			//tag5.Setdatasize (84);
			tag5.SetTimestamp(ti);
			packet1->AddPacketTag(tag5);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 6:
			tag6.SetNodeId(nid);
			//tag6.Setfrequency (data_transmission_frequency);
			tag6.Setneighborid (neighborid);
			//tag6.Setcombinedcost (combined_cost);
			//tag6.Setdatasize (84);
			tag6.SetTimestamp(ti);
			packet1->AddPacketTag(tag6);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 7:
			tag7.SetNodeId(nid);
			//tag7.Setfrequency (data_transmission_frequency);
			tag7.Setneighborid (neighborid);
			//tag7.Setcombinedcost (combined_cost);
			//tag7.Setdatasize (84);
			tag7.SetTimestamp(ti);
			packet1->AddPacketTag(tag7);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 8:
			tag8.SetNodeId(nid);
			//tag8.Setfrequency (data_transmission_frequency);
			tag8.Setneighborid (neighborid);
			//tag8.Setcombinedcost (combined_cost);
			//tag8.Setdatasize (84);
			tag8.SetTimestamp(ti);
			packet1->AddPacketTag(tag8);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 9:
			tag9.SetNodeId(nid);
			//tag9.Setfrequency (data_transmission_frequency);
			tag9.Setneighborid (neighborid);
			//tag9.Setcombinedcost (combined_cost);
			//tag9.Setdatasize (84);
			tag9.SetTimestamp(ti);
			packet1->AddPacketTag(tag9);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 10:
			tag10.SetNodeId(nid);
			//tag10.Setfrequency (data_transmission_frequency);
			tag10.Setneighborid (neighborid);
			//tag10.Setcombinedcost (combined_cost);
			//tag10.Setdatasize (84);
			tag10.SetTimestamp(ti);
			packet1->AddPacketTag(tag10);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 11:
			tag11.SetNodeId(nid);
			//tag11.Setfrequency (data_transmission_frequency);
			tag11.Setneighborid (neighborid);
			//tag11.Setcombinedcost (combined_cost);
			//tag11.Setdatasize (84);
			tag11.SetTimestamp(ti);
			packet1->AddPacketTag(tag11);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 12:
			tag12.SetNodeId(nid);
			//tag12.Setfrequency (data_transmission_frequency);
			tag12.Setneighborid (neighborid);
			//tag12.Setcombinedcost (combined_cost);
			//tag12.Setdatasize (84);
			tag12.SetTimestamp(ti);
			packet1->AddPacketTag(tag12);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 13:
			tag13.SetNodeId(nid);
			//tag13.Setfrequency (data_transmission_frequency);
			tag13.Setneighborid (neighborid);
			//tag13.Setcombinedcost (combined_cost);
			//tag13.Setdatasize (84);
			tag13.SetTimestamp(ti);
			packet1->AddPacketTag(tag13);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 14:
			tag14.SetNodeId(nid);
			//tag14.Setfrequency (data_transmission_frequency);
			tag14.Setneighborid (neighborid);
			//tag14.Setcombinedcost (combined_cost);
			//tag14.Setdatasize (84);
			tag14.SetTimestamp(ti);
			packet1->AddPacketTag(tag14);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 15:
			tag15.SetNodeId(nid);
			//tag15.Setfrequency (data_transmission_frequency);
			tag15.Setneighborid (neighborid);
			//tag15.Setcombinedcost (combined_cost);
			//tag15.Setdatasize (84);
			tag15.SetTimestamp(ti);
			packet1->AddPacketTag(tag15);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 16:
			tag16.SetNodeId(nid);
			//tag16.Setfrequency (data_transmission_frequency);
			tag16.Setneighborid (neighborid);
			//tag16.Setcombinedcost (combined_cost);
			//tag16.Setdatasize (84);
			tag16.SetTimestamp(ti);
			packet1->AddPacketTag(tag16);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 17:
			tag17.SetNodeId(nid);
			//tag17.Setfrequency (data_transmission_frequency);
			tag17.Setneighborid (neighborid);
			//tag17.Setcombinedcost (combined_cost);
			//tag17.Setdatasize (84);
			tag17.SetTimestamp(ti);
			packet1->AddPacketTag(tag17);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 18:
			tag18.SetNodeId(nid);
			//tag18.Setfrequency (data_transmission_frequency);
			tag18.Setneighborid (neighborid);
			//tag18.Setcombinedcost (combined_cost);
			//tag18.Setdatasize (84);
			tag18.SetTimestamp(ti);
			packet1->AddPacketTag(tag18);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 19:
			tag19.SetNodeId(nid);
			//tag19.Setfrequency (data_transmission_frequency);
			tag19.Setneighborid (neighborid);
			//tag19.Setcombinedcost (combined_cost);
			//tag19.Setdatasize (84);
			tag19.SetTimestamp(ti);
			packet1->AddPacketTag(tag19);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 20:
			tag20.SetNodeId(nid);
			//tag20.Setfrequency (data_transmission_frequency);
			tag20.Setneighborid (neighborid);
			//tag20.Setcombinedcost (combined_cost);
			//tag20.Setdatasize (84);
			tag20.SetTimestamp(ti);
			packet1->AddPacketTag(tag20);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 21:
			tag21.SetNodeId(nid);
			//tag21.Setfrequency (data_transmission_frequency);
			tag21.Setneighborid (neighborid);
			//tag21.Setcombinedcost (combined_cost);
			//tag21.Setdatasize (84);
			tag21.SetTimestamp(ti);
			packet1->AddPacketTag(tag21);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 22:
			tag22.SetNodeId(nid);
			//tag22.Setfrequency (data_transmission_frequency);
			tag22.Setneighborid (neighborid);
			//tag22.Setcombinedcost (combined_cost);
			//tag22.Setdatasize (84);
			tag22.SetTimestamp(ti);
			packet1->AddPacketTag(tag22);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 23:
			tag23.SetNodeId(nid);
			//tag23.Setfrequency (data_transmission_frequency);
			tag23.Setneighborid (neighborid);
			//tag23.Setcombinedcost (combined_cost);
			//tag23.Setdatasize (84);
			tag23.SetTimestamp(ti);
			packet1->AddPacketTag(tag23);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 24:
			tag24.SetNodeId(nid);
			//tag24.Setfrequency (data_transmission_frequency);
			tag24.Setneighborid (neighborid);
			//tag24.Setcombinedcost (combined_cost);
			//tag24.Setdatasize (84);
			tag24.SetTimestamp(ti);
			packet1->AddPacketTag(tag24);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 25:
			tag25.SetNodeId(nid);
			//tag25.Setfrequency (data_transmission_frequency);
			tag25.Setneighborid (neighborid);
			//tag25.Setcombinedcost (combined_cost);
			//tag25.Setdatasize (84);
			tag25.SetTimestamp(ti);
			packet1->AddPacketTag(tag25);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		default:
			cout<<"Cellular:maximum status datasize exceeded. size is "<<size<<endl;
			tag.SetNodeId(nid);
			//tag.Setfrequency (data_transmission_frequency);
			tag.Setneighborid ((neighbordata_inst+nid)->neighborid);
			//tag.Setcombinedcost ((neighbordata_inst+nid)->combined_cost);
			//tag.Setdatasize (84);
			tag.SetTimestamp(ti);
			packet1->AddPacketTag(tag);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
	}
	cout<<"lte total packet size is "<<lte_total_packet_size<<endl;
}

void send_LTE_metadata_downlink_alone(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> node_source, Ptr <Node> destination_node, uint32_t node_index)
{
  	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
	Ipv4InterfaceAddress iaddr = ipv4->GetAddress(1,0);//1st IPv4 interface,0th address index
	Ipv4Address dest_ip = iaddr.GetLocal();
	//cout<<dest_ip<<endl;
	Ptr <Node> nu = DynamicCast <Node> (node_source);
	CustomMetaDataDownlinkUnicastTag tag;
	uint32_t nid = uint32_t(destination_node->GetId());
	tag.SetNodeId(nid);
	tag.SetZ (Z_gurobi[nid]);
	tag.SetX (X_gurobi[nid]);
	//tag.SetZ (1);
	//tag.SetX (0);
	Ptr <Packet> packet1 = Create <Packet> (0);
	packet1->AddPacketTag(tag);
	Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
}





void send_LTE_deltavalues_downlink_alone(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> node_source, Ptr <Node> destination_node, uint32_t node_index)
{
  	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
	Ipv4InterfaceAddress iaddr = ipv4->GetAddress(1,0);//1st IPv4 interface,0th address index
	Ipv4Address dest_ip = iaddr.GetLocal();
	//cout<<dest_ip<<endl;
	Ptr <Node> nu = DynamicCast <Node> (node_source);
	CustomDeltavaluesDownlinkUnicastTag tag;
	uint32_t nid = uint32_t(destination_node->GetId());
	//cout<<"node id is "<<nid<<"dest ip "<<dest_ip<<"custom value is"<<(delta_at_controller_inst+3)->delta_fi_inst[4].delta_values[5]<<endl;
	
	double delta_Set[2*flows][total_size];
	uint32_t sources[2*flows];
	uint32_t destinations[2*flows];
	uint32_t flow_ids[2*flows];
	uint32_t flow_sizes[2*flows];
	uint32_t nodeid = nid-2;
	double load[2*flows];
	
	for(uint32_t i=0;i<2*flows;i++)
	{
		load[i] = 0.0;
		for(uint32_t j=0;j<total_size;j++)	
		{
			load[i] = load[i] + (L_at_controller_inst+i)->L_fi_inst[nid-2].L_values[j];
			delta_Set[i][j] = (delta_at_controller_inst+i)->delta_fi_inst[nid-2].delta_values[j];
			//cout<< "i = "<<i<<"nid = "<<nid<<"j= "<<j<<"value="<<(delta_at_controller_inst+i)->delta_fi_inst[nid-2].delta_values[j]<<endl;
		}
		sources[i] = (demanding_flow_struct_controller_inst+i)->source;
		destinations[i] = (demanding_flow_struct_controller_inst+i)->destination;
		flow_ids[i] = i;
		flow_sizes[i] = (demanding_flow_struct_controller_inst+i)->f_size;
	}
	/*

	*/
	
	//cout<<delta_Set[3][2]<<dest_ip<<endl;
	//TEST - comment at implementation
	/*
	if ((nid-2) == 2)
	{
		delta_Set[3][5] = 0.75;
		sources[3] = 7;
		destinations[3] = 15;
		flow_ids[3] = 3;
	}
	*/
	//
	
	tag.Setdeltas(delta_Set);
	tag.Setsources (sources);
	tag.Setdestinations (destinations);
	tag.Setflow_ids (flow_ids);
	tag.Setflow_sizes(flow_sizes);
	tag.Setnodeid(nodeid);
	tag.Setload(load);
	//tag.SetX (0);
	Ptr <Packet> packet1 = Create <Packet> (0);
	packet1->AddPacketTag(tag);
	Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
}

void RSU_deltavalues_downlink_unicast(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> source_node, Ptr <Node> destination_node)
{
	Ptr <Node> nu = DynamicCast <Node> (source_node);
	uint32_t nid = uint32_t(destination_node->GetId());
	
	CustomDeltavaluesDownlinkUnicastTag tag;
	//cout<<"node id is "<<nid<<"dest ip "<<dest_ip<<"custom value is"<<(delta_at_controller_inst+3)->delta_fi_inst[4].delta_values[5]<<endl;
	
	double delta_Set[2*flows][total_size];
	uint32_t sources[2*flows];
	uint32_t destinations[2*flows];
	uint32_t flow_ids[2*flows];
	uint32_t flow_sizes[2*flows];
	uint32_t nodeid = nid-2;
	double load[2*flows];
	
	for(uint32_t i=0;i<2*flows;i++)
	{
		load[i] = 0.0;
		for(uint32_t j=0;j<total_size;j++)	
		{
			load[i] = load[i] + (L_at_controller_inst+i)->L_fi_inst[nid-2].L_values[j];
			delta_Set[i][j] = (delta_at_controller_inst+i)->delta_fi_inst[nid-2].delta_values[j];
			//cout<< "i = "<<i<<"nid = "<<nid<<"j= "<<j<<"value="<<(delta_at_controller_inst+i)->delta_fi_inst[nid-2].delta_values[j]<<endl;
		}
		sources[i] = (demanding_flow_struct_controller_inst+i)->source;
		destinations[i] = (demanding_flow_struct_controller_inst+i)->destination;
		flow_ids[i] = i;
		flow_sizes[i] = (demanding_flow_struct_controller_inst+i)->f_size;
	}
	
	//cout<<delta_Set[3][2]<<dest_ip<<endl;
	
	tag.Setdeltas(delta_Set);
	tag.Setsources (sources);
	tag.Setdestinations (destinations);
	tag.Setflow_ids (flow_ids);
	tag.Setflow_sizes(flow_sizes);
	tag.Setnodeid(nodeid);
	tag.Setload(load);

	Ptr <Packet> packet1 = Create <Packet> (0);
	packet1->AddPacketTag(tag);
  	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
  	Ipv4InterfaceAddress iaddr;
	iaddr = ipv4->GetAddress(1,0);//2nd IPv4 interface,0th address index
	Ipv4Address dest_ip = iaddr.GetLocal();
	//cout<<"destination ip address "<<dest_ip;
	Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
}

void RSU_metadata_uplink_unicast(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> source_node, Ptr <Node> destination_node)
{

	Ptr <Node> nu = DynamicCast <Node> (source_node);
	uint32_t nid = uint32_t(nu->GetId());
	if (nid == (N_Vehicles+2))
	{
		ethernet_total_packet_size = 0;
		ethernet_initial_timestamp = Simulator::Now().GetSeconds();
	}
	uint32_t size = getNeighborsize((neighbordata_inst+nid));
	uint32_t neighborid[size];
	//uint32_t combined_cost[size];
	for (uint32_t i=0;i<size;i++)
	{
		neighborid[i] = large;
	  	//combined_cost[i] = large;
	}
	//cout<<neighborid[0]<<combined_cost[0]<<endl;
	//cout<<"RSU: "<<size<<"node id"<<nid<<endl;
	CustomMetaDataUnicastTag0 tag0;
	CustomMetaDataUnicastTag1 tag1;
	CustomMetaDataUnicastTag2 tag2;
	CustomMetaDataUnicastTag3 tag3;
	CustomMetaDataUnicastTag4 tag4;
	CustomMetaDataUnicastTag5 tag5;
	CustomMetaDataUnicastTag6 tag6;
	CustomMetaDataUnicastTag7 tag7;
	CustomMetaDataUnicastTag8 tag8;
	CustomMetaDataUnicastTag9 tag9;
	CustomMetaDataUnicastTag10 tag10;
	CustomMetaDataUnicastTag11 tag11;
	CustomMetaDataUnicastTag12 tag12;
	CustomMetaDataUnicastTag13 tag13;
	CustomMetaDataUnicastTag14 tag14;
	CustomMetaDataUnicastTag15 tag15;
	CustomMetaDataUnicastTag16 tag16;
	CustomMetaDataUnicastTag17 tag17;
	CustomMetaDataUnicastTag18 tag18;
	CustomMetaDataUnicastTag19 tag19;
	CustomMetaDataUnicastTag20 tag20;
	CustomMetaDataUnicastTag21 tag21;
	CustomMetaDataUnicastTag22 tag22;
	CustomMetaDataUnicastTag23 tag23;
	CustomMetaDataUnicastTag24 tag24;
	CustomMetaDataUnicastTag25 tag25;
	CustomMetaDataUnicastTag tag;
	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
	Ipv4InterfaceAddress iaddr;
	if (N_Vehicles > 0)
	{
		iaddr = ipv4->GetAddress(1,0);//2nd IPv4 interface,0th address index
	}
	else if (N_Vehicles == 0)
	{
		iaddr = ipv4->GetAddress(0,0);//1st IPv4 interface,0th address index
	}
	Ipv4Address dest_ip = iaddr.GetLocal();
	Time ti = Seconds(Simulator::Now().GetSeconds());
	Ptr <Packet> packet1 = Create <Packet> (0);
	uint32_t j=0;
	for (uint32_t i=0;i<max;i++)
	{
		if ((((neighbordata_inst+nid)->neighborid[i]) != large) and (j<size))
		{
			neighborid[j] = (neighbordata_inst+nid)->neighborid[i];
	  		//combined_cost[i] = (neighbordata_inst+nid)->combined_cost[i];
	  		j++;
	  	}
	}
	switch (size)
	{
		case 0:
			cout<<"case 0";
			tag0.SetNodeId(nid);
			//tag0.Setfrequency (data_transmission_frequency);
			//tag0.Setdatasize (84);
			tag0.SetTimestamp(ti);
			packet1->AddPacketTag(tag0);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 1:
			cout<<"case 1";
			tag1.SetNodeId(nid);
			//tag1.Setfrequency (data_transmission_frequency);
			tag1.Setneighborid (neighborid);
			//tag1.Setcombinedcost (combined_cost);
			//tag1.Setdatasize (84);
			tag1.SetTimestamp(ti);
			packet1->AddPacketTag(tag1);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 2:
			cout<<"case 2";
			tag2.SetNodeId(nid);
			//tag2.Setfrequency (data_transmission_frequency);
			tag2.Setneighborid (neighborid);
			//tag2.Setcombinedcost (combined_cost);
			//tag2.Setdatasize (84);
			tag2.SetTimestamp(ti);
			packet1->AddPacketTag(tag2);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 3:
			cout<<"case 3";
			tag3.SetNodeId(nid);
			//tag3.Setfrequency (data_transmission_frequency);
			tag3.Setneighborid (neighborid);
			//tag3.Setcombinedcost (combined_cost);
			//tag3.Setdatasize (84);
			tag3.SetTimestamp(ti);
			packet1->AddPacketTag(tag3);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 4:
			tag4.SetNodeId(nid);
			//tag4.Setfrequency (data_transmission_frequency);
			tag4.Setneighborid (neighborid);
			//tag4.Setcombinedcost (combined_cost);
			//tag4.Setdatasize (84);
			tag4.SetTimestamp(ti);
			packet1->AddPacketTag(tag4);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 5:
			tag5.SetNodeId(nid);
			//tag5.Setfrequency (data_transmission_frequency);
			tag5.Setneighborid (neighborid);
			//tag5.Setcombinedcost (combined_cost);
			//tag5.Setdatasize (84);
			tag5.SetTimestamp(ti);
			packet1->AddPacketTag(tag5);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 6:
			tag6.SetNodeId(nid);
			//tag6.Setfrequency (data_transmission_frequency);
			tag6.Setneighborid (neighborid);
			//tag6.Setcombinedcost (combined_cost);
			//tag6.Setdatasize (84);
			tag6.SetTimestamp(ti);
			packet1->AddPacketTag(tag6);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 7:
			tag7.SetNodeId(nid);
			//tag7.Setfrequency (data_transmission_frequency);
			tag7.Setneighborid (neighborid);
			//tag7.Setcombinedcost (combined_cost);
			//tag7.Setdatasize (84);
			tag7.SetTimestamp(ti);
			packet1->AddPacketTag(tag7);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 8:
			tag8.SetNodeId(nid);
			//tag8.Setfrequency (data_transmission_frequency);
			tag8.Setneighborid (neighborid);
			//tag8.Setcombinedcost (combined_cost);
			//tag8.Setdatasize (84);
			tag8.SetTimestamp(ti);
			packet1->AddPacketTag(tag8);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 9:
			tag9.SetNodeId(nid);
			//tag9.Setfrequency (data_transmission_frequency);
			tag9.Setneighborid (neighborid);
			//tag9.Setcombinedcost (combined_cost);
			//tag9.Setdatasize (84);
			tag9.SetTimestamp(ti);
			packet1->AddPacketTag(tag9);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 10:
			tag10.SetNodeId(nid);
			//tag10.Setfrequency (data_transmission_frequency);
			tag10.Setneighborid (neighborid);
			//tag10.Setcombinedcost (combined_cost);
			//tag10.Setdatasize (84);
			tag10.SetTimestamp(ti);
			packet1->AddPacketTag(tag10);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 11:
			tag11.SetNodeId(nid);
			//tag11.Setfrequency (data_transmission_frequency);
			tag11.Setneighborid (neighborid);
			//tag11.Setcombinedcost (combined_cost);
			//tag11.Setdatasize (84);
			tag11.SetTimestamp(ti);
			packet1->AddPacketTag(tag11);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 12:
			tag12.SetNodeId(nid);
			//tag12.Setfrequency (data_transmission_frequency);
			tag12.Setneighborid (neighborid);
			//tag12.Setcombinedcost (combined_cost);
			//tag12.Setdatasize (84);
			tag12.SetTimestamp(ti);
			packet1->AddPacketTag(tag12);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 13:
			tag13.SetNodeId(nid);
			//tag13.Setfrequency (data_transmission_frequency);
			tag13.Setneighborid (neighborid);
			//tag13.Setcombinedcost (combined_cost);
			//tag13.Setdatasize (84);
			tag13.SetTimestamp(ti);
			packet1->AddPacketTag(tag13);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 14:
			tag14.SetNodeId(nid);
			//tag14.Setfrequency (data_transmission_frequency);
			tag14.Setneighborid (neighborid);
			//tag14.Setcombinedcost (combined_cost);
			//tag14.Setdatasize (84);
			tag14.SetTimestamp(ti);
			packet1->AddPacketTag(tag14);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 15:
			tag15.SetNodeId(nid);
			//tag15.Setfrequency (data_transmission_frequency);
			tag15.Setneighborid (neighborid);
			//tag15.Setcombinedcost (combined_cost);
			//tag15.Setdatasize (84);
			tag15.SetTimestamp(ti);
			packet1->AddPacketTag(tag15);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 16:
			tag16.SetNodeId(nid);
			//tag16.Setfrequency (data_transmission_frequency);
			tag16.Setneighborid (neighborid);
			//tag16.Setcombinedcost (combined_cost);
			//tag16.Setdatasize (84);
			tag16.SetTimestamp(ti);
			packet1->AddPacketTag(tag16);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 17:
			tag17.SetNodeId(nid);
			//tag17.Setfrequency (data_transmission_frequency);
			tag17.Setneighborid (neighborid);
			//tag17.Setcombinedcost (combined_cost);
			//tag17.Setdatasize (84);
			tag17.SetTimestamp(ti);
			packet1->AddPacketTag(tag17);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 18:
			tag18.SetNodeId(nid);
			//tag18.Setfrequency (data_transmission_frequency);
			tag18.Setneighborid (neighborid);
			//tag18.Setcombinedcost (combined_cost);
			//tag18.Setdatasize (84);
			tag18.SetTimestamp(ti);
			packet1->AddPacketTag(tag18);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 19:
			tag19.SetNodeId(nid);
			//tag19.Setfrequency (data_transmission_frequency);
			tag19.Setneighborid (neighborid);
			//tag19.Setcombinedcost (combined_cost);
			//tag19.Setdatasize (84);
			tag19.SetTimestamp(ti);
			packet1->AddPacketTag(tag19);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 20:
			tag20.SetNodeId(nid);
			//tag20.Setfrequency (data_transmission_frequency);
			tag20.Setneighborid (neighborid);
			//tag20.Setcombinedcost (combined_cost);
			//tag20.Setdatasize (84);
			tag20.SetTimestamp(ti);
			packet1->AddPacketTag(tag20);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 21:
			tag21.SetNodeId(nid);
			//tag21.Setfrequency (data_transmission_frequency);
			tag21.Setneighborid (neighborid);
			//tag21.Setcombinedcost (combined_cost);
			//tag21.Setdatasize (84);
			tag21.SetTimestamp(ti);
			packet1->AddPacketTag(tag21);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 22:
			tag22.SetNodeId(nid);
			//tag22.Setfrequency (data_transmission_frequency);
			tag22.Setneighborid (neighborid);
			//tag22.Setcombinedcost (combined_cost);
			//tag22.Setdatasize (84);
			tag22.SetTimestamp(ti);
			packet1->AddPacketTag(tag22);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 23:
			tag23.SetNodeId(nid);
			//tag23.Setfrequency (data_transmission_frequency);
			tag23.Setneighborid (neighborid);
			//tag23.Setcombinedcost (combined_cost);
			//tag23.Setdatasize (84);
			tag23.SetTimestamp(ti);
			packet1->AddPacketTag(tag23);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 24:
			tag24.SetNodeId(nid);
			//tag24.Setfrequency (data_transmission_frequency);
			tag24.Setneighborid (neighborid);
			//tag24.Setcombinedcost (combined_cost);
			//tag24.Setdatasize (84);
			tag24.SetTimestamp(ti);
			packet1->AddPacketTag(tag24);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 25:
			tag25.SetNodeId(nid);
			//tag25.Setfrequency (data_transmission_frequency);
			tag25.Setneighborid (neighborid);
			//tag25.Setcombinedcost (combined_cost);
			//tag25.Setdatasize (84);
			tag25.SetTimestamp(ti);
			packet1->AddPacketTag(tag25);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		default:
			cout<<"RSU: maximum data size exceeded. size is"<<size<<endl;
			tag.SetNodeId(nid);
			//tag.Setfrequency (data_transmission_frequency);
			tag.Setneighborid ((neighbordata_inst+nid)->neighborid);
			//tag.Setcombinedcost ((neighbordata_inst+nid)->combined_cost);
			//tag.Setdatasize (84);
			tag.SetTimestamp(ti);
			packet1->AddPacketTag(tag);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
	}
	cout<<"RSU total packet size is "<<ethernet_total_packet_size<<endl;
}
bool sent_IDS[2*flows][total_size][Flow_size+2];

void RSU_metadata_downlink_unicast(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> source_node, Ptr <Node> destination_node)
{
	Ptr <Node> nu = DynamicCast <Node> (source_node);
	CustomMetaDataDownlinkUnicastTag tag;
	uint32_t nid = uint32_t(destination_node->GetId());
	tag.SetNodeId(nid);
	tag.SetZ (Z_gurobi[nid]);
	tag.SetX (X_gurobi[nid]);
	//tag.SetZ (0);
	//tag.SetX (1);
	Ptr <Packet> packet1 = Create <Packet> (0);
	packet1->AddPacketTag(tag);
  	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
  	Ipv4InterfaceAddress iaddr;
	iaddr = ipv4->GetAddress(1,0);//2nd IPv4 interface,0th address index
	Ipv4Address dest_ip = iaddr.GetLocal();
	//cout<<"destination ip address "<<dest_ip;
	Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
}

void write_csv()
{
	fstream fout;
	fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_data.csv",ios::out|ios::trunc);
	for (uint32_t i=2; i<total_size+2 ;i++)
	{
		fout << total_size << ", "
		     <<	con_data_inst[i].B << ", "
		     << con_data_inst[i].neighborsize << ", ";
		     //<< con_data_inst[i].frequency << ", "
		     //<< con_data_inst[i].datasize << ", ";
		     for(uint32_t j=0;j<max;j++)
		     {
		     	fout<< con_data_inst[i].neighborid[j] << ", ";
		     }
		     /*
		     for(uint32_t j=0;j<max;j++)
		     {
		     	fout<< con_data_inst[i].combined_cost[j] << ", ";
		     }
		     */
		     fout<< "\n";
	}
	fout.close();
}

void write_csv_status_lifetime()
{
	fstream fout;
	switch(routing_algorithm)
	{
		case(0):
			fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_link_lifetime_data_ECMP.csv",ios::out|ios::trunc);
			break;
		case(1):
			fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_link_lifetime_data_RR.csv",ios::out|ios::trunc);
			break;
		case(2):
			fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_link_lifetime_data_QRSDN.csv",ios::out|ios::trunc);
			break;
		case(3):
			fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_link_lifetime_data_RLMR.csv",ios::out|ios::trunc);
			break;
		case(4):
			fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_link_lifetime_data.csv",ios::out|ios::trunc);
			break;
		case(5):
			if(experiment_number == 0)
			{
				fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_link_lifetime_data_QRSDN.csv",ios::out|ios::trunc);
			}
			if(experiment_number == 1)
			{
				fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_link_lifetime_data_RR.csv",ios::out|ios::trunc);
			}
			if(experiment_number == 2)
			{
				fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_link_lifetime_data_QRSDN.csv",ios::out|ios::trunc);
			}
			if(experiment_number == 3)
			{
				fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_link_lifetime_data_RLMR.csv",ios::out|ios::trunc);
			}
			break;
			
		default:
			fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_link_lifetime_data.csv",ios::out|ios::trunc);
			break;
	}
	for (uint32_t i=0; i<total_size ;i++)
	{
		//cout<<"writing status "<<i<<endl;
		fout << total_size << ", "
		     << (routing_data_at_controller_inst+i)->nodeid << ", "
		     << (routing_data_at_controller_inst+i)->position.x << ", "
		     << (routing_data_at_controller_inst+i)->position.y << ", "
		     << (routing_data_at_controller_inst+i)->velocity.x<< ", "
		     << (routing_data_at_controller_inst+i)->velocity.y << ", "
		     << (routing_data_at_controller_inst+i)->acceleration.x << ", "
		     << (routing_data_at_controller_inst+i)->acceleration.y << ", "
		     << mobility_scenario << ", "
		     << N_Vehicles << ", "
		     << N_RSUs << ", "
		     << "\n";
	}
	fout.close();
	cout<<"finished writing link lifetime status at"<<Now().GetSeconds()<<endl;
}

void write_csv_status()
{
	fstream fout;
	fout.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_link_lifetime_data.csv",ios::out|ios::trunc);
	for (uint32_t i=2; i<total_size+2 ;i++)
	{
		Ptr <Node> node;
		if ((i-2) < N_Vehicles)
		{	
			node = DynamicCast <Node> (Vehicle_Nodes.Get(i-2));
		}
		else
		{
			node = DynamicCast <Node> (RSU_Nodes.Get(i-N_Vehicles-2));
		}
		
		Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (node->GetObject<MobilityModel>());
        	Vector position = mdl->GetPosition();
        	Vector velocity = mdl->GetVelocity();
		//cout<<"writing status "<<i<<endl;
		fout << total_size << ", "
		     << position.x << ", "
		     <<	position.y << ", "
		     << velocity.x<< ", "
		     << velocity.y << ", "
		     << data_at_manager_inst[i].acceleration.x << ", "
		     << data_at_manager_inst[i].acceleration.y << ", "
		     << mobility_scenario << ", "
		     << N_Vehicles << ", "
		     << N_RSUs << ", "
		     << "\n";
	}
	fout.close();
	cout<<"finished writing status"<<endl;
}


void read_csv()
{
    fstream fin;
    fin.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_results.csv", ios::in);
    vector<string> row;
    string line;
    string temp;
    int j=0;
    while (fin >> temp) 
    {
        row.clear();
        getline(fin, line);
        int n = line.length();
        char line_char[n+1];
        strcpy(line_char,line.c_str());
        //cout<<line<<endl;
        int int_val;
        char * ptr;
        ptr = strtok(line_char,",");
        int i =0;
        while(ptr != NULL)
        {
        	stringstream ss;
		ss << ptr;
		ss >> int_val;
		if (i==0)
		{
			X_gurobi[j+2] = int_val;
			//cout<<"x"<<j<<" value "<<int_val<<endl;
		}
		if (i==1)
		{
			Z_gurobi[j+2] = int_val;
			//cout<<"z"<<j<<"value "<<int_val<<endl;
		}
        	
        	ptr = strtok(NULL,",");   
        	i++;	
        }
        j++;
    }
    if (j == 0)
        cout << "Solution not found\n";
}

double current_cost = 0.0;
double current_lte_utilization = 0.0;
double current_ethernet_utilization = 0.0;
double current_dsrc_utilization=0.0;
double current_latency=0.0;
double current_latency_dsrc = 0.0;
double optimization_percentage = 0.0;
double average_packet_delivery_ratio = 0.0;
double current_packet_delivery_ratio = 0.0;
double average_packet_delivery_ratio_dsrc = 0.0;
double current_packet_delivery_ratio_dsrc = 0.0;
double normalized_mobility = 0.0;
double network_contention = 0.0;

void write_csv_results()
{
	fstream fout;
	string filename;
	if (architecture == 0)
	{
		switch (experiment_number)
		{
			case (0)://entropy experiment
				filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_entropy.csv";
	
				break;
			case (1)://optimization frequency
				if (data_transmission_frequency == 0.02)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_frequency_0.02.csv";
				}
				if (data_transmission_frequency ==0.05)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_frequency_0.05.csv";
				}
				if (data_transmission_frequency ==0.10)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_frequency_0.10.csv";
				}
				if (data_transmission_frequency ==0.25)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_frequency_0.25.csv";
				}
				if (data_transmission_frequency ==0.50)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_frequency_0.50.csv";
				}

				if (data_transmission_frequency == 1.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_frequency_1.00.csv";
				}

				if (data_transmission_frequency ==2.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_frequency_2.csv";
				}

				if (data_transmission_frequency ==4.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_frequency_4.csv";
				}

				if (data_transmission_frequency ==6.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_frequency_6.csv";
				}

				if (data_transmission_frequency ==8.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_frequency_8.csv";
				}

				if (data_transmission_frequency ==10.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_frequency_10.csv";
				}

				break;
			case (2): //number of nodes
				switch(total_size)
				{
					case (4):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_nodes_4.csv";
						break;
					case (8):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_nodes_8.csv";
						break;
					case (16):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_nodes_16.csv";
						break;
					case (32):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_nodes_32.csv";
						break;
					case (64):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_nodes_64.csv";
						break;
					case (96):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_nodes_96.csv";
						break;
					case (128):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_nodes_128.csv";
						break;
					case (160):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_nodes_160.csv";
						break;						
					case (192):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_nodes_192.csv";
						break;
					case (224):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_nodes_224.csv";
						break;
					case (256):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_nodes_256.csv";
						break;
				}
				break;
			case (3)://mobility scenario
				if (mobility_scenario == 0) //urban mobility
				  {
				  	switch(maxspeed)
				  	{
				  		case (0):
				  			filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_urban_0.csv";
					  		break;
				  		case (10):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_urban_10.csv";
					  		break;
					  	case (20):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_urban_20.csv";
					  		break;
					  	case (30):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_urban_30.csv";
					  		break;
					  	case (40):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_urban_40.csv";
					  		break;
					  	case (50):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_urban_50.csv";
					  		break;
					  	case (60):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_urban_60.csv";
					  		break;
					  	default:
					  		break;
					 }
				   }
				   
				   if (mobility_scenario == 1) //non-urban mobility
				   {
				   	switch(maxspeed)
				   	{
				   		case (0):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_rural_0.csv";
				   	  		break;
				   		case (10):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_rural_10.csv";
				   	  		break;
				   	  	case (20):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_rural_20.csv";
					  		break;
					  	case (30):
					   		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_rural_30.csv";
					   		break;
					   	case (40):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_rural_40.csv";
					  		break;
					  	case (50):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_rural_50.csv";
					  		break;
					  	case (60):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_rural_60.csv";
					  		break;
				   	  	case (70):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_rural_70.csv";
				   	  		break;
				   	  	case (80):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_rural_80.csv";
				   	  		break;
				   	  	case (90):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_rural_90.csv";
				   	  		break;
				   	  	case (100):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_rural_100.csv";
				   	  		break;
				   	  	default:
				   	  		break;
					 }
				   }
				   
				   if (mobility_scenario == 2)//highway
				   {
				   	  switch(maxspeed)
				   	  {
				   	  	case (0):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_0.csv";
				   	  		break;
				   	  	case (10):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_10.csv";
				   	  		break;
				   	  	case (30):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_30.csv";
				   	  		break;
				   	  	case (50):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_50.csv";
				   	  		break;
				   	  	case (70):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_70.csv";
				   	  		break;
				   	  	case (90):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_90.csv";
				   	  		break;
				   	  	case (110):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_110.csv";
				   	  		break;
					 	case (130):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_130.csv";
					 		break;
					 	case (150):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_150.csv";
					 		break;
					 	case (170):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_170.csv";
					 		break;
					 	case (190):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_190.csv";
					 		break;
					 	case (210):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_210.csv";
					 		break;
					 	case (230):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_230.csv";
					 		break;
					 	case (250):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_mobility_autobahn_250.csv";
					 		break;
					 	default:
					 		break;
					  }
				   }
				break;
			case (4): //RSU ratios
				uint32_t ratio;
				if (N_RSUs != 0)
				{
					ratio = N_Vehicles/N_RSUs;
				}
				else
				{
					ratio = 200;
				}
				switch (ratio)
				{
					case(200)://200 veh, 0 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_heterogeneity_inf.csv";
						break;
					case(199)://199 veh, 1 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_heterogeneity_199.csv";
						break;
					case(99)://198 veh, 2 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_heterogeneity_99.csv";
						break;
					case(49)://196 veh, 4 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_heterogeneity_49.csv";
						break;
					case(24)://192 veh, 8 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_heterogeneity_24.csv";
						break;
					case(9)://180 veh, 20 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_heterogeneity_9.csv";
						break;
					case(4)://160 veh, 40 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_heterogeneity_4.csv";
						break;
					case(3):// 150 veh, 50 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_heterogeneity_3.csv";
						break;
					case(2): //134 veh, 66 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_heterogeneity_2.csv";
						break;
					case(1): //100 veh, 100 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_heterogeneity_1.csv";
						break;
					case(0): //0 veh, 200 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/centralized_heterogeneity_0.csv";
						break;
				}
				break;
			case (7)://threshold experiment
				filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_threshold.csv";
				break;	
			case (8)://threshold experiment
				filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_threshold.csv";
				break;
			case (9)://routing frequency
				if (routing_frequency == 0.02)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_frequency_0.02.csv";
				}
				if (routing_frequency ==0.05)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_frequency_0.05.csv";
				}
				if (routing_frequency ==0.10)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_frequency_0.10.csv";
				}
				if (routing_frequency ==0.25)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_frequency_0.25.csv";
				}
				if (routing_frequency ==0.50)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_frequency_0.50.csv";
				}
				if (routing_frequency == 1.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_frequency_1.00.csv";
				}
				if (routing_frequency ==2.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_frequency_2.csv";
				}

				if (routing_frequency ==3.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_frequency_3.csv";
				}
		
				if (routing_frequency == 4.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_frequency_4.csv";
				}

				if (routing_frequency ==5.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_frequency_5.csv";
				}
				break;
			case (10): //number of nodes for routing
				switch(total_size)
				{
					case (4):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_nodes_4.csv";
						break;
					case (8):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_nodes_8.csv";
						break;
					case (16):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_nodes_16.csv";
						break;
					case (32):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_nodes_32.csv";
						break;
					case (64):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_nodes_64.csv";
						break;
					case (96):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_nodes_96.csv";
						break;
					case (128):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_nodes_128.csv";
						break;
					case (160):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_nodes_160.csv";
						break;						
					case (192):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_nodes_192.csv";
						break;
					case (224):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_nodes_224.csv";
						break;
					case (256):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_nodes_256.csv";
						break;
				}
				break;
			case (11)://mobility scenario routing
				if (mobility_scenario == 0) //urban mobility
				  {
				  	switch(maxspeed)
				  	{
				  		case (0):
				  			filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_urban_0.csv";
					  		break;
				  		case (10):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_urban_10.csv";
					  		break;
					  	case (20):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_urban_20.csv";
					  		break;
					  	case (30):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_urban_30.csv";
					  		break;
					  	case (40):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_urban_40.csv";
					  		break;
					  	case (50):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_urban_50.csv";
					  		break;
					  	case (60):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_urban_60.csv";
					  		break;
					  	default:
					  		break;
					 }
				   }
				   
				   if (mobility_scenario == 1) //non-urban mobility
				   {
				   	switch(maxspeed)
				   	{
				   		case (0):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_rural_0.csv";
				  	  		break;
				   	  	case (20):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_rural_20.csv";
					  		break;
					   	case (40):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_rural_40.csv";
					  		break;
					  	case (60):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_rural_60.csv";
					  		break;
				   	  	case (80):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_rural_80.csv";
				   	  		break;
				   	  	case (100):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_rural_100.csv";
				   	  		break;
				   	  	default:
				   	  		break;
					 }
				   }
				   
				   if (mobility_scenario == 2)//highway
				   {
				   	  switch(maxspeed)
				   	  {
				   	  	case (0):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_autobahn_0.csv";
				   	  		break;
				   	  	case (30):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized__routing_mobility_autobahn_30.csv";
				   	  		break;
				   	  	case (50):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized__routing_mobility_autobahn_50.csv";
				   	  		break;
				   	  	case (90):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized__routing_mobility_autobahn_90.csv";
				   	  		break;
					 	case (130):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized__routing_mobility_autobahn_130.csv";
					 		break;
					 	case (170):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized__routing_mobility_autobahn_170.csv";
					 		break;
					 	case (210):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized__routing_mobility_autobahn_210.csv";
					 		break;
					 	case (250):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/centralized_routing_mobility_autobahn_250.csv";
					 		break;
					 	default:
					 		break;
					  }
				   }
				break;
		}
	}
	
	if (architecture == 1)
	{
		switch (experiment_number)
		{
			case (0)://entropy experiment
				filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_entropy.csv";
	
				break;
			case (1)://optimization frequency
				if (data_transmission_frequency == 0.02)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_frequency_0.02.csv";
				}
				if (data_transmission_frequency ==0.05)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_frequency_0.05.csv";
				}
				if (data_transmission_frequency ==0.10)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_frequency_0.10.csv";
				}
				if (data_transmission_frequency ==0.25)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_frequency_0.25.csv";
				}
				if (data_transmission_frequency ==0.50)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_frequency_0.50.csv";
				}

				if (data_transmission_frequency == 1.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_frequency_1.00.csv";
				}

				if (data_transmission_frequency ==2.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_frequency_2.csv";
				}

				if (data_transmission_frequency ==4.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_frequency_4.csv";
				}

				if (data_transmission_frequency ==6.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_frequency_6.csv";
				}

				if (data_transmission_frequency ==8.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_frequency_8.csv";
				}

				if (data_transmission_frequency ==10.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_frequency_10.csv";
				}

				break;
			case (2): //number of nodes
				switch(total_size)
				{
					case (4):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_nodes_4.csv";
						break;
					case (8):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_nodes_8.csv";
						break;
					case (16):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_nodes_16.csv";
						break;
					case (32):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_nodes_32.csv";
						break;
					case (64):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_nodes_64.csv";
						break;
					case (96):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_nodes_96.csv";
						break;
					case (128):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_nodes_128.csv";
						break;
					case (160):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_nodes_160.csv";
						break;						
					case (192):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_nodes_192.csv";
						break;
					case (224):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_nodes_224.csv";
						break;
					case (256):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_nodes_256.csv";
						break;
				}
				break;
			case (3)://mobility scenario
				if (mobility_scenario == 0) //urban mobility
				  {
				  	switch(maxspeed)
				  	{
				  		case (0):
				  			filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_urban_0.csv";
					  		break;
				  		case (10):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_urban_10.csv";
					  		break;
					  	case (20):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_urban_20.csv";
					  		break;
					  	case (30):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_urban_30.csv";
					  		break;
					  	case (40):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_urban_40.csv";
					  		break;
					  	case (50):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_urban_50.csv";
					  		break;
					  	case (60):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_urban_60.csv";
					  		break;
					  	default:
					  		break;
					 }
				   }
				   
				   if (mobility_scenario == 1) //non-urban mobility
				   {
				   	switch(maxspeed)
				   	{
				   		case (0):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_rural_0.csv";
				   	  		break;
				   	  	case (20):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_rural_20.csv";
					  		break;
					   	case (40):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_rural_40.csv";
					  		break;
					  	case (60):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_rural_60.csv";
					  		break;
				   	  	case (80):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_rural_80.csv";
				   	  		break;
				   	  	case (100):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_rural_100.csv";
				   	  		break;
				   	  	default:
				   	  		break;
					 }
				   }
				   
				   if (mobility_scenario == 2)//highway
				   {
				   	  switch(maxspeed)
				   	  {
				   	  	case (0):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_autobahn_0.csv";
				   	  		break;
				   	  	case (30):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_autobahn_30.csv";
				   	  		break;
				   	  	case (50):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_autobahn_50.csv";
				   	  		break;
				   	  	case (90):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_autobahn_90.csv";
					 	case (130):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_autobahn_130.csv";
					 		break;
					 	case (170):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_autobahn_170.csv";
					 		break;
					 	case (210):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_autobahn_210.csv";
					 		break;
					 	case (250):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_mobility_autobahn_250.csv";
					 		break;
					 	default:
					 		break;
					  }
				   }
				break;
			case (4): //RSU ratios
				uint32_t ratio;
				if (N_RSUs != 0)
				{
					ratio = N_Vehicles/N_RSUs;
				}
				else
				{
					ratio = 200;
				}
				switch (ratio)
				{
					case(200)://200 veh, 0 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_heterogeneity_inf.csv";
						break;
					case(199)://199 veh, 1 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_heterogeneity_199.csv";
						break;
					case(99)://198 veh, 2 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_heterogeneity_99.csv";
						break;
					case(49)://196 veh, 4 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_heterogeneity_49.csv";
						break;
					case(24)://192 veh, 8 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_heterogeneity_24.csv";
						break;
					case(9)://180 veh, 20 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_heterogeneity_9.csv";
						break;
					case(4)://160 veh, 40 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_heterogeneity_4.csv";
						break;
					case(3):// 150 veh, 50 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_heterogeneity_3.csv";
						break;
					case(2): //134 veh, 66 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_heterogeneity_2.csv";
						break;
					case(1): //100 veh, 100 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_heterogeneity_1.csv";
						break;
					case(0): //0 veh, 200 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/distributed_heterogeneity_0.csv";
						break;
				}
				break;
			case (7)://link lifetime threshold experiment
				filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_threshold.csv";
				break;	
			case (8)://contention threshold experiment
				filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_threshold.csv";
				break;
			case (9)://routing frequency
				if (routing_frequency == 0.02)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_frequency_0.02.csv";
				}
				if (routing_frequency ==0.05)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_frequency_0.05.csv";
				}
				if (routing_frequency ==0.10)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_frequency_0.10.csv";
				}
				if (routing_frequency ==0.25)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_frequency_0.25.csv";
				}
				if (routing_frequency ==0.50)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_frequency_0.50.csv";
				}
				if (routing_frequency == 1.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_frequency_1.00.csv";
				}
				if (routing_frequency ==2.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_frequency_2.csv";
				}

				if (routing_frequency ==3.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_frequency_3.csv";
				}
		
				if (routing_frequency == 4.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_frequency_4.csv";
				}

				if (routing_frequency ==5.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_frequency_5.csv";
				}

				break;
			case (10): //number of nodes for routing
				switch(total_size)
				{
					case (4):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_nodes_4.csv";
						break;
					case (8):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_nodes_8.csv";
						break;
					case (16):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_nodes_16.csv";
						break;
					case (32):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_nodes_32.csv";
						break;
					case (64):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_nodes_64.csv";
						break;
					case (96):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_nodes_96.csv";
						break;
					case (128):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_nodes_128.csv";
						break;
					case (160):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_nodes_160.csv";
						break;						
					case (192):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_nodes_192.csv";
						break;
					case (224):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_nodes_224.csv";
						break;
					case (256):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_nodes_256.csv";
						break;
				}
				break;
			case (11)://mobility scenario - routing
				if (mobility_scenario == 0) //urban mobility
				  {
				  	switch(maxspeed)
				  	{
				  		case (0):
				  			filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_urban_0.csv";
					  		break;
				  		case (10):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_urban_10.csv";
					  		break;
					  	case (20):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_urban_20.csv";
					  		break;
					  	case (30):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_urban_30.csv";
					  		break;
					  	case (40):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_urban_40.csv";
					  		break;
					  	case (50):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_urban_50.csv";
					  		break;
					  	case (60):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_urban_60.csv";
					  		break;
					  	default:
					  		break;
					 }
				   }
				   
				   if (mobility_scenario == 1) //non-urban mobility
				   {
				   	switch(maxspeed)
				   	{
				   		case (0):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_rural_0.csv";
				   	  		break;
				   	  	case (20):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_rural_20.csv";
					  		break;
					   	case (40):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_rural_40.csv";
					  		break;
					  	case (60):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_rural_60.csv";
					  		break;
				   	  	case (80):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_rural_80.csv";
				   	  		break;
				   	  	case (100):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_rural_100.csv";
				   	  		break;
				   	  	default:
				   	  		break;
					 }
				   }
				   
				   if (mobility_scenario == 2)//highway
				   {
				   	  switch(maxspeed)
				   	  {
				   	  	case (0):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_autobahn_0.csv";
				   	  		break;
				   	  	case (30):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_autobahn_30.csv";
				   	  		break;
				   	  	case (50):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_autobahn_50.csv";
				   	  		break;
				   	  	case (90):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_autobahn_90.csv";
				   	  		break;
					 	case (130):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_autobahn_130.csv";
					 		break;
					 	case (170):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_autobahn_170.csv";
					 		break;
					 	case (210):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_autobahn_210.csv";
					 		break;
					 	case (250):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/distributed_routing_mobility_autobahn_250.csv";
					 		break;
					 	default:
					 		break;
					  }
				   }
				break;
		}
	}
	
	if (architecture == 2)
	{
		switch (experiment_number)
		{
			case (0)://entropy experiment
				if (entropy_threshold == 0.000)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_entropy_0.000.csv";
				}
				if(entropy_threshold == 0.001)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_entropy_0.001.csv";
				}
				if(entropy_threshold == 0.002)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_entropy_0.002.csv";
				}
				if(entropy_threshold == 0.005)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_entropy_0.005.csv";
				}
				if(entropy_threshold == 0.010)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_entropy_0.010.csv";
				}
				if(entropy_threshold == 0.020)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_entropy_0.020.csv";
				}
				if(entropy_threshold == 0.050)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_entropy_0.050.csv";
				}
				if(entropy_threshold == 0.100)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_entropy_0.100.csv";
				}
				if(entropy_threshold == 0.200)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_entropy_0.200.csv";
				}
				if(entropy_threshold == 0.500)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_entropy_0.500.csv";
				}
				break;
			case (1)://optimization frequency
				if (optimization_frequency == 0.02)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_frequency_0.02.csv";
				}
				if (optimization_frequency ==0.05)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_frequency_0.05.csv";
				}
				if (optimization_frequency ==0.10)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_frequency_0.10.csv";
				}
				if (optimization_frequency ==0.25)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_frequency_0.25.csv";
				}
				if (optimization_frequency ==0.50)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_frequency_0.50.csv";
				}
				if (optimization_frequency == 1.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_frequency_1.00.csv";
				}
				if (optimization_frequency ==2.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_frequency_2.csv";
				}

				if (optimization_frequency ==4.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_frequency_4.csv";
				}
		
				if (optimization_frequency == 6.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_frequency_6.csv";
				}

				if (optimization_frequency ==8.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_frequency_8.csv";
				}

				if (optimization_frequency ==10.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_frequency_10.csv";
				}

				break;
			case (2): //number of nodes
				switch(total_size)
				{
					case (4):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_nodes_4.csv";
						break;
					case (8):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_nodes_8.csv";
						break;
					case (16):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_nodes_16.csv";
						break;
					case (32):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_nodes_32.csv";
						break;
					case (64):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_nodes_64.csv";
						break;
					case (96):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_nodes_96.csv";
						break;
					case (128):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_nodes_128.csv";
						break;
					case (160):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_nodes_160.csv";
						break;
					case (192):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_nodes_192.csv";
						break;						
					case (224):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_nodes_224.csv";
						break;
					case (256):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_nodes_256.csv";
						break;
				}
				break;
			case (3)://mobility scenario
				if (mobility_scenario == 0) //urban mobility
				  {
				  	switch(maxspeed)
				  	{
				  		case (0):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_urban_0.csv";
					  		break;
				  		case (10):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_urban_10.csv";
					  		break;
					  	case (20):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_urban_20.csv";
					  		break;
					  	case (30):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_urban_30.csv";
					  		break;
					  	case (40):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_urban_40.csv";
					  		break;
					  	case (50):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_urban_50.csv";
					  		break;
					  	case (60):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_urban_60.csv";
					  		break;
					  	default:
					  		break;
					 }
				   }
				   
				   if (mobility_scenario == 1) //non-urban mobility
				   {
				   	switch(maxspeed)
				   	{
				   		case (0):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_rural_0.csv";
				   	  		break;
				   		case (10):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_rural_10.csv";
				   	  		break;
				   	  	case (20):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_rural_20.csv";
					  		break;
					  	case (30):
					   		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_rural_30.csv";
					   		break;
					   	case (40):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_rural_40.csv";
					  		break;
					  	case (50):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_rural_50.csv";
					  		break;
					  	case (60):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_rural_60.csv";
					  		break;
				   	  	case (70):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_rural_70.csv";
				   	  		break;
				   	  	case (80):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_rural_80.csv";
				   	  		break;
				   	  	case (90):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_rural_90.csv";
				   	  		break;
				   	  	case (100):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_rural_100.csv";
				   	  		break;
				   	  	default:
				   	  		break;
					 }
				   }
				   
				   if (mobility_scenario == 2)//highway
				   {
				   	  switch(maxspeed)
				   	  {
				   	  	case (0):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_0.csv";
				   	  		break;
				   	  	case (10):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_10.csv";
				   	  		break;
				   	  	case (30):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_30.csv";
				   	  		break;
				   	  	case (50):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_50.csv";
				   	  		break;
				   	  	case (70):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_70.csv";
				   	  		break;
				   	  	case (90):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_90.csv";
				   	  		break;
				   	  	case (110):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_110.csv";
				   	  		break;
					 	case (130):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_130.csv";
					 		break;
					 	case (150):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_150.csv";
					 		break;
					 	case (170):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_170.csv";
					 		break;
					 	case (190):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_190.csv";
					 		break;
					 	case (210):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_210.csv";
					 		break;
					 	case (230):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_230.csv";
					 		break;
					 	case (250):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_mobility_autobahn_250.csv";
					 		break;
					 	default:
					 		break;
					  }
				   }
				break;
			case (4): //RSU ratios
				uint32_t ratio;
				if (N_RSUs != 0)
				{
					ratio = N_Vehicles/N_RSUs;
				}
				else
				{
					ratio = 200;
				}
				switch (ratio)
				{
					case(200)://200 veh, 0 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_heterogeneity_inf.csv";
						break;
					case(199)://199 veh, 1 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_heterogeneity_199.csv";
						break;
					case(99)://198 veh, 2 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_heterogeneity_99.csv";
						break;
					case(49)://196 veh, 4 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_heterogeneity_49.csv";
						break;
					case(24)://192 veh, 8 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_heterogeneity_24.csv";
						break;
					case(9)://180 veh, 20 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_heterogeneity_9.csv";
						break;
					case(4)://160 veh, 40 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_heterogeneity_4.csv";
						break;
					case(3):// 150 veh, 50 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_heterogeneity_3.csv";
						break;
					case(2): //134 veh, 66 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_heterogeneity_2.csv";
						break;
					case(1): //100 veh, 100 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_heterogeneity_1.csv";
						break;
					case(0): //0 veh, 200 RSU
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/hybrid_heterogeneity_0.csv";
						break;
				}
				break;
			case (7)://link lifetime experiment
				if (link_lifetime_threshold == 0.000)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_link_lifetime_0.000.csv";
				}
				if(link_lifetime_threshold == 0.100)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_link_lifetime_0.100.csv";
				}
				if(link_lifetime_threshold == 0.200)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_link_lifetime_0.200.csv";
				}
				if(link_lifetime_threshold == 0.500)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_link_lifetime_0.500.csv";
				}
				if(link_lifetime_threshold == 1.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_link_lifetime_1.00.csv";
				}
				if(link_lifetime_threshold == 2.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_link_lifetime_2.000.csv";
				}
				if(link_lifetime_threshold == 4.00)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_link_lifetime_4.000.csv";
				}
				if(link_lifetime_threshold == 6.000)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_link_lifetime_6.000.csv";
				}
				if(link_lifetime_threshold == 8.000)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_link_lifetime_8.000.csv";
				}
				if(link_lifetime_threshold == 12.000)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_link_lifetime_10.000.csv";
				}
				break;	
			case (8)://contention experiment
				if (contention_threshold == 0.000)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_contention_0.000.csv";
				}
				if(contention_threshold == 0.001)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_contention_0.001.csv";
				}
				if(contention_threshold == 0.002)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_contention_0.002.csv";
				}
				if(contention_threshold == 0.005)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_contention_0.005.csv";
				}
				if(contention_threshold == 0.010)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_contention_0.010.csv";
				}
				if(contention_threshold == 0.020)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_contention_0.020.csv";
				}
				if(contention_threshold == 0.050)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_contention_0.050.csv";
				}
				if(contention_threshold == 0.100)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_contention_0.100.csv";
				}
				if(contention_threshold == 0.200)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_contention_0.200.csv";
				}
				if(contention_threshold == 0.500)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_contention_0.500.csv";
				}
				break;	
			case (9)://routing frequency
				if (routing_frequency == 0.02)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_frequency_0.02.csv";
				}
				if (routing_frequency ==0.05)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_frequency_0.05.csv";
				}
				if (routing_frequency ==0.10)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_frequency_0.10.csv";
				}
				if (routing_frequency ==0.25)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_frequency_0.25.csv";
				}
				if (routing_frequency ==0.50)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_frequency_0.50.csv";
				}
				if (routing_frequency == 1.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_frequency_1.00.csv";
				}
				if (routing_frequency ==2.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_frequency_2.csv";
				}

				if (routing_frequency ==3.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_frequency_3.csv";
				}
		
				if (routing_frequency == 4.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_frequency_4.csv";
				}

				if (routing_frequency ==5.0)
				{
					filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_frequency_5.csv";
				}

				break;
			case (10): //number of nodes-routing
				switch(total_size)
				{
					case (4):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_nodes_4.csv";
						break;
					case (8):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_nodes_8.csv";
						break;
					case (16):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_nodes_16.csv";
						break;
					case (32):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_nodes_32.csv";
						break;
					case (64):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_nodes_64.csv";
						break;
					case (96):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_nodes_96.csv";
						break;
					case (128):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_nodes_128.csv";
						break;
					case (160):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_nodes_160.csv";
						break;
					case (192):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_nodes_192.csv";
						break;						
					case (224):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_nodes_224.csv";
						break;
					case (256):
						filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_nodes_256.csv";
						break;
				}
				break;
			case (11)://mobility scenario
				if (mobility_scenario == 0) //urban mobility
				  {
				  	switch(maxspeed)
				  	{
				  		case (0):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_urban_0.csv";
					  		break;
				  		case (10):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_urban_10.csv";
					  		break;
					  	case (20):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_urban_20.csv";
					  		break;
					  	case (30):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_urban_30.csv";
					  		break;
					  	case (40):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_urban_40.csv";
					  		break;
					  	case (50):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_urban_50.csv";
					  		break;
					  	case (60):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_urban_60.csv";
					  		break;
					  	default:
					  		break;
					 }
				   }
				   
				   if (mobility_scenario == 1) //non-urban mobility
				   {
				   	switch(maxspeed)
				   	{
				   		case (0):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_rural_0.csv";
				   	  		break;
				   	  	case (20):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_rural_20.csv";
					  		break;
					   	case (40):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_rural_40.csv";
					  		break;
					  	case (60):
					  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_rural_60.csv";
					  		break;
				   	  	case (80):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_rural_80.csv";
				   	  		break;
				   	  	case (100):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_rural_100.csv";
				   	  		break;
				   	  	default:
				   	  		break;
					 }
				   }
				   
				   if (mobility_scenario == 2)//highway
				   {
				   	  switch(maxspeed)
				   	  {
				   	  	case (0):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_autobahn_0.csv";
				   	  		break;
				   	  	case (30):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_autobahn_30.csv";
				   	  		break;
				   	  	case (50):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_autobahn_50.csv";
				   	  		break;
				   	  	case (90):
				   	  		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_autobahn_90.csv";
				   	  		break;
					 	case (130):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_autobahn_130.csv";
					 		break;
					 	case (170):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_autobahn_170.csv";
					 		break;
					 	case (210):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_autobahn_210.csv";
					 		break;
					 	case (250):
					 		filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results_routing/hybrid_routing_mobility_autobahn_250.csv";
					 		break;
					 	default:
					 		break;
					  }
				   }
				break;
		}

	}
	
	fout.open(filename,ios::out|ios::app);
	if (architecture == 0)
	{
		fout << data_gathering_cycle_number << ", ";
	}
	if (architecture == 2)
	{
		fout << (data_gathering_cycle_number - 1) << ", ";
	}
	if (paper == 0)
	{
	fout << current_cost << ", "
	     << average_cost << ", "
	     << current_lte_utilization << ", "
	     << average_lte_utilization << ", "
	     << current_ethernet_utilization << ", "
	     << average_ethernet_utilization << ", "
	     << current_dsrc_utilization << ", "
	     << average_dsrc_utilization << ", "
	     << 1000*current_latency << ", "
	     << 1000*average_latency << ", "
	     << optimization_percentage << ", "
	     << 100*current_packet_delivery_ratio << ", "
	     << 100*average_packet_delivery_ratio << ", "
	     << "\n";
	}
	
	if (paper == 1)
	{
	fout << current_cost << ", "
	     << average_cost << ", "
	     << current_lte_utilization << ", "
	     << average_lte_utilization << ", "
	     << current_ethernet_utilization << ", "
	     << average_ethernet_utilization << ", "
	     << current_dsrc_utilization << ", "
	     << average_dsrc_utilization << ", "
	     << 1000*current_latency_dsrc << ", "
	     << 1000*average_latency_dsrc << ", "
	     << 100*current_packet_delivery_ratio_dsrc << ", "
	     << 100*average_packet_delivery_ratio_dsrc << ", "
	     << "\n";
	}
	fout.close();
}

double utilization_time = 0.0;

double packet_delay_routing [2*flows][Flow_size+1];
double packet_jitter_routing [2*flows][Flow_size+1];
double routing_packet_initial_timestamp [2*flows][Flow_size+1];
double routing_packet_final_timestamp [2*flows][Flow_size+1];
double routing_packet_general_final_timestamp [2*flows][total_size][Flow_size+1];
double routing_packet_general_initial_timestamp [2*flows][total_size][Flow_size+1];

double average_latency_routing = 0.0;
double current_latency_routing = 0.0;
double previous_cumulative_ratio = 0.0;
double previous_cumulative_jitter_ratio = 0.0;
double current_jitter_ratio = 0.0;
double previous_cumulative_latency = 0.0;
double average_jitter_routing = 0.0;
double current_load_imbalance = 0.0;
double current_load_balance = 0.0;
double average_load_balance = 0.0;
double previous_cumulative_load_imbalance = 0.0;

void write_csv_results_routing()
{
	fstream fout;
	string filename;

	switch (experiment_number)
	{
		case (0)://qos experiment
			switch(routing_algorithm)
			{
				case(0): //ECMP
					switch(qf)
					{
						case(0):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/ECMP_qos_0.csv";
							break;
						case(1):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/ECMP_qos_1.csv";
							break;
						case(2):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/ECMP_qos_2.csv";
							break;
						case(3):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/ECMP_qos_3.csv";
							break;
						default:
							break;
					}
					break;
					case(1): //RR
					switch(qf)
					{
						case(0):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/RR_qos_0.csv";
							break;
						case(1):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/RR_qos_1.csv";
							break;
						case(2):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/RR_qos_2.csv";
							break;
						case(3):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/RR_qos_3.csv";
							break;
						default:
							break;
					}
					break;
					case(2): //QR_SDN
					switch(qf)
					{
						case(0):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/QR_SDN_qos_0.csv";
							break;
						case(1):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/QR_SDN_qos_1.csv";
							break;
						case(2):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/QR_SDN_qos_2.csv";
							break;
						case(3):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/QR_SDN_qos_3.csv";
							break;
						default:
							break;
					}
					break;
					case(3): //RLMR
					switch(qf)
					{
						case(0):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/RLMR_qos_0.csv";
							break;
						case(1):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/RLMR_qos_1.csv";
							break;
						case(2):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/RLMR_qos_2.csv";
							break;
						case(3):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/RLMR_qos_3.csv";
							break;
						default:
							break;
					}
					break;
					case(4): //proposed
					switch(qf)
					{
						case(0):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/proposed_qos_0.csv";
							break;
						case(1):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/proposed_qos_1.csv";
							break;
						case(2):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/proposed_qos_2.csv";
							break;
						case(3):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/proposed_qos_3.csv";
							break;
						default:
							break;
					}
					break;
					
					case(5): //DCMR
					switch(qf)
					{
						case(0):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/DCMR_qos_0.csv";
							break;
						case(1):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/DCMR_qos_1.csv";
							break;
						case(2):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/DCMR_qos_2.csv";
							break;
						case(3):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/qos/DCMR_qos_3.csv";
							break;
						default:
							break;
					}
					break;
					
				default:
					break;
			}
			break;
		case (1)://flow_size (lambda)
			switch(routing_algorithm)
			{
				case(0)://ECMP
					switch(lambda)
					{
						case(10):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/ECMP_flowsize_10.csv";
							break;
						case(20):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/ECMP_flowsize_20.csv";
							break;
						case(30):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/ECMP_flowsize_30.csv";
							break;
						case(40):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/ECMP_flowsize_40.csv";
							break;
						case(47):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/ECMP_flowsize_50.csv";
							break;
						default:
							break;
					}
					break;
				case(1)://RR
					switch(lambda)
					{
						case(10):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/RR_flowsize_10.csv";
							break;
						case(20):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/RR_flowsize_20.csv";
							break;
						case(30):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/RR_flowsize_30.csv";
							break;
						case(40):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/RR_flowsize_40.csv";
							break;
						case(47):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/RR_flowsize_50.csv";
							break;
						default:
							break;
					}
					break;
				case(2)://QR-SDN
					switch(lambda)
					{
						case(10):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/QRSDN_flowsize_10.csv";
							break;
						case(20):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/QRSDN_flowsize_20.csv";
							break;
						case(30):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/QRSDN_flowsize_30.csv";
							break;
						case(40):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/QRSDN_flowsize_40.csv";
							break;
						case(47):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/QRSDN_flowsize_50.csv";
							break;
						default:
							break;
					}
					break;
				case(3)://RLMR
					switch(lambda)
					{
						case(10):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/RLMR_flowsize_10.csv";
							break;
						case(20):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/RLMR_flowsize_20.csv";
							break;
						case(30):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/RLMR_flowsize_30.csv";
							break;
						case(40):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/RLMR_flowsize_40.csv";
							break;
						case(47):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/RLMR_flowsize_50.csv";
							break;
						default:
							break;
					}
					break;
				case(4)://proposed
					switch(lambda)
					{
						
						case(10):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/Proposed_flowsize_10.csv";
							break;
						case(20):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/Proposed_flowsize_20.csv";
							break;
						case(30):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/Proposed_flowsize_30.csv";
							break;
						case(40):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/Proposed_flowsize_40.csv";
							break;
						case(47):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/Proposed_flowsize_50.csv";
							break;
						default:
							break;
					}
					break;
				case(5)://DCMR
					switch(lambda)
					{
						case(10):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/DCMR_flowsize_10.csv";
							break;
						case(20):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/DCMR_flowsize_20.csv";
							break;
						case(30):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/DCMR_flowsize_30.csv";
							break;
						case(40):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/DCMR_flowsize_40.csv";
							break;
						case(47):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/flowsize/DCMR_flowsize_50.csv";
							break;
						default:
							break;
					}
					break;
				default:
					break;
			}
			break;
			
		case (2)://mobility
			switch(routing_algorithm)
			{
				case(0)://ECMP
					switch(maxspeed)
					{
						case(8):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/ECMP_mobility_0.csv";
							break;
						case(20):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/ECMP_mobility_20.csv";
							break;
						case(40):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/ECMP_mobility_40.csv";
							break;
						case(60):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/ECMP_mobility_60.csv";
							break;
						case(80):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/ECMP_mobility_80.csv";
							break;
						case(100):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/ECMP_mobility_100.csv";
							break;
						case(120):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/ECMP_mobility_120.csv";
							break;
						case(140):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/ECMP_mobility_140.csv";
							break;
						default:
							break;
					}
					break;
				case(1)://RR
					switch(maxspeed)
					{
						case(8):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RR_mobility_0.csv";
							break;
						case(20):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RR_mobility_20.csv";
							break;
						case(40):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RR_mobility_40.csv";
							break;
						case(60):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RR_mobility_60.csv";
							break;
						case(80):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RR_mobility_80.csv";
							break;
						case(100):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RR_mobility_100.csv";
							break;
						case(120):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RR_mobility_120.csv";
							break;
						case(140):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RR_mobility_140.csv";
							break;
						default:
							break;
					}
					break;
					case(2)://QR-SDN
					switch(maxspeed)
					{
						case(8):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/QRSDN_mobility_0.csv";
							break;
						case(20):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/QRSDN_mobility_20.csv";
							break;
						case(40):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/QRSDN_mobility_40.csv";
							break;
						case(60):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/QRSDN_mobility_60.csv";
							break;
						case(80):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/QRSDN_mobility_80.csv";
							break;
						case(100):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/QRSDN_mobility_100.csv";
							break;
						case(120):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/QRSDN_mobility_120.csv";
							break;
						case(140):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/QRSDN_mobility_140.csv";
							break;
						default:
							break;
					}
					break;
				case(3)://RLMR
					switch(maxspeed)
					{
						case(8):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RLMR_mobility_0.csv";
							break;
						case(20):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RLMR_mobility_20.csv";
							break;
						case(40):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RLMR_mobility_40.csv";
							break;
						case(60):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RLMR_mobility_60.csv";
							break;
						case(80):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RLMR_mobility_80.csv";
							break;
						case(100):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RLMR_mobility_100.csv";
							break;
						case(120):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RLMR_mobility_120.csv";
							break;
						case(140):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/RLMR_mobility_140.csv";
							break;
						default:
							break;
					}
					break;
				case(4)://Proposed
					switch(maxspeed)
					{
						case(8):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/Proposed_mobility_0.csv";
							break;
						case(20):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/Proposed_mobility_20.csv";
							break;
						case(40):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/Proposed_mobility_40.csv";
							break;
						case(60):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/Proposed_mobility_60.csv";
							break;
						case(80):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/Proposed_mobility_80.csv";
							break;
						case(100):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/Proposed_mobility_100.csv";
							break;
						case(120):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/Proposed_mobility_120.csv";
							break;
						case(140):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/Proposed_mobility_140.csv";
							break;
						default:
							break;
					}
					break;
				 	case(5)://DCMR
					switch(maxspeed)
					{
						case(40):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/DCMR_mobility_40.csv";
							break;
						case(60):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/DCMR_mobility_60.csv";
							break;
						case(80):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/DCMR_mobility_80.csv";
							break;
						case(100):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/DCMR_mobility_100.csv";
							break;
						case(120):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/mobility/DCMR_mobility_120.csv";
							break;
						default:
							break;
					}
					break;
				default:
					break;
			}
			break;
		case (3)://network size
			switch(routing_algorithm)
			{
				case(0)://ECMP
					switch(total_size)
					{
						case(150):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/ECMP_nodes_150.csv";
							break;
						case(125):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/ECMP_nodes_125.csv";
							break;
						case(100):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/ECMP_nodes_100.csv";
							break;
						case(75):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/ECMP_nodes_75.csv";
							break;
						case(50):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/ECMP_nodes_50.csv";
							break;
						case(25):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/ECMP_nodes_25.csv";
							break;
						default:
							break;
					}
					break;
				case(1)://RR
					switch(total_size)
					{
						case(150):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/RR_nodes_150.csv";
							break;
						case(125):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/RR_nodes_125.csv";
							break;
						case(100):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/RR_nodes_100.csv";
							break;
						case(75):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/RR_nodes_75.csv";
							break;
						case(50):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/RR_nodes_50.csv";
							break;
						case(25):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/RR_nodes_25.csv";
							break;
						default:
							break;
					}
					break;
				case(2)://QRSDN
					switch(total_size)
					{
						case(150):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/QRSDN_nodes_150.csv";
							break;
						case(125):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/QRSDN_nodes_125.csv";
							break;
						case(100):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/QRSDN_nodes_100.csv";
							break;
						case(75):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/QRSDN_nodes_75.csv";
							break;
						case(50):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/QRSDN_nodes_50.csv";
							break;
						case(25):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/QRSDN_nodes_25.csv";
							break;
						default:
							break;
					}
					break;
				case(3)://RLMR
					switch(total_size)
					{
						case(150):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/RLMR_nodes_150.csv";
							break;
						case(125):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/RLMR_nodes_125.csv";
							break;
						case(100):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/RLMR_nodes_100.csv";
							break;
						case(75):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/RLMR_nodes_75.csv";
							break;
						case(50):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/RLMR_nodes_50.csv";
							break;
						case(25):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/RLMR_nodes_25.csv";
							break;
						default:
							break;
					}
					break;
				case(4)://Proposed
					switch(total_size)
					{
						case(150):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/Proposed_nodes_150.csv";
							break;
						case(125):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/Proposed_nodes_125.csv";
							break;
						case(100):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/Proposed_nodes_100.csv";
							break;
						case(75):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/Proposed_nodes_75.csv";
							break;
						case(50):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/Proposed_nodes_50.csv";
							break;
						case(25):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/Proposed_nodes_25.csv";
							break;
						default:
							break;
					}
					break;
				case(5)://
					switch(total_size)
					{
						case(150):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/DCMR_nodes_150.csv";
							break;
						case(125):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/DCMR_nodes_125.csv";
							break;
						case(100):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/DCMR_nodes_100.csv";
							break;
						case(75):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/DCMR_nodes_75.csv";
							break;
						case(50):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/DCMR_nodes_50.csv";
							break;
						case(25):
							filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/nodesize/DCMR_nodes_25.csv";
							break;
						default:
							break;
					}
					break;
				default:
					break;
			}
			break;
		default:
			break;
	}	
	
	fout.open(filename,ios::out|ios::app);

	fout << data_gathering_cycle_number << ", "
	     << 1000.0*current_latency_routing << ", "
	     << 1000.0*average_latency_routing << ", "
	     << 100.0*current_packet_delivery_ratio << ", "
	     << 100.0*average_packet_delivery_ratio_dsrc << ", "
	     << 1000.0*current_jitter_ratio<< ", "
	     << 1000.0*average_jitter_routing << ", "
	     << current_load_balance<< ", "
	     << average_load_balance<< ", "
	     << "\n";
	data_gathering_cycle_number++;
	fout.close();
	cout<<"written to file successfully"<<endl;
}


vector<vector<double>> adjacencyMatrix;
vector<vector<double>> linklifetimeMatrix_dsrc;
vector<vector<double>> linklifetimeMatrix_ethernet;
vector<vector<double>> delayMatrix_dsrc;
vector<vector<double>> delayMatrix_ethernet;

double shortestDistances[total_size];
vector<int> parents[total_size];
int NO_PARENT = -1;
 
// Function to print shortest path
// from source to currentVertex
// using parents array
void printPath(uint32_t vertexIndex)
{
    uint32_t size = parents[vertexIndex].size();
    for (uint32_t i=0; i<size; i++)
    {
    	cout << parents[vertexIndex][i] << " ";
    }
    cout << vertexIndex;
}
 
// A utility function to print
// the constructed distances
// array and shortest paths
void printSolution(int startVertex)
{
    uint32_t nVertices = total_size;
    cout << "Vertex\t Distance\tPath";
 
    for (uint32_t vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) 
    {
            cout << "\n" << startVertex << " -> ";
            cout << vertexIndex << " \t\t ";
            cout << shortestDistances[vertexIndex] << "\t\t";
            printPath(vertexIndex);
    }
}
 
// Function that implements Dijkstra's
// single source shortest path
// algorithm for a graph represented
// using adjacency matrix
// representation
 
void dijkstra(vector<vector<double> > adjacencyMatrix,
              uint32_t startVertex)
{
    uint32_t nVertices = adjacencyMatrix[0].size();
    cout<<nVertices<<endl;
 
    // shortestDistances[i] will hold the
    // shortest distance from src to i
    
 
    // added[i] will true if vertex i is
    // included / in shortest path tree
    // or shortest distance from src to
    // i is finalized
    bool added[nVertices];
 
    // Initialize all distances as
    // INFINITE and added[] as false
    for (uint32_t vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) 
    {
        shortestDistances[vertexIndex] = double(INT_MAX);
        added[vertexIndex] = false;
    }
 
    // Distance of source vertex from
    // itself is always 0
    shortestDistances[startVertex] = 0;
 
    // Parent array to store shortest
    // path tree
    vector<int> new_parents[total_size];
 
    // The starting vertex does not
    // have a parent
    new_parents[startVertex].push_back(startVertex);
 
    // Find shortest path for all
    // vertices
    for (uint32_t i = 1; i < nVertices; i++) 
    {
        // Pick the minimum distance vertex
        // from the set of vertices not yet
        // processed. nearestVertex is
        // always equal to startNode in
        // first iteration.
        uint32_t nearestVertex = large;
        double shortestDistance = double(INT_MAX);
        
        for (uint32_t vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) 
        {
            if ((!added[vertexIndex]) && (shortestDistances[vertexIndex] < shortestDistance)) 
            {
                nearestVertex = vertexIndex;
                shortestDistance = shortestDistances[vertexIndex];     
            }
        }  
 	//cout <<"iteration "<< i << "shortest distance "<<shortestDistance<<endl;
        // Mark the picked vertex as
        // processed
        added[nearestVertex] = true;
        cout<<"nearest vertex is "<<nearestVertex<<endl;
 
        // Update dist value of the
        // adjacent vertices of the
        // picked vertex.
        for (uint32_t vertexIndex = 0; vertexIndex < nVertices;vertexIndex++)
        {
            double edgeDistance = adjacencyMatrix[nearestVertex][vertexIndex];
            //cout<<"edge distance is "<<edgeDistance<<endl;
 
            if ((edgeDistance > 0.0) && ((shortestDistance + edgeDistance) <= (shortestDistances[vertexIndex]))) 
            {
            	//cout<<"parent is "<<nearestVertex;
                new_parents[vertexIndex].push_back(nearestVertex);
                shortestDistances[vertexIndex] = shortestDistance + edgeDistance;
                //cout<<"shortest distances at vertex index "<<vertexIndex<<"is "<<shortestDistances[vertexIndex];
            }
        }
    }
    for (uint32_t source=0;source<total_size;source++)
    {
    	parents[source] = new_parents[source];
    	uint32_t n = new_parents[source].size();	
    	uint32_t path[total_size];
    	path[0] = source;
    	for (uint32_t i=1;i<total_size;i++)
    	{
    		int sh = n-i+1;
    		if((sh) > 0)
    		{
    			path[i] = new_parents[source][n-i];
    			//cout<<"n is "<<n<<"is "<<"i is "<<i<<new_parents[source][n-i-1]<<endl;
    		}
    		else
    		{
    			path[i] = large;
    		}
    	}

    	//cout<<path[0];
    	update_proposed_route(source, startVertex, path);
    }
    printSolution(startVertex);
}

double get_length(Vector posi_1, Vector posi_2)
{
	double valx = (posi_1.x - posi_2.x)*(posi_1.x - posi_2.x);
	double valy = (posi_1.y - posi_2.y)*(posi_1.y - posi_2.y);
	double result = sqrt(valx + valy);
	return result;	
}

vector<double> node_distance[total_size];

vector<double> calculate_distance_to_each_node(uint32_t source_node)
{
	vector<double> x;
	/*
	Vector source_position = data_at_manager_inst[source_node].position;
	for (uint32_t index = 2; index < (total_size + 2); index++)
	{
		double dis = get_length(source_position, data_at_manager_inst[index].position);
		x.push_back(dis);
	}
	*/
	Ptr <Node> reference_node;
	Ptr <Node> other_node;
	
	// Validate source_node bounds
	if (source_node < 2) {
		std::cerr << "ERROR: Invalid source_node " << source_node << " (must be >= 2)" << std::endl;
		// Return empty vector with large distances
		for (uint32_t i = 0; i < total_size; i++) {
			x.push_back(1e9);
		}
		return x;
	}
	
	if ((source_node-2) < N_Vehicles)
	{	
		if ((source_node-2) >= Vehicle_Nodes.GetN()) {
			std::cerr << "ERROR: source_node-2=" << (source_node-2) << " exceeds Vehicle_Nodes count=" << Vehicle_Nodes.GetN() << std::endl;
			for (uint32_t i = 0; i < total_size; i++) {
				x.push_back(1e9);
			}
			return x;
		}
		reference_node = DynamicCast <Node> (Vehicle_Nodes.Get(source_node-2));
	}
	else
	{
		uint32_t rsu_index = source_node-N_Vehicles-2;
		if (rsu_index >= RSU_Nodes.GetN()) {
			std::cerr << "ERROR: RSU index=" << rsu_index << " exceeds RSU_Nodes count=" << RSU_Nodes.GetN() << std::endl;
			for (uint32_t i = 0; i < total_size; i++) {
				x.push_back(1e9);
			}
			return x;
		}
		reference_node = DynamicCast <Node> (RSU_Nodes.Get(rsu_index));
	}
	
	// Check if reference_node is valid
	if (!reference_node) {
		std::cerr << "ERROR: reference_node is NULL for source_node=" << source_node << std::endl;
		for (uint32_t i = 0; i < total_size; i++) {
			x.push_back(1e9);
		}
		return x;
	}
	
	Ptr<ConstantVelocityMobilityModel> mdl1 = DynamicCast <ConstantVelocityMobilityModel> (reference_node->GetObject<MobilityModel>());
	
	// Check if mobility model is valid
	if (!mdl1) {
		std::cerr << "ERROR: Could not get MobilityModel for source_node=" << source_node << std::endl;
		for (uint32_t i = 0; i < total_size; i++) {
			x.push_back(1e9);
		}
		return x;
	}
	
	Vector posi_reference = mdl1->GetPosition();
        for (uint32_t index = 2; index < (total_size + 2); index++)
	{
		if ((index-2) < N_Vehicles)
		{	
			if ((index-2) >= Vehicle_Nodes.GetN()) {
				x.push_back(1e9);
				continue;
			}
			other_node = DynamicCast <Node> (Vehicle_Nodes.Get(index-2));
		}
		else
		{
			uint32_t rsu_index = index-N_Vehicles-2;
			if (rsu_index >= RSU_Nodes.GetN()) {
				x.push_back(1e9);
				continue;
			}
			other_node = DynamicCast <Node> (RSU_Nodes.Get(rsu_index));
		}
		
		// Check if other_node is valid
		if (!other_node) {
			x.push_back(1e9);
			continue;
		}
		
		Ptr<ConstantVelocityMobilityModel> mdl2 = DynamicCast <ConstantVelocityMobilityModel> (other_node->GetObject<MobilityModel>());
		
		// Check if mobility model is valid
		if (!mdl2) {
			x.push_back(1e9);
			continue;
		}
		
        	Vector posi_other = mdl2->GetPosition();	
		double dis = get_length(posi_reference, posi_other);
		x.push_back(dis);
	}
       
	return x;
}

void generate_adjacency_matrix()
{
	
	for(uint32_t i=0;i<total_size;i++)
	{
		node_distance[i] = calculate_distance_to_each_node(i+2);	
	}
	
	/*
	double large_new = large;
	node_distance[0] =  {0.0, 400.0, large_new, large_new, large_new, large_new, large_new, 800, large_new};
	node_distance[1] =  { 400.0, 0.0, 800.0, large_new, large_new, large_new, large_new, 1100, large_new};
	node_distance[2] =  { large_new, 800.0, 0.0, 700.0, large_new, 400.0, large_new, large_new, 200.0};
	node_distance[3] =  { large_new, large_new, 700.0, 0.0, 900.0, 1400.0, large_new, large_new, large_new};
	node_distance[4] =  { large_new, large_new, large_new, 900.0, 0.0, 1000.0, large_new, large_new, large_new};
	node_distance[5] =  { large_new, large_new, 400, large_new, 1000.0, 0.0, 200.0, large_new, large_new};
	node_distance[6]  =  { large_new, large_new, large_new, 1400.0, large_new, 200.0, 0.0, 100.0, 600.0};
	node_distance[7]  =  { 800.0, 1100.0, large_new, large_new, large_new, large_new, 100.0, 0.0, 700.0};
	node_distance[8]  =  { large_new, large_new, 2.0, large_new, large_new, large_new, 600.0, 700.0, 0.0};
	*/
	
	vector<vector<double>> new_adjacencyMatrix;
	for(uint32_t i=0;i<total_size;i++)
	//for(uint32_t i=0;i<9;i++)
	{
		new_adjacencyMatrix.push_back(node_distance[i]);
	}
	adjacencyMatrix = new_adjacencyMatrix;
	/*	VISUALIZE ADJACENCY MATRIX-----------------------
	for (uint32_t i=0;i<total_size;i++)
	//for (uint32_t i=0;i<9;i++)
	{
		
		for (uint32_t j=0;j<total_size;j++)
		//for (uint32_t j=0;j<9;j++)
		{
			cout<<"distance from source node"<<(i)<<"to node "<<(j)<<"is "<<adjacencyMatrix[i][j]<<endl;
		}
	}
	*/
		
	//cout<<"adjacency matrix size"<<adjacencyMatrix.size()<<endl;
	cout<<"adjacency matrix generated"<<"at timestampt "<<Now().GetSeconds()<<endl;
}

struct proposed_algo2_output
{
	uint32_t Y[total_size];
	double U[total_size];
	int32_t conn[total_size];
	bool met[total_size];
	uint32_t paths;
};

struct proposed_algo2_output proposed_algo2_output_inst[2*flows];

struct distance_algo2_output
{
	uint32_t Y[total_size];
	double D[total_size];
	int32_t conn[total_size];
	bool met[total_size];
	uint32_t paths;
};

struct distance_algo2_output distance_algo2_output_inst[2*flows];

double minimum(double x, double y)
{
	if(x<y)
	{
		return x;
	}
	else
	{
		return y;
	}

}

double average(double x, double y)
{
	double average = (x+y)/2.0;
	return average;

}

// Recursion depth tracking to prevent stack overflow
static uint32_t update_stable_depth = 0;
static uint32_t update_unstable_depth = 0;
const uint32_t MAX_RECURSION_DEPTH = 100;  // Safety limit

void update_stable(uint32_t flow_id, uint32_t current_hop)
{
	// Recursion depth protection
	update_stable_depth++;
	if (update_stable_depth > MAX_RECURSION_DEPTH) {
		std::cerr << "ERROR: update_stable recursion depth exceeded " << MAX_RECURSION_DEPTH 
		          << " (flow_id=" << flow_id << ", current_hop=" << current_hop << ")" << std::endl;
		update_stable_depth--;
		return;
	}
	
	// Safety checks
	if (flow_id >= 2*flows) {
		update_stable_depth--;
		return;
	}
	if (current_hop >= (uint32_t)total_size) {
		update_stable_depth--;
		return;
	}
	if (linklifetimeMatrix_dsrc.size() <= (size_t)current_hop) {
		update_stable_depth--;
		return;
	}
	if (linklifetimeMatrix_dsrc[current_hop].size() < (size_t)total_size) {
		update_stable_depth--;
		return;
	}
	
	proposed_algo2_output_inst[flow_id].met[current_hop] = true;
	for(uint32_t i=0;i<total_size;i++)
	{
		if(linklifetimeMatrix_dsrc[current_hop][i] >link_lifetime_threshold)
		{
			if(i== (demanding_flow_struct_controller_inst+flow_id)->source)
			{
				proposed_algo2_output_inst[flow_id].paths++;
				proposed_algo2_output_inst[flow_id].conn[i] = 1;
			}
			
			else
			{
				if((proposed_algo2_output_inst[flow_id].met[i] == false)||(proposed_algo2_output_inst[flow_id].Y[i] >= ((proposed_algo2_output_inst[flow_id].Y[current_hop] + 1))))
				{
					proposed_algo2_output_inst[flow_id].Y[i] = proposed_algo2_output_inst[flow_id].Y[current_hop] + 1;
					proposed_algo2_output_inst[flow_id].conn[i] = 1;
					proposed_algo2_output_inst[flow_id].U[i] = minimum(linklifetimeMatrix_dsrc[current_hop][i], proposed_algo2_output_inst[flow_id].U[current_hop]);
					update_stable(flow_id, i);
					
					
					//cout<<"Flow ID "<<flow_id<<"Stable routing: updated values at node "<<i<<"stability "<<proposed_algo2_output_inst[flow_id].U[i]<<"connectivity "<< proposed_algo2_output_inst[flow_id].conn[i]<<"number of hops "<< proposed_algo2_output_inst[flow_id].Y[i]<<endl;

				}
			
			}
		
		}
	}
	
	// Decrement recursion depth before returning
	update_stable_depth--;
}

void run_stable_path_finding(uint32_t flow_id)
{
	cout << "DEBUG run_stable_path_finding: Entered with flow_id=" << flow_id << ", flows=" << flows << ", 2*flows=" << 2*flows << endl;
	
	// Safety checks to prevent crashes - CHECK FLOW_ID FIRST before pointer access
	if (flow_id >= (uint32_t)(2*flows)) {
		std::cerr << "ERROR: Invalid flow_id " << flow_id << " (max: " << 2*flows-1 << "), cannot access demanding_flow_struct_controller_inst" << std::endl;
		return;
	}
	
	// Check if matrices are ready
	if (linklifetimeMatrix_dsrc.size() == 0 || linklifetimeMatrix_dsrc.size() < (size_t)total_size) {
		std::cerr << "WARNING: linklifetimeMatrix_dsrc not ready yet (size=" << linklifetimeMatrix_dsrc.size() << ", need " << total_size << "), skipping path finding for flow " << flow_id << std::endl;
		return;
	}
	
	cout << "DEBUG run_stable_path_finding: About to access demanding_flow_struct_controller_inst[" << flow_id << "]" << endl;
	
	// NOW safe to access pointer - flow_id is validated
	uint32_t source = (demanding_flow_struct_controller_inst+flow_id)->source;
	uint32_t destination =	(demanding_flow_struct_controller_inst+flow_id)->destination;
	
	cout << "DEBUG run_stable_path_finding: source=" << source << ", destination=" << destination << endl;
	
	// Validate source/destination
	if (source >= (uint32_t)total_size || destination >= (uint32_t)total_size) {
		std::cerr << "ERROR: Invalid source/destination (src=" << source << ", dst=" << destination << ", max=" << total_size-1 << ")" << std::endl;
		return;
	}
	
	for(uint32_t i=0; i<total_size; i++)
	{
		proposed_algo2_output_inst[flow_id].met[i] = false;
		proposed_algo2_output_inst[flow_id].Y[i] = 1000;
		proposed_algo2_output_inst[flow_id].U[i] = 1e-9;
		proposed_algo2_output_inst[flow_id].conn[i] = -1;
	}
	proposed_algo2_output_inst[flow_id].paths = 0;
	proposed_algo2_output_inst[flow_id].U[destination] = 1e9;
	proposed_algo2_output_inst[flow_id].conn[destination] = 1;
	proposed_algo2_output_inst[flow_id].Y[destination] = 0;
	update_stable(flow_id, destination);
	cout<<"Routing stable: Number of stable paths from source: "<<source<<"to destination "<<destination<<"is "<<proposed_algo2_output_inst[flow_id].paths<<" at timestamp "<<Now().GetSeconds()<<endl;

}

void update_unstable(uint32_t flow_id, uint32_t current_hop)
{
	// Recursion depth protection
	update_unstable_depth++;
	if (update_unstable_depth > MAX_RECURSION_DEPTH) {
		std::cerr << "ERROR: update_unstable recursion depth exceeded " << MAX_RECURSION_DEPTH 
		          << " (flow_id=" << flow_id << ", current_hop=" << current_hop << ")" << std::endl;
		update_unstable_depth--;
		return;
	}
	
	// Safety checks
	if (flow_id >= 2*flows) {
		update_unstable_depth--;
		return;
	}
	if (current_hop >= (uint32_t)total_size) {
		update_unstable_depth--;
		return;
	}
	if (linklifetimeMatrix_dsrc.size() <= (size_t)current_hop) {
		update_unstable_depth--;
		return;
	}
	if (linklifetimeMatrix_dsrc[current_hop].size() < (size_t)total_size) {
		update_unstable_depth--;
		return;
	}
	if (adjacencyMatrix.size() <= (size_t)current_hop) {
		update_unstable_depth--;
		return;
	}
	if (adjacencyMatrix[current_hop].size() < (size_t)total_size) {
		update_unstable_depth--;
		return;
	}
	
	distance_algo2_output_inst[flow_id].met[current_hop] = true;
	for(uint32_t i=0;i<total_size;i++)
	{
		if(linklifetimeMatrix_dsrc[current_hop][i] >0.0)
		{
			if(i== (demanding_flow_struct_controller_inst+flow_id)->source)
			{
				distance_algo2_output_inst[flow_id].paths++;
				distance_algo2_output_inst[flow_id].conn[i] = 1;
			}
			
			else
			{
				double value = distance_algo2_output_inst[flow_id].D[current_hop] + adjacencyMatrix[current_hop][i];
				if((distance_algo2_output_inst[flow_id].met[i] == false)||(distance_algo2_output_inst[flow_id].D[i] > value))
				{
					distance_algo2_output_inst[flow_id].Y[i] = distance_algo2_output_inst[flow_id].Y[current_hop] + 1;
					distance_algo2_output_inst[flow_id].D[i] = value;
					distance_algo2_output_inst[flow_id].conn[i] = 1;
					update_unstable(flow_id, i);
					//cout<<"Distance routing: updated values at node "<<i<<"distance "<<distance_algo2_output_inst[flow_id].D[i]<<"connectivity "<<distance_algo2_output_inst[flow_id].conn[i]<<"number of hops "<< distance_algo2_output_inst[flow_id].Y[i]<<endl;
				}
			
			}
		
		}
	}
	
	// Decrement recursion depth before returning
	update_unstable_depth--;
}

void run_distance_path_finding(uint32_t flow_id)
{
	cout << "DEBUG run_distance_path_finding: Entered with flow_id=" << flow_id << ", flows=" << flows << ", 2*flows=" << 2*flows << endl;
	
	// Safety checks to prevent crashes - CHECK FLOW_ID FIRST before pointer access
	if (flow_id >= (uint32_t)(2*flows)) {
		std::cerr << "ERROR: Invalid flow_id " << flow_id << " (max: " << 2*flows-1 << "), cannot access demanding_flow_struct_controller_inst" << std::endl;
		return;
	}
	
	// Check if matrices are ready
	if (linklifetimeMatrix_dsrc.size() == 0 || linklifetimeMatrix_dsrc.size() < (size_t)total_size) {
		std::cerr << "WARNING: linklifetimeMatrix_dsrc not ready yet (size=" << linklifetimeMatrix_dsrc.size() << ", need " << total_size << "), skipping path finding for flow " << flow_id << std::endl;
		return;
	}
	if (adjacencyMatrix.size() == 0 || adjacencyMatrix.size() < (size_t)total_size) {
		std::cerr << "WARNING: adjacencyMatrix not ready yet (size=" << adjacencyMatrix.size() << ", need " << total_size << "), skipping path finding for flow " << flow_id << std::endl;
		return;
	}
	
	cout << "DEBUG run_distance_path_finding: About to access demanding_flow_struct_controller_inst[" << flow_id << "]" << endl;
	
	// NOW safe to access pointer - flow_id is validated
	uint32_t source = (demanding_flow_struct_controller_inst+flow_id)->source;
	uint32_t destination =	(demanding_flow_struct_controller_inst+flow_id)->destination;
	
	cout << "DEBUG run_distance_path_finding: source=" << source << ", destination=" << destination << endl;
	
	// Validate source/destination
	if (source >= (uint32_t)total_size || destination >= (uint32_t)total_size) {
		std::cerr << "ERROR: Invalid source/destination (src=" << source << ", dst=" << destination << ", max=" << total_size-1 << ")" << std::endl;
		return;
	}
	
	for(uint32_t i=0; i<total_size; i++)
	{
		distance_algo2_output_inst[flow_id].met[i] = false;
		distance_algo2_output_inst[flow_id].Y[i] = 1000;
		distance_algo2_output_inst[flow_id].D[i] = 1e9;
		distance_algo2_output_inst[flow_id].conn[i] = -1;
	}
	distance_algo2_output_inst[flow_id].paths = 0;
	distance_algo2_output_inst[flow_id].conn[destination] = 1;
	distance_algo2_output_inst[flow_id].D[destination] = 1e-9;
	distance_algo2_output_inst[flow_id].Y[destination] = 0;
	update_unstable(flow_id, destination);
	cout<<"Routing distance-based: Number of paths from source: "<<source<<"to destination "<<destination<<"is "<<distance_algo2_output_inst[flow_id].paths<<" at timestamp "<<Now().GetSeconds()<<endl;
}


void update_flows()
{
	  cout<<"updating flows - path finding at"<<Now().GetSeconds()<<endl;
	  cout<<"DEBUG: flows=" << flows << ", total_size=" << total_size << ", 2*flows=" << 2*flows << endl;
	  if(routing_algorithm == 4)
	  {	
	  	for(uint32_t i=0;i<2*flows;i++)
	  	{
	  		cout<<"DEBUG: Scheduling run_stable_path_finding for flow_id=" << i << endl;
	  		Simulator::Schedule(Seconds(0.000005*(i+1)), run_stable_path_finding, i);
	  	}
	  }
	  else
	  {
	  	generate_adjacency_matrix();
	  	for(uint32_t i=0;i<2*flows;i++)
	  	{
	  		cout<<"DEBUG: Scheduling run_distance_path_finding for flow_id=" << i << endl;
	  		Simulator::Schedule(Seconds(0.000005*(i+1)), run_distance_path_finding, i);
	  	}
	  	
	  }

}
uint32_t scheduled_flows;

void filter_flows()
{
	  scheduled_flows = 0;
	  uint32_t flow_counter = 0;
	  if(routing_algorithm == 4)
	  {	
		for(uint32_t flow_id=0;flow_id<2*flows;flow_id++)
		{
			if (routing_test == true)
    			{
    				if(flow_id ==1)
    				{
    					(demanding_flow_struct_controller_inst+flow_id)->f_size = 0;
    				}
    				else
    				{
    					flow_counter++;
    					scheduled_flows++;
    				}
    			}
    			else
    			{
			  	if(proposed_algo2_output_inst[flow_id].paths == 0)
			  	{
			  		(demanding_flow_struct_controller_inst+flow_id)->f_size = 0;
			  		(demanding_flow_struct_nodes_inst+flow_id)->f_size = 0;
			  	}
			  	
			  	else
			  	{
			  		flow_counter++;
			  		scheduled_flows++;
			  	}
			}
		}
		cout<<"Number of connected flows "<<flow_counter<<"at timestamp "<<Now().GetSeconds()<<endl;
	  }
	  else
	  {

	  	for(uint32_t flow_id=0;flow_id<2*flows;flow_id++)
		{
		  	
		  	if (routing_test == true)
    			{
    				if(flow_id ==1)
    				{
    					(demanding_flow_struct_controller_inst+flow_id)->f_size = 0;
    				}
    				else
    				{
    					flow_counter++;
    					scheduled_flows++;
    				}
    			}
    			else
    			{
			  	if(distance_algo2_output_inst[flow_id].paths == 0)
			  	{
			  		(demanding_flow_struct_controller_inst+flow_id)->f_size = 0;
			  		(demanding_flow_struct_nodes_inst+flow_id)->f_size = 0;
			  	}
			  	
			  	else
			  	{
			  		flow_counter++;
			  		scheduled_flows++;
			  	}
		  	}
		}
		cout<<"Number of connected flows "<<flow_counter<<endl;
	  }
}


void dijkstra_stable(uint32_t startVertex)
{
    cout<<"started dijkstra stable solution"<<endl;
    uint32_t nVertices = adjacencyMatrix[0].size();
    cout<<nVertices<<endl;
    
    // shortestDistances[i] will hold the
    // shortest distance from src to i
    
 
    // added[i] will true if vertex i is
    // included / in shortest path tree
    // or shortest distance from src to
    // i is finalized
    uint32_t link_type = 0;//0-DSRC, 1-ethernet
    bool added[nVertices];
 
    // Initialize all distances as
    // INFINITE and added[] as false
    for (uint32_t vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) 
    {
        shortestDistances[vertexIndex] = double(INT_MAX);
        added[vertexIndex] = false;
    }
 
    // Distance of source vertex from
    // itself is always 0
    shortestDistances[startVertex] = 0;
 
    // Parent array to store shortest
    // path tree
    vector<int> new_parents[total_size];
    vector<int> parent_link[total_size];
 
    // The starting vertex does not
    // have a parent
    new_parents[startVertex].push_back(startVertex);
    
    // Find shortest path for all
    // vertices

    for (uint32_t i = 1; i < nVertices; i++) 
    {
        // Pick the minimum distance vertex
        // from the set of vertices not yet
        // processed. nearestVertex is
        // always equal to startNode in
        // first iteration.
        uint32_t nearestVertex = large;
        double shortestDistance = double(INT_MAX);
        
        for (uint32_t vertexIndex = 0; vertexIndex < nVertices; vertexIndex++) 
        {
            if ((!added[vertexIndex]) && (shortestDistances[vertexIndex] < shortestDistance)) 
            {
                nearestVertex = vertexIndex;
                shortestDistance = shortestDistances[vertexIndex];     
            }
        }  
 	//cout <<"iteration "<< i << "shortest distance "<<shortestDistance<<endl;
        // Mark the picked vertex as
        // processed
        
	added[nearestVertex] = true;
	//cout<<"nearest vertex is "<<nearestVertex<<endl;
	
	// Update dist value of the
	// adjacent vertices of the
	// picked vertex.
	for (uint32_t vertexIndex = 0; vertexIndex < nVertices;vertexIndex++)
	{
		double edgeDistance;
		
		if (contention > contention_threshold)
		{
			//cout<<"distance mode is running"<<endl;
			edgeDistance = adjacencyMatrix[nearestVertex][vertexIndex];
			if ((linklifetimeMatrix_dsrc[nearestVertex][vertexIndex]) >= (linklifetimeMatrix_ethernet[nearestVertex][vertexIndex]))
			{
		    		link_type = 0;
		    	}
		    	
		    	else
			{
		    		link_type = 1;
		    	}
		    	
		    	if ((edgeDistance > 0.0)&&(shortestDistance + edgeDistance) <= (shortestDistances[vertexIndex]+30)) 
	    		{
		    		int n = new_parents[vertexIndex].size();
		    		uint32_t index;
		    		double edgeLife;
		    		if (n>0)
		    		{
		    			index = new_parents[vertexIndex][n-1];
		    			if (link_type == 0)
		    			{
		    		        	edgeLife = linklifetimeMatrix_dsrc[nearestVertex][index];
		    		        }
		    		        else if (link_type == 1)
		    		        {
		    		        	edgeLife = linklifetimeMatrix_ethernet[nearestVertex][index];
		    		        }
		    		        //cout<<"edge life is "<<edgeLife<<endl;
		    		        if (edgeLife > link_lifetime_threshold)
					{
						//cout<<"edge life is between "<<nearestVertex<<" and "<<index<<"is "<<edgeLife<<endl;
						new_parents[vertexIndex].push_back(nearestVertex);
						parent_link[vertexIndex].push_back(link_type);
						shortestDistances[vertexIndex] = shortestDistance + edgeDistance;
					}
		    		}
		    		else
		    		{
		    			new_parents[vertexIndex].push_back(nearestVertex);
		    			shortestDistances[vertexIndex] = shortestDistance + edgeDistance;
		    		}
				//cout<<"shortest distances at vertex index "<<vertexIndex<<"is "<<shortestDistances[vertexIndex];
	    		}
		}
		
		else
		{
			//cout<<"delay mode is running"<<endl;
			if ((linklifetimeMatrix_ethernet[nearestVertex][vertexIndex]) <= (linklifetimeMatrix_dsrc[nearestVertex][vertexIndex]))
			{
				edgeDistance = delayMatrix_dsrc[nearestVertex][vertexIndex];
		    		link_type = 0;
		    	}
		    	
		    	else
			{
				edgeDistance = delayMatrix_ethernet[nearestVertex][vertexIndex];
		    		link_type = 1;
		    	}
		    	
		    	if ((edgeDistance > 0.0)&&(shortestDistance + edgeDistance) <= (shortestDistances[vertexIndex])+30) 
	    		{
		    		int n = new_parents[vertexIndex].size();
		    		uint32_t index;
		    		double edgeLife;
		    		if (n>0)
		    		{
		    			index = new_parents[vertexIndex][n-1];
		    			if (link_type == 0)
		    			{
		    		        	edgeLife = linklifetimeMatrix_dsrc[nearestVertex][index];
		    		        }
		    		        else if (link_type == 1)
		    		        {
		    		        	edgeLife = linklifetimeMatrix_ethernet[nearestVertex][index];
		    		        }
		    		        //cout<<"edge life is "<<edgeLife<<endl;
		    		        if (edgeLife > link_lifetime_threshold)
					{
						//cout<<"edge life is between "<<nearestVertex<<" and "<<index<<"is "<<edgeLife<<endl;
						new_parents[vertexIndex].push_back(nearestVertex);
						parent_link[vertexIndex].push_back(link_type);
						shortestDistances[vertexIndex] = shortestDistance + edgeDistance;
					}
		    		}
		    		else
		    		{
		    			new_parents[vertexIndex].push_back(nearestVertex);
		    			shortestDistances[vertexIndex] = shortestDistance + edgeDistance;
		    		}
				//cout<<"shortest distances at vertex index "<<vertexIndex<<"is "<<shortestDistances[vertexIndex];
	    		}
		}
	    	
	    	//cout<<"edge distance is "<<edgeDistance<<endl;
 	  }   
    }
    for (uint32_t source=0;source<total_size;source++)
    {
    	parents[source] = new_parents[source];
    	uint32_t n = new_parents[source].size();
    	
    	//uint32_t j = 0;
    	//uint32_t next_hop[n];
    	//bool updated = false;
    	//uint32_t hop_count = 5;
    	//uint32_t reverse_next_hop[hop_count];
    	//bool routing_loop = false;
    	uint32_t path[total_size];
    	uint32_t alternative_path[total_size];
    	path[0] = source;
    	alternative_path[0] = source;
    	alternative_path[1] = startVertex;
    	for (uint32_t i=1;i<total_size;i++)
    	{
    		int sh = n-i+1;
    		if((sh) > 0)
    		{
    			path[i] = new_parents[source][n-i];
    			//cout<<"n is "<<n<<"is "<<"i is "<<i<<new_parents[source][n-i-1]<<endl;
    		}
    		else
    		{
    			path[i] = large;
    		}
    	}
    	for (uint32_t i=2;i<total_size;i++)
    	{
		alternative_path[i] = large;
    	}
    	//cout<<path[0];
    	//update_proposed_route(source, startVertex, path);
    	if ((source > (N_Vehicles-1)) && (startVertex > (N_Vehicles-1)))
    	{
    		if ((experiment_number == 7) && (link_lifetime_threshold > 6.00))
    		{
    			update_proposed_route(source, startVertex, path);
    		}
    		else
    		{
        		update_proposed_route(source, startVertex, alternative_path);
        	}
    	}
    	else
    	{
    		update_proposed_route(source, startVertex, path);
    	/*
	    	while((j < n) && (updated==false))
	    	{
		    	next_hop[j] = new_parents[source][n-j-1];
		    	reverse_next_hop[0] = routing_tables[next_hop[j]].rows[startVertex].next_hop;
		    	for (uint32_t i=1;i<hop_count;i++)
		    	{
		    		if(reverse_next_hop[i-1] != large)
		    		{
		    			reverse_next_hop[i] = routing_tables[reverse_next_hop[i-1]].rows[startVertex].next_hop;
		    		}
		    		else
		    		{
		    			reverse_next_hop[i] = large;
		    		}
		    	}
		    	
		    	
		    	for (uint32_t i=0; i<hop_count;i++)
		    	{
		    		if(reverse_next_hop[i] == source)
		    		{
		    			routing_loop = true;
		    		}
		    	}
		    	if (routing_loop == false)
		    	{
		    		update_route(source, startVertex, next_hop[j]);
		    		updated = true;
		    	}  	
		    	j++; 	
		}
	*/
	}
    }
    /*
    for (uint32_t source=0;source<total_size;source++)
    {
    	for (uint32_t k=0;k<total_size;k++)
    	{
    		cout<<"destination is "<<startVertex<<" "<<"source is "<<source<<" "<<k<<"th hop is "<<proposed_routing_tables[source].rows[startVertex].path[k]<<endl;
    	}
    }
    */
    printSolution(startVertex);  
}




void calculate_average_latency_routing()
{
	double total_latency = 0.0;
	uint32_t flow_counter = 0;
	uint32_t delivered_packet_counter = 0;
	for (uint32_t fid=0;fid<2*flows;fid++)
	{
		uint32_t f_size = (demanding_flow_struct_nodes_inst+fid)->f_size;
		if (f_size > 0)
		{
			flow_counter++;
			for (uint32_t i=1; i<f_size+1;i++)
			{
				if (routing_packet_final_timestamp[fid][i] > routing_packet_initial_timestamp[fid][i])
				{
					packet_delay_routing[fid][i] = routing_packet_final_timestamp[fid][i] - routing_packet_initial_timestamp[fid][i];
					delivered_packet_counter++;
					//cout<<"Flow id "<<fid<<" packet "<<i<<"latency is "<<1000.0*packet_delay_routing[fid][i]<<" ms"<<endl;
				}
				
				//cout<<"packet "<<i<<"final timestamp "<<packet_final_timestamp[i]<<"initial timestamp: "<<packet_initial_timestamp[i]<<endl;
				total_latency = total_latency + packet_delay_routing[fid][i];
			}
		}
	}
	//total_latency = total_latency;
	if((flow_counter !=0)&(delivered_packet_counter != 0))
	{
		current_latency_routing = total_latency/(delivered_packet_counter);
	}
	else
	{
		current_latency_routing = 0.0;
	}
	//cout<<"Latency calculation: flow counter is "<<flow_counter<<" delivered packets is "<<delivered_packet_counter<<"current_latency is "<<current_latency_routing<<endl;
	double current_cumulative_latency = previous_cumulative_latency + current_latency_routing;
	average_latency_routing = (current_cumulative_latency)/(data_gathering_cycle_number);
	cout<<"average_latency "<<1000*average_latency_routing<<" ms"<<endl;	
	previous_cumulative_latency = current_cumulative_latency;
}


void calculate_average_packet_delivery_ratio_routing()
{
	uint32_t flow_counter = 0;
	uint32_t delivered_packet_counter = 0;
	uint32_t total_packets = 0;
	for (uint32_t fid=0;fid<2*flows;fid++)
	{
		uint32_t f_size = (demanding_flow_struct_nodes_inst+fid)->f_size;
		if (f_size > 0)
		{
			flow_counter++;
			for (uint32_t i=1; i<f_size+1;i++)
			{
				if (routing_packet_final_timestamp[fid][i] > routing_packet_initial_timestamp[fid][i])
				{
					delivered_packet_counter++;
				}
				
				//cout<<"packet "<<i<<"final timestamp "<<packet_final_timestamp[i]<<"initial timestamp: "<<packet_initial_timestamp[i]<<endl;
				//total_latency = total_latency + packet_delay_routing[fid][i];
			}
		}
		total_packets = total_packets + f_size;
	}
	//cout<<"PDR calculation: flow counter is "<<flow_counter<<" delivered packets is "<<delivered_packet_counter<<endl;
	//total_latency = total_latency;
	if((flow_counter !=0)&(delivered_packet_counter != 0))
	{
		current_packet_delivery_ratio = delivered_packet_counter/(1.0*total_packets);
	}
	else
	{
		current_packet_delivery_ratio = 0.0;
	}
	
	double current_cumulative_ratio = previous_cumulative_ratio + current_packet_delivery_ratio;
	average_packet_delivery_ratio_dsrc = (current_cumulative_ratio)/(1.0*data_gathering_cycle_number);
	cout<<"average packet delivery ratio is "<<100.0*average_packet_delivery_ratio_dsrc<<endl;
	previous_cumulative_ratio = current_cumulative_ratio;
	
	
}
	
void calculate_average_jitter_routing()
{
	uint32_t flow_counter = 0;
	uint32_t delivered_jitter_counter = 0;
	double jitter_sum = 0.0;
	for (uint32_t fid=0;fid<2*flows;fid++)
	{
		uint32_t f_size = (demanding_flow_struct_nodes_inst+fid)->f_size;
		if (f_size > 0)
		{
			flow_counter++;
			for (uint32_t i=1; i<f_size;i++)
			{
				if ((routing_packet_final_timestamp[fid][i] > routing_packet_initial_timestamp[fid][i]) & (routing_packet_final_timestamp[fid][i+1] > routing_packet_initial_timestamp[fid][i+1])&((routing_packet_final_timestamp[fid][i] > routing_packet_initial_timestamp[fid][i])))
				{
					packet_jitter_routing[fid][i] = abs(routing_packet_final_timestamp[fid][i+1] - routing_packet_final_timestamp[fid][i]);
					//cout<<"Flow id "<<fid<<"packet "<<i<<" and "<<i+1<<"jitter is "<<1000.0*packet_jitter_routing[fid][i]<<" ms"<<endl;
					delivered_jitter_counter++;
				}
				
				//cout<<"packet "<<i<<"final timestamp "<<packet_final_timestamp[i]<<"initial timestamp: "<<packet_initial_timestamp[i]<<endl;
				jitter_sum = jitter_sum + packet_jitter_routing[fid][i];
			}
		}
	}
	//cout<<"Jitter calculation: flow counter is "<<flow_counter<<" delivered jitter packets is "<<delivered_jitter_counter<<endl;
	//total_latency = total_latency;

	if((flow_counter !=0)&(delivered_jitter_counter != 0))
	{
		current_jitter_ratio = jitter_sum/(delivered_jitter_counter);
	}
	else
	{
		current_jitter_ratio = 0.0;
	}
	
	double current_cumulative_jitter_ratio = previous_cumulative_jitter_ratio + current_jitter_ratio;
	average_jitter_routing = (current_cumulative_jitter_ratio)/(data_gathering_cycle_number);
	cout<<"average jitter is "<<1000*average_jitter_routing<<endl;
	previous_cumulative_jitter_ratio = current_cumulative_jitter_ratio;

}

void calculate_average_load_balance_routing()
{
	uint32_t flow_counter = 0;
	double total_load_imbalance = 0.0;
	double phifbar[2*flows];
	for (uint32_t fid=0;fid<2*flows;fid++)
	{
		
		uint32_t f_size = (demanding_flow_struct_nodes_inst+fid)->f_size;
		
		if (f_size > 0)
		{
			phifbar[fid] = 0.0;
			double latency_average = 0.0;
			for (uint32_t i=1; i<f_size+1;i++)
			{
				double packet_rec_counter = 0.0;
				double q_count = 0.0;
				double latency_sum = 0.0;
				for(uint32_t j=0;j<total_size;j++)
				{
					for(uint32_t l=0;l<total_size;l++)
					{
						if ((routing_packet_general_final_timestamp[fid][j][i] > routing_packet_general_initial_timestamp[fid][l][i])&((delta_at_controller_inst+fid)->delta_fi_inst[l].delta_values[j] > 0.0)&(sent_IDS[fid][l][i] == true))
						{
							double difference = routing_packet_general_final_timestamp[fid][j][i] - routing_packet_general_initial_timestamp[fid][l][i];
							packet_rec_counter++;
							latency_sum = latency_sum + difference;
							//cout<<"Flow id "<<fid<<" link "<<l<<"to "<<j<<"latency difference for packet "<<i<<"is "<<1000.0*difference<<" ms"<<endl;
						}
						if ((delta_at_controller_inst+fid)->delta_fi_inst[l].delta_values[j] > 0.0)
						{
							q_count++;
						}
					}
					//cout<<"packet "<<i<<"final timestamp "<<packet_final_timestamp[i]<<"initial timestamp: "<<packet_initial_timestamp[i]<<endl;	
				}
				double local_average = 0.0;
				if(q_count >0)
				{
					//local_average = latency_sum/q_count;
					local_average = packet_rec_counter/q_count;
				}
				latency_average = latency_average + (local_average);
			}
			
			phifbar[fid] = latency_average;
			
			
			flow_counter++;
			//cout<<"phi bar for flow id "<<fid<<" is "<<phifbar[fid]<<endl;

			double q_count = 0;
			for(uint32_t j=0;j<total_size;j++)
			{
				for(uint32_t l=0;l<total_size;l++)
				{
					double local_count = 0.0;
					double local_sum = 0.0;
					for (uint32_t i=1; i<f_size+1;i++)
					{
						if ((routing_packet_general_final_timestamp[fid][j][i] > routing_packet_general_initial_timestamp[fid][l][i])&((delta_at_controller_inst+fid)->delta_fi_inst[l].delta_values[j] > 0.0)&(sent_IDS[fid][l][i] == true))
						{
							double diff = routing_packet_general_final_timestamp[fid][j][i] - routing_packet_general_initial_timestamp[fid][l][i];
							//double load_imbalance = (abs(diff - phifbar))/(phifbar);
							local_sum = local_sum + diff;
							local_count++;
							//cout<<"Flow id "<<fid<<" packet "<<i<<"latency is "<<1000.0*packet_delay_routing[fid][i]<<" ms"<<endl;
							
							//cout<<"packet "<<i<<"final timestamp "<<packet_final_timestamp[i]<<"initial timestamp: "<<packet_initial_timestamp[i]<<endl;
							//total_latency = total_latency + packet_delay_routing[fid][i];
						}
					}
					//double local_average = local_sum/(total_size*f_size);
					if (((delta_at_controller_inst+fid)->delta_fi_inst[l].delta_values[j] > 0.0))
					{
						double load_imbalance = 0.0;
						if(phifbar[fid]> 0.0)
						{
							//load_imbalance = (abs(local_sum - phifbar[fid]))/(phifbar[fid]);
							load_imbalance = (abs(local_count - phifbar[fid]))/(f_size/2.0);
						}
						//cout<<"load imbalance for link"<<l<<"to "<<j<<" is "<<load_imbalance<<endl;
						total_load_imbalance = total_load_imbalance + load_imbalance;
						q_count++;
					}
				}
					
			}
			if(q_count > 0)
			{
				total_load_imbalance = total_load_imbalance/q_count;
			}
			
		}
	}
	
	//total_latency = total_latency;
	
	if((flow_counter !=0))
	{
		current_load_imbalance = total_load_imbalance/(flow_counter);
	}
	
	current_load_balance = 100.0*(1.0-current_load_imbalance);
	
	//cout<<"Load balance calculation: flow counter is "<<flow_counter<<"current_load imbalance is "<<current_load_imbalance<<"current load balance is"<<current_load_balance<<endl;
	double current_cumulative_load_imbalance = previous_cumulative_load_imbalance + current_load_imbalance;
	
	
	average_load_balance = 100.0*(1.0 -((current_cumulative_load_imbalance)/(data_gathering_cycle_number)));
	cout<<"average load balance is "<<average_load_balance<<endl;	
	previous_cumulative_load_imbalance = current_cumulative_load_imbalance;
}


void calculate_performance_evaluation_metrics()
{

	Simulator::Schedule(Seconds(0.000000), calculate_average_latency_routing);
	Simulator::Schedule(Seconds(0.000020), calculate_average_packet_delivery_ratio_routing);
	Simulator::Schedule(Seconds(0.000040), calculate_average_jitter_routing);
	Simulator::Schedule(Seconds(0.000060), calculate_average_load_balance_routing);
	Simulator::Schedule(Seconds(0.000070), write_csv_results_routing);
}




void calculate_average_latency()
{
	double total_latency = 0.0;
	for (uint32_t i=2; i<total_size+2;i++)
	{
		if (packet_final_timestamp[i] > packet_initial_timestamp[i])
		{
			packet_delay[i] = packet_final_timestamp[i] - packet_initial_timestamp[i];
		}
		//cout<<"packet "<<i<<"final timestamp "<<packet_final_timestamp[i]<<"initial timestamp: "<<packet_initial_timestamp[i]<<endl;
		total_latency = total_latency + packet_delay[i];
	}
	current_latency = total_latency/(total_size);
	double previous_cumulative_latency = average_latency*(data_gathering_cycle_number - 1)*total_size;
	double current_cumulative_latency = previous_cumulative_latency + total_latency;
	average_latency = (current_cumulative_latency)/((data_gathering_cycle_number)*(total_size));
	cout<<"average_latency "<<1000*average_latency<<" ms"<<endl;
	
}

void calculate_packet_delivery_ratio()
{
	double delivered_packets = 0.0;
	for (uint32_t i=2; i<total_size+2;i++)
	{
		if (packet_final_timestamp[i] > packet_initial_timestamp[i])
		{
			delivered_packets = delivered_packets + 1;
		}
	}
	
	current_packet_delivery_ratio = delivered_packets/(total_size);
	if (architecture == 2)
	{
		double previous_cumulative_ratio = average_packet_delivery_ratio*(data_gathering_cycle_number - 2);
		double current_cumulative_ratio = previous_cumulative_ratio + current_packet_delivery_ratio;
		average_packet_delivery_ratio = (current_cumulative_ratio)/(data_gathering_cycle_number - 1);
	}
	if (architecture == 0)
	{
		double previous_cumulative_ratio = average_packet_delivery_ratio*(data_gathering_cycle_number - 1);
		double current_cumulative_ratio = previous_cumulative_ratio + current_packet_delivery_ratio;
		average_packet_delivery_ratio = (current_cumulative_ratio)/(data_gathering_cycle_number);
	}

	cout<<"packet delivery ratio is "<<100*average_packet_delivery_ratio<<endl;
	
}


void calculate_packet_delivery_ratio_dsrc()
{
	double delivered_packets = 0.0;
	for (uint32_t i=2; i<total_size+2;i++)
	{
		if (dsrc_packet_final_timestamp[i] > dsrc_packet_initial_timestamp[i])
		{
			delivered_packets = delivered_packets + 1;
		}
	}
	
	current_packet_delivery_ratio_dsrc = delivered_packets/(total_size);
	cout<<"current packet delivery ratio is "<<100*current_packet_delivery_ratio_dsrc<<endl;
	double previous_cumulative_ratio = average_packet_delivery_ratio_dsrc*(data_gathering_cycle_number - 1);
	double current_cumulative_ratio = previous_cumulative_ratio + current_packet_delivery_ratio_dsrc;
	average_packet_delivery_ratio_dsrc = (current_cumulative_ratio)/(data_gathering_cycle_number);
	cout<<"packet delivery ratio is "<<100*average_packet_delivery_ratio_dsrc<<endl;
	
}


void calculate_packet_delivery_ratio_dsrc_hybrid()
{
	double delivered_packets = 0.0;
	for (uint32_t i=2; i<total_size+2;i++)
	{
		if (dsrc_packet_final_timestamp[i] > dsrc_packet_initial_timestamp[i])
		{
			delivered_packets = delivered_packets + 1;
		}
	}
	
	current_packet_delivery_ratio_dsrc = delivered_packets/(total_size);
	cout<<"current packet delivery ratio is "<<100*current_packet_delivery_ratio_dsrc<<endl;
	double previous_cumulative_ratio = average_packet_delivery_ratio_dsrc*(data_gathering_cycle_number - 2);
	double current_cumulative_ratio = previous_cumulative_ratio + current_packet_delivery_ratio_dsrc;
	average_packet_delivery_ratio_dsrc = (current_cumulative_ratio)/(data_gathering_cycle_number -1);
	cout<<"packet delivery ratio is "<<100*average_packet_delivery_ratio_dsrc<<endl;
	
}

void calculate_average_latency_hybrid()
{
	double total_latency = 0.0;
	for (uint32_t i=2; i<total_size+2;i++)
	{
		if (dsrc_packet_final_timestamp[i] > dsrc_packet_initial_timestamp[i])
		{
			packet_delay_dsrc[i] = dsrc_packet_final_timestamp[i] - dsrc_packet_initial_timestamp[i];
		}
		else
		{
			packet_delay_dsrc[i] = 0.010;//maximum latency when packet not delivered
		}
		//cout<<"packet "<<i<<"final timestamp "<<packet_final_timestamp[i]<<"initial timestamp: "<<packet_initial_timestamp[i]<<endl;
		total_latency = total_latency + packet_delay_dsrc[i];
	}
	total_latency = total_latency;
	current_latency_dsrc = total_latency/(total_size);
	double previous_cumulative_latency = average_latency_dsrc*(data_gathering_cycle_number - 1)*total_size;
	double current_cumulative_latency = previous_cumulative_latency + total_latency;
	average_latency_dsrc = (current_cumulative_latency)/((data_gathering_cycle_number)*(total_size));
	cout<<"average_latency "<<1000*average_latency_dsrc<<" ms"<<endl;	
}


void calculate_average_latency_dsrc()
{
	double total_latency = 0.0;
	for (uint32_t i=2; i<total_size+2;i++)
	{
		if (dsrc_packet_final_timestamp[i] > dsrc_packet_initial_timestamp[i])
		{
			packet_delay_dsrc[i] = dsrc_packet_final_timestamp[i] - dsrc_packet_initial_timestamp[i];
		}
		//cout<<"packet "<<i<<"final timestamp "<<packet_final_timestamp[i]<<"initial timestamp: "<<packet_initial_timestamp[i]<<endl;
		total_latency = total_latency + packet_delay_dsrc[i];
	}
	total_latency = total_latency;
	current_latency_dsrc = total_latency/(total_size);
	double previous_cumulative_latency = average_latency_dsrc*(data_gathering_cycle_number - 1)*total_size;
	double current_cumulative_latency = previous_cumulative_latency + total_latency;
	average_latency_dsrc = (current_cumulative_latency)/((data_gathering_cycle_number)*(total_size));
	cout<<"average_latency "<<1000*average_latency_dsrc<<" ms"<<endl;	
}


void calculate_aodv_packet_delivery_ratio()
{
	double delivered_packets = 0.0;
	for (uint32_t i=2; i< (total_size+2); i++)
	{
		if (aodv_final_timestamp[i] > aodv_initial_timestamp[i])
		{
			delivered_packets = delivered_packets + 1;
		}
	}
	current_packet_delivery_ratio_dsrc = delivered_packets/(total_size);
	cout<<"current packet delivery ratio is "<<100*current_packet_delivery_ratio_dsrc<<endl;
	double previous_cumulative_ratio = average_packet_delivery_ratio_dsrc*(data_gathering_cycle_number - 1);
	double current_cumulative_ratio = previous_cumulative_ratio + current_packet_delivery_ratio_dsrc;
	average_packet_delivery_ratio_dsrc = (current_cumulative_ratio)/(data_gathering_cycle_number);
	cout<<"average packet delivery ratio is "<<100*average_packet_delivery_ratio_dsrc<<endl;	
}

void calculate_aodv_latency()
{
	double total_latency = 0.0;
	for (uint32_t i=2;i<(total_size+2);i++)
	{
		if (aodv_final_timestamp[i] > aodv_initial_timestamp[i])
		{
			packet_delay[i] = aodv_final_timestamp[i] - aodv_initial_timestamp[i];
		}
		else
		{
			packet_delay[i] = 0.010;//maximum latency when packet not delivered
		}
		total_latency = total_latency + packet_delay[i];	
	}
	//cout<<"packet "<<i<<"final timestamp "<<packet_final_timestamp[i]<<"initial timestamp: "<<packet_initial_timestamp[i]<<endl;
	current_latency_dsrc = total_latency/(total_size);
	double previous_cumulative_latency = average_latency_dsrc*(data_gathering_cycle_number - 1)*(total_size);
	double current_cumulative_latency = previous_cumulative_latency + total_latency;
	average_latency_dsrc = (current_cumulative_latency)/((data_gathering_cycle_number)*(total_size));
	cout<<"average_latency "<<1000*average_latency_dsrc<<" ms"<<"current latency is "<<current_latency_dsrc*1000<<" ms"<<endl;
}

void calculate_average_channel_utilization_with_solution()
{
	if (dsrc_final_timestamp > dsrc_initial_timestamp)
	{
		dsrc_utilization_time = dsrc_final_timestamp - dsrc_initial_timestamp;
	}
	else
	{
		dsrc_utilization_time = 0.0;
	}
	lte_utilization_time = (lte_final_timestamp - lte_initial_timestamp) + ((0.00005*N_Vehicles));
	cout<<"lte final timestamp is :"<<lte_final_timestamp;
	ethernet_utilization_time = (ethernet_final_timestamp - ethernet_initial_timestamp) + ((0.00005*N_RSUs));
	current_dsrc_utilization = 100.0*(dsrc_utilization_time)/(data_transmission_period);
	current_ethernet_utilization = 100.0*(ethernet_utilization_time)/(data_transmission_period);
	current_lte_utilization = 100.0*(lte_utilization_time)/(data_transmission_period);
	
	double previous_cumulative_dsrc = (data_gathering_cycle_number - 1.0)*(average_dsrc_utilization);
	double previous_cumulative_ethernet = (data_gathering_cycle_number - 1.0)*(average_ethernet_utilization);
	double previous_cumulative_lte = (data_gathering_cycle_number - 1.0)*(average_lte_utilization);
	
	average_dsrc_utilization = (current_dsrc_utilization + previous_cumulative_dsrc)/(data_gathering_cycle_number);
	average_ethernet_utilization = (current_ethernet_utilization + previous_cumulative_ethernet)/(data_gathering_cycle_number);
	average_lte_utilization = (current_lte_utilization + previous_cumulative_lte)/(data_gathering_cycle_number);
	cout<<"DSRC uti: "<<average_dsrc_utilization<<"Ethernet uti "<<average_ethernet_utilization<<"LTE utilization "<<average_lte_utilization<<endl;
}

void calculate_average_channel_utilization()
{
	if (dsrc_final_timestamp > dsrc_initial_timestamp)
	{
		dsrc_utilization_time = dsrc_final_timestamp - dsrc_initial_timestamp;
	}
	else
	{
		dsrc_utilization_time = 0.0;
	}
	lte_utilization_time = lte_final_timestamp - lte_initial_timestamp;
	cout<<"lte final timestamp is :"<<lte_final_timestamp;
	ethernet_utilization_time = ethernet_final_timestamp - ethernet_initial_timestamp;
	current_dsrc_utilization = 100.0*(dsrc_utilization_time)/(data_transmission_period);
	current_ethernet_utilization = 100.0*(ethernet_utilization_time)/(data_transmission_period);
	current_lte_utilization = 100.0*(lte_utilization_time)/(data_transmission_period);
	
	double previous_cumulative_dsrc = (data_gathering_cycle_number - 1.0)*(average_dsrc_utilization);
	double previous_cumulative_ethernet = (data_gathering_cycle_number - 1.0)*(average_ethernet_utilization);
	double previous_cumulative_lte = (data_gathering_cycle_number - 1.0)*(average_lte_utilization);
	
	average_dsrc_utilization = (current_dsrc_utilization + previous_cumulative_dsrc)/(data_gathering_cycle_number);
	average_ethernet_utilization = (current_ethernet_utilization + previous_cumulative_ethernet)/(data_gathering_cycle_number);
	average_lte_utilization = (current_lte_utilization + previous_cumulative_lte)/(data_gathering_cycle_number);
	cout<<"DSRC uti: "<<average_dsrc_utilization<<"Ethernet uti "<<average_ethernet_utilization<<"LTE utilization "<<average_lte_utilization<<endl;
}

void calculate_average_cost_with_solution()
{
	double ethernet_cost = 1.0;
	double dsrc_cost =2.0;
	double lte_cost = 40.0;
	//calculate total cost in kilo bytes
	double current_total_cost = ((ethernet_cost*ethernet_total_packet_size) + (dsrc_cost*dsrc_total_packet_size) + (lte_cost*lte_total_packet_size) + (lte_cost*2*N_Vehicles) + (ethernet_cost*2*N_RSUs))/1024.0;
	current_cost = current_total_cost/(total_size);
	cout<<"current average cost is "<<current_cost<<endl;
	double previous_cumulative_total_cost = (total_size)*(data_gathering_cycle_number - 1.0)*(average_cost);
	double current_cumulative_total_cost = previous_cumulative_total_cost + current_total_cost;
	average_cost = (current_cumulative_total_cost)/((data_gathering_cycle_number)*(total_size));
	cout<<"average cost per node is "<< average_cost<<endl;
	ethernet_total_packet_size = 0;
	dsrc_total_packet_size = 0;
	lte_total_packet_size = 0;
}

void calculate_average_cost_without_solution()
{
	double ethernet_cost = 1.0;
	double dsrc_cost =2.0;
	double lte_cost = 40.0;
	//calculate total cost in kilo bytes
	double current_total_cost = ((ethernet_cost*ethernet_total_packet_size) + (dsrc_cost*dsrc_total_packet_size) + (lte_cost*lte_total_packet_size))/1024.0;
	current_cost = current_total_cost/(total_size);
	cout<<"current average cost is "<<current_cost<<endl;
	double previous_cumulative_total_cost = (total_size)*(data_gathering_cycle_number - 1.0)*(average_cost);
	double current_cumulative_total_cost = previous_cumulative_total_cost + current_total_cost;
	average_cost = (current_cumulative_total_cost)/((data_gathering_cycle_number)*(total_size));
	cout<<"average cost per node is "<< average_cost<<endl;
	ethernet_total_packet_size = 0;
	dsrc_total_packet_size = 0;
	lte_total_packet_size = 0;
}


void calculate_average_cost_without_solution_dsrc()
{
	double dsrc_cost =2.0;
	//calculate total cost in kilo bytes
	double current_total_cost =  (dsrc_cost*dsrc_total_packet_size)*10/1024.0;
	current_cost = current_total_cost/(total_size);
	cout<<"current average cost is "<<current_cost<<endl;
	double previous_cumulative_total_cost = (total_size)*(data_gathering_cycle_number - 1.0)*(average_cost);
	double current_cumulative_total_cost = previous_cumulative_total_cost + current_total_cost;
	average_cost = (current_cumulative_total_cost)/((data_gathering_cycle_number)*(total_size));
	cout<<"average cost per node is "<< average_cost<<endl;
	ethernet_total_packet_size = 0;
	dsrc_total_packet_size = 0;
	lte_total_packet_size = 0;
	dsrc_total_received_packets = 0;
}




double times_optimized =0.0;
double times_checked = 0.0;

void calculate_percentage()
{
	optimization_percentage = 100.0*(times_optimized/times_checked);
}

void transmit_solution()
{
	read_csv();
	//After getting the solution, unicast the solution to the nodes.
	for (uint32_t u=0;u< actual_total_nodes;u++)
	{
		if (u < (N_Vehicles))
		{
			Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (apps.Get(0));
			Simulator::Schedule(Seconds(0.002 + 0.000015*u),send_LTE_metadata_downlink_alone,udp_app,controller_Node.Get(0),Vehicle_Nodes.Get(u), u);
		}
		else
		{
			uint32_t index = u - N_Vehicles;
			//cout<<"index is "<<index;
			// Safety check: ensure index is within RSU_Nodes bounds
			if (index >= N_RSUs) {
				std::cerr << "ERROR: transmit_metadata - index " << index 
				          << " exceeds N_RSUs " << N_RSUs << " (u=" << u 
				          << ", N_Vehicles=" << N_Vehicles << ")" << std::endl;
				continue;
			}
			Ptr <Node> nu = DynamicCast <Node> (RSU_Nodes.Get(index));	
	  		Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (apps.Get(0));
			Simulator::Schedule(Seconds(0.002 + 0.000015*u),RSU_metadata_downlink_unicast, udp_app, controller_Node.Get(0), nu);
		}
	}
}


void transmit_delta_values()
{
	//read_csv();
	//After getting the solution, unicast the solution to the nodes.
	for (uint32_t u=0;u< actual_total_nodes;u++)
	{
		if (u < (N_Vehicles))
		{
			Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (apps.Get(0));
			Simulator::Schedule(Seconds(0.000 + (0.000015*u)),send_LTE_deltavalues_downlink_alone,udp_app,controller_Node.Get(0),Vehicle_Nodes.Get(u), u);
		}
		else
		{
			uint32_t index = u - N_Vehicles;
			//cout<<"index is "<<index;
			// Safety check: ensure index is within RSU_Nodes bounds
			if (index >= N_RSUs) {
				std::cerr << "ERROR: transmit_delta_values - index " << index 
				          << " exceeds N_RSUs " << N_RSUs << " (u=" << u 
				          << ", N_Vehicles=" << N_Vehicles << ")" << std::endl;
				continue;
			}
			Ptr <Node> nu = DynamicCast <Node> (RSU_Nodes.Get(index));	
	  		Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (apps.Get(0));
			Simulator::Schedule(Seconds(0.000 + (0.000015*u)),RSU_deltavalues_downlink_unicast, udp_app, controller_Node.Get(0), nu);
		}
	}
	cout<<"Transmitting delta values at"<<Now().GetSeconds()<<endl;
}
	
	
void optimize_subsequent()
{
	//calculate entropy of the network and compare with threshold.
	std::string filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization.py";
    	std::string command = "python3 ";
    	command += filename;
    	system(command.c_str());
}

void optimize_link_lifetime()
{
	//generate optimization solution for predicting link lifetimes
	std::string filename;
	switch(routing_algorithm)
	{
		case(0):
			filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_lifetime.py";
			break;
		case(1):
			filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_lifetime.py";
			break;
		case(2):
			filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_lifetime.py";
			break;
		case(3):
			filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_lifetime.py";
			break;
		case(4):
			filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_lifetime.py";
			break;
		case(5):
			if(experiment_number == 0)
			{
				filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_lifetime.py";
			}
			if(experiment_number == 1)
			{
				filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_lifetime.py";
			}
			if(experiment_number == 2)
			{
				filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_lifetime.py";
			}
			if(experiment_number == 3)
			{
				filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_lifetime.py";
			}
			
			break;
		default:
			filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization_lifetime.py";
			break;
		
	}
    	std::string command = "python3 ";
    	command += filename;
    	system(command.c_str());
}

void optimize_first_time()
{
	std::string filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/optimization.py";
    	std::string command = "python3 ";
    	command += filename;
    	system(command.c_str());
}


vector<double> link_lifetime_dsrc[total_size];
vector<double> link_lifetime_ethernet[total_size];
vector<double> delay_dsrc[total_size];
vector<double> delay_ethernet[total_size];
double link_lifetime_vector[total_size*total_size];
double delay_vector[2*total_size];

void convert_link_lifetimes_dsrc()
{
	for(uint32_t i=0;i<total_size;i++)
	{
		vector<double> x_dsrc;
		for (uint32_t j = 0;j < (total_size);j++)
		{
			x_dsrc.push_back(link_lifetime_vector[(i*total_size)+j]);

		}
		
		link_lifetime_dsrc[i] = x_dsrc;	
	}
		
	vector<vector<double>> new_adjacencyMatrix_dsrc;
	for(uint32_t i=0;i<total_size;i++)
	//for(uint32_t i=0;i<9;i++)
	{
		new_adjacencyMatrix_dsrc.push_back(link_lifetime_dsrc[i]);
	}
	linklifetimeMatrix_dsrc = new_adjacencyMatrix_dsrc;
	//cout<<"link lifetime matrix converted"<<endl;
	
	/*
	for (uint32_t i=0;i<total_size;i++)
	//for (uint32_t i=0;i<9;i++)
	{
	
		for (uint32_t j=0;j<total_size;j++)
		//for (uint32_t j=0;j<9;j++)
		{
			cout<<"DSRC Link lifetime from source node"<<(i)<<"to node "<<(j)<<"is "<<linklifetimeMatrix_dsrc[i][j]<<endl;
		}
	}
	*/
			
	//cout<<"adjacency matrix size"<<adjacencyMatrix.size()<<endl;
	cout<<"link lifetime conversion finished at"<<Seconds(Now().GetSeconds())<<endl;
}


void convert_link_lifetimes()
{
	for(uint32_t i=0;i<total_size;i++)
	{
		vector<double> x_dsrc;
		vector<double> x_ethernet;
		for (uint32_t j = 0;j < (total_size);j++)
		{
			x_dsrc.push_back(link_lifetime_vector[(i*total_size)+j]);
			if(i<N_Vehicles)
			{
				x_ethernet.push_back(0.0);
			}
			else
			{
				if(j<N_Vehicles)
				{
					x_ethernet.push_back(0.0);
				}
				else
				{
					if(i==j)
					{
						x_ethernet.push_back(0.0);
					}
					else
					{
						x_ethernet.push_back(11.0);
					}
				}
			}
		}
		
		link_lifetime_dsrc[i] = x_dsrc;	
		link_lifetime_ethernet[i] = x_ethernet;
	}
		
	vector<vector<double>> new_adjacencyMatrix_dsrc;
	vector<vector<double>> new_adjacencyMatrix_ethernet;
	for(uint32_t i=0;i<total_size;i++)
	//for(uint32_t i=0;i<9;i++)
	{
		new_adjacencyMatrix_dsrc.push_back(link_lifetime_dsrc[i]);
		new_adjacencyMatrix_ethernet.push_back(link_lifetime_ethernet[i]);
	}
	linklifetimeMatrix_dsrc = new_adjacencyMatrix_dsrc;
	linklifetimeMatrix_ethernet = new_adjacencyMatrix_ethernet;
	cout<<"link lifetime matrix converted"<<endl;
	
	
	for (uint32_t i=0;i<total_size;i++)
	//for (uint32_t i=0;i<9;i++)
	{
		
		for (uint32_t j=0;j<total_size;j++)
		//for (uint32_t j=0;j<9;j++)
		{
			cout<<"DSRC Link lifetime from source node"<<(i)<<"to node "<<(j)<<"is "<<linklifetimeMatrix_dsrc[i][j]<<endl;
			cout<<"Ethernet Link lifetime from source node"<<(i)<<"to node "<<(j)<<"is "<<linklifetimeMatrix_ethernet[i][j]<<endl;
		}
		
		
	}
			
	//cout<<"adjacency matrix size"<<adjacencyMatrix.size()<<endl;
}

void read_lifetime_from_csv()
{
    fstream fin;
    cout<<"reading lifetime from csv at"<<Now().GetSeconds()<<endl;
    switch(routing_algorithm)
    {
    	case(0):
    		fin.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/link_lifetime_solution_ECMP.csv", ios::in);
    		break;
    	case(1):
    		fin.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/link_lifetime_solution_RR.csv", ios::in);
    		break;
    	case(2):
    		fin.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/link_lifetime_solution_QRSDN.csv", ios::in);
    		break;
    	case(3):
    		fin.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/link_lifetime_solution_RLMR.csv", ios::in);
    		break;
    	case(4):
    		fin.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/link_lifetime_solution.csv", ios::in);
    		break;	
    	case(5):
    		if(experiment_number == 0)
    		{
    			fin.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/link_lifetime_solution_QRSDN.csv", ios::in);
    		}
    		if(experiment_number == 1)
    		{
    			fin.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/link_lifetime_solution_RR.csv", ios::in);
    		}
    		if(experiment_number == 2)
    		{
    			fin.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/link_lifetime_solution_QRSDN.csv", ios::in);
    		}
    		if(experiment_number == 3)
    		{
    			fin.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/link_lifetime_solution_RLMR.csv", ios::in);
    		}
    		break;	
    	default:
    		fin.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/link_lifetime_solution.csv", ios::in);
    		break;
    }
    
    // Check if file opened successfully
    if (!fin.is_open()) {
        std::cerr << "ERROR: Cannot open lifetime CSV file for routing_algorithm " << routing_algorithm << std::endl;
        std::cerr << "Matrices will remain uninitialized - path finding may fail!" << std::endl;
        return;
    }
    
    vector<string> row;
    string line;
    string temp;
    int j=0;
    while (fin >> temp) 
    {
        row.clear();
        getline(fin, line);
        int n = line.length();
        char line_char[n+1];
        strcpy(line_char,line.c_str());
        //cout<<line<<endl;
        double dou_val;
        char * ptr;
        ptr = strtok(line_char,",");
        int i =0;
        while(ptr != NULL)
        {
        	stringstream ss;
		ss << ptr;
		//cout<<ptr<<endl;
		ss >> dou_val;
		if (i==0)
		{
			link_lifetime_vector[j] = dou_val;
			//cout<<j<<" value "<<dou_val<<endl;
		}
        	
        	ptr = strtok(NULL,",");   
        	i++;	
        }
        j++;
    }
    if (j == 0)
        cout << "Solution not found\n";
    convert_link_lifetimes_dsrc();
}

void run_ECMP()
{
	cout<<"Running ECMP started at "<<Now().GetSeconds()<<endl;
	for(uint32_t fid=0;fid<2*flows;fid++)
	{
		//uint32_t f_size = (demanding_flow_struct_controller_inst+fid)->f_size;
		uint32_t f_source = (demanding_flow_struct_controller_inst+fid)->source;
		//uint32_t f_destination = (demanding_flow_struct_controller_inst+fid)->destination;
		if((demanding_flow_struct_controller_inst+fid)->f_size == 0)
		{
			for(uint32_t cid=0;cid<total_size;cid++)	
			{
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
					(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = 0.0;
				}
			}
		}
		else
		{
			for(uint32_t cid=0;cid<total_size;cid++)	
			{
				uint32_t next_hops_count = 0;
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					if ((distance_algo2_output_inst[fid].D[nid] < distance_algo2_output_inst[fid].D[cid])&&(distance_algo2_output_inst[fid].conn[nid]==1)&& (distance_algo2_output_inst[fid].conn[cid]==1)&&(linklifetimeMatrix_dsrc[cid][nid]>0.0))
					{
						next_hops_count++;
					}
				}
				
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					if ((distance_algo2_output_inst[fid].D[nid] < distance_algo2_output_inst[fid].D[cid])&&(distance_algo2_output_inst[fid].conn[nid]==1)&& (distance_algo2_output_inst[fid].conn[cid]==1)&&(linklifetimeMatrix_dsrc[cid][nid]>0.0))
					{
						double lifetime_uncertainity = maxspeed*0.001;
						(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 1.0/(next_hops_count+lifetime_uncertainity);
					}
					else
					{
						(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
					}
					
					//Compute load values
					if(cid == f_source)
					{
						(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = (delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid];
					}
					else
					{
						double summation = 0;
						for(int i=0;i<total_size;i++)
						{
							summation = summation + (L_at_controller_inst+fid)->L_fi_inst[i].L_values[cid];
						}
						(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = ((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid])*summation;
					}
				}
			}
		}
	}
	cout<<"Running ECMP finished at "<<Now().GetSeconds()<<endl;
}

double compute_packet_delay_DCMR(uint32_t fid, uint32_t nid, uint32_t packet_size)
{
	//uint32_t zeta = 1;
	double B_bar;
	if(qf < 2)
	{
		//B_bar = (1+B_max)/2.0;
		B_bar = 2.0;
	}
	else
	{
		B_bar = B_max;
	}
	rts = 20.0;
	cts = 14.0;
	ack = 14.0;

	double datarate = 12.0;
	double T_trans = ((8*((B_bar*(packet_size+rts+cts))+(ack)))/(datarate));
	double delay = (distance_algo2_output_inst[fid].Y[nid]*(T_trans))/(1000000);
	//cout<<"Computed packet delay DCMR is "<<delay<<" seconds "<<endl;
	return delay;
}

void run_DCMR()
{
	cout<<"Running DCMR started at "<<Now().GetSeconds()<<endl;
	double RBW[total_size];
	double congestion_level[total_size];
	
	for(uint32_t i=0; i<total_size;i++)
	{
		RBW[i] = 1.0;
		congestion_level[i] = 0.0001;
	}
	for(uint32_t fid=0;fid<2*flows;fid++)
	{
		//uint32_t f_size = (demanding_flow_struct_controller_inst+fid)->f_size;
		uint32_t f_source = (demanding_flow_struct_controller_inst+fid)->source;
		//uint32_t f_destination = (demanding_flow_struct_controller_inst+fid)->destination;
		uint32_t f_psize = (demanding_flow_struct_controller_inst+fid)->p_size;
		
		if((demanding_flow_struct_controller_inst+fid)->f_size == 0)
		{
			for(uint32_t cid=0;cid<total_size;cid++)	
			{
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
					(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = 0.0;
				}
			}
		}
		else
		{	
			//uint32_t cid = f_source;
			//while(cid != f_destination)
			for(uint32_t cid=0;cid<total_size;cid++)
			{
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
					(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = 0.0;
				}
				//uint32_t next_hops_count = 0;
				double RBW_local[total_size];
				double congestion_level_local[total_size];
				double PUF_local[total_size];
				int32_t cost_local[total_size];
				for(uint32_t i=0; i<total_size;i++)
				{
					RBW_local[i] = 1.0;
					congestion_level_local[i] = 0.0001;
					PUF_local[i] = 0.0;
					cost_local[i] = 100000;
				}
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					double packet_delay = compute_packet_delay_DCMR(fid, nid, f_psize);
					if ((distance_algo2_output_inst[fid].D[nid] < distance_algo2_output_inst[fid].D[cid])&&(distance_algo2_output_inst[fid].conn[nid]==1)&& (distance_algo2_output_inst[fid].conn[cid]==1)&&(linklifetimeMatrix_dsrc[cid][nid]>0.0)&&(packet_delay < latency_max))
					{
						//next_hops_count++;
						cout<<"packet delay is "<<packet_delay<<"latency constraint is "<<latency_max<<endl;
						cout<<"current hop "<<cid<<"next hop "<<nid<<endl;
						//(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.00001;
						//(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = 0.00001;
						double cur_delta = (lambda*flow_packet_size*8/1000.0);
						double prev_delta = 12000 - RBW[nid]*12000;
						double delta = prev_delta + cur_delta;
						RBW_local[nid] = (12000 - delta)/(12000.0);
						cout<<"RBW_local is "<<RBW_local[nid]<<endl;
						double cur_to = lambda;
						double prev_to = congestion_level[nid]*10*lambda;
						congestion_level_local[nid] = (cur_to + prev_to)/(10.0*lambda);
						cout<<"congestion_local is "<<congestion_level_local[nid]<<endl;
						cout<<"link lifetime is "<<linklifetimeMatrix_dsrc[cid][nid]<<endl;
						PUF_local[nid] = (RBW_local[nid]/congestion_level_local[nid])*(linklifetimeMatrix_dsrc[cid][nid]);
						cout<<"PUF_local is "<<PUF_local[nid]<<endl;
						cost_local[nid] = (distance_algo2_output_inst[fid].D[nid]/25.0) - PUF_local[nid];
						cout<<"distance is "<<distance_algo2_output_inst[fid].D[nid]<<endl;
						cout<<"cost_local is "<<cost_local[nid]<<endl;
					}
				}
				
				uint32_t least_cost_hop = cid;
				int32_t least_cost = 100000;
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					if(cost_local[nid] < least_cost)
					{
						least_cost_hop = nid;
						least_cost = cost_local[nid];
					}
				}
				cout<<endl;
				cout<<"Least cost hop is "<<least_cost_hop<<endl;
				cout<<endl;
				RBW[least_cost_hop] = RBW_local[least_cost_hop];
				congestion_level[least_cost_hop] = congestion_level_local[least_cost_hop];
				
				
				uint32_t second_least_cost_hop = cid;
				int32_t second_least_cost = 100000;
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					if((cost_local[nid] < second_least_cost)&&(cost_local[nid] > least_cost))
					{
						second_least_cost_hop = nid;
						second_least_cost = cost_local[nid];
					}
				}
				cout<<endl;
				cout<<"Second least cost hop is "<<second_least_cost_hop<<endl;
				cout<<endl;
				RBW[second_least_cost_hop] = RBW_local[second_least_cost_hop];
				congestion_level[second_least_cost_hop] = congestion_level_local[second_least_cost_hop];
				
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					if(second_least_cost_hop == cid)
					{
						if((nid!=cid)&&(nid == least_cost_hop))
						{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 1.0;
						}
						else
						{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
						}
					}
					else
					{
						if((nid!=cid)&&(nid == least_cost_hop))
						{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.7;
						}
						else if((nid!=cid)&&(nid == second_least_cost_hop))
						{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.3;
						}
						else
						{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
						}
					}
				}
			}
			for(uint32_t cid=0;cid<total_size;cid++)
			{
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					if(cid == f_source)
					{
						(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = (delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid];
					}
					else
					{
						double summation = 0;
						for(int i=0;i<total_size;i++)
						{
							summation = summation + (L_at_controller_inst+fid)->L_fi_inst[i].L_values[cid];
						}
						(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = ((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid])*summation;
					}
				}
			//cid = least_cost_hop;
			}	
		}
	}
	cout<<"Running DCMR finished at "<<Now().GetSeconds()<<endl;
}

double learning_rate = 0.1;
uint32_t max_hops = 20;
double discount_factor =0.50;
uint32_t RL_iterations = uint32_t(1050);

void run_QRSDN()
{
	cout<<"Running QRSDN started at "<<Now().GetSeconds()<<endl;
	for(uint32_t fid=0;fid<2*flows;fid++)
	{
		//uint32_t f_size = (demanding_flow_struct_controller_inst+fid)->f_size;
		uint32_t f_source = (demanding_flow_struct_controller_inst+fid)->source;
		uint32_t f_destination = (demanding_flow_struct_controller_inst+fid)->destination;
		
		if((demanding_flow_struct_controller_inst+fid)->f_size == 0)
		{
			for(uint32_t cid=0;cid<total_size;cid++)	
			{
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
					(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = 0.0;
				}
			}
			//cout<<"flow id "<<fid<<"is empty"<<endl;
		}
		else
		{
			//cout<<"Running RL in fid "<<fid<<endl;
			for(uint32_t cid=0;cid<total_size;cid++)	
			{
				//Initialize Q values with lifetime
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					if ((cid==f_destination) || (nid==f_source))
					{
						(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
					}
					else if ((linklifetimeMatrix_dsrc[cid][nid]>0.0))
					{
						(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 1.0;
					}
					else
					{
						(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
					}
					(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
					(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = 0.0;
				}
			}
			//cout<<"Q-values initialized"<<endl;
			
			for(uint32_t cid=0;cid<total_size;cid++)	
			{	
				//convert to acyclic graph
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					
					(Y_at_controller_inst+fid)->Y_fi_inst[cid].Y_values[nid] = distance_algo2_output_inst[fid].Y[cid];
					if (((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] == 1.0) && ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[cid] == 1.0))
					{
						if ((distance_algo2_output_inst[fid].D[nid] < distance_algo2_output_inst[fid].D[cid]))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[cid] = 0.0;
						}
						else if ((distance_algo2_output_inst[fid].D[nid] > distance_algo2_output_inst[fid].D[cid]))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
						}
						else if ((distance_algo2_output_inst[fid].D[nid] == distance_algo2_output_inst[fid].D[cid]))
						{
							if ((distance_algo2_output_inst[fid].Y[nid] < distance_algo2_output_inst[fid].Y[cid]))
							{
								(Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[cid] = 0.0;
							}
							else if ((distance_algo2_output_inst[fid].Y[nid] > distance_algo2_output_inst[fid].Y[cid]))
							{
								(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
							}
						}
					}
				}
			}
			//cout<<"Converted to acyclic graph"<<endl;
			//Initialize delta, load values
			for(uint32_t cid=0;cid<total_size;cid++)	
			{	
				//count actions
				uint32_t actions=0;
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
					{
						actions++;
					}
				}//Intialize delta, load values
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					
					if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
					{
						(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 1.0/actions;
						if(cid == f_source)
						{
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = (delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid];
						}
						else
						{
							double summation = 0.0;
							for(int i=0;i<total_size;i++)
							{
								summation = summation + (L_at_controller_inst+fid)->L_fi_inst[i].L_values[cid];
							}
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = ((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid])*summation;
						}
						//cout<<"Initialized delta as "<<(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid]<<"and load as "<<(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid]<<"for flow id "<<fid<<"current node "<<cid<<"next hop "<<nid<<endl;
					}
				}
			}
			//cout<<"Initialized delta and load values"<<endl;
			
				//RL
				for(uint32_t m=0;m<RL_iterations;m++)
				{
					//cout<<"Iteration "<<m<<endl;
					uint32_t cid = f_source;
					uint32_t actions=0;
					list<uint32_t> action_set;
					
					for(uint32_t nid=0;nid<total_size;nid++)	
					{
						if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
						{
							action_set.push_back(nid);
							actions++;
						}
					}
					while (actions > 0)
					{
						uint32_t index = rand()%actions;
						auto front = action_set.begin();
						advance(front,index);
					 	uint32_t nid = *front;
					 	(Omega_at_controller_inst+fid)->Omega_fi_inst[cid].Omega_values[nid]	= distance_algo2_output_inst[fid].conn[nid];
					 	
					 	double y_summation = 0.0;
					 	for(int j=0;j<total_size;j++)
					 	{
					 		y_summation = y_summation + (((delta_at_controller_inst+fid)->delta_fi_inst[nid].delta_values[j])*((Y_at_controller_inst+fid)->Y_fi_inst[nid].Y_values[j]));
					 	}
						(Y_at_controller_inst+fid)->Y_fi_inst[cid].Y_values[nid]= 1 + y_summation;
						
						
						//Compute delta_values
						double q_summation = 0.0;
						double q_max = 0.0;
						for(int j=0;j<total_size;j++)
					 	{
					 		if(((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j])> 0.0)
					 		{
					 			q_summation = q_summation + ((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j]);
					 		}
					 		if(((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j])> 0.0)
					 		{
						 		if(q_max < ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j]))
						 		{
						 			q_max = ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j]);
						 		}
					 		}
					 	}
					 	if ((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
					 	{
						
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = (((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid]))/(q_summation);
						}
						else
						{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
						}
						
						//Compute load values
						if(cid == f_source)
						{
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = (delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid];
						}
						else
						{
							double summation = 0;
							for(int i=0;i<total_size;i++)
							{
								summation = summation + (L_at_controller_inst+fid)->L_fi_inst[i].L_values[cid];
							}
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = ((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid])*summation;
						}
						
						//Compute reward
						(W_at_controller_inst+fid)->W_fi_inst[cid].W_values[nid] = ((max_hops) - (Y_at_controller_inst+fid)->Y_fi_inst[cid].Y_values[nid])/(max_hops);
						
						//Update Q value
						double q_term1 = (1.0-learning_rate)*((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid]);
						double q_term2 = (learning_rate)*(((W_at_controller_inst+fid)->W_fi_inst[cid].W_values[nid])+(discount_factor*q_max));
						(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = q_term1 + q_term2;
						//cout<<"Flow id "<<fid<<"current hop "<<cid<<"next hop "<<nid<<"updated Q value as : "<<(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid]<<"updated delta value is "<<(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid]<<"Link load "<<((L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid])*f_size<<"packets"<<"Hop count "<<(Y_at_controller_inst+fid)->Y_fi_inst[cid].Y_values[nid]<<"with reward "<<(W_at_controller_inst+fid)->W_fi_inst[cid].W_values[nid]<<endl;
						
						//Compute delta_values
						double q_summation_again = 0.0;
						double q_max_again = 0.0;
						for(int j=0;j<total_size;j++)
					 	{
					 		if(((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j])> 0.0)
					 		{
					 			q_summation_again = q_summation_again + ((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j]);
					 		}
					 		if(((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j])> 0.0)
					 		{
						 		if(q_max_again < ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j]))
						 		{
						 			q_max_again = ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j]);
						 		}
					 		}
					 	}
					 	if ((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
					 	{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = (((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid]))/(q_summation_again);
						}
						
						else
						{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
						}
						
						//Compute load values
						if(cid == f_source)
						{
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = (delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid];
						}
						else
						{
							double summation = 0;
							for(int i=0;i<total_size;i++)
							{
								summation = summation + (L_at_controller_inst+fid)->L_fi_inst[i].L_values[cid];
							}
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = ((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid])*summation;
						}
						
						//Go to next state
						cid = nid;
						uint32_t local_actions=0;
						list<uint32_t> local_action_set;
						
						for(uint32_t j=0;j<total_size;j++)	
						{
							if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j] > 0.0)
							{
								local_action_set.push_back(j);
								local_actions++;
							}
						}
						actions = local_actions;
						action_set = local_action_set;
					}
			}
		}
	}
	cout<<"QRSDN finished at "<<Now().GetSeconds()<<endl;
}

void run_RLMR()
{
	cout<<"Running RLMR started at "<<Now().GetSeconds()<<endl;
	for(uint32_t fid=0;fid<2*flows;fid++)
	{
		//uint32_t f_size = (demanding_flow_struct_controller_inst+fid)->f_size;
		uint32_t f_source = (demanding_flow_struct_controller_inst+fid)->source;
		uint32_t f_destination = (demanding_flow_struct_controller_inst+fid)->destination;
		//uint32_t f_psize = (demanding_flow_struct_controller_inst+i)->p_size;
		uint32_t f_qos = (demanding_flow_struct_controller_inst+fid)->qos;
		
		if((demanding_flow_struct_controller_inst+fid)->f_size == 0)
		{
			for(uint32_t cid=0;cid<total_size;cid++)	
			{
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
					(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = 0.0;
				}
			}
			//cout<<"flow id "<<fid<<"is empty"<<endl;
		}
		else
		{
			//cout<<"Running RL in fid "<<fid<<endl;
			for(uint32_t cid=0;cid<total_size;cid++)	
			{
				//Initialize Q values with lifetime
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					if ((cid==f_destination) || (nid==f_source))
					{
						(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
					}
					else if ((linklifetimeMatrix_dsrc[cid][nid]>0.0))
					{
						(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 1.0;
					}
					else
					{
						(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
					}
					(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
					(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = 0.0;
				}
			}
			//cout<<"Q-values initialized"<<endl;
			
			for(uint32_t cid=0;cid<total_size;cid++)	
			{	
				//convert to acyclic graph
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					
					(Y_at_controller_inst+fid)->Y_fi_inst[cid].Y_values[nid] = distance_algo2_output_inst[fid].Y[cid];
					if (((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] == 1.0) && ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[cid] == 1.0))
					{
						if ((distance_algo2_output_inst[fid].D[nid] < distance_algo2_output_inst[fid].D[cid]))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[cid] = 0.0;
						}
						else if ((distance_algo2_output_inst[fid].D[nid] > distance_algo2_output_inst[fid].D[cid]))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
						}
						else if ((distance_algo2_output_inst[fid].D[nid] == distance_algo2_output_inst[fid].D[cid]))
						{
							if ((distance_algo2_output_inst[fid].Y[nid] < distance_algo2_output_inst[fid].Y[cid]))
							{
								(Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[cid] = 0.0;
							}
							else if ((distance_algo2_output_inst[fid].Y[nid] > distance_algo2_output_inst[fid].Y[cid]))
							{
								(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
							}
						}
					}
				}
			}
			//cout<<"Converted to acyclic graph"<<endl;
			//Initialize delta, load values
			for(uint32_t cid=0;cid<total_size;cid++)	
			{	
				//count actions
				uint32_t actions=0;
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
					{
						actions++;
					}
				}//Intialize delta, load values
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					
					if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
					{
						(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 1.0/actions;
						if(cid == f_source)
						{
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = (delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid];
						}
						else
						{
							double summation = 0.0;
							for(int i=0;i<total_size;i++)
							{
								summation = summation + (L_at_controller_inst+fid)->L_fi_inst[i].L_values[cid];
							}
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = ((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid])*summation;
						}
						//cout<<"Initialized delta as "<<(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid]<<"and load as "<<(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid]<<"for flow id "<<fid<<"current node "<<cid<<"next hop "<<nid<<endl;
					}
				}
			}
			//cout<<"Initialized delta and load values"<<endl;
			
				//RL
				for(uint32_t m=0;m<RL_iterations;m++)
				{
					//cout<<"Iteration "<<m<<endl;
					uint32_t cid = f_source;
					uint32_t actions=0;
					list<uint32_t> action_set;
					
					for(uint32_t nid=0;nid<total_size;nid++)	
					{
						if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
						{
							action_set.push_back(nid);
							actions++;
						}
					}
					uint32_t l_count = 0;
					while ((actions > 0)&&(l_count<10000))
					{
						uint32_t index = rand()%actions;
						auto front = action_set.begin();
						advance(front,index);
					 	uint32_t nid = *front;
					 	if (nid == f_destination)
					 	{
					 		(Omega_at_controller_inst+fid)->Omega_fi_inst[cid].Omega_values[nid]	= distance_algo2_output_inst[fid].conn[nid];
					 	}
					 	
					 	else
					 	{
					 		(Omega_at_controller_inst+fid)->Omega_fi_inst[cid].Omega_values[nid]	= 0;
					 	}
					 	
					 	double y_summation = 0.0;
					 	for(int j=0;j<total_size;j++)
					 	{
					 		y_summation = y_summation + (((delta_at_controller_inst+fid)->delta_fi_inst[nid].delta_values[j])*((Y_at_controller_inst+fid)->Y_fi_inst[nid].Y_values[j]));
					 	}
						(Y_at_controller_inst+fid)->Y_fi_inst[cid].Y_values[nid]= 1 + y_summation;
						
						
						//Compute delta_values
						double q_summation = 0.0;
						double q_max = 0.0;
						for(int j=0;j<total_size;j++)
					 	{
					 		if(((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j])> 0.0)
					 		{
					 			q_summation = q_summation + ((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j]);
					 		}
					 		if(((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j])> 0.0)
					 		{
						 		if(q_max < ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j]))
						 		{
						 			q_max = ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j]);
						 		}
					 		}
					 	}
					 	
					 	if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
					 	{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = (((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid]))/(q_summation);
						}
						else
						{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
						
						}
						
						//Compute load values
						if(cid == f_source)
						{
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = (delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid];
						}
						else
						{
							double summation = 0;
							for(int i=0;i<total_size;i++)
							{
								summation = summation + (L_at_controller_inst+fid)->L_fi_inst[i].L_values[cid];
							}
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = ((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid])*summation;
						}
						
						//Compute reward
						(W_at_controller_inst+fid)->W_fi_inst[cid].W_values[nid] = ((3*(max_hops)) - (f_qos*(Y_at_controller_inst+fid)->Y_fi_inst[cid].Y_values[nid])+((L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid])+(10*(Omega_at_controller_inst+fid)->Omega_fi_inst[cid].Omega_values[nid]))/((3*(max_hops))+10+lambda);
						
						//Update Q value
						double q_term1 = (1.0-learning_rate)*((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid]);
						double q_term2 = (learning_rate)*(((W_at_controller_inst+fid)->W_fi_inst[cid].W_values[nid])+(discount_factor*q_max));
						(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = q_term1 + q_term2;
						//cout<<"Flow id "<<fid<<"f qos"<<f_qos<<"current hop "<<cid<<"next hop "<<nid<<"updated Q value as : "<<(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid]<<"updated delta value is "<<(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid]<<"Link load "<<((L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid])*f_size<<"packets"<<"Hop count "<<(Y_at_controller_inst+fid)->Y_fi_inst[cid].Y_values[nid]<<"with reward "<<(W_at_controller_inst+fid)->W_fi_inst[cid].W_values[nid]<<"Omega"<<(Omega_at_controller_inst+fid)->Omega_fi_inst[cid].Omega_values[nid]<<endl;
						
						//Compute delta_values
						double q_summation_again = 0.0;
						double q_max_again = 0.0;
						for(int j=0;j<total_size;j++)
					 	{
					 		if(((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j])> 0.0)
					 		{
					 			q_summation_again = q_summation_again + ((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j]);
					 		}
					 		if(((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j])> 0.0)
					 		{
						 		if(q_max_again < ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j]))
						 		{
						 			q_max_again = ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j]);
						 		}
					 		}
					 	}
					 	if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
					 	{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = (((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid]))/(q_summation_again);
						}
						else
						{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
						
						}
						//Compute load values
						if(cid == f_source)
						{
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = (delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid];
						}
						else
						{
							double summation = 0;
							for(int i=0;i<total_size;i++)
							{
								summation = summation + (L_at_controller_inst+fid)->L_fi_inst[i].L_values[cid];
							}
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = ((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid])*summation;
						}
						
						//Go to next state
						cid = nid;
						uint32_t local_actions=0;
						list<uint32_t> local_action_set;
						
						for(uint32_t j=0;j<total_size;j++)	
						{
							if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j] > 0.0)
							{
								local_action_set.push_back(j);
								local_actions++;
							}
						}
						actions = local_actions;
						action_set = local_action_set;
						l_count++;
					}
			}
		}
	}
	cout<<"RLMR finished at "<<Now().GetSeconds()<<endl;
}

struct flow_cardinality
{
	uint32_t cardinality[total_size];
};

struct flow_cardinality f_card_inst[2*flows];

double unit_step(double number, double step)
{
	if(number < step)
	{
		return 0.0;
	}
	else
	{
		return 1.0;
	}
}

double compute_link_delay(uint32_t next_hop, double link_load, uint32_t flow_size, uint32_t packet_size, uint32_t destination, uint32_t zeta)
{
	//uint32_t zeta = 1;
	double B_bar;
	if(qf < 2)
	{
		//B_bar = (1+B_max)/2.0;
		B_bar = 2.0;
	}
	else
	{
		B_bar = B_max;
	}
	rts = 20.0;
	cts = 14.0;
	ack = 14.0;
	double guard_delay = 0.000100;
	double datarate = 12.0;
	double T_cont = (AIFS) + ((T_slot*CW_min)/(pow(2,(3-B_bar))));//in microseconds
	double T_trans = ((8*((B_bar*(packet_size+rts+cts))+(ack)))/(datarate));
	double delay = guard_delay + (zeta*link_load*flow_size*(T_trans+T_cont))/(1000000);
	//cout<<"Computed link delay is "<<delay<<" seconds for next hop "<<next_hop<<endl;
	return delay;
}

double compute_individual_link_delay(uint32_t next_hop, uint32_t CW, uint32_t flow_size, uint32_t packet_size, uint32_t destination, uint32_t zeta)
{
	//uint32_t zeta = 1;
	rts = 20.0;
	cts = 14.0;
	ack = 14.0;
	double guard_delay = 0.000100;
	double datarate = 12.0;
	double T_cont = (AIFS) + ((T_slot*CW_min)/(pow(2,(3-CW))));//in microseconds
	double T_trans = ((8*((1.00*(packet_size+rts+cts))+(ack)))/(datarate));
	double delay = guard_delay + (zeta*1.15*flow_size*(T_trans+T_cont))/(1000000);
	//cout<<"Computed link delay is "<<delay<<" seconds for next hop "<<next_hop<<endl;
	return delay;
}

double compute_path_delay(uint32_t fid, uint32_t cid, uint32_t nid, double link_load, uint32_t flow_size, uint32_t packet_size, uint32_t destination)
{

	uint32_t zeta;
	if (flows == 1)
	{
		zeta = 14;
	}
	else
	{	if(routing_algorithm != 4)
		{
			zeta = 18;
		}
		else
		{
			zeta = 14 + 2*scheduled_flows;
		
		}
	}
	
	double link_lat_summation = 0.0;
	for(uint32_t i =0;i<total_size; i++)
	{
		if (((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid]) >= ((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[i]))
		{
			link_lat_summation = link_lat_summation + ((t_at_controller_inst+fid)->t_fi_inst[cid].t_values[i])/2.0;
		}
	}
	
	double y_summation = 0.0;
	for(uint32_t i =0;i<total_size; i++)
	{
		y_summation = y_summation + (((delta_at_controller_inst+fid)->delta_fi_inst[nid].delta_values[i])*((Y_at_controller_inst+fid)->Y_fi_inst[nid].Y_values[i]));
	}
	
	double packet_latency = 0.0;
	if(link_load > 0.0)
	{
		packet_latency = (((t_at_controller_inst+fid)->t_fi_inst[cid].t_values[nid])/((1.0 + (0.1*scheduled_flows*scheduled_flows))*(zeta*flow_size*link_load)))*(y_summation);
	}
	
	double path_latency = link_lat_summation + packet_latency;
	//cout<<"Computed path delay is "<<path_latency<<" seconds for current hop"<<cid<<"next hop "<<nid<<endl;
	return path_latency;
}




double Lf_bar[2*flows];

double epsilon_0_initial = 0.9;
void run_proposed_RL()
{
	cout<<"Proposed RL started at "<<Now().GetSeconds()<<endl;
	for(uint32_t fid=0;fid<2*flows;fid++)
	{
		uint32_t f_size = (demanding_flow_struct_controller_inst+fid)->f_size;
		uint32_t f_source = (demanding_flow_struct_controller_inst+fid)->source;
		uint32_t f_destination = (demanding_flow_struct_controller_inst+fid)->destination;
		uint32_t f_psize = (demanding_flow_struct_controller_inst+fid)->p_size;
		uint32_t f_qos = (demanding_flow_struct_controller_inst+fid)->qos;
		
		//cout<<f_size<<f_qos<<f_psize<<endl;
		
		if((demanding_flow_struct_controller_inst+fid)->f_size == 0)
		{
			for(uint32_t cid=0;cid<total_size;cid++)	
			{
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
					(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = 0.0;
					(T_at_controller_inst+fid)->T_fi_inst[cid].T_values[nid] = 0.0;
				}
			}
			//cout<<"flow id "<<fid<<"is empty"<<endl;
		}
		else
		{
			//cout<<"Running RL in fid "<<fid<<endl;
			for(uint32_t cid=0;cid<total_size;cid++)	
			{
				//Initialize Q values with lifetime
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					if ((cid==f_destination) || (nid==f_source))
					{
						(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
					}
					else if ((linklifetimeMatrix_dsrc[cid][nid]>link_lifetime_threshold))
					{
						(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 1.0;
					}
					else
					{
						(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
					}
					(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
					(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = 0.0;
					(T_at_controller_inst+fid)->T_fi_inst[cid].T_values[nid] = 0.0;
					(t_at_controller_inst+fid)->t_fi_inst[cid].t_values[nid] = 0.0;
				}
			}
			//cout<<"Q-values initialized"<<endl;
			
			//find cardinality
			for(uint32_t cid=0;cid<total_size;cid++)	
			{	
				uint32_t summation = 0;
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					double lt = unit_step(linklifetimeMatrix_dsrc[cid][nid]-link_lifetime_threshold, 0);
					double product = (proposed_algo2_output_inst[fid].conn[nid])*lt;
					summation = summation + product;
				}
				f_card_inst[fid].cardinality[cid] = summation;
				//cout<<"cardinality of node "<<cid<<"is "<<f_card_inst[fid].cardinality[cid]<<endl;
			}		
			
			
			//convert to directed acyclic graph
			for(uint32_t cid=0;cid<total_size;cid++)	
			{	
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					
					(Y_at_controller_inst+fid)->Y_fi_inst[cid].Y_values[nid] = proposed_algo2_output_inst[fid].Y[cid];
					if(proposed_algo2_output_inst[fid].U[cid] - link_lifetime_threshold > 0.0)
					{
						(U_at_controller_inst+fid)->U_fi_inst[cid].U_values[nid] = proposed_algo2_output_inst[fid].U[cid] - link_lifetime_threshold;
					}
					else
					{
						(U_at_controller_inst+fid)->U_fi_inst[cid].U_values[nid] = 0.0;
					}
					
					if (((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] == 1.0) && ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[cid] == 1.0))
					{
						/*	
						if((f_card_inst[fid].cardinality[cid]>2)&&(f_card_inst[fid].cardinality[nid]==2)&&(((proposed_algo2_output_inst[fid].Y[nid]/1.0) == proposed_algo2_output_inst[fid].Y[cid])))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[cid] = 0.0;
						}
						*/
						if((f_card_inst[fid].cardinality[cid]>2)&&(f_card_inst[fid].cardinality[nid]==2)&&
						   (proposed_algo2_output_inst[fid].U[nid] > 0.0) && (proposed_algo2_output_inst[fid].U[cid] > 0.0) &&
						   (((proposed_algo2_output_inst[fid].Y[nid]/(proposed_algo2_output_inst[fid].U[nid])) <= (proposed_algo2_output_inst[fid].Y[cid]/proposed_algo2_output_inst[fid].U[cid]))))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[cid] = 0.0;
						}
						else if((f_card_inst[fid].cardinality[cid]>2)&&(f_card_inst[fid].cardinality[nid]==2)&&(((proposed_algo2_output_inst[fid].Y[nid]/1.0) == (proposed_algo2_output_inst[fid].Y[cid]/1.0))))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[cid] = 0.0;
						}
						
						else if((f_card_inst[fid].cardinality[cid]==2)&&(f_card_inst[fid].cardinality[nid]>2)&&
						        (proposed_algo2_output_inst[fid].U[nid] > 0.0) && (proposed_algo2_output_inst[fid].U[cid] > 0.0) &&
						        (((proposed_algo2_output_inst[fid].Y[nid]/(proposed_algo2_output_inst[fid].U[nid])) >= (proposed_algo2_output_inst[fid].Y[cid]/proposed_algo2_output_inst[fid].U[cid]))))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
						}
						else if((f_card_inst[fid].cardinality[cid]==2)&&(f_card_inst[fid].cardinality[nid]>2)&&(((proposed_algo2_output_inst[fid].Y[nid]/1.0) == (proposed_algo2_output_inst[fid].Y[cid]/1.0))))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
						}
						
						else if (((proposed_algo2_output_inst[fid].Y[nid]/1.0) < proposed_algo2_output_inst[fid].Y[cid]))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[cid] = 0.0;
						}
						
						else if (((proposed_algo2_output_inst[fid].Y[nid]/1.0) > proposed_algo2_output_inst[fid].Y[cid]))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
						}
						
						else if ((proposed_algo2_output_inst[fid].U[cid] > 0.0) && (proposed_algo2_output_inst[fid].U[nid] > 0.0) &&
						         ((proposed_algo2_output_inst[fid].Y[nid]/1.0) == proposed_algo2_output_inst[fid].Y[cid]) && 
						         (((1.0/proposed_algo2_output_inst[fid].U[cid]) > (1.0/proposed_algo2_output_inst[fid].U[nid]))))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = 0.0;
						}
						
						else if ((proposed_algo2_output_inst[fid].U[cid] > 0.0) && (proposed_algo2_output_inst[fid].U[nid] > 0.0) &&
						         ((proposed_algo2_output_inst[fid].Y[nid]/1.0) == proposed_algo2_output_inst[fid].Y[cid]) && 
						         (((1.0/proposed_algo2_output_inst[fid].U[cid]) <= (1.0/proposed_algo2_output_inst[fid].U[nid]))))
						{
							(Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[cid] = 0.0;
						}
						
					}
				}
			}
			
			//cout<<"Converted to acyclic graph"<<endl;
			
			
			//Initialize delta, load, and latency values
			for(uint32_t cid=0;cid<total_size;cid++)	
			{	
				//count actions
				uint32_t actions=0;
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
					{
						actions++;
					}
				}//Intialize delta, load values, latency values
				for(uint32_t nid=0;nid<total_size;nid++)	
				{
					
					
					if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
					{
						(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 1.0/actions;
						if(cid == f_source)
						{
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = (delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid];
						}
						else
						{
							double summation = 0.0;
							for(int i=0;i<total_size;i++)
							{
								summation = summation + (L_at_controller_inst+fid)->L_fi_inst[i].L_values[cid];
							}
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = ((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid])*summation;
						}
						
						uint32_t zeta;
						if (flows == 1)
						{
							zeta = 14;
						}
						else
						{
							zeta = 14+ 2*scheduled_flows;
						}
						
						(t_at_controller_inst+fid)->t_fi_inst[cid].t_values[nid] = (1.0 + (0.1*scheduled_flows*scheduled_flows))*compute_link_delay(nid, (L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid], f_size, f_psize, f_destination, zeta);
						(T_at_controller_inst+fid)->T_fi_inst[cid].T_values[nid] = compute_path_delay(fid, cid, nid, (L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid], f_size, f_psize, f_destination);
						
						
						//cout<<"Initialized delta as "<<(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid]<<"and load as "<<(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid]<<"for flow id "<<fid<<"current node "<<cid<<"next hop "<<nid<<endl;
					}
				}
			}
			//cout<<"Initialized delta, load, and latency values"<<endl;
			
				//RL
				for(uint32_t m=0;m<RL_iterations;m++)
				{
					//cout<<"Iteration "<<m<<endl;
					uint32_t cid = f_source;
					uint32_t actions=0;
					list<uint32_t> action_set;
					
					//compute Lf_bar
					double load_sum = 0.0;
					uint32_t load_count = 0;
					for(uint32_t i=0;i<total_size;i++)	
					{
						for(uint32_t j=0;j<total_size;j++)	
						{
							load_sum = load_sum + (L_at_controller_inst+fid)->L_fi_inst[i].L_values[j];
							if((L_at_controller_inst+fid)->L_fi_inst[i].L_values[j] > 0.0)
							{
								load_count++;
							}
						}
						
					}
					if(load_count > 0)
					{
						Lf_bar[fid] = load_sum/load_count;
					}
					
					else
					{
						Lf_bar[fid] = 0.0;
					}
					
					for(uint32_t nid=0;nid<total_size;nid++)	
					{
						if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
						{
							action_set.push_back(nid);
							actions++;
						}
					}
					//cout<<"Lf_bar is "<<Lf_bar[fid]<<"connections from source "<<actions<<endl;
					
					while (actions > 0)
					{
						
						double epsilon = (rand()%10)/10.0;
						uint32_t index;
						double val = m/500.0;
						//cout<<"epsilon is "<<epsilon<<"m is "<<m<<"exponent is "<<val<<endl;
						double epsilon_0 = epsilon_0_initial*pow(2.71, -val);
						//cout<<"epsilon_0 is "<<epsilon_0<<endl;
						if (epsilon > epsilon_0)
						{
						 	index = rand()%actions;
						}
						
						else
						{
							double minimum_u = 10000;
							uint32_t min_index = 0;
							for(uint32_t i=0;i<actions;i++)
							{
								auto local_front = action_set.begin();
								advance(local_front,i);
						 		uint32_t local_nid = *local_front;
						 		if (((U_at_controller_inst+fid)->U_fi_inst[cid].U_values[local_nid])< minimum_u)
						 		{
						 			minimum_u = ((U_at_controller_inst+fid)->U_fi_inst[cid].U_values[local_nid]);
						 			min_index = i;
						 		}
						 	}
						 	index = min_index;
						}	
						
						auto front = action_set.begin();
						advance(front,index);
					 	uint32_t nid = *front;
					 	(Omega_at_controller_inst+fid)->Omega_fi_inst[cid].Omega_values[nid]	= proposed_algo2_output_inst[fid].conn[nid];
					 	
					 	(Theta_at_controller_inst+fid)->Theta_fi_inst[cid].Theta_values[nid]	= (unit_step((proposed_algo2_output_inst[fid].conn[nid]+1), 1))*(unit_step(actions-1,1));
					 	//cout<<"flow id "<<fid<<"current hop "<<cid<<" next hop "<<nid<<" Omega value "<<(Omega_at_controller_inst+fid)->Omega_fi_inst[cid].Omega_values[nid]<<" Theta value is "<<(Theta_at_controller_inst+fid)->Theta_fi_inst[cid].Theta_values[nid]<<endl;
					 	
					 	double y_summation = 0.0;
					 	for(int j=0;j<total_size;j++)
					 	{
					 		y_summation = y_summation + (((delta_at_controller_inst+fid)->delta_fi_inst[nid].delta_values[j])*((Y_at_controller_inst+fid)->Y_fi_inst[nid].Y_values[j]));
					 	}
						(Y_at_controller_inst+fid)->Y_fi_inst[cid].Y_values[nid]= 1 + y_summation;
						
						if(nid != f_destination)
						{
						double u_summation = 0.0;
						 	for(int j=0;j<total_size;j++)
						 	{
						 		u_summation = u_summation + (((delta_at_controller_inst+fid)->delta_fi_inst[nid].delta_values[j])*((U_at_controller_inst+fid)->U_fi_inst[nid].U_values[j]));
						 	}
							(U_at_controller_inst+fid)->U_fi_inst[cid].U_values[nid]= minimum(linklifetimeMatrix_dsrc[cid][nid]-link_lifetime_threshold, u_summation);
						}
						
						
						//Compute delta_values
						double q_summation = 0.0;
						double q_max = 0.0;
						for(int j=0;j<total_size;j++)
					 	{
					 		if(((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j])> 0.0)
					 		{
					 			q_summation = q_summation + ((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j]);
					 		}
					 		if(((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j])> 0.0)
					 		{
						 		if(q_max < ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j]))
						 		{
						 			q_max = ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j]);
						 		}
					 		}
					 	}
					 	if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
					 	{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = (((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid]))/(q_summation);
						}
						else
						{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
						
						}
						
						//Compute load values
						if(cid == f_source)
						{
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = (delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid];
						}
						else
						{
							double summation = 0;
							for(int i=0;i<total_size;i++)
							{
								summation = summation + (L_at_controller_inst+fid)->L_fi_inst[i].L_values[cid];
							}
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = ((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid])*summation;
						}
						uint32_t zeta;
						if (flows == 1)
						{
							zeta = 14;
						}
						else
						{
							zeta = 14 + 2*scheduled_flows;
						}
						//compute link and path latencies
						(t_at_controller_inst+fid)->t_fi_inst[cid].t_values[nid] = (1.0 + (0.1*scheduled_flows*scheduled_flows))*compute_link_delay(nid, (L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid], f_size, f_psize, f_destination, zeta);
						(T_at_controller_inst+fid)->T_fi_inst[cid].T_values[nid] = compute_path_delay(fid, cid, nid, (L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid], f_size, f_psize, f_destination);
						
						//Compute reward
						//uint32_t zeta = 5;
						/*
						if (nid == f_destination)
						{
							zeta = 1;
						}
						else 
						{
							zeta = 2;
						}
						*/
						double term1 = mu1*(Omega_at_controller_inst+fid)->Omega_fi_inst[cid].Omega_values[nid];
						double overall_quality;
						double packet_delivery;
						double packet_latency;
						double negation_factor = 0.1*(scheduled_flows+1);
						if (((U_at_controller_inst+fid)->U_fi_inst[cid].U_values[nid]-(negation_factor*link_lifetime_threshold)) > 0.0)
						{
							overall_quality = ((T_at_controller_inst+fid)->T_fi_inst[cid].T_values[nid])/(2.0*((U_at_controller_inst+fid)->U_fi_inst[cid].U_values[nid]-negation_factor*link_lifetime_threshold));
							packet_delivery= (1.0-loss_max)*((((T_at_controller_inst+fid)->T_fi_inst[cid].T_values[nid])/(2.0*((U_at_controller_inst+fid)->U_fi_inst[cid].U_values[nid]-negation_factor*link_lifetime_threshold)))*(unit_step(((T_at_controller_inst+fid)->T_fi_inst[cid].T_values[nid])/(1.0*((U_at_controller_inst+fid)->U_fi_inst[cid].U_values[nid]-negation_factor*link_lifetime_threshold)),1)));
						}
						else
						{
							overall_quality = 1e6;
							packet_delivery = 1e6;
						}
						double mu2t = 2.0;
						uint32_t tucount =0;
						double tusum = 0.0;
						for(uint32_t i=0;i<total_size;i++)
						{
							if((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[i] > 0.0)
							{
								
								if (((U_at_controller_inst+fid)->U_fi_inst[cid].U_values[i] - negation_factor*link_lifetime_threshold) > 0.0)
								{
									double qu = unit_step((((T_at_controller_inst+fid)->T_fi_inst[cid].T_values[i])/((U_at_controller_inst+fid)->U_fi_inst[cid].U_values[i]-negation_factor*link_lifetime_threshold)), 0.5);
									tusum = tusum +qu;
									tucount++;
								}
							
							}
						
						}
						
						
						if(tucount > 0)
						{
							double result = tusum/tucount;
							if (result == 0)
							{
								mu2t = 1.0;
							}
							else
							{
								mu2t = 2.0;
							}
						}
						else
						{
							mu2t = 2.0;
						}	
						//cout<<"mu2t is "<<mu2t<<endl;
						
						if ((L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] > 0.0)
						{
							packet_latency = (((t_at_controller_inst+fid)->t_fi_inst[cid].t_values[nid])*((Y_at_controller_inst+fid)->Y_fi_inst[cid].Y_values[nid]))/((1.0 + (0.1*scheduled_flows*scheduled_flows))*(mu2t*latency_max*zeta*f_size*(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid]));
						
						}
						else
						{
							packet_latency = 0.0;
						}
						//cout<<"overall quality reward "<<overall_quality<<"packet delivery reward "<<packet_delivery<<"packet latency reward "<<packet_latency<<endl;
						
						double term2 = mu2*(1.0-(overall_quality)-(packet_delivery)-(packet_latency))*(Theta_at_controller_inst+fid)->Theta_fi_inst[cid].Theta_values[nid];
						double term3 = mu3*(-1.0*((3.0-f_qos)/(3.0))*((L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] - Lf_bar[fid])*(Theta_at_controller_inst+fid)->Theta_fi_inst[cid].Theta_values[nid]);
						(W_at_controller_inst+fid)->W_fi_inst[cid].W_values[nid] = term1 + term2 + term3;
						
						//Update Q value
						double q_term1 = (1.0-learning_rate)*((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid]);
						double q_term2 = (learning_rate)*(((W_at_controller_inst+fid)->W_fi_inst[cid].W_values[nid])+(discount_factor*q_max));
						//cout<<"Q max is"<<q_max<<"Q value term 1 is "<<q_term1<<"term 2 is "<<q_term2<<endl;
						(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] = q_term1 + q_term2;
						
						//Compute delta_values
						double q_summation_again = 0.0;
						double q_max_again = 0.0;
						for(int j=0;j<total_size;j++)
					 	{
					 		if(((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j])> 0.0)
					 		{
					 			q_summation_again = q_summation_again + ((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j]);
					 		}
					 		if(((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j])> 0.0)
					 		{
						 		if(q_max_again < ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j]))
						 		{
						 			q_max_again = ((Q_at_controller_inst+fid)->Q_fi_inst[nid].Q_values[j]);
						 		}
					 		}
					 	}
					 	if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid] > 0.0)
					 	{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = (((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid]))/(q_summation_again);
						}
						else
						{
							(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid] = 0.0;
						}
						
						//Compute load values
						if(cid == f_source)
						{
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = (delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid];
						}
						else
						{
							double summation = 0;
							for(int i=0;i<total_size;i++)
							{
								summation = summation + (L_at_controller_inst+fid)->L_fi_inst[i].L_values[cid];
							}
							(L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid] = ((delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid])*summation;
						}
						
						//cout<<"Flow id "<<fid<<"current hop "<<cid<<"next hop "<<nid<<"updated Q value as : "<<(Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[nid]<<"updated delta value is "<<(delta_at_controller_inst+fid)->delta_fi_inst[cid].delta_values[nid]<<"Link load "<<((L_at_controller_inst+fid)->L_fi_inst[cid].L_values[nid])*f_size<<"packets"<<"Hop count "<<(Y_at_controller_inst+fid)->Y_fi_inst[cid].Y_values[nid]<<"with path lifetime "<<(U_at_controller_inst+fid)->U_fi_inst[cid].U_values[nid]<<"with path latency"<<(T_at_controller_inst+fid)->T_fi_inst[cid].T_values[nid]<<"with total reward "<<(W_at_controller_inst+fid)->W_fi_inst[cid].W_values[nid]<<"reward term 1 "<<term1<<"reward term 2:"<<term2<<"reward term 3:"<<term3<<endl;
						
						//Go to next state
						cid = nid;
						uint32_t local_actions=0;
						list<uint32_t> local_action_set;
						
						for(uint32_t j=0;j<total_size;j++)	
						{
							if((Q_at_controller_inst+fid)->Q_fi_inst[cid].Q_values[j] > 0.0)
							{
								local_action_set.push_back(j);
								local_actions++;
							}
						}
						actions = local_actions;
						action_set = local_action_set;
					
					}
			}
			
		}
	}
	cout<<"Proposed RL learning finished at "<<Now().GetSeconds()<<endl;
}

void  run_optimization_link_lifetime()
{
	cout<<"link lifetime optimization beginning at "<<Now().GetSeconds()<<endl;
	write_csv_status_lifetime();//write status data to csv
	Simulator::Schedule(Seconds(0.000050), optimize_link_lifetime);
	Simulator::Schedule(Seconds(0.000100), read_lifetime_from_csv);
}


void  run_optimization_subsequent()
{
	for (uint32_t i=2;i<(total_size + 2);i++)
	{
		refresh_controller_data(con_data_inst+i);
	}
	double new_entropy = calculate_network_entropy();
	double entropy_change = abs(last_optimized_entropy - new_entropy);
	cout<<"entropy_change is "<<entropy_change<<endl;
	if(entropy_change > entropy_threshold)
	{
		write_csv();//write data to csv
		cout<<"Entropy change is high. optimizing"<<endl;
		Simulator::Schedule(Seconds(0.002), optimize_subsequent);
		/*
		if (N_Vehicles < 50)
		{
			Simulator::Schedule(Seconds(0.015), transmit_solution);
		}
		*/
		//else
		//{
		Simulator::Schedule(Seconds(0.042), transmit_solution);
			
		//}
		last_optimized_entropy = new_entropy;
		if (paper == 0)
		{
			calculate_average_cost_with_solution();
			calculate_average_channel_utilization_with_solution();
			calculate_average_latency();
			Simulator::Schedule(Seconds(0.100), calculate_packet_delivery_ratio);
			times_checked++;
			times_optimized++;
			calculate_percentage();
			Simulator::Schedule(Seconds(0.105),write_csv_results);
			data_gathering_cycle_number++;
		}
		
		

	}
	else
	{
		cout<<"omitting optimization as entropy change is low"<<endl;
		if (paper == 0)
		{
			calculate_average_cost_without_solution();
			calculate_average_channel_utilization();
			calculate_average_latency();
			Simulator::Schedule(Seconds(0.100), calculate_packet_delivery_ratio);
			times_checked++;
			calculate_percentage();
			Simulator::Schedule(Seconds(0.105),write_csv_results);
			data_gathering_cycle_number++;
		}
			
	}
}




//vector<double> node_distance[9];





void predict_DNN_link_lifetime()
{
	cout<<"predicting link lifetimes"<<endl;
	std::string filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/DNN_link_stability.py";
    	std::string command = "python3 ";
    	command += filename;
    	system(command.c_str());
}

void predict_DNN_delay()
{
	cout<<"predicting delay"<<endl;
	std::string filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/DNN_delay.py";
    	std::string command = "python3 ";
    	command += filename;
    	system(command.c_str());
}

void  run_DNN_link_lifetime()
{
	write_csv_status();//write status data to csv
	Simulator::Schedule(Seconds(0.005), predict_DNN_link_lifetime);
}

void  run_DNN_delay()
{
	write_csv_delay_prediction();//write delay data to csv
	Simulator::Schedule(Seconds(0.005), predict_DNN_delay);
}




void convert_delay()
{
	cout<<"converting delay"<<endl;
	for(uint32_t i=0;i<(2*total_size);i=i+2)
	{
		vector<double> x_dsrc;
		vector<double> x_ethernet;
		for (uint32_t j = 0;j < total_size;j++)
		{
			double dij_dsrc;
			double dij_ethernet;
			if (i == 2*j)
			{
				dij_dsrc = 0.0;
				dij_ethernet = 0.0;
			}
			else
			{
				//dij_dsrc = delay_vector[i+1] + 4*(adjacencyMatrix[i/2][j]);
				//dij_ethernet = delay_vector[i] + 1*(adjacencyMatrix[i/2][j]);
				dij_dsrc =  0.01*delay_vector[i+1] + adjacencyMatrix[i/2][j];
				dij_ethernet = 0.01*delay_vector[i] + adjacencyMatrix[i/2][j];
			}
			x_dsrc.push_back(dij_dsrc);
			x_ethernet.push_back(dij_ethernet);
		}
		delay_dsrc[i/2] = x_dsrc;	
		delay_ethernet[i/2] = x_ethernet;
	}
	
	vector<vector<double>> new_adjacencyMatrix_dsrc;
	vector<vector<double>> new_adjacencyMatrix_ethernet;
	for(uint32_t i=0;i<total_size;i++)
	//for(uint32_t i=0;i<9;i++)
	{
		new_adjacencyMatrix_dsrc.push_back(delay_dsrc[i]);
		new_adjacencyMatrix_ethernet.push_back(delay_ethernet[i]);
	}
	delayMatrix_dsrc = new_adjacencyMatrix_dsrc;
	delayMatrix_ethernet = new_adjacencyMatrix_ethernet;
	cout<<"delay matrix converted"<<endl;
	
	
	for (uint32_t i=0;i<total_size;i++)
	//for (uint32_t i=0;i<9;i++)
	{
		
		for (uint32_t j=0;j<total_size;j++)
		//for (uint32_t j=0;j<9;j++)
		{
			cout<<"DSRC delay from source node"<<(i)<<"to node "<<(j)<<"is "<<delayMatrix_dsrc[i][j]<<endl;
			cout<<"Ethernet delay from source node"<<(i)<<"to node "<<(j)<<"is "<<delayMatrix_ethernet[i][j]<<endl;
		}
		
		
	}
	
	
		
	//cout<<"adjacency matrix size"<<adjacencyMatrix.size()<<endl;
}




void read_delay_from_csv()
{
    fstream fin;
    cout<<"reading delay from csv"<<endl;
    fin.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/scratch/delay_solution.csv", ios::in);
    vector<string> row;
    string line;
    string temp;
    int j=0;
    while (fin >> temp) 
    {
        row.clear();
        getline(fin, line);
        int n = line.length();
        char line_char[n+1];
        strcpy(line_char,line.c_str());
        //cout<<line<<endl;
        double dou_val;
        char * ptr;
        ptr = strtok(line_char,",");
        int i =0;
        while(ptr != NULL)
        {
        	stringstream ss;
		ss << ptr;
		//cout<<ptr<<endl;
		ss >> dou_val;
		if (i==0)
		{
			delay_vector[j] = dou_val;
			//cout<<j<<" value "<<dou_val<<endl;
		}
        	
        	ptr = strtok(NULL,",");   
        	i++;	
        }
        j++;
    }
    if (j == 0)
        cout << "Solution not found\n";
    convert_delay();
}


void generate_linklifetime_matrix()
{
	run_DNN_link_lifetime();
	Simulator::Schedule(Seconds(0.010), read_lifetime_from_csv);	
}

void generate_delay_matrix()
{
	compute_average_delays();
	run_DNN_delay();
	Simulator::Schedule(Seconds(0.010), read_delay_from_csv);	
}


void calculate_dijkstra_solution(uint32_t destination)
{
	dijkstra(adjacencyMatrix, destination);
}

void calculate_dijkstra_stable_solution(uint32_t destination)
{
	dijkstra_stable(destination);
}


void write_distance_metrics()
{
	fstream fout;
	string filename = "/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/results/maximum_distance_results.csv";
	fout.open(filename,ios::out|ios::app);
	
	fout << Simulator::Now().GetSeconds();
	for (uint32_t i=3;i<total_size+2; i=i+2)
	{
		fout << max_distance[i] << ", ";
	}
	fout << "\n";
	fout.close();

}

/*
void calculate_normalized_mobility()
{
	double sum = 0.0;
	for (uint32_t i=2; i<total_size+2 ;i++)
	{
		double xi,yi,zi;
		
		xi = data_at_manager_inst[i].velocity.x;
		yi = data_at_manager_inst[i].velocity.y;
		zi = data_at_manager_inst[i].velocity.z; 
		
		sum = sum + sqrt ((xi*xi) + (yi*yi) + (zi*zi));
	}
	
	normalized_mobility = sum/(total_size*maxspeed*(5.0/18.0));
	cout<<"normalized mobility: "<<normalized_mobility<<endl;	
}

void calculate_network_contention()
{
	network_contention = last_optimized_entropy*(1.0 - normalized_mobility);
	cout<<"network contention: "<<network_contention<<endl;
}
*/


void calculate_centralized_metrics_routing()
{
	calculate_average_cost_without_solution();
	calculate_average_channel_utilization();
	calculate_average_latency_hybrid();
	calculate_packet_delivery_ratio_dsrc();
	write_csv_results();
	data_gathering_cycle_number++;
}

void calculate_hybrid_metrics_routing()
{
	calculate_average_cost_without_solution();
	calculate_average_channel_utilization();
	calculate_average_latency_hybrid();
	calculate_packet_delivery_ratio_dsrc_hybrid();
	write_csv_results();
	data_gathering_cycle_number++;
}


void calculate_centralized_metrics()
{

	calculate_average_cost_without_solution();
	calculate_average_channel_utilization();
	calculate_average_latency();
	calculate_packet_delivery_ratio();
	write_csv_results();
	data_gathering_cycle_number++;
}

void calculate_distributed_metrics()
{
	calculate_average_cost_without_solution_dsrc();
	calculate_average_channel_utilization();
	calculate_average_latency_dsrc();
	calculate_packet_delivery_ratio_dsrc();
	write_csv_results();
	data_gathering_cycle_number++;
}

void calculate_aodv_metrics()
{
	calculate_average_cost_without_solution_dsrc();
	calculate_average_channel_utilization();
	calculate_aodv_latency();
	if (experiment_number !=11)
	{
		calculate_aodv_packet_delivery_ratio();
	}
	write_csv_results();
	data_gathering_cycle_number++;
}

void run_optimization_first_time()
{
	write_csv();//write data to csv
	Simulator::Schedule(Seconds(0.002), optimize_first_time);
	last_optimized_entropy = calculate_network_entropy();
	cout<<"first ever entropy value "<<last_optimized_entropy<<endl;
	Simulator::Schedule(Seconds(0.060), transmit_solution);
	calculate_average_cost_with_solution();
	calculate_average_channel_utilization_with_solution();
	if (paper == 0)
	{
		calculate_average_latency();
		Simulator::Schedule(Seconds(0.050), calculate_packet_delivery_ratio);
		times_checked++;
		times_optimized++;
		calculate_percentage();
		Simulator::Schedule(Seconds(0.055),write_csv_results);
	}
	data_gathering_cycle_number++;
}

void Enqueue (std::string context, Ptr <const Packet> pkt)
{
	cout<<"A packet enqued"<<endl;
}

void Dequeue (std::string context, Ptr <const Packet> pkt)
{
	cout<<"A packet dequed"<<endl;
}

void MacTx (std::string context, Ptr <const Packet> pkt)
{
	//cout<<"This is MacTx"<<endl;
}

void RSU_routing_dataunicast_alone(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> source_node, Ptr <Node> destination_node, Ptr <Packet> packet1)
{
	Ptr <Node> nu = DynamicCast <Node> (source_node);
	//uint32_t nid = uint32_t(nu->GetId());
	
	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
  	Ipv4InterfaceAddress iaddr;
  	if(N_Vehicles > 0)
  	{
		iaddr = ipv4->GetAddress(1,0);//2nd IPv4 interface,0th address index
	}
	else if (N_Vehicles == 0)
	{
		iaddr = ipv4->GetAddress(0,0);//1st IPv4 interface,0th address index
	}
	Ipv4Address dest_ip = iaddr.GetLocal();	
	ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
	Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);		
}

struct transmit_opportunity
{	
	Time last_set_timestamp[185][total_size];
	bool busy[185][total_size];
	uint32_t pending_packets[185][total_size];
};

struct transmit_opportunity txop_inst[2*flows];

struct custom_struct
{
	uint32_t p_size;
	uint32_t channel;
	uint32_t CW;
};

void updateTxop(uint32_t fid, uint32_t nodeid, uint32_t receiver_id, uint32_t pending_packets, bool busy, struct custom_struct arguments)
{
	uint32_t zeta = 1;
	double tg = compute_individual_link_delay(0, arguments.CW, 1, flow_packet_size, 1, zeta);
	for(uint32_t f=0;f<2*flows;f++)
	{ 
		//update current node status
		if(busy == true)
		{
			txop_inst[f].busy[arguments.channel][nodeid] = busy;
			txop_inst[f].last_set_timestamp[arguments.channel][nodeid] = Seconds(Now().GetSeconds());
			//cout<<"Set node "<<nodeid<<"as busy at "<<Now().GetSeconds()<<endl;
		}
		else
		{
			Time diff = Seconds(Now().GetSeconds())-txop_inst[f].last_set_timestamp[arguments.channel][nodeid];
			if(diff > Seconds(tg))
			{
				txop_inst[f].busy[arguments.channel][nodeid] = busy;
				//cout<<"Set node "<<nodeid<<"as free at "<<Now().GetSeconds()<<endl;
			}
			else
			{
				//cout<<"Node "<<nodeid<<"remains busy "<<Now().GetSeconds()<<endl;
			}
		}
		//update other node status
		for(uint32_t i=0;i<total_size;i++)
		{
			if((linklifetimeMatrix_dsrc[nodeid][i]) > 0.0)
			{
				if(busy == true)
				{
					txop_inst[f].busy[arguments.channel][i] = busy;
					txop_inst[f].last_set_timestamp[arguments.channel][i] = Seconds(Now().GetSeconds());
					//cout<<"Set node "<<i<<"as busy at "<<Now().GetSeconds()<<endl;
					for(uint32_t j=0;j<total_size;j++)
					{
						if((linklifetimeMatrix_dsrc[i][j]) > 0.0)
						{
							txop_inst[f].busy[arguments.channel][j] = busy;
							txop_inst[f].last_set_timestamp[arguments.channel][j] = Seconds(Now().GetSeconds());
							//cout<<"Set node "<<j<<"as busy at "<<Now().GetSeconds()<<endl;
						}
					}
				}
				else
				{
					Time diff = Seconds(Now().GetSeconds())-txop_inst[f].last_set_timestamp[arguments.channel][i];
					if(diff > Seconds(tg))
					{
						txop_inst[f].busy[arguments.channel][i] = busy;
						//cout<<"Set node "<<i<<"as free at "<<Now().GetSeconds()<<endl;
					}
					else
					{
						//cout<<"Node "<<i<<"remains busy "<<Now().GetSeconds()<<endl;
					}
					
					for(uint32_t j=0;j<total_size;j++)
					{
						if((linklifetimeMatrix_dsrc[i][j]) > 0.0)
						{
							Time diff_inner = Seconds(Now().GetSeconds())-txop_inst[f].last_set_timestamp[arguments.channel][j];
							if(diff_inner > Seconds(tg))
							{
								txop_inst[f].busy[arguments.channel][j] = busy;
								//cout<<"Set node "<<j<<"as free at "<<Now().GetSeconds()<<endl;
							}
							else
							{
								//cout<<"Node "<<j<<"remains busy "<<Now().GetSeconds()<<endl;
							}
						}
					}
					
				}
			}
			
			
			if((linklifetimeMatrix_dsrc[receiver_id][i]) > 0.0)
			{
				if(busy == true)
				{
					txop_inst[f].busy[arguments.channel][i] = busy;
					txop_inst[f].last_set_timestamp[arguments.channel][i] = Seconds(Now().GetSeconds());
					//cout<<"Set node "<<i<<"as busy at "<<Now().GetSeconds()<<endl;
					for(uint32_t j=0;j<total_size;j++)
					{
						if((linklifetimeMatrix_dsrc[i][j]) > 0.0)
						{
							txop_inst[f].busy[arguments.channel][j] = busy;
							txop_inst[f].last_set_timestamp[arguments.channel][j] = Seconds(Now().GetSeconds());
							//cout<<"Set node "<<j<<"as busy at "<<Now().GetSeconds()<<endl;
						}
					}
				}
				else
				{
					Time diff = Seconds(Now().GetSeconds())-txop_inst[f].last_set_timestamp[arguments.channel][i];
					if(diff > Seconds(tg))
					{
						txop_inst[f].busy[arguments.channel][i] = busy;
						//cout<<"Set node "<<i<<"as free at "<<Now().GetSeconds()<<endl;
					}
					else
					{
						//cout<<"Node "<<i<<"remains busy "<<Now().GetSeconds()<<endl;
					}
					
					for(uint32_t j=0;j<total_size;j++)
					{
						if((linklifetimeMatrix_dsrc[i][j]) > 0.0)
						{
							Time diff_inner = Seconds(Now().GetSeconds())-txop_inst[f].last_set_timestamp[arguments.channel][j];
							if(diff_inner > Seconds(tg))
							{
								txop_inst[f].busy[arguments.channel][j] = busy;
								//cout<<"Set node "<<j<<"as free at "<<Now().GetSeconds()<<endl;
							}
							else
							{
								//cout<<"Node "<<j<<"remains busy "<<Now().GetSeconds()<<endl;
							}
						}
					}
					
				}
			}
		}
	}
	txop_inst[fid].pending_packets[arguments.channel][nodeid] = pending_packets;
}

void updateTxop_self(uint32_t fid, uint32_t nodeid, uint32_t pending_packets, bool busy, struct custom_struct arguments)
{
	uint32_t zeta = 1;
	double tg = compute_individual_link_delay(0, arguments.CW, 1, flow_packet_size, 1, zeta);
	for(uint32_t f=0;f<2*flows;f++)
	{	
		if(busy == true)
		{
			txop_inst[f].busy[arguments.channel][nodeid] = busy;
			txop_inst[f].last_set_timestamp[arguments.channel][nodeid] = Seconds(Now().GetSeconds());
			//cout<<"Set node "<<nodeid<<"as busy at "<<Now().GetSeconds()<<endl;
		}
		else
		{
			Time diff = Seconds(Now().GetSeconds())-txop_inst[f].last_set_timestamp[arguments.channel][nodeid];
			if(diff > Seconds(tg))
			{
				txop_inst[f].busy[arguments.channel][nodeid] = busy;
				//cout<<"Set node "<<nodeid<<"as free at "<<Now().GetSeconds()<<endl;
			}
			else
			{
				//cout<<"Node "<<nodeid<<"remains busy "<<Now().GetSeconds()<<endl;
			}
		}
	}
	txop_inst[fid].pending_packets[arguments.channel][nodeid] = pending_packets;
}

uint32_t destination_counter[2*flows];
vector<vector<vector<tuple<double,uint32_t,uint32_t>>>> all_sorted_delta_next_hop_flow_size;

struct packet_delivery
{
	bool pending[185][Flow_size+2];
	bool delivery[185][Flow_size+2];
	uint32_t attempts[185][Flow_size+2];
};

struct pd_all
{
	struct packet_delivery pd_inst[total_size];
};

struct pd_all pd_all_inst[2*flows];

bool retransmitted [2*flows][total_size][Flow_size+2];
uint32_t s_flow_counter[2*flows][total_size][Flow_size+2];





void check_delivery_and_retransmit(uint32_t flow_id, uint32_t packet_id, uint32_t hop, uint32_t current_hop, Time originail_timestamp, struct custom_struct arguments)
{
	double diff = Now().GetSeconds() - flow_initiation_time;
	arguments.CW = pd_all_inst[flow_id].pd_inst[hop].attempts[arguments.channel][packet_id] + 2;
	if(diff > 0.90)
	{
		cout<<"Retransmission packet dropped for flow id "<<flow_id<<"packet ID: "<< packet_id<<endl;
		pd_all_inst[flow_id].pd_inst[current_hop].pending[arguments.channel][packet_id] = false;
	}
	else
	{
		srand(packet_id+hop+current_hop+Now().GetMicroSeconds());
		double rand_delay = 0.000010*(rand()%100);
		if(pd_all_inst[flow_id].pd_inst[hop].delivery[arguments.channel][packet_id] == true)
		{
			retransmitted[flow_id][hop][packet_id] = false;
			pd_all_inst[flow_id].pd_inst[current_hop].pending[arguments.channel][packet_id] = false;
			//cout<<"packet has been delivered. Retransmission success"<<" in flow ID "<<flow_id<<" packet ID "<<packet_id<<" from "<<current_hop<<" to next hop "<<hop<<"at time "<<Now().GetSeconds()<<endl;
			Simulator::Schedule (Seconds (0.0), updateTxop, flow_id, current_hop, hop, packet_id, false, arguments);
			//do nothing
		}
		else
		{
			
			bool pending_lower_ids = false;
			double pending_count = 0;
			for(uint32_t i=0;i<Flow_size+1;i++)
			{
				if (i< packet_id)
				{
					pending_lower_ids = pd_all_inst[flow_id].pd_inst[current_hop].pending[arguments.channel][i] | pending_lower_ids;
					pending_count++;
				}
			
			}
			if((pending_lower_ids==true) && (pending_count>0))
			{
				//cout<<"Retransmission pending for flow id "<<flow_id<<"packet ID: "<< packet_id<<endl;
				Simulator::Schedule (Seconds (0.0), updateTxop, flow_id, current_hop, hop, packet_id, false, arguments);
				Simulator::Schedule (Seconds (0.000100+rand_delay), check_delivery_and_retransmit, flow_id, packet_id, hop, current_hop, originail_timestamp, arguments);
			}		
			
			else
			{
				
				bool neighborhood_busy = false;
				for(uint32_t i=0;i<total_size;i++)
				{
					if((linklifetimeMatrix_dsrc[current_hop][i]) > 0.0)
					{
						neighborhood_busy = neighborhood_busy | txop_inst[flow_id].busy[arguments.channel][i];	
						for(uint32_t j=0;j<total_size;j++)
						{
							if((linklifetimeMatrix_dsrc[i][j]) > 0.0)
							{
								neighborhood_busy = neighborhood_busy | txop_inst[flow_id].busy[arguments.channel][j];
							}
						}
					}
				}
				if(neighborhood_busy == true)
				//if(txop_inst[flow_id].busy[hop] == true)
				{
					//cout<<"Retransmission attempt in flow ID "<<flow_id<<"packet ID "<< packet_id<<" at hop "<<current_hop<<". Receiver or its is neighborhood busy. Waiting for 100 Micro senconds until free"<<endl;
					Simulator::Schedule (Seconds (0.0), updateTxop, flow_id, current_hop, hop, packet_id, false,arguments);
					Simulator::Schedule (Seconds (0.000100+rand_delay), check_delivery_and_retransmit, flow_id, packet_id, hop, current_hop, originail_timestamp, arguments);
				}
				
				else
				{	
				
					if(pd_all_inst[flow_id].pd_inst[hop].attempts[arguments.channel][packet_id] < (B_max))
					{
						uint32_t zeta = 1;
						double tg = compute_individual_link_delay(0, pd_all_inst[flow_id].pd_inst[hop].attempts[arguments.channel][packet_id] + 2, 1, flow_packet_size, 1, zeta);
						//cout<<"retransmitting"<<endl;
						uint16_t protocolwave = 0x88dc;
						Ptr <NetDevice> current_nd = wifidevices.Get(current_hop);
					
						Ptr <Packet> packet_i = Create<Packet> (arguments.p_size-28);
						CustomDataUnicastTag_ModifiedRouting tag;
						tag.SetchannelId(arguments.channel);
						tag.SetflowId(flow_id);
						tag.SetpacketId(packet_id);
						tag.Setprevious_senderId(current_hop);
						tag.Setprevious_timestamp(MicroSeconds(Now().GetMicroSeconds()));
						tag.Setoriginal_timestamp(originail_timestamp);
						packet_i->AddPacketTag(tag);
						
						Ptr <NetDevice> destination_nd = wifidevices.Get(hop);

						Simulator::Schedule (Seconds (0.0), updateTxop, flow_id, current_hop, hop, packet_id, true, arguments);
						switch(arguments.channel)
						{
							case(172):
								current_nd = wifidevices_172.Get(current_hop);
								destination_nd = wifidevices_172.Get(hop);
								break;
							case(174):
								current_nd = wifidevices_174.Get(current_hop);
								destination_nd = wifidevices_174.Get(hop);
								break;
							case(176):
								current_nd = wifidevices_176.Get(current_hop);
								destination_nd = wifidevices_176.Get(hop);
								break;
							case(178):
								current_nd = wifidevices.Get(current_hop);
								destination_nd = wifidevices.Get(hop);
								break;
							case(180):
								current_nd = wifidevices_180.Get(current_hop);
								destination_nd = wifidevices_180.Get(hop);
								break;
							case(182):
								current_nd = wifidevices_182.Get(current_hop);
								destination_nd = wifidevices_182.Get(hop);
								break;
							case(184):
								current_nd = wifidevices_184.Get(current_hop);
								destination_nd = wifidevices_184.Get(hop);
								break;
							default:
								break;
						}
						Address addr = destination_nd->GetAddress();
						Mac48Address dest_address = Mac48Address::ConvertFrom(addr);
						Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (current_nd);
						Simulator::Schedule (Seconds(0.0), &WifiNetDevice::Send, wdi, packet_i, dest_address, protocolwave);
						//cout<<"This is flow ID "<<flow_id<<"Re-transmitting attempt of packet ID "<<packet_id<<" from "<<current_hop<<" to next hop "<<hop<<"at time "<<Now().GetSeconds()<<endl;
						Simulator::Schedule (Seconds (tg+0.000100+rand_delay), check_delivery_and_retransmit, flow_id, packet_id, hop, current_hop, originail_timestamp, arguments);
						//Simulator::Schedule (Seconds (tg), updateTxop, flow_id, current_hop, hop, packet_id, false,arguments.channel);
						sent_IDS[flow_id][current_hop][packet_id] = true;
						routing_packet_general_initial_timestamp[flow_id][current_hop][packet_id] = Now().GetSeconds();
						retransmitted[flow_id][hop][packet_id] = true;
						s_flow_counter[flow_id][hop][packet_id]++;
						pd_all_inst[flow_id].pd_inst[hop].attempts[arguments.channel][packet_id]++;
						
					//*subflow_counter = *subflow_counter + 1;
					//retransmit
					}
					else
					{
						cout<<"Retransmission packet dropped for flow id "<<flow_id<<"packet ID: "<< packet_id<<endl;
						pd_all_inst[flow_id].pd_inst[current_hop].pending[arguments.channel][packet_id] = false;
					
					}
				}
			}
		}
	}		
}

void MacRx (std::string context, Ptr <const Packet> pkt)
{
	//context will include info about the source of this event. Use string manipulation if you want to extract info.
	//std::cout <<  context << std::endl;
	//cout<<context[10]<<endl;
	//Print the info.
	
	/*
	std::cout << "\t total packet Size=" << pkt->GetSerializedSize()
			  << " Freq="<<channelFreqMhz
			  << " Mode=" << txVector.GetMode()
			  << " Signal=" << signalNoise.signal
			  << " Noise=" << signalNoise.noise << std::endl;
	*/
	
	//int x = int (channelFreqMhz);
	//int y = int (staId);
	//std::cout << x << "+" << y << "=" << apb.Func(x, y) << std::endl;
	//We can also examine the WifiMacHeader
	
	uint32_t destination_node_id;
	//if (!((paper == 1) && (architecture == 1)))
	//{
		//cout<<"Rx";
		string casted_context = context;
		int n = casted_context.length();
		char char_array[n+1];
		strcpy(char_array, casted_context.c_str());
		string str = "/";
		int l = str.length();
		char test_char[l+1];
		strcpy(test_char,str.c_str());
		//cout<<"raw character array is "<<context[10]<<context[11]<<context[12];
		if((char_array[11] == test_char[0]) and (char_array[12] == test_char[0]))
		{
			stringstream ss;
			ss << char_array[10];
			ss >> destination_node_id;
			//cout<<"testing "<<destination_node_id;
		}
		else if(char_array[12] == test_char[0])
		{	
			stringstream ss;
			string mystr;
			mystr += mystr + char_array[10];
			mystr +=  char_array[11];
			ss << mystr;
			ss >> destination_node_id;
			//cout<<"testing "<<destination_node_id;
		}
		else
		{
			stringstream ss;
			string mystr;
			mystr += mystr + char_array[10];
			mystr +=  char_array[11];
			mystr +=  char_array[12];
			ss << mystr;
			ss >> destination_node_id;
			//cout<<"testing "<<destination_node_id;
		}
		
		if ((destination_node_id > (total_size+1)) or (destination_node_id < 2))
		{
			cout<<"invalid conversion. setting default value to 2"<<endl;
			destination_node_id = 2;
		}
		//cout<<"Converted destination node id is "<<destination_node_id;		
		dsrc_final_timestamp = Simulator::Now().GetSeconds();
		dsrc_total_received_packets = dsrc_total_received_packets + 1.0;
		if (paper == 1)
		{
			dsrc_total_packet_size = dsrc_total_packet_size + pkt->GetSerializedSize();
		}
	//}
	
		CustomDataUnicastTag_ModifiedRouting tagmodified_routing;
		if(pkt->PeekPacketTag(tagmodified_routing))
		{		
			//cout<<"transmiiting a a packet at "<<Now().GetMilliSeconds()<<endl;
			//uint32_t nid = source_node->GetId();
			
			
			uint32_t current_hop = destination_node_id -2;
			uint32_t fid = tagmodified_routing.GetflowId();
			uint32_t packet_ID = tagmodified_routing.GetpacketId();
			uint32_t channel = tagmodified_routing.GetchannelId();
			
			//cout<<"Received at hop "<<current_hop<<"packet id "<<packet_ID<<"flow ID"<<fid<<"at time "<<Now().GetSeconds()<<endl;
			
			//uint32_t previous_sender_ID = tagmodified_routing.Getprevious_senderId();
			Time previous_timestamp = tagmodified_routing.Getprevious_timestamp();
			Time originail_timestamp = tagmodified_routing.Getoriginal_timestamp();
			//cout<<previous_sender_ID<<endl;
			
			//uint32_t packets = txop_inst[fid].pending_packets[previous_sender_ID];
			//updateTxop(fid, previous_sender_ID, packets, false);
			
			uint32_t destination =  (delta_at_nodes_inst+fid)->destination_f;
			if(pd_all_inst[fid].pd_inst[current_hop].delivery[channel][packet_ID] == false)
			{
				pd_all_inst[fid].pd_inst[current_hop].delivery[channel][packet_ID] = true;
				
				if(destination == current_hop)
				{
					destination_counter[fid]++;
					routing_packet_final_timestamp[fid][packet_ID] = Now().GetSeconds();
					routing_packet_general_final_timestamp[fid][current_hop][packet_ID] = Now().GetSeconds();
					cout<<"Flow ID "<<fid<<"received "<<" Packet ID: "<<packet_ID<<"Totally received "<<destination_counter[fid]<<"packets at destination "<<destination<<" at "<<Now().GetSeconds()<<endl;
				}
				else
				{
					routing_packet_general_final_timestamp[fid][current_hop][packet_ID] = Now().GetSeconds();
					pd_all_inst[fid].pd_inst[current_hop].pending[channel][packet_ID] = true;
					//uint32_t f_size = (demanding_flow_struct_nodes_inst+fid)->f_size;
					uint32_t p_size = (demanding_flow_struct_nodes_inst+fid)->p_size;
					struct custom_struct arguments;
					arguments.p_size = p_size;
					arguments.channel = channel;
					//double total_load = (load_at_nodes+fid)->load_f[current_hop];
					//uint32_t total_packets = ceil(total_load*f_size);
					
					//bool busy_current;
				  	uint32_t pending_packets = txop_inst[fid].pending_packets[channel][current_hop];
				  	//uint32_t pending_packets_copy = txop_inst[fid].pending_packets[current_hop];
					/*
					for(uint32_t f=0;f<2*flows;f++)
					{
						busy_current = txop_inst[f].busy[current_hop];
					}
					*/
					pending_packets++;
					arguments.CW = pd_all_inst[fid].pd_inst[current_hop].attempts[arguments.channel][packet_ID] + 2;
					updateTxop_self(fid, current_hop, pending_packets, false, arguments);
					//Modify tag
					//Ptr <Packet> packet_i = Create<Packet> (packet_size-28);
					//packet_i->AddPacketTag(tagmodified_routing);
					//cout<<"next hop is "<< next_hop_id <<endl;
									
					

				  	Ptr <NetDevice> current_nd = wifidevices.Get(current_hop);
					Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (current_nd);
					//Ptr <Node> ni = DynamicCast <Node> (source_node);				

					
					//double tg = compute_link_delay(current_hop, 1.0, 1, p_size, destination);
					//cout<<"Time gap is "<<tg<<endl;
					//double subflow_start_time = 0.0;
					uint32_t total_packet_counter = 0;
					
					
					auto index_top = all_sorted_delta_next_hop_flow_size.begin();
					advance(index_top,fid);
					//cout<<subflow_start_time<<total_packet_counter<<total_packets<<endl;

					auto index_middle = index_top->begin();
					advance(index_middle,current_hop);
					bool sent = false;
					//bool queued = false;
					while (sent == false)
					{
						if (routing_algorithm == 1)
						{
							list<uint32_t> indices;
							for(uint32_t j =0;j<total_size;j++)
							{
								auto index_innermost = index_middle->begin();
								//cout<<subflow_start_time<<total_packet_counter<<total_packets<<endl;
								advance(index_innermost,j);
								double sub_flow_load; 
								uint32_t nid;
								uint32_t sub_flow_packets;
								tie(sub_flow_load, nid, sub_flow_packets) = *index_innermost;
								//cout<<"sub flow load is "<<sub_flow_load<<" next hop "<<nid<<"packets "<<sub_flow_packets<<endl;		
								//uint32_t sub_flow_counter = 0;
								//cout<<sub_flow_counter<<endl;
								
								if(sub_flow_load !=0.0)
								{	
									indices.push_back(j);
								}
							}
							
							uint32_t rand_index = 0;
							if (indices.size() > 0)
							{
								rand_index = rand()%(indices.size());
							}
							else
							{
								sent =true;
							}
							//cout<<"size of indices is "<<indices.size()<<"random index is "<<rand_index<<endl;;
							auto index_list = indices.begin();
							advance(index_list, rand_index);
							uint32_t index = *index_list;
							//cout<<"index is "<<index<<endl;
							auto index_innermost = index_middle->begin();
							//cout<<subflow_start_time<<total_packet_counter<<total_packets<<endl;
							advance(index_innermost,index);
							double sub_flow_load; 
							uint32_t nid;
							uint32_t sub_flow_packets;
							tie(sub_flow_load, nid, sub_flow_packets) = *index_innermost;
							//cout<<"sub flow load is "<<sub_flow_load<<" next hop "<<nid<<"packets "<<sub_flow_packets<<endl;		
							uint32_t sub_flow_counter = 0;
							//cout<<sub_flow_counter<<endl;
							//cout<<"sub flow packets is "<<sub_flow_packets<<endl;
								
							if(sub_flow_load>0.0)
							{	
								
								uint32_t updated_packet_ID = packet_ID;
								//cout<<"updated packet ID is "<<updated_packet_ID<<endl;
								Simulator::Schedule (Seconds (0.0), check_delivery_and_retransmit, fid, updated_packet_ID, nid, current_hop, originail_timestamp, arguments);
								sub_flow_counter++;
								total_packet_counter++;
								if(get<2>(*index_innermost) > 0)
								{
									get<2>(*index_innermost) = get<2>(*index_innermost) - 1;	
								}					
								sent = true;
							}
						}
						else
						{
							for(uint32_t j =0;j<total_size;j++)
							{
								//cout<<"value of j is "<<j<<endl;
								auto index_innermost = index_middle->begin();
								//cout<<subflow_start_time<<total_packet_counter<<total_packets<<endl;
								advance(index_innermost,j);
								double sub_flow_load; 
								uint32_t nid;
								uint32_t sub_flow_packets;
								tie(sub_flow_load, nid, sub_flow_packets) = *index_innermost;
								//cout<<"sub flow load is "<<sub_flow_load<<" next hop "<<nid<<"packets "<<sub_flow_packets<<endl;		
								uint32_t sub_flow_counter = 0;
								//cout<<sub_flow_counter<<endl;
									
								if((sub_flow_packets>0) | (j==(total_size-1)))
								{	
									//cout<<"sub flow packet size is "<<sub_flow_packets<<endl;
									//Ptr <NetDevice> destination_nd = wifidevices.Get(nid);
									//Address addr = destination_nd->GetAddress();
									//Mac48Address dest_address = Mac48Address::ConvertFrom(addr);
									//cout <<endl<<"MAC address of next hop node "<<next_hop<<" is "<<dest_address<<endl;
					  				//uint16_t protocolwave = 0x88dc;
									
									/*
									bool busy_next;
									for(uint32_t f=0;f<2*flows;f++)
									{
										busy_next = txop_inst[f].busy[nid];
									}
									if(busy_next==true)
									{
										cout<<"Next Hop is busy. Queuing packet"<<endl;
										queued = true;
									}
									*/
									//else
									//{
										//for(uint32_t i=0;i<pending_packets;i++)
										//{
											/*
											Ptr <Packet> packet_i = Create<Packet> (p_size-28);
											CustomDataUnicastTag_ModifiedRouting tag;
											tag.SetflowId(fid);
											
											tag.SetpacketId(updated_packet_ID);
											tag.Setprevious_senderId(current_hop);
											tag.Setprevious_timestamp(MicroSeconds(Now().GetMicroSeconds()));
											tag.Setoriginal_timestamp(originail_timestamp);
											packet_i->AddPacketTag(tag);
											*/
											//uint32_t updated_packet_ID = packet_ID-pending_packets_copy+sub_flow_counter;
											uint32_t updated_packet_ID = packet_ID;
											//cout<<"updated packet ID is "<<updated_packet_ID<<endl;
											//Simulator::Schedule (Seconds (0.0), updateTxop, fid, current_hop, nid, pending_packets, true, arguements.channel);
											//cout<<"This is flow ID "<<fid<<"Re-transmission attempt 1 packet ID "<<updated_packet_ID<<" from "<<current_hop<<" to next hop "<<nid<<"at time "<<Now().GetSeconds()<<endl;
											//Simulator::Schedule (Seconds ((tg/1.0)*(sub_flow_counter)), &WifiNetDevice::Send, wdi, packet_i, dest_address, protocolwave);						
											//Simulator::Schedule (Seconds ((tg/1.0)*(sub_flow_counter)), check_delivery_and_retransmit, fid, updated_packet_ID, nid, current_hop, p_size, originail_timestamp);
											Simulator::Schedule (Seconds (0.0), check_delivery_and_retransmit, fid, updated_packet_ID, nid, current_hop, originail_timestamp, arguments);
											
											/*		
											if (retransmitted[fid][nid][updated_packet_ID] == true)
											{
												cout<<"incrementing counter due to retransmission"<<endl;
												sub_flow_counter = sub_flow_counter + s_flow_counter[fid][nid][updated_packet_ID];
											}
											*/
											//pending_packets--;
											sub_flow_counter++;
											total_packet_counter++;
											if(get<2>(*index_innermost) > 0)
											{
												get<2>(*index_innermost) = get<2>(*index_innermost) - 1;	
											}				
										//}
										//Simulator::Schedule (Seconds ((tg/0.99)*(sub_flow_counter)),updateTxop, fid, current_hop, nid, pending_packets, false, arguments.channel);
										sent = true;
									//}	
								}
								//subflow_start_time = (tg*total_packet_counter);
							}
						}
					}
					//uint32_t nid = uint32_t(ni->GetId());
					//dsrc_packet_initial_timestamp[nid] = Simulator::Now().GetSeconds();
					//Time ti = Seconds(Simulator::Now().GetSeconds());
					//Ptr <Packet> packet_i = Create<Packet> (packet_size-28);;

					//dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
					//dsrc_final_timestamp = Simulator::Now().GetSeconds();
					//dsrc_total_received_packets = dsrc_total_received_packets + 1.0;
					

				}
			}
			else
			{
				//cout<<"Duplicate packet "<<packet_ID<<" for flow id "<<fid<<" received at hop "<<current_hop<<endl;
			
			}
	}
	
	
	CustomDataUnicastTag_Routing tag_routing;
	
	

	if(pkt->PeekPacketTag(tag_routing))
	{
		uint32_t node_index = tag_routing.GetsenderId();
		uint32_t destination = tag_routing.GetdestinationId() + 2;
		uint32_t * source = tag_routing.GetNodeId();
		if (architecture == 1)
		{
			cout<<"packet from "<<*source -2<<"with destination "<<destination -4<<"now at "<<destination_node_id -2<<endl;
		}
		if (!((paper == 1) && (architecture == 1)))
		{
			Y[*source - 2] = Y[*source - 2] - 1;
			packets_received_wl[*source - 2] = packets_received_wl[*source - 2] + 1;
			double delay = Now().GetMicroSeconds()-tag_routing.GetTimestamp()->GetMicroSeconds();
			one_hop_delay_training_wl[*source - 2] = one_hop_delay_training_wl[*source - 2] + delay;
			cout<<"1-hop delay wireless is "<<delay<<endl;
			
			if (destination_node_id != destination)
			{
				//uint32_t next_hop = routing_tables[destination_node_id -2].rows[destination-2].next_hop;
				uint32_t next_hop = find_next_hop(node_index,destination-2,destination_node_id -2);
				cout<<endl<<"next hop from routing table is "<< next_hop <<endl;
				if (next_hop == (*source -2))
				{
					cout<<"routing loop. stopping routing"<<endl;
				}
				else if (next_hop < total_size)
				{
					Ptr <Packet> packet_i = Create<Packet> (packet_additional_size);
					tag_routing.SetNodeId(&destination_node_id);
					Time ti = MicroSeconds(Simulator::Now().GetMicroSeconds());
					tag_routing.SetTimestamp(&ti);
					packet_i->AddPacketTag(tag_routing);
					
					if (((destination_node_id-2) > N_Vehicles) && (next_hop > N_Vehicles))
					{
						Ptr <Node> nu = DynamicCast <Node> (RSU_Nodes.Get(destination_node_id-2-N_Vehicles));	
				  		Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (RSU_apps.Get(destination_node_id-2-N_Vehicles));
				  		cout<<"Ethernet data Unicasting from node "<<destination_node_id - 2<<endl;
						Simulator::Schedule(Seconds(0),RSU_routing_dataunicast_alone, udp_app, nu, RSU_Nodes.Get(next_hop-N_Vehicles),packet_i);
					}
					
					else
					{
						Ptr <NetDevice> destination_nd = wifidevices.Get(next_hop);
						Address addr = destination_nd->GetAddress();
						Mac48Address dest_address = Mac48Address::ConvertFrom(addr);
						//cout <<endl<<"MAC address of next hop node "<<next_hop<<" is "<<dest_address<<endl;
					  	uint16_t protocolwave = 0x88dc;//
						Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (wifidevices.Get(destination_node_id -2));
						cout<<"DSRC data Unicasting from node "<<destination_node_id - 2<<endl;
						dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
						Simulator::Schedule (Seconds(0.000000) , &WifiNetDevice::Send, wdi, packet_i, dest_address, protocolwave);
					}
					
					
					Y[destination_node_id - 2] = Y[destination_node_id - 2] + 1;	
					//cout<<"dsrc total size is "<<dsrc_total_packet_size<<endl;
					
				}
			}
			if (destination_node_id == destination)
			{
				cout<<"packet successfully delivered to destination node"<<destination_node_id - 2<<endl;
				dsrc_packet_final_timestamp[node_index+2] = Simulator::Now().GetSeconds();
				std::cout << "Received data unicasted packet from "<< tag_routing.GetsenderId()<<"to node "<<destination_node_id -2 <<"of size "<<tag_routing.GetSerializedSize()<<" at position "<< *tag_routing.Getposition()<<"with velocity "<<*tag_routing.Getvelocity()<<"with acceleration "<<*tag_routing.Getacceleration()<<"packet timestamp "<< tag_routing.GetTimestamp()->GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tag_routing.GetTimestamp()->GetMicroSeconds()<<"us"<<std::endl;
			}
		}
	}	
	//pkt->RemoveAtEnd(1000);
	//pkt->RemoveAllPacketTags();
}



void Rx (std::string context, Ptr <const Packet> pkt, uint16_t channelFreqMhz,  WifiTxVector txVector,MpduInfo aMpdu, SignalNoiseDbm signalNoise, uint16_t staId)
{
	//context will include info about the source of this event. Use string manipulation if you want to extract info.
	//std::cout <<  context << std::endl;
	//cout<<context[10]<<endl;
	//Print the info.
	
	/*
	std::cout << "\t total packet Size=" << pkt->GetSerializedSize()
			  << " Freq="<<channelFreqMhz
			  << " Mode=" << txVector.GetMode()
			  << " Signal=" << signalNoise.signal
			  << " Noise=" << signalNoise.noise << std::endl;
	*/
	
	
	//int x = int (channelFreqMhz);
	//int y = int (staId);
	//std::cout << x << "+" << y << "=" << apb.Func(x, y) << std::endl;
	//We can also examine the WifiMacHeader
	
	bool routing_packet_present = false;
	CustomDataUnicastTag_Routing tag_routing;
	routing_packet_present = pkt->PeekPacketTag(tag_routing);

	int destination_node_id;
	if (!((paper == 1) && (architecture == 1)))
	{
		if(!routing_packet_present)
		{
			//cout<<"Rx";
			string casted_context = context;
			int n = casted_context.length();
			char char_array[n+1];
			strcpy(char_array, casted_context.c_str());
			string str = "/";
			int l = str.length();
			char test_char[l+1];
			strcpy(test_char,str.c_str());
			//cout<<"raw character array is "<<context[10]<<context[11]<<context[12];
			if((char_array[11] == test_char[0]) and (char_array[12] == test_char[0]))
			{
				stringstream ss;
				ss << char_array[10];
				ss >> destination_node_id;
				//cout<<"testing "<<destination_node_id;
			}
			else if(char_array[12] == test_char[0])
			{	
				stringstream ss;
				string mystr;
				mystr += mystr + char_array[10];
				mystr +=  char_array[11];
				ss << mystr;
				ss >> destination_node_id;
				//cout<<"testing "<<destination_node_id;
			}
			else
			{
				stringstream ss;
				string mystr;
				mystr += mystr + char_array[10];
				mystr +=  char_array[11];
				mystr +=  char_array[12];
				ss << mystr;
				ss >> destination_node_id;
				//cout<<"testing "<<destination_node_id;
			}
			
			if ((destination_node_id > (total_size+1)) or (destination_node_id < 2))
			{
				cout<<"invalid conversion. setting default value to 2"<<endl;
				destination_node_id = 2;
			}
			//cout<<"Converted destination node id is "<<destination_node_id;
			
			/*
			WifiMacHeader hdr;
			if (pkt->PeekHeader(hdr))
			{
				//std::cout << "\tDestination MAC : " << hdr.GetAddr1() << "\tSource MAC : " << hdr.GetAddr2()<<"size: "<<hdr.GetSize() << std::endl;
				cout<<"wifi mac header "<<hdr.GetSize() <<endl;
			}
			
			WifiActionHeader hdr2;
			if (pkt->PeekHeader(hdr2))
			{
				//std::cout << "\tDestination MAC : " << hdr.GetAddr1() << "\tSource MAC : " << hdr.GetAddr2()<<"size: "<<hdr.GetSize() << std::endl;
				cout<<"wifi action header "<<hdr2.GetSerializedSize() <<endl;
			}
			
			OfdmPpdu::LSigHeader hdr5;
			if (pkt->PeekHeader(hdr5))
			{
				//std::cout << "\tDestination MAC : " << hdr.GetAddr1() << "\tSource MAC : " << hdr.GetAddr2()<<"size: "<<hdr.GetSize() << std::endl;
				cout<<"wifi ofdm header "<<hdr5.GetSerializedSize() <<endl;
			}
			
			GenericMacHeader hdr6;
			if (pkt->PeekHeader(hdr6))
			{
				//std::cout << "\tDestination MAC : " << hdr.GetAddr1() << "\tSource MAC : " << hdr.GetAddr2()<<"size: "<<hdr.GetSize() << std::endl;
				cout<<"wifi generic mac header "<<hdr6.GetSerializedSize() <<endl;
			}
			
			TcpHeader hdr3;
			if (pkt->PeekHeader(hdr3))
			{
				//std::cout << "\tDestination MAC : " << hdr.GetAddr1() << "\tSource MAC : " << hdr.GetAddr2()<<"size: "<<hdr.GetSize() << std::endl;
				cout<<"wifi tcp header "<<hdr3.GetSerializedSize() <<endl;
			}
			
			UdpHeader hdr4;
			if (pkt->PeekHeader(hdr4))
			{
				//std::cout << "\tDestination MAC : " << hdr.GetAddr1() << "\tSource MAC : " << hdr.GetAddr2()<<"size: "<<hdr.GetSize() << std::endl;
				cout<<"wifi udp header "<<hdr4.GetSerializedSize() <<endl;
			}
			*/
			
			dsrc_final_timestamp = Simulator::Now().GetSeconds();
			dsrc_total_received_packets = dsrc_total_received_packets + 1.0;
		}
	}
	
		

	
	CustomDataTag tag;
	if(pkt->PeekPacketTag(tag))
	{
		if (experiment_number == 5)
		{
			max_distance[tag.GetNodeId()] = tag.GetPosition().x;
		}
		if (paper == 0)
		{
			dsrc_packet_final_timestamp[tag.GetNodeId()] = Simulator::Now().GetSeconds();
		}
		add_neighbor_info(neighbordata_inst+destination_node_id,tag.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tag.GetPosition(), tag.GetVelocity(), tag.GetAcceleration(), tag.GetNodeId(), empty_neighborset, 0);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tag.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tag.GetSerializedSize()<<" at position "<< tag.GetPosition()<<"with velocity "<<tag.GetVelocity()<<"with acceleration "<<tag.GetAcceleration()<<"packet timestamp "<< tag.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tag.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag1 tagd1;
	if(pkt->PeekPacketTag(tagd1))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd1.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd1.GetPosition(), tagd1.GetVelocity(), tagd1.GetAcceleration(), tagd1.GetNodeId(), tagd1.GetNeighborids(), 1);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd1.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd1.GetSerializedSize()<<" at position "<< tagd1.GetPosition()<<"with velocity "<<tagd1.GetVelocity()<<"with acceleration "<<tagd1.GetAcceleration()<<"packet timestamp "<< tagd1.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd1.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag2 tagd2;
	if(pkt->PeekPacketTag(tagd2))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd2.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd2.GetPosition(), tagd2.GetVelocity(), tagd2.GetAcceleration(), tagd2.GetNodeId(), tagd2.GetNeighborids(), 2);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd2.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd2.GetSerializedSize()<<" at position "<< tagd2.GetPosition()<<"with velocity "<<tagd2.GetVelocity()<<"with acceleration "<<tagd2.GetAcceleration()<<"packet timestamp "<< tagd2.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd2.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag3 tagd3;
	if(pkt->PeekPacketTag(tagd3))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd3.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd3.GetPosition(), tagd3.GetVelocity(), tagd3.GetAcceleration(), tagd3.GetNodeId(), tagd3.GetNeighborids(), 3);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd3.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd3.GetSerializedSize()<<" at position "<< tagd3.GetPosition()<<"with velocity "<<tagd3.GetVelocity()<<"with acceleration "<<tagd3.GetAcceleration()<<"packet timestamp "<< tagd3.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd3.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag4 tagd4;
	if(pkt->PeekPacketTag(tagd4))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd4.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd4.GetPosition(), tagd4.GetVelocity(), tagd4.GetAcceleration(), tagd4.GetNodeId(), tagd4.GetNeighborids(), 4);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd4.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd4.GetSerializedSize()<<" at position "<< tagd4.GetPosition()<<"with velocity "<<tagd4.GetVelocity()<<"with acceleration "<<tagd4.GetAcceleration()<<"packet timestamp "<< tagd4.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd4.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag5 tagd5;
	if(pkt->PeekPacketTag(tagd5))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd5.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd5.GetPosition(), tagd5.GetVelocity(), tagd5.GetAcceleration(), tagd5.GetNodeId(), tagd5.GetNeighborids(), 5);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd5.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd5.GetSerializedSize()<<" at position "<< tagd5.GetPosition()<<"with velocity "<<tagd5.GetVelocity()<<"with acceleration "<<tagd5.GetAcceleration()<<"packet timestamp "<< tagd5.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd5.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag6 tagd6;
	if(pkt->PeekPacketTag(tagd6))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd6.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd6.GetPosition(), tagd6.GetVelocity(), tagd6.GetAcceleration(), tagd6.GetNodeId(), tagd6.GetNeighborids(), 6);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd6.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd6.GetSerializedSize()<<" at position "<< tagd6.GetPosition()<<"with velocity "<<tagd6.GetVelocity()<<"with acceleration "<<tagd6.GetAcceleration()<<"packet timestamp "<< tagd6.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd6.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag7 tagd7;
	if(pkt->PeekPacketTag(tagd7))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd7.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd7.GetPosition(), tagd7.GetVelocity(), tagd7.GetAcceleration(), tagd7.GetNodeId(), tagd7.GetNeighborids(), 7);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd7.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd7.GetSerializedSize()<<" at position "<< tagd7.GetPosition()<<"with velocity "<<tagd7.GetVelocity()<<"with acceleration "<<tagd7.GetAcceleration()<<"packet timestamp "<< tagd7.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd7.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	
	CustomDataTag8 tagd8;
	if(pkt->PeekPacketTag(tagd8))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd8.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd8.GetPosition(), tagd8.GetVelocity(), tagd8.GetAcceleration(), tagd8.GetNodeId(), tagd8.GetNeighborids(), 8);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd8.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd8.GetSerializedSize()<<" at position "<< tagd8.GetPosition()<<"with velocity "<<tagd8.GetVelocity()<<"with acceleration "<<tagd8.GetAcceleration()<<"packet timestamp "<< tagd8.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd8.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag9 tagd9;
	if(pkt->PeekPacketTag(tagd9))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd9.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd9.GetPosition(), tagd9.GetVelocity(), tagd9.GetAcceleration(), tagd9.GetNodeId(), tagd9.GetNeighborids(), 9);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd9.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd9.GetSerializedSize()<<" at position "<< tagd9.GetPosition()<<"with velocity "<<tagd9.GetVelocity()<<"with acceleration "<<tagd9.GetAcceleration()<<"packet timestamp "<< tagd9.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd9.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag10 tagd10;
	if(pkt->PeekPacketTag(tagd10))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd10.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd10.GetPosition(), tagd10.GetVelocity(), tagd10.GetAcceleration(), tagd10.GetNodeId(), tagd10.GetNeighborids(), 10);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd10.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd10.GetSerializedSize()<<" at position "<< tagd10.GetPosition()<<"with velocity "<<tagd10.GetVelocity()<<"with acceleration "<<tagd10.GetAcceleration()<<"packet timestamp "<< tagd10.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd10.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag11 tagd11;
	if(pkt->PeekPacketTag(tagd11))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd11.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd11.GetPosition(), tagd11.GetVelocity(), tagd11.GetAcceleration(), tagd11.GetNodeId(), tagd11.GetNeighborids(), 11);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd11.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd11.GetSerializedSize()<<" at position "<< tagd11.GetPosition()<<"with velocity "<<tagd11.GetVelocity()<<"with acceleration "<<tagd11.GetAcceleration()<<"packet timestamp "<< tagd11.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd11.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag12 tagd12;
	if(pkt->PeekPacketTag(tagd12))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd12.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd12.GetPosition(), tagd12.GetVelocity(), tagd12.GetAcceleration(), tagd12.GetNodeId(), tagd12.GetNeighborids(), 12);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd12.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd12.GetSerializedSize()<<" at position "<< tagd12.GetPosition()<<"with velocity "<<tagd12.GetVelocity()<<"with acceleration "<<tagd12.GetAcceleration()<<"packet timestamp "<< tagd12.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd12.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag13 tagd13;
	if(pkt->PeekPacketTag(tagd13))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd13.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd13.GetPosition(), tagd13.GetVelocity(), tagd13.GetAcceleration(), tagd13.GetNodeId(), tagd13.GetNeighborids(), 13);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd13.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd13.GetSerializedSize()<<" at position "<< tagd13.GetPosition()<<"with velocity "<<tagd13.GetVelocity()<<"with acceleration "<<tagd13.GetAcceleration()<<"packet timestamp "<< tagd13.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd13.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag14 tagd14;
	if(pkt->PeekPacketTag(tagd14))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd14.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd14.GetPosition(), tagd14.GetVelocity(), tagd14.GetAcceleration(), tagd14.GetNodeId(), tagd14.GetNeighborids(), 14);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd14.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd14.GetSerializedSize()<<" at position "<< tagd14.GetPosition()<<"with velocity "<<tagd14.GetVelocity()<<"with acceleration "<<tagd14.GetAcceleration()<<"packet timestamp "<< tagd14.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd14.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag15 tagd15;
	if(pkt->PeekPacketTag(tagd15))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd15.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd15.GetPosition(), tagd15.GetVelocity(), tagd15.GetAcceleration(), tagd15.GetNodeId(), tagd15.GetNeighborids(), 15);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd15.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd15.GetSerializedSize()<<" at position "<< tagd15.GetPosition()<<"with velocity "<<tagd15.GetVelocity()<<"with acceleration "<<tagd15.GetAcceleration()<<"packet timestamp "<< tagd15.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd15.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag16 tagd16;
	if(pkt->PeekPacketTag(tagd16))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd16.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd16.GetPosition(), tagd16.GetVelocity(), tagd16.GetAcceleration(), tagd16.GetNodeId(), tagd16.GetNeighborids(), 16);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd16.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd16.GetSerializedSize()<<" at position "<< tagd16.GetPosition()<<"with velocity "<<tagd16.GetVelocity()<<"with acceleration "<<tagd16.GetAcceleration()<<"packet timestamp "<< tagd16.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd16.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	
	CustomDataTag17 tagd17;
	if(pkt->PeekPacketTag(tagd17))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd17.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd17.GetPosition(), tagd17.GetVelocity(), tagd17.GetAcceleration(), tagd17.GetNodeId(), tagd17.GetNeighborids(), 17);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd17.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd17.GetSerializedSize()<<" at position "<< tagd17.GetPosition()<<"with velocity "<<tagd17.GetVelocity()<<"with acceleration "<<tagd17.GetAcceleration()<<"packet timestamp "<< tagd17.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd17.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag18 tagd18;
	if(pkt->PeekPacketTag(tagd18))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd18.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd18.GetPosition(), tagd18.GetVelocity(), tagd18.GetAcceleration(), tagd18.GetNodeId(), tagd18.GetNeighborids(), 18);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd18.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd18.GetSerializedSize()<<" at position "<< tagd18.GetPosition()<<"with velocity "<<tagd18.GetVelocity()<<"with acceleration "<<tagd18.GetAcceleration()<<"packet timestamp "<< tagd18.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd18.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag19 tagd19;
	if(pkt->PeekPacketTag(tagd19))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd19.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd19.GetPosition(), tagd19.GetVelocity(), tagd19.GetAcceleration(), tagd19.GetNodeId(), tagd19.GetNeighborids(), 19);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd19.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd19.GetSerializedSize()<<" at position "<< tagd19.GetPosition()<<"with velocity "<<tagd19.GetVelocity()<<"with acceleration "<<tagd19.GetAcceleration()<<"packet timestamp "<< tagd19.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd19.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag20 tagd20;
	if(pkt->PeekPacketTag(tagd20))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd20.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd20.GetPosition(), tagd20.GetVelocity(), tagd20.GetAcceleration(), tagd20.GetNodeId(), tagd20.GetNeighborids(), 20);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd20.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd20.GetSerializedSize()<<" at position "<< tagd20.GetPosition()<<"with velocity "<<tagd20.GetVelocity()<<"with acceleration "<<tagd20.GetAcceleration()<<"packet timestamp "<< tagd20.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd20.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag21 tagd21;
	if(pkt->PeekPacketTag(tagd21))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd21.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd21.GetPosition(), tagd21.GetVelocity(), tagd21.GetAcceleration(), tagd21.GetNodeId(), tagd21.GetNeighborids(), 21);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd21.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd21.GetSerializedSize()<<" at position "<< tagd21.GetPosition()<<"with velocity "<<tagd21.GetVelocity()<<"with acceleration "<<tagd21.GetAcceleration()<<"packet timestamp "<< tagd21.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd21.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag22 tagd22;
	if(pkt->PeekPacketTag(tagd22))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd22.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd22.GetPosition(), tagd22.GetVelocity(), tagd22.GetAcceleration(), tagd22.GetNodeId(), tagd22.GetNeighborids(), 22);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd22.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd22.GetSerializedSize()<<" at position "<< tagd22.GetPosition()<<"with velocity "<<tagd22.GetVelocity()<<"with acceleration "<<tagd22.GetAcceleration()<<"packet timestamp "<< tagd22.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd22.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag23 tagd23;
	if(pkt->PeekPacketTag(tagd23))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd23.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd23.GetPosition(), tagd23.GetVelocity(), tagd23.GetAcceleration(), tagd23.GetNodeId(), tagd23.GetNeighborids(), 23);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd23.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd23.GetSerializedSize()<<" at position "<< tagd23.GetPosition()<<"with velocity "<<tagd23.GetVelocity()<<"with acceleration "<<tagd23.GetAcceleration()<<"packet timestamp "<< tagd23.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd23.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag24 tagd24;
	if(pkt->PeekPacketTag(tagd24))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd24.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd24.GetPosition(), tagd24.GetVelocity(), tagd24.GetAcceleration(), tagd24.GetNodeId(), tagd24.GetNeighborids(), 24);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd24.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd24.GetSerializedSize()<<" at position "<< tagd24.GetPosition()<<"with velocity "<<tagd24.GetVelocity()<<"with acceleration "<<tagd24.GetAcceleration()<<"packet timestamp "<< tagd24.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd24.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomDataTag25 tagd25;
	if(pkt->PeekPacketTag(tagd25))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagd25.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagd25.GetPosition(), tagd25.GetVelocity(), tagd25.GetAcceleration(), tagd25.GetNodeId(), tagd25.GetNeighborids(), 25);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagd25.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagd25.GetSerializedSize()<<" at position "<< tagd25.GetPosition()<<"with velocity "<<tagd25.GetVelocity()<<"with acceleration "<<tagd25.GetAcceleration()<<"packet timestamp "<< tagd25.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagd25.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	
	CustomDataTagmax tagdmax;
	if(pkt->PeekPacketTag(tagdmax))
	{
		add_neighbor_info(neighbordata_inst+destination_node_id,tagdmax.GetNodeId()); //add current neighbor information
		refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		add_received_data_at_nodes(data_at_nodes_inst+destination_node_id, tagdmax.GetPosition(), tagdmax.GetVelocity(), tagdmax.GetAcceleration(), tagdmax.GetNodeId(), tagdmax.GetNeighborids(), max);
		refresh_data_at_nodes(data_at_nodes_inst+destination_node_id);
		std::cout << "Received data broadcasted packet from "<< tagdmax.GetNodeId()<<"to node "<<destination_node_id <<"of size "<<tagdmax.GetSerializedSize()<<" at position "<< tagdmax.GetPosition()<<"with velocity "<<tagdmax.GetVelocity()<<"with acceleration "<<tagdmax.GetAcceleration()<<"packet timestamp "<< tagdmax.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tagdmax.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
	
	CustomMetaDataBroadcastTag tag2;
	if(pkt->PeekPacketTag(tag2))
	{
		
		 //int combined_cost = 2 + (Now().GetMilliSeconds()-tag2.GetTimestamp().GetMilliSeconds());
		 //add_neighbor_info(neighbordata_inst+destination_node_id,tag2.GetNodeId(), combined_cost);
		 add_neighbor_info(neighbordata_inst+destination_node_id,tag2.GetNodeId()); //add current neighbor information
		 refresh_neighbors(neighbordata_inst+destination_node_id);//remove old neighbors
		 uint32_t ns = getNeighborsize(neighbordata_inst+destination_node_id);	
		 cout<<"received metadata broadcasted to"<<destination_node_id <<"neighbor size"<<ns<<endl;
		std::cout << "Current neighbor size is "<<ns<<"Received packet from "<< tag2.GetNodeId()<<"to node "<<context[10]<<context[11] <<"of size "<<tag2.GetSerializedSize()<<"packet timestamp "<< tag2.GetTimestamp().GetSeconds()<<"s "<<"with delay "<< Now().GetMicroSeconds()-tag2.GetTimestamp().GetMicroSeconds()<<"us"<<std::endl;
	}
}





void p2p_data_broadcast(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> node)
{
	Ptr <Node> nu = DynamicCast <Node> (node);
	CustomDataTag tag;
	uint32_t nid = uint32_t(nu->GetId());
	tag.SetNodeId(nid);
	Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (node->GetObject<MobilityModel>());
        Vector posi = mdl->GetPosition();
        Vector veli = mdl->GetVelocity();
        Vector acci = Vector(0,0,0);
	tag.SetPosition(posi);
	tag.SetVelocity(veli);
	tag.SetAcceleration(acci);
	Time ti = Seconds(Simulator::Now().GetSeconds());
	tag.SetTimestamp(ti);
	Ptr <Packet> packet1 = Create <Packet> (0);
	packet1->AddPacketTag(tag);
  	Ptr <Ipv4> ipv4;
  	ipv4 = node->GetObject<Ipv4>();
  	uint32_t N_interfaces = ipv4->GetNInterfaces();
  	for (uint32_t j=1; j<N_interfaces-1; j++)
  	{
		Ipv4InterfaceAddress iaddr = ipv4->GetAddress(j,0);//jth IPv4 interface,0th address index
		Ipv4Address dest_ip = iaddr.GetBroadcast();//get braoadcast address for p2p
		//cout<<dest_ip<<endl;
		//Ipv4Address dest_ip = Ipv4Address("20.1.0.255");
		Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
	}
}

void p2p_metadata_broadcast(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> node)
{
	Ptr <Node> nu = DynamicCast <Node> (node);
	CustomMetaDataBroadcastTag tag;
	uint32_t nid = uint32_t(nu->GetId());
	tag.SetNodeId(nid);
	Time ti = Seconds(Simulator::Now().GetSeconds());
	tag.SetTimestamp(ti);
	Ptr <Packet> packet1 = Create <Packet> (0);
	packet1->AddPacketTag(tag);
  	Ptr <Ipv4> ipv4;
  	ipv4 = node->GetObject<Ipv4>();
  	uint32_t N_interfaces = ipv4->GetNInterfaces();
  	for (uint32_t j=1; j<N_interfaces-1; j++)
  	{
		Ipv4InterfaceAddress iaddr = ipv4->GetAddress(j,0);//jth IPv4 interface,0th address index
		Ipv4Address dest_ip = iaddr.GetBroadcast();//get braoadcast address for p2p
		//cout<<dest_ip<<endl;
		//Ipv4Address dest_ip = Ipv4Address("20.1.0.255");
		Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
	}
}

void AODV_dataunicast_alone(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> source_node, Ptr <Node> destination_node)
{
	Ptr <Node> nu = DynamicCast <Node> (source_node);
	uint32_t nid = uint32_t(nu->GetId());
	uint32_t destination = destination_node->GetId();
	aodv_initial_timestamp[nid] = Simulator::Now().GetSeconds();
	Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (source_node->GetObject<MobilityModel>());
        Vector posi = mdl->GetPosition();
        Vector veli = mdl->GetVelocity();
        Vector acci = Vector(0,0,0);
	Time ti = Seconds(Simulator::Now().GetSeconds());
	Ptr <Packet> packet1 = Create <Packet> (0);
	uint32_t nodeid = nid;
	CustomDataUnicastTag_Routing tag1;
	tag1.SetsenderId(nid);
	tag1.SetNodeId(&nodeid);
	tag1.Setposition(&posi);
	tag1.Setvelocity(&veli);
	tag1.Setacceleration(&acci);
	tag1.SetTimestamp(&ti);
	tag1.SetdestinationId(destination);
	packet1->AddPacketTag(tag1);
  	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
  	Ipv4InterfaceAddress iaddr;
  	Ipv4Address dest_ip;
  	
  	//Ptr <Node> dest_nd = DynamicCast <Node> (destination_node);
	//uint32_t dest_nid = uint32_t(nu->GetId());
  	//if (dest_nid < (2+N_Vehicles))
  	//{
		iaddr = ipv4->GetAddress(1,0);
		dest_ip = iaddr.GetLocal();	
		cout<<dest_ip<<endl;
	//}
	dsrc_total_packet_size = dsrc_total_packet_size + 84;
	Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);	
}




void RSU_dataunicast_alone(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> source_node, Ptr <Node> destination_node)
{
	Ptr <Node> nu = DynamicCast <Node> (source_node);
	uint32_t nid = uint32_t(nu->GetId());
	Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (source_node->GetObject<MobilityModel>());
        Vector posi = mdl->GetPosition();
        Vector veli = mdl->GetVelocity();
        Vector acci = Vector(0,0,0);
	Time ti = Seconds(Simulator::Now().GetSeconds());
	Ptr <Packet> packet1 = Create <Packet> (0);
  	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
  	Ipv4InterfaceAddress iaddr;
  	if(N_Vehicles > 0)
  	{
		iaddr = ipv4->GetAddress(1,0);//2nd IPv4 interface,0th address index
	}
	else if (N_Vehicles == 0)
	{
		iaddr = ipv4->GetAddress(0,0);//1st IPv4 interface,0th address index
	}
	Ipv4Address dest_ip = iaddr.GetLocal();	
	
	uint32_t size_nei = getNeighborsize((neighbordata_inst+nid));
	uint32_t neighborid[size_nei];
	for (uint32_t i=0;i<size_nei;i++)
	{
		neighborid[i] = large;
	}
	
	uint32_t j=0;
	for (uint32_t i=0;i<max;i++)
	{
		if ((((neighbordata_inst+nid)->neighborid[i]) != large) and (j<size_nei))
		{
			neighborid[j] = (neighbordata_inst+nid)->neighborid[i];
	  		j++;
	  	}
	}
	add_received_data_at_nodes(data_at_nodes_inst+nid, posi, veli, acci, nid, neighborid, size_nei);
  	//send the content at data at nodes to the mangement node
  	uint32_t size = get_size_of_data_at_nodes(data_at_nodes_inst+nid);
  	uint32_t nodeid[size];
	Vector position[size];
	Vector acceleration[size];
	Vector velocity[size];
	Time timestamp[size];

	
	for(uint32_t i=0;i<size;i++)
	{
		nodeid[i] = large;
		position[i] = Vector(0,0,0);
		acceleration[i] = Vector(0,0,0);
		velocity[i] = Vector(0,0,0);
		timestamp[i] = Simulator::Now();
	}
	
	uint32_t k=0;
	for(uint32_t i=0;i<max;i++)
	{
		if (((data_at_nodes_inst+nid)->nodeid[i] != large) and (k<size))
		{
			nodeid[k] = (data_at_nodes_inst+nid)->nodeid[i];
			position[k] = (data_at_nodes_inst+nid)->position[i];
			velocity[k] = (data_at_nodes_inst+nid)->velocity[i];
			acceleration[k] = (data_at_nodes_inst+nid)->acceleration[i];
			timestamp[k] = (data_at_nodes_inst+nid)->timestamp[i];
			k++;
		}
		
	}	
	
	CustomDataUnicastTag1 tag1;
	CustomDataUnicastTag2 tag2;
	CustomDataUnicastTag3 tag3;
	CustomDataUnicastTag4 tag4;
	CustomDataUnicastTag5 tag5;
	CustomDataUnicastTag6 tag6;
	CustomDataUnicastTag7 tag7;
	CustomDataUnicastTag8 tag8;
	CustomDataUnicastTag9 tag9;
	CustomDataUnicastTag10 tag10;
	CustomDataUnicastTag11 tag11;
	CustomDataUnicastTag12 tag12;
	CustomDataUnicastTag13 tag13;
	CustomDataUnicastTag14 tag14;
	CustomDataUnicastTag15 tag15;
	CustomDataUnicastTag16 tag16;
	CustomDataUnicastTag17 tag17;
	CustomDataUnicastTag18 tag18;
	CustomDataUnicastTag19 tag19;
	CustomDataUnicastTag20 tag20;
	CustomDataUnicastTag21 tag21;
	CustomDataUnicastTag22 tag22;
	CustomDataUnicastTag23 tag23;
	CustomDataUnicastTag24 tag24;
	CustomDataUnicastTag25 tag25;
	CustomDataUnicastTag tag;
	switch (size)
	{	
		case 1:
			tag1.SetsenderId(nid);
			tag1.SetNodeId(nodeid);
			tag1.Setposition(position);
			tag1.Setvelocity(velocity);
			tag1.Setacceleration(acceleration);
			tag1.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag1);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 2:
			tag2.SetsenderId(nid);
			tag2.SetNodeId(nodeid);
			tag2.Setposition(position);
			tag2.Setvelocity(velocity);
			tag2.Setacceleration(acceleration);
			tag2.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag2);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 3:
			tag3.SetsenderId(nid);
			tag3.SetNodeId(nodeid);
			tag3.Setposition(position);
			tag3.Setvelocity(velocity);
			tag3.Setacceleration(acceleration);
			tag3.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag3);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 4:
			tag4.SetsenderId(nid);
			tag4.SetNodeId(nodeid);
			tag4.Setposition(position);
			tag4.Setvelocity(velocity);
			tag4.Setacceleration(acceleration);
			tag4.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag4);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 5:
			tag5.SetsenderId(nid);
			tag5.SetNodeId(nodeid);
			tag5.Setposition(position);
			tag5.Setvelocity(velocity);
			tag5.Setacceleration(acceleration);
			tag5.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag5);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 6:
			tag6.SetsenderId(nid);
			tag6.SetNodeId(nodeid);
			tag6.Setposition(position);
			tag6.Setvelocity(velocity);
			tag6.Setacceleration(acceleration);
			tag6.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag6);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 7:
			tag7.SetsenderId(nid);
			tag7.SetNodeId(nodeid);
			tag7.Setposition(position);
			tag7.Setvelocity(velocity);
			tag7.Setacceleration(acceleration);
			tag7.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag7);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 8:
			tag8.SetsenderId(nid);
			tag8.SetNodeId(nodeid);
			tag8.Setposition(position);
			tag8.Setvelocity(velocity);
			tag8.Setacceleration(acceleration);
			tag8.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag8);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 9:
			tag9.SetsenderId(nid);
			tag9.SetNodeId(nodeid);
			tag9.Setposition(position);
			tag9.Setvelocity(velocity);
			tag9.Setacceleration(acceleration);
			tag9.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag9);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 10:
			tag10.SetsenderId(nid);
			tag10.SetNodeId(nodeid);
			tag10.Setposition(position);
			tag10.Setvelocity(velocity);
			tag10.Setacceleration(acceleration);
			tag10.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag10);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 11:
			tag11.SetsenderId(nid);
			tag11.SetNodeId(nodeid);
			tag11.Setposition(position);
			tag11.Setvelocity(velocity);
			tag11.Setacceleration(acceleration);
			tag11.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag11);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 12:
			tag12.SetsenderId(nid);
			tag12.SetNodeId(nodeid);
			tag12.Setposition(position);
			tag12.Setvelocity(velocity);
			tag12.Setacceleration(acceleration);
			tag12.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag12);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 13:
			tag13.SetsenderId(nid);
			tag13.SetNodeId(nodeid);
			tag13.Setposition(position);
			tag13.Setvelocity(velocity);
			tag13.Setacceleration(acceleration);
			tag13.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag13);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;	
		case 14:
			tag14.SetsenderId(nid);
			tag14.SetNodeId(nodeid);
			tag14.Setposition(position);
			tag14.Setvelocity(velocity);
			tag14.Setacceleration(acceleration);
			tag14.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag14);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 15:
			tag15.SetsenderId(nid);
			tag15.SetNodeId(nodeid);
			tag15.Setposition(position);
			tag15.Setvelocity(velocity);
			tag15.Setacceleration(acceleration);
			tag15.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag15);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;

		case 16:
			tag16.SetsenderId(nid);
			tag16.SetNodeId(nodeid);
			tag16.Setposition(position);
			tag16.Setvelocity(velocity);
			tag16.Setacceleration(acceleration);
			tag16.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag16);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 17:
			tag17.SetsenderId(nid);
			tag17.SetNodeId(nodeid);
			tag17.Setposition(position);
			tag17.Setvelocity(velocity);
			tag17.Setacceleration(acceleration);
			tag17.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag17);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 18:
			tag18.SetsenderId(nid);	
			tag18.SetNodeId(nodeid);
			tag18.Setposition(position);
			tag18.Setvelocity(velocity);
			tag18.Setacceleration(acceleration);
			tag18.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag18);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 19:
			tag19.SetsenderId(nid);
			tag19.SetNodeId(nodeid);
			tag19.Setposition(position);
			tag19.Setvelocity(velocity);
			tag19.Setacceleration(acceleration);
			tag19.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag19);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 20:
			tag20.SetsenderId(nid);
			tag20.SetNodeId(nodeid);
			tag20.Setposition(position);
			tag20.Setvelocity(velocity);
			tag20.Setacceleration(acceleration);
			tag20.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag20);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 21:
			tag21.SetsenderId(nid);
			tag21.SetNodeId(nodeid);
			tag21.Setposition(position);
			tag21.Setvelocity(velocity);
			tag21.Setacceleration(acceleration);
			tag21.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag21);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 22:
			tag22.SetsenderId(nid);
			tag22.SetNodeId(nodeid);
			tag22.Setposition(position);
			tag22.Setvelocity(velocity);
			tag22.Setacceleration(acceleration);
			tag22.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag22);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 23:
			tag23.SetsenderId(nid);
			tag23.SetNodeId(nodeid);
			tag23.Setposition(position);
			tag23.Setvelocity(velocity);
			tag23.Setacceleration(acceleration);
			tag23.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag23);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 24:
			tag24.SetsenderId(nid);
			tag24.SetNodeId(nodeid);
			tag24.Setposition(position);
			tag24.Setvelocity(velocity);
			tag24.Setacceleration(acceleration);
			tag24.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag24);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 25:
			tag25.SetsenderId(nid);
			tag25.SetNodeId(nodeid);
			tag25.Setposition(position);
			tag25.Setvelocity(velocity);
			tag25.Setacceleration(acceleration);
			tag25.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag25);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		default:
			cout<<"Cellular:maximum status datasize exceeded . size is  "<<size<<endl;
			tag.SetsenderId(nid);
			tag.SetNodeId((data_at_nodes_inst+nid)->nodeid);
			tag.Setposition((data_at_nodes_inst+nid)->position);
			tag.Setvelocity((data_at_nodes_inst+nid)->velocity);
			tag.Setacceleration((data_at_nodes_inst+nid)->acceleration);
			tag.SetTimestamp((data_at_nodes_inst+nid)->timestamp);
			packet1->AddPacketTag(tag);
			ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;	
	}
	cout<<"ethernet total packet size is "<<ethernet_total_packet_size<<endl;
}



void set_dsrc_initial_timestamp()
{
	dsrc_initial_timestamp = Simulator::Now().GetSeconds();
}

void set_lte_initial_timestamp()
{
	lte_initial_timestamp = Simulator::Now().GetSeconds();
}

void set_ethernet_initial_timestamp()
{
	ethernet_initial_timestamp = Simulator::Now().GetSeconds();
}


void dsrc_data_broadcast(Ptr <NetDevice> nd, Ptr <Node> node, uint32_t node_index)
{
	uint32_t nid = node->GetId();
	//cout<<"Z value at "<<nid<<"is "<<Z_nodes[nid]<<endl;
	if (Z_nodes[nid] == 1)
	{
		packet_initial_timestamp[nid] = Simulator::Now().GetSeconds();
		cout<<"DSRC data Broadcasting from node "<<nid<<endl;
		Mac48Address dest = Mac48Address::GetBroadcast();
	  	uint16_t protocolwave = 0x88dc;//ethertype for WAVE is set here.
		Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (nd);
		Ptr <Node> ni = DynamicCast <Node> (node);
		CustomDataTag tag;
		CustomDataTag1 tag1;
		CustomDataTag2 tag2;
		CustomDataTag3 tag3;
		CustomDataTag4 tag4;
		CustomDataTag5 tag5;
		CustomDataTag6 tag6;
		CustomDataTag7 tag7;
		CustomDataTag8 tag8;
		CustomDataTag9 tag9;
		CustomDataTag10 tag10;
		CustomDataTag11 tag11;
		CustomDataTag12 tag12;
		CustomDataTag13 tag13;
		CustomDataTag14 tag14;
		CustomDataTag15 tag15;
		CustomDataTag16 tag16;
		CustomDataTag17 tag17;
		CustomDataTag18 tag18;
		CustomDataTag19 tag19;
		CustomDataTag20 tag20;
		CustomDataTag21 tag21;
		CustomDataTag22 tag22;
		CustomDataTag23 tag23;
		CustomDataTag24 tag24;
		CustomDataTag25 tag25;
		CustomDataTagmax tagmax;
		
		uint32_t nid = uint32_t(ni->GetId());
		uint32_t size = getNeighborsize((neighbordata_inst+nid));
		uint32_t neighborid[size];
		for (uint32_t i=0;i<size;i++)
		{
			neighborid[i] = large;
		}
		
		uint32_t j=0;
		for (uint32_t i=0;i<max;i++)
		{
			if ((((neighbordata_inst+nid)->neighborid[i]) != large) and (j<size))
			{
				neighborid[j] = (neighbordata_inst+nid)->neighborid[i];
		  		j++;
		  	}
		}
		
		Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (node->GetObject<MobilityModel>());
		Vector posi = mdl->GetPosition();
		Vector current_velocity = mdl->GetVelocity();
		double delta_t = data_transmission_period;
		Vector acceleration = calculate_acceleration(previous_velocity_dsrc[node_index],current_velocity,delta_t);
		Time ti = Seconds(Simulator::Now().GetSeconds());
		Ptr <Packet> packet_i = Create<Packet> (0);
		switch (size)
		{	
			case 0:
				tag.SetNodeId(nid);
				tag.SetPosition(posi);
				tag.SetVelocity(current_velocity);
				tag.SetAcceleration(acceleration);
				tag.SetTimestamp(ti);
				packet_i->AddPacketTag(tag);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 1:
				tag1.SetNodeId(nid);
				tag1.SetNeighborids(neighborid);
				tag1.SetPosition(posi);
				tag1.SetVelocity(current_velocity);
				tag1.SetAcceleration(acceleration);
				tag1.SetTimestamp(ti);
				packet_i->AddPacketTag(tag1);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 2:
				tag2.SetNodeId(nid);
				tag2.SetNeighborids(neighborid);
				tag2.SetPosition(posi);
				tag2.SetVelocity(current_velocity);
				tag2.SetAcceleration(acceleration);
				tag2.SetTimestamp(ti);
				packet_i->AddPacketTag(tag2);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 3: 
				tag3.SetNodeId(nid);
				tag3.SetNeighborids(neighborid);
				tag3.SetPosition(posi);
				tag3.SetVelocity(current_velocity);
				tag3.SetAcceleration(acceleration);
				tag3.SetTimestamp(ti);
				packet_i->AddPacketTag(tag3);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 4:
				tag4.SetNodeId(nid);
				tag4.SetNeighborids(neighborid);
				tag4.SetPosition(posi);
				tag4.SetVelocity(current_velocity);
				tag4.SetAcceleration(acceleration);
				tag4.SetTimestamp(ti);
				packet_i->AddPacketTag(tag4);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 5:
				tag5.SetNodeId(nid);
				tag5.SetNeighborids(neighborid);
				tag5.SetPosition(posi);
				tag5.SetVelocity(current_velocity);
				tag5.SetAcceleration(acceleration);
				tag5.SetTimestamp(ti);
				packet_i->AddPacketTag(tag5);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 6:
				tag6.SetNodeId(nid);
				tag6.SetNeighborids(neighborid);
				tag6.SetPosition(posi);
				tag6.SetVelocity(current_velocity);
				tag6.SetAcceleration(acceleration);
				tag6.SetTimestamp(ti);
				packet_i->AddPacketTag(tag6);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 7:
				tag7.SetNodeId(nid);
				tag7.SetNeighborids(neighborid);
				tag7.SetPosition(posi);
				tag7.SetVelocity(current_velocity);
				tag7.SetAcceleration(acceleration);
				tag7.SetTimestamp(ti);
				packet_i->AddPacketTag(tag7);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 8:
				tag8.SetNodeId(nid);
				tag8.SetNeighborids(neighborid);
				tag8.SetPosition(posi);
				tag8.SetVelocity(current_velocity);
				tag8.SetAcceleration(acceleration);
				tag8.SetTimestamp(ti);
				packet_i->AddPacketTag(tag8);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 9:
				tag9.SetNodeId(nid);
				tag9.SetNeighborids(neighborid);
				tag9.SetPosition(posi);
				tag9.SetVelocity(current_velocity);
				tag9.SetAcceleration(acceleration);
				tag9.SetTimestamp(ti);
				packet_i->AddPacketTag(tag9);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 10:
				tag10.SetNodeId(nid);
				tag10.SetNeighborids(neighborid);
				tag10.SetPosition(posi);
				tag10.SetVelocity(current_velocity);
				tag10.SetAcceleration(acceleration);
				tag10.SetTimestamp(ti);
				packet_i->AddPacketTag(tag10);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 11:
				tag11.SetNodeId(nid);
				tag11.SetNeighborids(neighborid);
				tag11.SetPosition(posi);
				tag11.SetVelocity(current_velocity);
				tag11.SetAcceleration(acceleration);
				tag11.SetTimestamp(ti);
				packet_i->AddPacketTag(tag11);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 12:
				tag12.SetNodeId(nid);
				tag12.SetNeighborids(neighborid);
				tag12.SetPosition(posi);
				tag12.SetVelocity(current_velocity);
				tag12.SetAcceleration(acceleration);
				tag12.SetTimestamp(ti);
				packet_i->AddPacketTag(tag12);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 13:
				tag13.SetNodeId(nid);
				tag13.SetNeighborids(neighborid);
				tag13.SetPosition(posi);
				tag13.SetVelocity(current_velocity);
				tag13.SetAcceleration(acceleration);
				tag13.SetTimestamp(ti);
				packet_i->AddPacketTag(tag13);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 14:
				tag14.SetNodeId(nid);
				tag14.SetNeighborids(neighborid);
				tag14.SetPosition(posi);
				tag14.SetVelocity(current_velocity);
				tag14.SetAcceleration(acceleration);
				tag14.SetTimestamp(ti);
				packet_i->AddPacketTag(tag14);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 15:
				tag15.SetNodeId(nid);
				tag15.SetNeighborids(neighborid);
				tag15.SetPosition(posi);
				tag15.SetVelocity(current_velocity);
				tag15.SetAcceleration(acceleration);
				tag15.SetTimestamp(ti);
				packet_i->AddPacketTag(tag15);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 16:
				tag16.SetNodeId(nid);
				tag16.SetNeighborids(neighborid);
				tag16.SetPosition(posi);
				tag16.SetVelocity(current_velocity);
				tag16.SetAcceleration(acceleration);
				tag16.SetTimestamp(ti);
				packet_i->AddPacketTag(tag16);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 17:
				tag17.SetNodeId(nid);
				tag17.SetNeighborids(neighborid);
				tag17.SetPosition(posi);
				tag17.SetVelocity(current_velocity);
				tag17.SetAcceleration(acceleration);
				tag17.SetTimestamp(ti);
				packet_i->AddPacketTag(tag17);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 18:
				tag18.SetNodeId(nid);
				tag18.SetNeighborids(neighborid);
				tag18.SetPosition(posi);
				tag18.SetVelocity(current_velocity);
				tag18.SetAcceleration(acceleration);
				tag18.SetTimestamp(ti);
				packet_i->AddPacketTag(tag18);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 19:
				tag19.SetNodeId(nid);
				tag19.SetNeighborids(neighborid);
				tag19.SetPosition(posi);
				tag19.SetVelocity(current_velocity);
				tag19.SetAcceleration(acceleration);
				tag19.SetTimestamp(ti);
				packet_i->AddPacketTag(tag19);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 20:
				tag20.SetNodeId(nid);
				tag20.SetNeighborids(neighborid);
				tag20.SetPosition(posi);
				tag20.SetVelocity(current_velocity);
				tag20.SetAcceleration(acceleration);
				tag20.SetTimestamp(ti);
				packet_i->AddPacketTag(tag20);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 21:
				tag21.SetNodeId(nid);
				tag21.SetNeighborids(neighborid);
				tag21.SetPosition(posi);
				tag21.SetVelocity(current_velocity);
				tag21.SetAcceleration(acceleration);
				tag21.SetTimestamp(ti);
				packet_i->AddPacketTag(tag21);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 22:
				tag22.SetNodeId(nid);
				tag22.SetNeighborids(neighborid);
				tag22.SetPosition(posi);
				tag22.SetVelocity(current_velocity);
				tag22.SetAcceleration(acceleration);
				tag22.SetTimestamp(ti);
				packet_i->AddPacketTag(tag22);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 23:
				tag23.SetNodeId(nid);
				tag23.SetNeighborids(neighborid);
				tag23.SetPosition(posi);
				tag23.SetVelocity(current_velocity);
				tag23.SetAcceleration(acceleration);
				tag23.SetTimestamp(ti);
				packet_i->AddPacketTag(tag23);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 24:
				tag24.SetNodeId(nid);
				tag24.SetNeighborids(neighborid);
				tag24.SetPosition(posi);
				tag24.SetVelocity(current_velocity);
				tag24.SetAcceleration(acceleration);
				tag24.SetTimestamp(ti);
				packet_i->AddPacketTag(tag24);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			case 25:
				tag25.SetNodeId(nid);
				tag25.SetNeighborids(neighborid);
				tag25.SetPosition(posi);
				tag25.SetVelocity(current_velocity);
				tag25.SetAcceleration(acceleration);
				tag25.SetTimestamp(ti);
				packet_i->AddPacketTag(tag25);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
			default:
				tagmax.SetNodeId(nid);
				uint32_t neighboridmax[max];
				for(uint32_t i=0;i<max;i++)
				{
					if(i<size)
					{
						neighboridmax[i] = neighborid[i];
					}
					else
					{
						neighboridmax[i] = large;
					}
				}
				tagmax.SetNeighborids(neighboridmax);
				tagmax.SetPosition(posi);
				tagmax.SetVelocity(current_velocity);
				tagmax.SetAcceleration(acceleration);
				tagmax.SetTimestamp(ti);
				packet_i->AddPacketTag(tagmax);
				dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
				Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
				break;
		}
		cout<<"dsrc total size is "<<dsrc_total_packet_size<<endl;
		previous_velocity_dsrc[node_index] = current_velocity;
	}
}

void centralized_dsrc_data_broadcast(Ptr <NetDevice> nd, Ptr <Node> node, uint32_t node_index)
{
	routing_time = false;
	//uint32_t nid = node->GetId();
	Mac48Address dest = Mac48Address::GetBroadcast();
  	uint16_t protocolwave = 0x88dc;//ethertype for WAVE is set here.
	Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (nd);
	Ptr <Node> ni = DynamicCast <Node> (node);
	CustomDataTag tag;
	uint32_t nid = uint32_t(ni->GetId());
	packet_initial_timestamp[nid] = Simulator::Now().GetSeconds();
	cout<<"DSRC data Broadcasting from node "<<nid<<endl;
	Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (node->GetObject<MobilityModel>());
	Vector posi = mdl->GetPosition();
	Vector current_velocity = mdl->GetVelocity();
	double delta_t = data_transmission_period;
	Vector acceleration = calculate_acceleration(previous_velocity_dsrc[node_index],current_velocity,delta_t);
	Time ti = Seconds(Simulator::Now().GetSeconds());
	Ptr <Packet> packet_i = Create<Packet> (0);
	tag.SetNodeId(nid);
	tag.SetPosition(posi);
	tag.SetVelocity(current_velocity);
	tag.SetAcceleration(acceleration);
	tag.SetTimestamp(ti);
	packet_i->AddPacketTag(tag);
	dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
	Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);	
	cout<<"dsrc total size is "<<dsrc_total_packet_size<<endl;
	previous_velocity_dsrc[node_index] = current_velocity;
}

MobilityHelper vehicle_mobility;

void update_mobility()
{
  for(uint32_t i=0;i<Vehicle_Nodes.GetN();i++)
  {
	  	Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (Vehicle_Nodes.Get(i)->GetObject<MobilityModel>());
	  	srand(Now().GetSeconds()*i);
	  	int sign1 = (rand()%2)==0?-1:1;
	  	//double vx = 5.0 + (rand()%10);
	  	uint32_t vx_max = maxspeed*(1000.0/3600.0);
	  	double vx = (vx_max/2) + (rand()%(vx_max/2));
	  	Vector cur_pos = mdl->GetPosition();
	  	double px;
	  	if((cur_pos.x > (750+1500))|(cur_pos.x< (650)))
	  	{
	  		px = 750 + (rand()%1500);
	  	}
	  	else
	  	{
	  		px = cur_pos.x;
	  	
	  	}
	  	srand(i*Now().GetSeconds()+0.2);
	  	int sign2 = (rand()%2)==0?-1:1;
	  	//double vy = 5.0 + (rand()%10);
	  	uint32_t vy_max = maxspeed*(1000.0/3600.0);
	  	double vy = (vy_max/2) + (rand()%(vy_max/2));
	  	double py;
	  	if((cur_pos.y > (1200+1500)) |(cur_pos.y<1000))
	  	{
	  		py = 1200 + (rand()%1500);
	  	}
	  	else
	  	{
	  		py = cur_pos.y;
	  	}
	  	double updated_vx = sign1*vx;
	  	double updated_vy = sign2*vy;
	  	mdl->SetPosition(Vector(px, py, 0));
	  	mdl->SetVelocity(Vector(updated_vx, updated_vy, 0));
	  	//cout<<"sign 1 is"<<sign1<<"vx is "<<vx<<"product is "<<updated_vx<<"sign 2 "<<sign2<<"vy is "<<vy<<"product is "<<updated_vy<<endl;
	  	//cout<<mdl->GetVelocity()<<endl;
	  	//cout<<"updating mobility file at "<<Now().GetSeconds()<<endl;
  }

}


void hybrid_data_unicast(Ptr <NetDevice> source_nd, Ptr <Node> source_node, uint32_t node_index, uint32_t destination)
{
	uint32_t nid = source_node->GetId();
	//cout<<"original node id is "<<nid<<endl;
	//uint32_t next_hop = routing_tables[node_index].rows[destination].next_hop;
	uint32_t next_hop = find_next_hop(node_index,destination,node_index);
	cout<<endl<<"next hop from routing table is "<< next_hop <<endl;
	dsrc_packet_initial_timestamp[nid] = Simulator::Now().GetSeconds();
	if (next_hop < total_size)
	{
		CustomDataUnicastTag_Routing tag;
		//uint32_t nid = uint32_t(ni->GetId());
		Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (source_node->GetObject<MobilityModel>());
		Vector posi = mdl->GetPosition();
		Vector current_velocity = mdl->GetVelocity();
		double delta_t = data_transmission_period;
		Vector acceleration = calculate_acceleration(previous_velocity_dsrc[node_index],current_velocity,delta_t);
		Time ti = MicroSeconds(Simulator::Now().GetMicroSeconds());
		Ptr <Packet> packet_i = Create<Packet> (packet_additional_size);
		tag.SetsenderId(nid-2);
		tag.SetNodeId(&nid);
		tag.Setposition(&posi);
		tag.Setvelocity(&current_velocity);
		tag.Setacceleration(&acceleration);
		tag.SetTimestamp(&ti);
		tag.SetdestinationId(destination);
		packet_i->AddPacketTag(tag);
		
		
		if (((nid-2) > N_Vehicles) && (next_hop > N_Vehicles))
		{
			Ptr <Node> nu = DynamicCast <Node> (RSU_Nodes.Get(nid-2-N_Vehicles));	
	  		Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (RSU_apps.Get(nid-2-N_Vehicles));
	  		cout<<"This is source node. Ethernet data Unicasting from node "<<nid - 2<<endl;
			Simulator::Schedule(Seconds(0),RSU_routing_dataunicast_alone, udp_app, nu, RSU_Nodes.Get(next_hop-N_Vehicles),packet_i);
		}
		
		else
		{
			cout<<"This is source node. DSRC data Unicasting from node "<<nid - 2<<endl;
			Ptr <NetDevice> destination_nd = wifidevices.Get(next_hop);
			Address addr = destination_nd->GetAddress();
			Mac48Address dest_address = Mac48Address::ConvertFrom(addr);
			//cout <<endl<<"MAC address of next hop node "<<next_hop<<" is "<<dest_address<<endl;
		  	uint16_t protocolwave = 0x88dc;//
			Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (source_nd);
			Ptr <Node> ni = DynamicCast <Node> (source_node);
			dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
			Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest_address, protocolwave);
		}
		uint32_t * pt = tag.GetNodeId();
		//cout<<"node id from tag is "<<*pt<<endl;	
		Y[*pt - 2] = Y[*pt -2] + 1;
		//cout<<"dsrc total size is "<<dsrc_total_packet_size<<endl;
		previous_velocity_dsrc[node_index] = current_velocity;
	}
	else
	{
		cout<<"A route does not exist"<<endl;
	}
}

void routing_dsrc_data_unicast(Ptr <NetDevice> source_nd, Ptr <Node> source_node, uint32_t flow_id, uint32_t next_hop_id, struct custom_struct arguments, uint32_t packet_ID)
{
	//cout<<"transmiiting a a packet at "<<Now().GetMilliSeconds()<<endl;
	uint32_t nid = source_node->GetId();
	uint32_t source = nid -2;
	//cout<<"next hop is "<< next_hop_id <<endl;
	Ptr <NetDevice> destination_nd = wifidevices.Get(next_hop_id);
	switch(arguments.channel)
	{
		case(172):
			destination_nd = wifidevices_172.Get(next_hop_id);
			break;
		case(174):
			destination_nd = wifidevices_174.Get(next_hop_id);
			break;
		case(176):
			destination_nd = wifidevices_176.Get(next_hop_id);
			break;
		case(178):
			destination_nd = wifidevices.Get(next_hop_id);
			break;
		case(180):
			destination_nd = wifidevices_180.Get(next_hop_id);
			break;
		case(182):
			destination_nd = wifidevices_182.Get(next_hop_id);
			break;
		case(184):
			destination_nd = wifidevices_184.Get(next_hop_id);
			break;
		default:
			break;
	
	}
	//Ptr <NetDevice> destination_nd = wifidevices.Get(13);
	Address addr = destination_nd->GetAddress();
	Mac48Address dest_address = Mac48Address::ConvertFrom(addr);
	//cout <<endl<<"MAC address of next hop node "<<next_hop_id<<" is "<<dest_address<<endl;
  	uint16_t protocolwave = 0x88dc;//
	Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (source_nd);
	Ptr <Node> ni = DynamicCast <Node> (source_node);
	CustomDataUnicastTag_ModifiedRouting tag;
	//uint32_t nid = uint32_t(ni->GetId());
	dsrc_packet_initial_timestamp[nid] = Simulator::Now().GetSeconds();
	Time ti = Seconds(Simulator::Now().GetSeconds());
	Ptr <Packet> packet_i = Create<Packet> (arguments.p_size-28);
	tag.SetflowId(flow_id);
	tag.SetpacketId(packet_ID);
	tag.SetchannelId(arguments.channel);
	tag.Setprevious_senderId(source);
	tag.Setprevious_timestamp(MicroSeconds(Now().GetMicroSeconds()));
	tag.Setoriginal_timestamp(MicroSeconds(Now().GetMicroSeconds()));
	packet_i->AddPacketTag(tag);
	WifiMacHeader header;
	packet_i->RemoveHeader(header);
	header.SetAddr1(dest_address);
	packet_i->AddHeader(header);
	//dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
	Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest_address, protocolwave);
	//cout<<"This is flow ID "<<flow_id<<"Transmitting packet ID "<<packet_ID<<" from "<<source<<" to next hop "<<next_hop_id<<"at time "<<Now().GetSeconds()<<endl;
	//uint32_t * pt = tag.GetNodeId();
	//cout<<"node id from tag is "<<*pt<<endl;	
	//Y[*pt - 2] = Y[*pt -2] + 1;
	//cout<<"dsrc total size is "<<dsrc_total_packet_size<<endl;
	//cout<<"packet size is "<<arguments.p_size-28<<endl;
}


void centralized_dsrc_data_unicast(Ptr <NetDevice> source_nd, Ptr <Node> source_node, uint32_t node_index, uint32_t destination)
{
	cout<<"transmiiting a a packet at "<<Now().GetMilliSeconds()<<endl;
	uint32_t nid = source_node->GetId();
	//cout<<"original node id is "<<nid<<endl;
	//uint32_t next_hop = routing_tables[node_index].rows[destination].next_hop;
	uint32_t next_hop = find_next_hop(node_index,destination,node_index);
	cout<<endl<<"next hop from routing table is "<< next_hop <<endl;
	if (next_hop < total_size)
	{
		Ptr <NetDevice> destination_nd = wifidevices.Get(next_hop);
		Address addr = destination_nd->GetAddress();
		Mac48Address dest_address = Mac48Address::ConvertFrom(addr);
		//cout <<endl<<"MAC address of next hop node "<<next_hop<<" is "<<dest_address<<endl;
	  	uint16_t protocolwave = 0x88dc;//
		Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (source_nd);
		Ptr <Node> ni = DynamicCast <Node> (source_node);
		CustomDataUnicastTag_Routing tag;
		//uint32_t nid = uint32_t(ni->GetId());
		dsrc_packet_initial_timestamp[nid] = Simulator::Now().GetSeconds();
		cout<<"This is source node. DSRC data Unicasting from node "<<nid - 2<<endl;
		Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (source_node->GetObject<MobilityModel>());
		Vector posi = mdl->GetPosition();
		Vector current_velocity = mdl->GetVelocity();
		double delta_t = data_transmission_period;
		Vector acceleration = calculate_acceleration(previous_velocity_dsrc[node_index],current_velocity,delta_t);
		Time ti = Seconds(Simulator::Now().GetSeconds());
		Ptr <Packet> packet_i = Create<Packet> (0);
		tag.SetsenderId(nid-2);
		tag.SetNodeId(&nid);
		tag.Setposition(&posi);
		tag.Setvelocity(&current_velocity);
		tag.Setacceleration(&acceleration);
		tag.SetTimestamp(&ti);
		tag.SetdestinationId(destination);
		packet_i->AddPacketTag(tag);
		dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
		Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest_address, protocolwave);
		uint32_t * pt = tag.GetNodeId();
		//cout<<"node id from tag is "<<*pt<<endl;	
		Y[*pt - 2] = Y[*pt -2] + 1;
		//cout<<"dsrc total size is "<<dsrc_total_packet_size<<endl;
		previous_velocity_dsrc[node_index] = current_velocity;
	}
	else
	{
		cout<<"A route does not exist"<<endl;
	}
}

void clear_RQY()
{
    for (int i=0; i<total_size;i++)
    {
    	Y[i] = 0;
	R[i] = 0;
	Q[i] = 0;
    }
    Q_bar = 0;
}

void compute_RandQ(uint32_t timestep)
{
	for (uint32_t i=0;i<total_size;i++)
	{
		R[i] = ((R[i]*(timestep-1)) + Y[i])/timestep;
		double U;
		if (Y[i] > 0)
		{
			U = 1;
		}
		if (Y[i] == 0)
		{
			U = 0;
		}
		Q[i] = ((Q[i]*(timestep-1)) + U)/timestep;
	}
}

void print_RandQ()
{
	for (uint32_t i=0;i<total_size;i++)
	{
		cout<<"R "<<i<<"value is "<<R[i]<<endl;
		cout<<"Q "<<i<<"value is "<<Q[i]<<endl;
	}
}

void send_hybrid_packets(uint32_t destination)
{
	//calculate_normalized_mobility();
	//calculate_network_contention();
	initialize_all_routing_tables();
	reset_delays_and_packets();
	generate_adjacency_matrix();
	generate_linklifetime_matrix();
	generate_delay_matrix();
	calculate_contention();
	for (uint32_t i=0;i<total_size;i++)
	{
		cout<<"calculating dijkstra stable solution"<<endl;
		Simulator::Schedule(Seconds(0.010),calculate_dijkstra_stable_solution,i);
	}

	uint32_t dgcn = data_gathering_cycle_number;
	uint32_t condition1 = (dgcn/125)%2;
	double tg;
	if (condition1 == 0)
	{
		tg = 0.000040*(dgcn%125);
	}
	if (condition1 == 1)
	{
		tg = -0.000040*(dgcn%250) + 0.010;
	}
	
	uint32_t condition2 = (dgcn/50)%2;
	uint32_t x;
	if (condition2 == 0)
	{
		x = ceil((dgcn%50)/10.0);
	}
	
	if (condition2 == 1)
	{
		x = -ceil((dgcn%100)/10.0) + 10;
	}
	
	clear_RQY();
	//x = 1;

	for (uint32_t source=0; source<wifidevices.GetN(); source++)
  	{    
  		cout<<"dgcn is "<<dgcn<<endl;
  		cout<<"x is "<<x<<endl;
  		for (uint32_t i=0; i<x;i++)
  		{
  			uint32_t dest = (destination + source + i)%total_size;  
  			//dest = total_size - 2;
  			//tg = 0.0001; 
			Simulator::Schedule (Seconds (0.020 + tg*source), hybrid_data_unicast, wifidevices.Get (source), dsrc_Nodes.Get(source), source, dest);
		}
	} 
	
	double stepsize = 0.000020;
	for (uint32_t timestep=1; timestep<200*(total_size);timestep++)
	{
		Simulator::Schedule (Seconds (0.020 + (stepsize*timestep)), compute_RandQ, timestep);
	}
	
	Simulator::Schedule (Seconds (0.020 + stepsize*200*total_size), print_RandQ);
	Simulator::Schedule (Seconds (0.020 + stepsize*200*total_size), compute_1hop_delay);
		
}

void send_centralized_packets(uint32_t destination)
{
	//calculate_normalized_mobility();
	//calculate_network_contention();
	initialize_all_routing_tables();
	generate_adjacency_matrix();
	for (uint32_t i=0;i<total_size;i++)
	{
		cout<<"calculating dijkstra solution"<<endl;		
		calculate_dijkstra_solution(i);
	}

	uint32_t dgcn = data_gathering_cycle_number;
	uint32_t condition1 = (dgcn/125)%2;
	double tg;
	if (condition1 == 0)
	{
		tg = 0.000040*(dgcn%125);
	}
	if (condition1 == 1)
	{
		tg = -0.000040*(dgcn%250) + 0.010;
	}
	
	uint32_t condition2 = (dgcn/50)%2;
	uint32_t x;
	if (condition2 == 0)
	{
		x = ceil((dgcn%50)/10.0);
	}
	
	if (condition2 == 1)
	{
		x = -ceil((dgcn%100)/10.0) + 10;
	}
	
	//x = 1;
	
	for (uint32_t source=0; source<wifidevices.GetN(); source++)
  	{    
  		cout<<"dgcn is "<<dgcn<<endl;
  		cout<<"x is "<<x<<endl;
  		for (uint32_t i=0; i<x;i++)
  		{
  			uint32_t dest = (destination + source + i)%total_size;   
    			//dest = total_size - 2;
  			//tg = 0.0001;
			Simulator::Schedule (Seconds (0.020 + tg*source), centralized_dsrc_data_unicast, wifidevices.Get (source), dsrc_Nodes.Get(source), source, dest);
		}
	} 
		
}





void initialize_flow_counters()
{
	vector<vector<vector<tuple<double,uint32_t,uint32_t>>>> all_sorted_delta_next_hop_flow_size_local;

	for (uint32_t fid=0;fid<2*flows;fid++)
  	{    
		//(delta_at_nodes_inst+i)->flow_id = flow_ids[i];
		uint32_t f_size = (demanding_flow_struct_nodes_inst+fid)->f_size;
		//Initialize transmission opportunity
		for(uint32_t i=0;i<total_size;i++)
		{
			for(uint32_t j=0;j<f_size+1;j++)
			{
				for(uint32_t c=170;c<185;c++)
				{
					(pd_all_inst+fid)->pd_inst[i].delivery[c][j] = false;
					(pd_all_inst+fid)->pd_inst[i].pending[c][j] = false;
					(pd_all_inst+fid)->pd_inst[i].attempts[c][j] = 0;
				}
				sent_IDS[fid][i][j] = false;
				s_flow_counter[fid][i][j] = 0;
			}
		}
		
		
		
		for(uint32_t j =0;j<total_size;j++)
		{
			for(uint32_t c= 170;c<185;c++)
			{
				txop_inst[fid].busy[c][j] = false;
				txop_inst[fid].pending_packets[c][j] = 0;
				txop_inst[fid].last_set_timestamp[c][j] = Seconds(Now().GetSeconds());
			}
			
		}
		
		for(uint32_t i=1;i<Flow_size+1;i++)
		{
			routing_packet_final_timestamp[fid][i] = Now().GetSeconds();
			routing_packet_initial_timestamp[fid][i] = Now().GetSeconds();
			packet_delay_routing[fid][i] = 0;
		}
		
		for(uint32_t i =0;i<total_size;i++)
		{
			for(uint32_t j=1;j<Flow_size+1;j++)
			{
				routing_packet_general_final_timestamp [fid][i][j] = Now().GetSeconds();
				routing_packet_general_initial_timestamp [fid][i][j] = Now().GetSeconds();
			}
		}
		
		vector<vector<tuple<double,uint32_t,uint32_t>>> middle_sorted_delta_next_hop_flow_size_local;
		for(uint32_t i=0;i<total_size;i++)
		{
			uint32_t main_flow_packets = ceil(f_size*((load_at_nodes+fid)->load_f[i]));
			vector<tuple<double,uint32_t,uint32_t>> innermost_sorted_delta_next_hop_flow_size;
			for(uint32_t j=0;j<total_size;j++)
			{
				uint32_t sub_flow_packets = ((delta_at_nodes_inst+fid)->delta_fi_inst[i].delta_values[j])*main_flow_packets;
				innermost_sorted_delta_next_hop_flow_size.emplace_back((delta_at_nodes_inst+fid)->delta_fi_inst[i].delta_values[j], j, sub_flow_packets);
				
			}
			
			sort(innermost_sorted_delta_next_hop_flow_size.begin(), innermost_sorted_delta_next_hop_flow_size.end());
			uint32_t total_count =0;
			for(uint32_t j =0;j<total_size;j++)
			{
				auto index_innermost = innermost_sorted_delta_next_hop_flow_size.begin();
				//cout<<subflow_start_time<<total_packet_counter<<total_packets<<endl;
				advance(index_innermost,j);
				double sub_flow_load; 
				uint32_t nid;
				uint32_t sub_flow_packets;
				tie(sub_flow_load, nid, sub_flow_packets) = *index_innermost;
				if(j < (total_size-1))
				{
					uint32_t checker = j%2;
					//cout<<"checker is "<<checker<<endl;
					if(checker == 0)
					{
						get<2>(*index_innermost) = floor(get<2>(*index_innermost));
						total_count = total_count + floor(get<2>(*index_innermost));
					}
					else if (checker == 1)
					{
						get<2>(*index_innermost) = ceil(get<2>(*index_innermost));
						total_count = total_count + ceil(get<2>(*index_innermost));
					}
					
				
				}
				else if (j == (total_size-1))
				{
					uint32_t original_value = ceil(get<2>(*index_innermost));
					total_count = total_count + original_value;
					uint32_t deficiency = main_flow_packets - total_count;
					get<2>(*index_innermost) = original_value + deficiency;	
				}
			}
			
			//cout<<"Inner most list size "<<innermost_sorted_delta_next_hop_flow_size.size()<<endl;
			middle_sorted_delta_next_hop_flow_size_local.emplace_back(innermost_sorted_delta_next_hop_flow_size);	
		}
		//cout<<"Middle list size "<<middle_sorted_delta_next_hop_flow_size_local.size()<<endl;
		all_sorted_delta_next_hop_flow_size_local.emplace_back(middle_sorted_delta_next_hop_flow_size_local);
	}
	all_sorted_delta_next_hop_flow_size = all_sorted_delta_next_hop_flow_size_local;
	//cout<<"Outermost list size "<<all_sorted_delta_next_hop_flow_size.size()<<endl;
	cout<<"Initialized flow counters at "<<Now().GetSeconds()<<endl;

}




void check_and_transmit(uint32_t fid, uint32_t source, uint32_t total_packets, uint32_t total_packet_counter, uint32_t nid, struct custom_struct arguments)
{
	uint32_t packet_id = total_packet_counter + 1;
	arguments.CW = pd_all_inst[fid].pd_inst[nid].attempts[arguments.channel][packet_id] + 2;
	double diff = Now().GetSeconds() - flow_initiation_time;
	if(diff > 0.90)
	{
		pd_all_inst[fid].pd_inst[source].pending[arguments.channel][packet_id] = false;
		cout<<"Intial transmission packet dropped for flow id "<<fid<<"packet ID: "<< packet_id<<endl;
	}
	else
	{
		srand(packet_id+nid+Now().GetMicroSeconds());
		double rand_delay = 0.000010*(rand()%100);
		if(pd_all_inst[fid].pd_inst[nid].delivery[arguments.channel][packet_id] == true)
		{
			retransmitted[fid][nid][packet_id] = false;
			pd_all_inst[fid].pd_inst[source].pending[arguments.channel][packet_id] = false;
			//cout<<"packet has been delivered. Initial transmission success"<<" in flow ID "<<fid<<" packet ID "<<packet_id<<" from "<<source<<" to next hop "<<nid<<"at time "<<Now().GetSeconds()<<endl;
			Simulator::Schedule (Seconds (0.0), updateTxop, fid, source, nid, total_packets - total_packet_counter, false, arguments);
			//do nothing
		}
		else
		{
			bool pending_lower_ids = false;
			uint32_t pending_count = 0;
			for(uint32_t i=0;i<Flow_size+1;i++)
			{
				if (i< packet_id)
				{
					pending_lower_ids = pd_all_inst[fid].pd_inst[source].pending[arguments.channel][i] | pending_lower_ids;
					pending_count++;
				}
			
			}
			if((pending_lower_ids==true)&&(pending_count>0))
			{
				//cout<<"Intial transmission pending for flow id "<<fid<<"packet ID: "<< packet_id<<endl;
				Simulator::Schedule (Seconds (0.000100+rand_delay), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, arguments);
				Simulator::Schedule (Seconds (0.0), updateTxop, fid, source, nid, total_packets - total_packet_counter, false, arguments);
			}
			else
			{
				bool neighborhood_busy = false;
				for(uint32_t i=0;i<total_size;i++)
				{
					if((linklifetimeMatrix_dsrc[source][i]) > 0.0)
					{
						neighborhood_busy = neighborhood_busy | txop_inst[fid].busy[arguments.channel][i];
						for(uint32_t j=0;j<total_size;j++)
						{
							if((linklifetimeMatrix_dsrc[i][j]) > 0.0)
							{
								neighborhood_busy = neighborhood_busy | txop_inst[fid].busy[arguments.channel][j];
							}
						}
					}
				}
				
				//if (txop_inst[fid].busy[nid] == true)
				if (neighborhood_busy == true)
				{
					Simulator::Schedule (Seconds (0.000100+rand_delay), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, arguments);
					Simulator::Schedule (Seconds (0.0), updateTxop, fid, source, nid, total_packets - total_packet_counter, false, arguments);
					
				}
				else
				{
					if(pd_all_inst[fid].pd_inst[nid].attempts[arguments.channel][packet_id] < (B_max))
					{
						uint32_t zeta = 1;
						double tg = 1.01*compute_individual_link_delay(source, pd_all_inst[fid].pd_inst[nid].attempts[arguments.channel][packet_id] + 2, 1, arguments.p_size, nid, zeta);
						Simulator::Schedule (Seconds (0.0), updateTxop, fid, nid, source, total_packets - total_packet_counter, true, arguments);
						switch(arguments.channel)
						{
							case(172):
								Simulator::Schedule (Seconds (0.0), routing_dsrc_data_unicast, wifidevices_172.Get (source), dsrc_Nodes.Get(source), fid, nid, arguments, total_packet_counter+1);
								break;
							case(174):
								Simulator::Schedule (Seconds (0.0), routing_dsrc_data_unicast, wifidevices_174.Get (source), dsrc_Nodes.Get(source), fid, nid, arguments, total_packet_counter+1);
								break;
							case(176):
								Simulator::Schedule (Seconds (0.0), routing_dsrc_data_unicast, wifidevices_176.Get (source), dsrc_Nodes.Get(source), fid, nid, arguments, total_packet_counter+1);
								break;
							case(178):
								Simulator::Schedule (Seconds (0.0), routing_dsrc_data_unicast, wifidevices.Get (source), dsrc_Nodes.Get(source), fid, nid, arguments, total_packet_counter+1);
								break;
							case(180):
								Simulator::Schedule (Seconds (0.0), routing_dsrc_data_unicast, wifidevices_180.Get (source), dsrc_Nodes.Get(source), fid, nid, arguments, total_packet_counter+1);
								break;
							case(182):
								Simulator::Schedule (Seconds (0.0), routing_dsrc_data_unicast, wifidevices_182.Get (source), dsrc_Nodes.Get(source), fid, nid, arguments, total_packet_counter+1);
							break;
							case(184):
								Simulator::Schedule (Seconds (0.0), routing_dsrc_data_unicast, wifidevices_184.Get (source), dsrc_Nodes.Get(source), fid, nid, arguments, total_packet_counter+1);
								break;
							default:
							break;
						
						}
						
						Simulator::Schedule (Seconds (tg+0.000050+rand_delay), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, arguments);
						routing_packet_initial_timestamp[fid][packet_id] = Now().GetSeconds();
						sent_IDS[fid][source][packet_id] = true;
						routing_packet_general_initial_timestamp[fid][source][packet_id] = Now().GetSeconds();
						pd_all_inst[fid].pd_inst[nid].attempts[arguments.channel][packet_id]++;
					}
					else
					{
						pd_all_inst[fid].pd_inst[source].pending[arguments.channel][packet_id] = false;
						cout<<"Intial transmission packet dropped for flow id "<<fid<<"packet ID: "<< packet_id<<endl;
					
					}
				}
			}
		}
	}
}

void initiate_all_flows()
{	
	flow_initiation_time = Now().GetSeconds();
	for (uint32_t fid=0;fid<2*flows;fid++)
  	{    
  		
		uint32_t source = (delta_at_nodes_inst+fid)->source_f;
		//cout<<"source node is "<<source<<endl;
		uint32_t dest =   (delta_at_nodes_inst+fid)->destination_f;
		//(delta_at_nodes_inst+i)->flow_id = flow_ids[i];
		uint32_t f_size = (demanding_flow_struct_nodes_inst+fid)->f_size;
		uint32_t p_size = (demanding_flow_struct_nodes_inst+fid)->p_size;
		double total_load = (load_at_nodes+fid)->load_f[source];
		uint32_t total_packets = ceil(total_load*f_size);
		
		uint32_t zeta;
		if (flows == 1)
		{
			zeta = 14;
		}
		else
		{
			if(routing_algorithm != 4)
			{
				zeta = 18;
			}
			else
			{
				zeta = 14 + 2*scheduled_flows;
			
			}
		}
		double tg = compute_link_delay(source, 1.0, 1, p_size, dest, zeta);
		//cout<<"Time gap is "<<tg<<endl;
		double subflow_start_time = 0.0;
		uint32_t total_packet_counter = 0;
		
		auto index_top = all_sorted_delta_next_hop_flow_size.begin();
		advance(index_top,fid);
		//cout<<subflow_start_time<<total_packet_counter<<total_packets<<endl;

		auto index_middle = index_top->begin();
		advance(index_middle,source);	
		
		uint32_t total_subflows =0;
		for(uint32_t j =0;j<total_size;j++)
		{
			auto index_innermost = index_middle->begin();
			//cout<<subflow_start_time<<total_packet_counter<<total_packets<<endl;
			advance(index_innermost,j);
			double sub_flow_load; 
			uint32_t nid;
			uint32_t sub_flow_packets;
			tie(sub_flow_load, nid, sub_flow_packets) = *index_innermost;
			cout<<"flow id "<<fid<<"sub flow load is "<<sub_flow_load<<" next hop "<<nid<<"packets "<<sub_flow_packets<<endl;		
			//uint32_t sub_flow_counter = 0;
			//cout<<sub_flow_counter<<endl;
			
			if(sub_flow_load !=0.0)
			{	
				total_subflows++;
			}
		}
		
		uint32_t pending_subflows = total_subflows;
		//uint32_t chnl = 178;
		uint32_t subflow_id = 0;
		struct custom_struct size_channel;
		size_channel.p_size = p_size;
		size_channel.channel = 178;
		for(uint32_t j =0;j<total_size;j++)
		{
			auto index_innermost = index_middle->begin();
			//cout<<subflow_start_time<<total_packet_counter<<total_packets<<endl;
			advance(index_innermost,j);
			double sub_flow_load; 
			uint32_t nid;
			uint32_t sub_flow_packets;
			tie(sub_flow_load, nid, sub_flow_packets) = *index_innermost;
			//cout<<"sub flow load is "<<sub_flow_load<<" next hop "<<nid<<"packets "<<sub_flow_packets<<endl;		
			uint32_t sub_flow_counter = 0;
			//cout<<sub_flow_counter<<endl;
			
			if (routing_algorithm == 8)
			{
				size_channel.channel = 178;
				if(sub_flow_load !=0.0)
				{	
					while(sub_flow_counter<sub_flow_packets)
					{
						if(routing_algorithm == 1)
						{
							Simulator::Schedule (Seconds ((fid*tg/2*(flows)) + ((subflow_id*tg) +(total_subflows*tg*sub_flow_counter))), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
							pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
						
						}
						else
						{
							Simulator::Schedule (Seconds ((fid*tg/2*(flows)) +subflow_start_time + (tg*sub_flow_counter)), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
							pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
						}
						sub_flow_counter++;
						total_packet_counter++;
						get<2>(*index_innermost) = get<2>(*index_innermost) - 1;
						
					}
					subflow_id++;
				}
				subflow_start_time = (tg*total_packet_counter);
		  	}
		  	else
		  	{
		  		if(pending_subflows > 6)
		  		{
		  			size_channel.channel = 178;
			  		if(sub_flow_load !=0.0)
					{	
						while(sub_flow_counter<sub_flow_packets)
						{
							if(routing_algorithm == 1)
							{
								Simulator::Schedule (Seconds ((fid*tg/2*(flows)) + subflow_start_time + ((subflow_id*tg) +(total_subflows*tg*sub_flow_counter))), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
								pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
							
							}
							else
							{
								Simulator::Schedule (Seconds ((fid*tg/2*(flows)) +subflow_start_time + (tg*sub_flow_counter)), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
								pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
							}
							sub_flow_counter++;
							total_packet_counter++;
							get<2>(*index_innermost) = get<2>(*index_innermost) - 1;
							
						}
						subflow_id++;
						pending_subflows--;
						cout<<"scheduled in channel 7"<<endl;
					}
					subflow_start_time = (tg*total_packet_counter);
				}
				else
				{
					switch(pending_subflows)
					{
						case(6):
							size_channel.channel = 172;
							if(sub_flow_load !=0.0)
							{	
								
								while(sub_flow_counter<sub_flow_packets)
								{
									if(routing_algorithm == 1)
									{
										Simulator::Schedule (Seconds ((fid*tg/2*(flows)) + ((subflow_id*tg) +(total_subflows*tg*sub_flow_counter))), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
										pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
									
									}
									else
									{
										Simulator::Schedule (Seconds ((fid*tg/2*(flows)) +subflow_start_time + (tg*sub_flow_counter)), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
										pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
									}
									sub_flow_counter++;
									total_packet_counter++;
									get<2>(*index_innermost) = get<2>(*index_innermost) - 1;
									
								}
								subflow_id++;
								pending_subflows--;
								cout<<"scheduled in channel 6"<<endl;
							}
							subflow_start_time = subflow_start_time + (tg*sub_flow_counter)/2.0;
							break;
						case(5):
							size_channel.channel = 174;
							if(sub_flow_load !=0.0)
							{	
								while(sub_flow_counter<sub_flow_packets)
								{
									if(routing_algorithm == 1)
									{
										Simulator::Schedule (Seconds ((fid*tg/2*(flows)) + ((subflow_id*tg) +(total_subflows*tg*sub_flow_counter))), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
										pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
									
									}
									else
									{
										Simulator::Schedule (Seconds ((fid*tg/2*(flows)) +subflow_start_time + (tg*sub_flow_counter)), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
										pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
									}
									sub_flow_counter++;
									total_packet_counter++;
									get<2>(*index_innermost) = get<2>(*index_innermost) - 1;
									
								}
								subflow_id++;
								pending_subflows--;
								cout<<"scheduled in channel 5"<<endl;
							}
							subflow_start_time = subflow_start_time + (tg*sub_flow_counter)/2.0;
							break;
						case(4):
							size_channel.channel = 176;
							if(sub_flow_load !=0.0)
							{	
								
								while(sub_flow_counter<sub_flow_packets)
								{
									if(routing_algorithm == 1)
									{
										Simulator::Schedule (Seconds ((fid*tg/2*(flows)) + ((subflow_id*tg) +(total_subflows*tg*sub_flow_counter))), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
										pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
									
									}
									else
									{
										Simulator::Schedule (Seconds ((fid*tg/2*(flows)) +subflow_start_time + (tg*sub_flow_counter)), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
										pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
									}
									sub_flow_counter++;
									total_packet_counter++;
									get<2>(*index_innermost) = get<2>(*index_innermost) - 1;
									
								}
								subflow_id++;
								pending_subflows--;
								cout<<"scheduled in channel 4"<<endl;
							}
							subflow_start_time = subflow_start_time + (tg*sub_flow_counter)/2.0;
							break;
						case(3):
							size_channel.channel = 180;
							if(sub_flow_load !=0.0)
							{	
								while(sub_flow_counter<sub_flow_packets)
								{
									if(routing_algorithm == 1)
									{
										Simulator::Schedule (Seconds ((fid*tg/2*(flows)) + ((subflow_id*tg) +(total_subflows*tg*sub_flow_counter))), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
										pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
									
									}
									else
									{
										Simulator::Schedule (Seconds ((fid*tg/2*(flows)) +subflow_start_time + (tg*sub_flow_counter)), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
										pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
									}
									sub_flow_counter++;
									total_packet_counter++;
									get<2>(*index_innermost) = get<2>(*index_innermost) - 1;
									
								}
								subflow_id++;
								pending_subflows--;
								cout<<"scheduled in channel 3"<<endl;
							}
							subflow_start_time = subflow_start_time + (tg*sub_flow_counter)/2.0;
							break;
						case(2):
							size_channel.channel = 182;
							if(sub_flow_load !=0.0)
							{	
								while(sub_flow_counter<sub_flow_packets)
								{
									if(routing_algorithm == 1)
									{
										Simulator::Schedule (Seconds ((fid*tg/2*(flows)) + ((subflow_id*tg) +(total_subflows*tg*sub_flow_counter))), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
										pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
									
									}
									else
									{
										Simulator::Schedule (Seconds ((fid*tg/2*(flows)) +subflow_start_time + (tg*sub_flow_counter)), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
										pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
									}
									sub_flow_counter++;
									total_packet_counter++;
									get<2>(*index_innermost) = get<2>(*index_innermost) - 1;
									
								}
								subflow_id++;
								pending_subflows--;
								cout<<"scheduled in channel 2"<<endl;
							}
							subflow_start_time = subflow_start_time + (tg*sub_flow_counter)/2.0;
							break;
						case(1):
							size_channel.channel = 184;
							if(sub_flow_load !=0.0)
							{	
								while(sub_flow_counter<sub_flow_packets)
								{
									if(routing_algorithm == 1)
									{
										Simulator::Schedule (Seconds ((fid*tg/2*(flows)) + ((subflow_id*tg) +(total_subflows*tg*sub_flow_counter))), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
										pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
									
									}
									else
									{
										Simulator::Schedule (Seconds ((fid*tg/2*(flows)) +subflow_start_time + (tg*sub_flow_counter)), check_and_transmit, fid, source, total_packets, total_packet_counter, nid, size_channel);
										pd_all_inst[fid].pd_inst[source].pending[size_channel.channel][total_packet_counter+1] = true;
									}
									sub_flow_counter++;
									total_packet_counter++;
									get<2>(*index_innermost) = get<2>(*index_innermost) - 1;
									
								}
								subflow_id++;
								pending_subflows--;
								cout<<"scheduled in channel 1"<<endl;
							}
							subflow_start_time = subflow_start_time + (tg*sub_flow_counter)/2.0;
							break;
						default:
							break;
					
					}
				}
		  	}	
		}	

		if(total_packet_counter == total_packets)
		{
			cout<<"Flow id "<<fid<<" scheduled "<<total_packets<<"total packets from "<<source<<endl;
		}
		destination_counter[fid] = 0;
		
			
	}
		
}

void send_distributed_packets(uint32_t destination)
{
	//calculate_normalized_mobility();
	//calculate_network_contention();


	uint32_t dgcn = data_gathering_cycle_number;
	uint32_t condition1 = (dgcn/125)%2;
	uint32_t tg;
	if (condition1 == 0)
	{
		tg = 0.000040*(dgcn%125);
	}
	if (condition1 == 1)
	{
		tg = -0.000040*(dgcn%250) + 0.010;
	}
	
	uint32_t condition2 = (dgcn/50)%2;
	uint32_t x;
	if (condition2 == 0)
	{
		x = ceil((dgcn%50)/10.0);
	}
	
	if (condition2 == 1)
	{
		x = -ceil((dgcn%100)/10.0) + 10;
	}
	//x = 1;
  	Ptr <Node> nu;
	Ptr <SimpleUdpApplication> udp_app;

	for (uint32_t source=0; source<wifidevices.GetN(); source++)
  	{    
  		cout<<"dgcn is "<<dgcn<<endl;
  		cout<<"x is "<<x<<endl;
		if (source < N_Vehicles)
  		{
	  		nu = DynamicCast <Node> (Vehicle_Nodes.Get(source));	
	  		udp_app = DynamicCast <SimpleUdpApplication> (apps.Get(source));
	  	}
	  	if (source > (N_Vehicles-1))	
	  	{
	  		nu = DynamicCast <Node> (RSU_Nodes.Get(source-N_Vehicles));	
	  		udp_app = DynamicCast <SimpleUdpApplication> (RSU_apps.Get(source-N_Vehicles));
	  	}
  		for (uint32_t i=0; i<x;i++)
  		{		
  			uint32_t dest = (destination + source + i)%total_size;
  			//dest = total_size - 2;
  			//tg = 0.0001;
			if (dest < N_Vehicles)
			{
				Simulator::Schedule(Seconds(0.020 + tg*source),AODV_dataunicast_alone, udp_app, nu, Vehicle_Nodes.Get(dest));
			}
			
			if (dest > (N_Vehicles -1))
			{
				Simulator::Schedule(Seconds(0.020 + tg*source),AODV_dataunicast_alone, udp_app, nu, RSU_Nodes.Get(dest-N_Vehicles));
			}
		}
	} 
		
}


void distributed_dsrc_data_broadcast(Ptr <NetDevice> nd, Ptr <Node> node, uint32_t node_index)
{
	//uint32_t nid = node->GetId();
	Mac48Address dest = Mac48Address::GetBroadcast();
  	uint16_t protocolwave = 0x88dc;//ethertype for WAVE is set here.
	Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (nd);
	Ptr <Node> ni = DynamicCast <Node> (node);
	CustomDataTag tag;
	uint32_t nid = uint32_t(ni->GetId());
	if (paper == 0)
	{
		dsrc_packet_initial_timestamp[nid] = Simulator::Now().GetSeconds();
	}
	cout<<"DSRC data Broadcasting from node "<<nid<<endl;
	Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (node->GetObject<MobilityModel>());
	Vector posi = mdl->GetPosition();
	Vector current_velocity = mdl->GetVelocity();
	double delta_t = data_transmission_period;
	Vector acceleration = calculate_acceleration(previous_velocity_dsrc[node_index],current_velocity,delta_t);
	Time ti = Seconds(Simulator::Now().GetSeconds());
	Ptr <Packet> packet_i = Create<Packet> (0);
	tag.SetNodeId(nid);
	tag.SetPosition(posi);
	tag.SetVelocity(current_velocity);
	tag.SetAcceleration(acceleration);
	tag.SetTimestamp(ti);
	packet_i->AddPacketTag(tag);
	dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
	Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);	
	cout<<"dsrc total size is "<<dsrc_total_packet_size<<endl;
	previous_velocity_dsrc[node_index] = current_velocity;
}


void dsrc_metadata_broadcast(Ptr <NetDevice> nd, Ptr <Node> node, uint32_t node_index)
{	
	Mac48Address dest = Mac48Address::GetBroadcast();
  	uint16_t protocolwave = 0x88dc;//ethertype for WAVE is set here.
	Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (nd);
	Ptr <Node> ni = DynamicCast <Node> (node);
	//cout<<"DSRC metadata broadcast from "<<ni->GetId();
	CustomMetaDataBroadcastTag tag;
	uint32_t nid = uint32_t(ni->GetId());
	if (nid==2)
	{
		dsrc_total_packet_size = 0;
		dsrc_initial_timestamp = Simulator::Now().GetSeconds();
	}
	packet_initial_timestamp[nid] = Simulator::Now().GetSeconds();
	tag.SetNodeId(nid);
	Time ti = Seconds(Simulator::Now().GetSeconds());
	tag.SetTimestamp(ti);
	Ptr <Packet> packet_i = Create<Packet> (0);
	packet_i->AddPacketTag(tag);
	dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
	cout<<"dsrc total size is "<<dsrc_total_packet_size<<endl;
	Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
}


void dsrc_metadata_broadcast_subsequent(Ptr <NetDevice> nd, Ptr <Node> node, uint32_t node_index)
{
	Ptr <Node> ni = DynamicCast <Node> (node);
	//cout<<"DSRC metadata broadcast from "<<ni->GetId();
	uint32_t nid = uint32_t(ni->GetId());
	if (X_nodes[nid] == 1)
	{
		packet_initial_timestamp[nid] = Simulator::Now().GetSeconds();
		CustomMetaDataBroadcastTag tag;
		Mac48Address dest = Mac48Address::GetBroadcast();
  		uint16_t protocolwave = 0x88dc;//ethertype for WAVE is set here.
		Ptr <WifiNetDevice> wdi = DynamicCast <WifiNetDevice> (nd);
		cout<<"subsequent metadata broadcast from "<<nid<<endl;
		tag.SetNodeId(nid);
		Time ti = Seconds(Simulator::Now().GetSeconds());
		tag.SetTimestamp(ti);
		Ptr <Packet> packet_i = Create<Packet> (0);
		packet_i->AddPacketTag(tag);
		dsrc_total_packet_size = dsrc_total_packet_size + packet_i->GetSerializedSize();
		cout<<"dsrc total size is "<<dsrc_total_packet_size<<endl;
		Simulator::Schedule (Seconds(0) , &WifiNetDevice::Send, wdi, packet_i, dest, protocolwave);
	}
}


Vector previous_velocity_LTE[total_size];

void send_LTE_routing_data_alone(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> node_source, Ptr <Node> destination_node, uint32_t node_index)
{
  	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
	Ipv4InterfaceAddress iaddr = ipv4->GetAddress(2,0);//2nd IPv4 interface,0th address index
	Ipv4Address dest_ip = iaddr.GetLocal();
	Ptr <Node> nu = DynamicCast <Node> (node_source);
	Ptr <Packet> packet1 = Create <Packet> (0);
	
	uint32_t nid;
        Vector posi[2];
	Vector veli[2];
	Vector acci[2];
	uint32_t nodeid[2];

	nid = uint32_t(nu->GetId()) - 2;
        posi[0] = (routing_data_at_nodes_inst+nid)->position;
	veli[0] = (routing_data_at_nodes_inst+nid)->velocity;
	acci[0] = (routing_data_at_nodes_inst+nid)->acceleration;
	nodeid[0] = (routing_data_at_nodes_inst+nid)->nodeid;
	
	CustomStatusDataUplinkTag1 tag1;
	tag1.SetNodeId(nodeid);
	tag1.Setposition(posi);
	tag1.Setvelocity(veli);
	tag1.Setacceleration(acci);

	packet1->AddPacketTag(tag1);
	//lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
	Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
		
	//cout<<"sent status data from node "<<nid<<"sent velocity"<<veli[0]<<endl;
}


void RSU_routing_statusdataunicast_alone(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> source_node, Ptr <Node> destination_node)
{
	Ptr <Node> nu = DynamicCast <Node> (source_node);
	uint32_t nid = uint32_t(nu->GetId());
	Ptr <Packet> packet1 = Create <Packet> (0);
  	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
  	Ipv4InterfaceAddress iaddr;
  	if(N_Vehicles > 0)
  	{
		iaddr = ipv4->GetAddress(1,0);//2nd IPv4 interface,0th address index
	}
	else if (N_Vehicles == 0)
	{
		iaddr = ipv4->GetAddress(0,0);//1st IPv4 interface,0th address index
	}
	Ipv4Address dest_ip = iaddr.GetLocal();	
	
	//uint32_t nid;
        Vector posi[2];
	Vector veli[2];
	Vector acci[2];
	uint32_t nodeid[2];

	nid = uint32_t(nu->GetId()) - 2;
        posi[0] = (routing_data_at_nodes_inst+nid)->position;
	veli[0] = (routing_data_at_nodes_inst+nid)->velocity;
	acci[0] = (routing_data_at_nodes_inst+nid)->acceleration;
	nodeid[0] = (routing_data_at_nodes_inst+nid)->nodeid;
	
	CustomStatusDataUplinkTag1 tag1;
	tag1.SetNodeId(nodeid);
	tag1.Setposition(posi);
	tag1.Setvelocity(veli);
	tag1.Setacceleration(acci);
	
	packet1->AddPacketTag(tag1);
	Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
		
	//cout<<"sent status data from node "<<nid<<"sent velocity"<<veli[0]<<endl;
}


void RSU_flowdata_unicast_alone(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> source_node, Ptr <Node> destination_node)
{
	Ptr <Node> nu = DynamicCast <Node> (source_node);
	uint32_t nid = uint32_t(nu->GetId());
	Ptr <Packet> packet1 = Create <Packet> (0);
  	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
  	Ipv4InterfaceAddress iaddr;
  	if(N_Vehicles > 0)
  	{
		iaddr = ipv4->GetAddress(1,0);//2nd IPv4 interface,0th address index
	}
	else if (N_Vehicles == 0)
	{
		iaddr = ipv4->GetAddress(0,0);//1st IPv4 interface,0th address index
	}
	Ipv4Address dest_ip = iaddr.GetLocal();	
	
	
        uint32_t source[2*flows];
        uint32_t destination[2*flows];
        uint32_t X[2*flows];
        uint32_t P[2*flows];
        uint32_t Q[2*flows];
	
	

	nid = uint32_t(nu->GetId()) - 2;
	for (uint32_t i=0;i< (2*flows);i++)
	{
		source[i] = (demanding_flow_struct_nodes_inst+i)->source;
		destination[i] = (demanding_flow_struct_nodes_inst+i)->destination;
		X[i] = (demanding_flow_struct_nodes_inst+i)->f_size;
		P[i] = (demanding_flow_struct_nodes_inst+i)->p_size;
		Q[i] = (demanding_flow_struct_nodes_inst+i)->qos;
	}
	
	CustomFlowDataUplinkTag1 tag1;
	tag1.Setsource(source);
	tag1.Setdestination(destination);
	tag1.SetX(X);
	tag1.SetP(P);
	tag1.SetQ(Q);
	
	packet1->AddPacketTag(tag1);
	Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
		
	cout<<"sent all flow data from node "<<nid<<endl;
}



void send_LTE_data_alone(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> node_source, Ptr <Node> destination_node, uint32_t node_index)
{
  	Ptr <Ipv4> ipv4;  	
  	ipv4 = destination_node->GetObject<Ipv4>();
	Ipv4InterfaceAddress iaddr = ipv4->GetAddress(2,0);//2nd IPv4 interface,0th address index
	Ipv4Address dest_ip = iaddr.GetLocal();
	Ptr <Node> nu = DynamicCast <Node> (node_source);
	Ptr <Packet> packet1 = Create <Packet> (0);

	//adding own data to the data_at_nodes
	uint32_t nid = uint32_t(nu->GetId());
	Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (node_source->GetObject<MobilityModel>());
        Vector posi = mdl->GetPosition();
	Vector veli = mdl->GetVelocity();
	double delta_t = data_transmission_period;
	Vector acci = calculate_acceleration(previous_velocity_LTE[node_index],veli,delta_t);
	previous_velocity_LTE[node_index] = veli;
	Time ti = Seconds(Simulator::Now().GetSeconds());
	uint32_t size_nei = getNeighborsize((neighbordata_inst+nid));
	uint32_t neighborid[size_nei];
	for (uint32_t i=0;i<size_nei;i++)
	{
		neighborid[i] = large;
	}
	
	uint32_t j=0;
	for (uint32_t i=0;i<max;i++)
	{
		if ((((neighbordata_inst+nid)->neighborid[i]) != large) and (j<size_nei))
		{
			neighborid[j] = (neighbordata_inst+nid)->neighborid[i];
	  		j++;
	  	}
	}
	add_received_data_at_nodes(data_at_nodes_inst+nid, posi, veli, acci, nid, neighborid, size_nei);
  	//send the content at data at nodes to the mangement node
  	uint32_t size = get_size_of_data_at_nodes(data_at_nodes_inst+nid);
  	uint32_t nodeid[size];
	Vector position[size];
	Vector acceleration[size];
	Vector velocity[size];
	Time timestamp[size];

	
	for(uint32_t i=0;i<size;i++)
	{
		nodeid[i] = large;
		position[i] = Vector(0,0,0);
		acceleration[i] = Vector(0,0,0);
		velocity[i] = Vector(0,0,0);
		timestamp[i] = Simulator::Now();
	}
	
	uint32_t k=0;
	for(uint32_t i=0;i<max;i++)
	{
		if (((data_at_nodes_inst+nid)->nodeid[i] != large) and (k<size))
		{
			nodeid[k] = (data_at_nodes_inst+nid)->nodeid[i];
			position[k] = (data_at_nodes_inst+nid)->position[i];
			velocity[k] = (data_at_nodes_inst+nid)->velocity[i];
			acceleration[k] = (data_at_nodes_inst+nid)->acceleration[i];
			timestamp[k] = (data_at_nodes_inst+nid)->timestamp[i];
			k++;
		}
		
	}
		
	
	CustomDataUnicastTag1 tag1;
	CustomDataUnicastTag2 tag2;
	CustomDataUnicastTag3 tag3;
	CustomDataUnicastTag4 tag4;
	CustomDataUnicastTag5 tag5;
	CustomDataUnicastTag6 tag6;
	CustomDataUnicastTag7 tag7;
	CustomDataUnicastTag8 tag8;
	CustomDataUnicastTag9 tag9;
	CustomDataUnicastTag10 tag10;
	CustomDataUnicastTag11 tag11;
	CustomDataUnicastTag12 tag12;
	CustomDataUnicastTag13 tag13;
	CustomDataUnicastTag14 tag14;
	CustomDataUnicastTag15 tag15;
	CustomDataUnicastTag16 tag16;
	CustomDataUnicastTag17 tag17;
	CustomDataUnicastTag18 tag18;
	CustomDataUnicastTag19 tag19;
	CustomDataUnicastTag20 tag20;
	CustomDataUnicastTag21 tag21;
	CustomDataUnicastTag22 tag22;
	CustomDataUnicastTag23 tag23;
	CustomDataUnicastTag24 tag24;
	CustomDataUnicastTag25 tag25;
	CustomDataUnicastTag tag;
	switch (size)
	{	
		case 1:
			tag1.SetsenderId(nid);
			tag1.SetNodeId(nodeid);
			tag1.Setposition(position);
			tag1.Setvelocity(velocity);
			tag1.Setacceleration(acceleration);
			tag1.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag1);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 2:
			tag2.SetsenderId(nid);
			tag2.SetNodeId(nodeid);
			tag2.Setposition(position);
			tag2.Setvelocity(velocity);
			tag2.Setacceleration(acceleration);
			tag2.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag2);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 3:
			tag3.SetsenderId(nid);
			tag3.SetNodeId(nodeid);
			tag3.Setposition(position);
			tag3.Setvelocity(velocity);
			tag3.Setacceleration(acceleration);
			tag3.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag3);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 4:
			tag4.SetsenderId(nid);
			tag4.SetNodeId(nodeid);
			tag4.Setposition(position);
			tag4.Setvelocity(velocity);
			tag4.Setacceleration(acceleration);
			tag4.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag4);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 5:
			tag5.SetsenderId(nid);
			tag5.SetNodeId(nodeid);
			tag5.Setposition(position);
			tag5.Setvelocity(velocity);
			tag5.Setacceleration(acceleration);
			tag5.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag5);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 6:
			tag6.SetsenderId(nid);
			tag6.SetNodeId(nodeid);
			tag6.Setposition(position);
			tag6.Setvelocity(velocity);
			tag6.Setacceleration(acceleration);
			tag6.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag6);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 7:
			tag7.SetsenderId(nid);
			tag7.SetNodeId(nodeid);
			tag7.Setposition(position);
			tag7.Setvelocity(velocity);
			tag7.Setacceleration(acceleration);
			tag7.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag7);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 8:
			tag8.SetsenderId(nid);
			tag8.SetNodeId(nodeid);
			tag8.Setposition(position);
			tag8.Setvelocity(velocity);
			tag8.Setacceleration(acceleration);
			tag8.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag8);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 9:
			tag9.SetsenderId(nid);
			tag9.SetNodeId(nodeid);
			tag9.Setposition(position);
			tag9.Setvelocity(velocity);
			tag9.Setacceleration(acceleration);
			tag9.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag9);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		
		case 10:
			tag10.SetsenderId(nid);
			tag10.SetNodeId(nodeid);
			tag10.Setposition(position);
			tag10.Setvelocity(velocity);
			tag10.Setacceleration(acceleration);
			tag10.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag10);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 11:
			tag11.SetsenderId(nid);
			tag11.SetNodeId(nodeid);
			tag11.Setposition(position);
			tag11.Setvelocity(velocity);
			tag11.Setacceleration(acceleration);
			tag11.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag11);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 12:
			tag12.SetsenderId(nid);
			tag12.SetNodeId(nodeid);
			tag12.Setposition(position);
			tag12.Setvelocity(velocity);
			tag12.Setacceleration(acceleration);
			tag12.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag12);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 13:
			tag13.SetsenderId(nid);
			tag13.SetNodeId(nodeid);
			tag13.Setposition(position);
			tag13.Setvelocity(velocity);
			tag13.Setacceleration(acceleration);
			tag13.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag13);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;	
		case 14:
			tag14.SetsenderId(nid);
			tag14.SetNodeId(nodeid);
			tag14.Setposition(position);
			tag14.Setvelocity(velocity);
			tag14.Setacceleration(acceleration);
			tag14.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag14);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 15:
			tag15.SetsenderId(nid);
			tag15.SetNodeId(nodeid);
			tag15.Setposition(position);
			tag15.Setvelocity(velocity);
			tag15.Setacceleration(acceleration);
			tag15.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag15);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;

		case 16:
			tag16.SetsenderId(nid);
			tag16.SetNodeId(nodeid);
			tag16.Setposition(position);
			tag16.Setvelocity(velocity);
			tag16.Setacceleration(acceleration);
			tag16.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag16);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 17:
			tag17.SetsenderId(nid);
			tag17.SetNodeId(nodeid);
			tag17.Setposition(position);
			tag17.Setvelocity(velocity);
			tag17.Setacceleration(acceleration);
			tag17.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag17);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 18:
			tag18.SetsenderId(nid);	
			tag18.SetNodeId(nodeid);
			tag18.Setposition(position);
			tag18.Setvelocity(velocity);
			tag18.Setacceleration(acceleration);
			tag18.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag18);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 19:
			tag19.SetsenderId(nid);
			tag19.SetNodeId(nodeid);
			tag19.Setposition(position);
			tag19.Setvelocity(velocity);
			tag19.Setacceleration(acceleration);
			tag19.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag19);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 20:
			tag20.SetsenderId(nid);
			tag20.SetNodeId(nodeid);
			tag20.Setposition(position);
			tag20.Setvelocity(velocity);
			tag20.Setacceleration(acceleration);
			tag20.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag20);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 21:
			tag21.SetsenderId(nid);
			tag21.SetNodeId(nodeid);
			tag21.Setposition(position);
			tag21.Setvelocity(velocity);
			tag21.Setacceleration(acceleration);
			tag21.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag21);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 22:
			tag22.SetsenderId(nid);
			tag22.SetNodeId(nodeid);
			tag22.Setposition(position);
			tag22.Setvelocity(velocity);
			tag22.Setacceleration(acceleration);
			tag22.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag22);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 23:
			tag23.SetsenderId(nid);
			tag23.SetNodeId(nodeid);
			tag23.Setposition(position);
			tag23.Setvelocity(velocity);
			tag23.Setacceleration(acceleration);
			tag23.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag23);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 24:
			tag24.SetsenderId(nid);
			tag24.SetNodeId(nodeid);
			tag24.Setposition(position);
			tag24.Setvelocity(velocity);
			tag24.Setacceleration(acceleration);
			tag24.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag24);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		case 25:
			tag25.SetsenderId(nid);
			tag25.SetNodeId(nodeid);
			tag25.Setposition(position);
			tag25.Setvelocity(velocity);
			tag25.Setacceleration(acceleration);
			tag25.SetTimestamp(timestamp);
			packet1->AddPacketTag(tag25);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;
		default:
			cout<<"Cellular:maximum status datasize exceeded . size is  "<<size<<endl;
			tag.SetsenderId(nid);
			tag.SetNodeId((data_at_nodes_inst+nid)->nodeid);
			tag.Setposition((data_at_nodes_inst+nid)->position);
			tag.Setvelocity((data_at_nodes_inst+nid)->velocity);
			tag.Setacceleration((data_at_nodes_inst+nid)->acceleration);
			tag.SetTimestamp((data_at_nodes_inst+nid)->timestamp);
			packet1->AddPacketTag(tag);
			lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
			Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
			break;	
	}
	cout<<"lte total packet size is "<<lte_total_packet_size<<endl;
}




void send_LTE_data_agent(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> node_source, Ptr <Node> destination_node, uint32_t node_index)
{
	Ptr <Node> nu = DynamicCast <Node> (node_source);
	uint32_t nid = uint32_t(nu->GetId());
	if (X_nodes[nid] == 1)
	{
		
		Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (node_source->GetObject<MobilityModel>());
        	Vector posi = mdl->GetPosition();
		Vector veli = mdl->GetVelocity();
		double delta_t = data_transmission_period;
		Vector acci = calculate_acceleration(previous_velocity_LTE[node_index],veli,delta_t);
		previous_velocity_LTE[node_index] = veli;
		//adding own data to the data_at_nodes
		uint32_t size_nei = getNeighborsize((neighbordata_inst+nid));
		uint32_t neighborid[size_nei];
		for (uint32_t i=0;i<size_nei;i++)
		{
			neighborid[i] = large;
		}
		
		uint32_t j=0;
		for (uint32_t i=0;i<max;i++)
		{
			if ((((neighbordata_inst+nid)->neighborid[i]) != large) and (j<size_nei))
			{
				neighborid[j] = (neighbordata_inst+nid)->neighborid[i];
		  		j++;
		  	}
		}
		add_received_data_at_nodes(data_at_nodes_inst+nid, posi, veli, acci, nid, neighborid, size_nei);
	  	//send the content at data at nodes to the mangement node
	  	uint32_t size = get_size_of_data_at_nodes(data_at_nodes_inst+nid);
	  	uint32_t nodeid[size];
		Vector position[size];
		Vector acceleration[size];
		Vector velocity[size];
		Time timestamp[size];
		struct set_of_neighbors neighbor_set[size];
		bool neighbors_changed[size];
		
		for(uint32_t i=0;i<size;i++)
		{
			nodeid[i] = large;
			position[i] = Vector(0,0,0);
			acceleration[i] = Vector(0,0,0);
			velocity[i] = Vector(0,0,0);
			timestamp[i] = Simulator::Now();
			for (uint32_t j=0;j<max;j++)
			{
				neighbor_set[i].neighbors[j] = large;
			}
			neighbors_changed[i] = false;
		}
		
		uint32_t k=0;
		for(uint32_t i=0;i<max;i++)
		{
			if (((data_at_nodes_inst+nid)->nodeid[i] != large) and (k<size))
			{
				nodeid[k] = (data_at_nodes_inst+nid)->nodeid[i];
				position[k] = (data_at_nodes_inst+nid)->position[i];
				velocity[k] = (data_at_nodes_inst+nid)->velocity[i];
				acceleration[k] = (data_at_nodes_inst+nid)->acceleration[i];
				timestamp[k] = (data_at_nodes_inst+nid)->timestamp[i];
				neighbor_set[k] = (data_at_nodes_inst+nid)->neighbor_set[i];
				neighbors_changed[k] = (data_at_nodes_inst+nid)->neighbors_changed[i];
				k++;
			}
			
		}
		
		uint32_t nei_sizes[max];
		for(uint32_t i=0;i<max;i++)
		{
			nei_sizes[i] = 0;
		}
		
		for(uint32_t i=0;i<size;i++)
		{
			for(uint32_t j=0;j<max;j++)
			{

				if((neighbor_set[i].neighbors[j]) != large)
				{
					nei_sizes[i] = nei_sizes[i] + 1;
				}	
			}
		}
		/*
		for(uint32_t i=0;i<max;i++)
		{
			cout<<"neighbor sizes of agent "<<nid<<"is "<<nei_sizes[i]<<endl;
		}
		*/
		
		
		Ptr <Ipv4> ipv4;  	
	  	ipv4 = destination_node->GetObject<Ipv4>();
		Ipv4InterfaceAddress iaddr = ipv4->GetAddress(2,0);//2nd IPv4 interface,0th address index
		Ipv4Address dest_ip = iaddr.GetLocal();
		Ptr <Packet> packet1 = Create <Packet> (0);
		
		

		CustomMetaDataUnicastTagN011 tagN011;
		CustomMetaDataUnicastTagN012 tagN012;
		CustomMetaDataUnicastTagN013 tagN013;
		CustomMetaDataUnicastTagN014 tagN014;
		CustomMetaDataUnicastTagN015 tagN015;
		CustomMetaDataUnicastTagN016 tagN016;
		CustomMetaDataUnicastTagN017 tagN017;
		CustomMetaDataUnicastTagN018 tagN018;
		CustomMetaDataUnicastTagN019 tagN019;
		CustomMetaDataUnicastTagN0110 tagN0110;
		CustomMetaDataUnicastTagN0111 tagN0111;
		CustomMetaDataUnicastTagN0112 tagN0112;
		CustomMetaDataUnicastTagN0113 tagN0113;
		CustomMetaDataUnicastTagN0114 tagN0114;
		CustomMetaDataUnicastTagN0115 tagN0115;
		CustomMetaDataUnicastTagN0116 tagN0116;
		CustomMetaDataUnicastTagN0117 tagN0117;
		CustomMetaDataUnicastTagN0118 tagN0118;
		CustomMetaDataUnicastTagN0119 tagN0119;
		CustomMetaDataUnicastTagN0120 tagN0120;
		CustomMetaDataUnicastTagN0121 tagN0121;
		CustomMetaDataUnicastTagN0122 tagN0122;
		CustomMetaDataUnicastTagN0123 tagN0123;
		CustomMetaDataUnicastTagN0124 tagN0124;
		CustomMetaDataUnicastTagN0125 tagN0125;
		CustomMetaDataUnicastTagN01max tagN01max;
		
		if ((nei_sizes[0] > 0) and (neighbors_changed[0]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[0] = false;
			switch(nei_sizes[0])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[0].neighbors[0];
					tagN011.Setneighborid(new_neighborset1);
					tagN011.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN011);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[0].neighbors[i];
					}
					tagN012.Setneighborid(new_neighborset2);
					tagN012.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN012);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[0].neighbors[i];
					}
					tagN013.Setneighborid(new_neighborset3);
					tagN013.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN013);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[0].neighbors[i];
					}
					tagN014.Setneighborid(new_neighborset4);
					tagN014.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN014);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[0].neighbors[i];
					}
					tagN015.Setneighborid(new_neighborset5);
					tagN015.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN015);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[0].neighbors[i];
					}
					tagN016.Setneighborid(new_neighborset6);
					tagN016.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN016);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[0].neighbors[i];
					}
					tagN017.Setneighborid(new_neighborset7);
					tagN017.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN017);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[0].neighbors[i];
					}
					tagN018.Setneighborid(new_neighborset8);
					tagN018.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN018);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[0].neighbors[i];
					}
					tagN019.Setneighborid(new_neighborset9);
					tagN019.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN019);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[0].neighbors[i];
					}
					tagN0110.Setneighborid(new_neighborset10);
					tagN0110.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0110);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[0].neighbors[i];
					}
					tagN0111.Setneighborid(new_neighborset11);
					tagN0111.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0111);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[0].neighbors[i];
					}
					tagN0112.Setneighborid(new_neighborset12);
					tagN0112.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0112);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[0].neighbors[i];
					}
					tagN0113.Setneighborid(new_neighborset13);
					tagN0113.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0113);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[0].neighbors[i];
					}
					tagN0114.Setneighborid(new_neighborset14);
					tagN0114.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0114);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[0].neighbors[i];
					}
					tagN0115.Setneighborid(new_neighborset15);
					tagN0115.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0115);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[0].neighbors[i];
					}
					tagN0116.Setneighborid(new_neighborset16);
					tagN0116.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0116);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[0].neighbors[i];
					}
					tagN0117.Setneighborid(new_neighborset17);
					tagN0117.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0117);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[0].neighbors[i];
					}
					tagN0118.Setneighborid(new_neighborset18);
					tagN0118.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0118);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[0].neighbors[i];
					}
					tagN0119.Setneighborid(new_neighborset19);
					tagN0119.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0119);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[0].neighbors[i];
					}
					tagN0120.Setneighborid(new_neighborset20);
					tagN0120.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0120);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[0].neighbors[i];
					}
					tagN0121.Setneighborid(new_neighborset21);
					tagN0121.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0121);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[0].neighbors[i];
					}
					tagN0122.Setneighborid(new_neighborset22);
					tagN0122.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0122);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[0].neighbors[i];
					}
					tagN0123.Setneighborid(new_neighborset23);
					tagN0123.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0123);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[0].neighbors[i];
					}
					tagN0124.Setneighborid(new_neighborset24);
					tagN0124.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0124);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[0].neighbors[i];
					}
					tagN0125.Setneighborid(new_neighborset25);
					tagN0125.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0125);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is "<<nei_sizes[0]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[0])
						{
							new_neighborsetmax[i] = neighbor_set[0].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN01max.Setneighborid(new_neighborsetmax);
					tagN01max.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN01max);
					break;
			}
		}
		
	

		CustomMetaDataUnicastTagN021 tagN021;
		CustomMetaDataUnicastTagN022 tagN022;
		CustomMetaDataUnicastTagN023 tagN023;
		CustomMetaDataUnicastTagN024 tagN024;
		CustomMetaDataUnicastTagN025 tagN025;
		CustomMetaDataUnicastTagN026 tagN026;
		CustomMetaDataUnicastTagN027 tagN027;
		CustomMetaDataUnicastTagN028 tagN028;
		CustomMetaDataUnicastTagN029 tagN029;
		CustomMetaDataUnicastTagN0210 tagN0210;
		CustomMetaDataUnicastTagN0211 tagN0211;
		CustomMetaDataUnicastTagN0212 tagN0212;
		CustomMetaDataUnicastTagN0213 tagN0213;
		CustomMetaDataUnicastTagN0214 tagN0214;
		CustomMetaDataUnicastTagN0215 tagN0215;
		CustomMetaDataUnicastTagN0216 tagN0216;
		CustomMetaDataUnicastTagN0217 tagN0217;
		CustomMetaDataUnicastTagN0218 tagN0218;
		CustomMetaDataUnicastTagN0219 tagN0219;
		CustomMetaDataUnicastTagN0220 tagN0220;
		CustomMetaDataUnicastTagN0221 tagN0221;
		CustomMetaDataUnicastTagN0222 tagN0222;
		CustomMetaDataUnicastTagN0223 tagN0223;
		CustomMetaDataUnicastTagN0224 tagN0224;
		CustomMetaDataUnicastTagN0225 tagN0225;
		CustomMetaDataUnicastTagN2max tagN2max;
		
		if ((nei_sizes[1] > 0)and (neighbors_changed[1]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[1] = false;
			switch(nei_sizes[1])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[1].neighbors[0];
					tagN021.Setneighborid(new_neighborset1);
					tagN021.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN021);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[1].neighbors[i];
					}
					tagN022.Setneighborid(new_neighborset2);
					tagN022.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN022);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[1].neighbors[i];
					}
					tagN023.Setneighborid(new_neighborset3);
					tagN023.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN023);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[1].neighbors[i];
					}
					tagN024.Setneighborid(new_neighborset4);
					tagN024.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN024);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[1].neighbors[i];
					}
					tagN025.Setneighborid(new_neighborset5);
					tagN025.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN025);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[1].neighbors[i];
					}
					tagN026.Setneighborid(new_neighborset6);
					tagN026.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN026);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[1].neighbors[i];
					}
					tagN027.Setneighborid(new_neighborset7);
					tagN027.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN027);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[1].neighbors[i];
					}
					tagN028.Setneighborid(new_neighborset8);
					tagN028.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN028);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[1].neighbors[i];
					}
					tagN029.Setneighborid(new_neighborset9);
					tagN029.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN029);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[1].neighbors[i];
					}
					tagN0210.Setneighborid(new_neighborset10);
					tagN0210.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0210);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[1].neighbors[i];
					}
					tagN0211.Setneighborid(new_neighborset11);
					tagN0211.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0211);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[1].neighbors[i];
					}
					tagN0212.Setneighborid(new_neighborset12);
					tagN0212.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0212);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[1].neighbors[i];
					}
					tagN0213.Setneighborid(new_neighborset13);
					tagN0213.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0213);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[1].neighbors[i];
					}
					tagN0214.Setneighborid(new_neighborset14);
					tagN0214.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0214);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[1].neighbors[i];
					}
					tagN0215.Setneighborid(new_neighborset15);
					tagN0215.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0215);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[1].neighbors[i];
					}
					tagN0216.Setneighborid(new_neighborset16);
					tagN0216.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0216);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[1].neighbors[i];
					}
					tagN0217.Setneighborid(new_neighborset17);
					tagN0217.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0217);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[1].neighbors[i];
					}
					tagN0218.Setneighborid(new_neighborset18);
					tagN0218.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0218);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[1].neighbors[i];
					}
					tagN0219.Setneighborid(new_neighborset19);
					tagN0219.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0219);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[1].neighbors[i];
					}
					tagN0220.Setneighborid(new_neighborset20);
					tagN0220.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0220);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[1].neighbors[i];
					}
					tagN0221.Setneighborid(new_neighborset21);
					tagN0221.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0221);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[1].neighbors[i];
					}
					tagN0222.Setneighborid(new_neighborset22);
					tagN0222.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0222);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[1].neighbors[i];
					}
					tagN0223.Setneighborid(new_neighborset23);
					tagN0223.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0223);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[1].neighbors[i];
					}
					tagN0224.Setneighborid(new_neighborset24);
					tagN0224.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0224);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[1].neighbors[i];
					}
					tagN0225.Setneighborid(new_neighborset25);
					tagN0225.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0225);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is  "<<nei_sizes[1]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[1])
						{
							new_neighborsetmax[i] = neighbor_set[1].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN2max.Setneighborid(new_neighborsetmax);
					tagN2max.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN2max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN31 tagN31;
		CustomMetaDataUnicastTagN32 tagN32;
		CustomMetaDataUnicastTagN33 tagN33;
		CustomMetaDataUnicastTagN34 tagN34;
		CustomMetaDataUnicastTagN35 tagN35;
		CustomMetaDataUnicastTagN36 tagN36;
		CustomMetaDataUnicastTagN37 tagN37;
		CustomMetaDataUnicastTagN38 tagN38;
		CustomMetaDataUnicastTagN39 tagN39;
		CustomMetaDataUnicastTagN310 tagN310;
		CustomMetaDataUnicastTagN311 tagN311;
		CustomMetaDataUnicastTagN312 tagN312;
		CustomMetaDataUnicastTagN313 tagN313;
		CustomMetaDataUnicastTagN314 tagN314;
		CustomMetaDataUnicastTagN315 tagN315;
		CustomMetaDataUnicastTagN316 tagN316;
		CustomMetaDataUnicastTagN317 tagN317;
		CustomMetaDataUnicastTagN318 tagN318;
		CustomMetaDataUnicastTagN319 tagN319;
		CustomMetaDataUnicastTagN320 tagN320;
		CustomMetaDataUnicastTagN321 tagN321;
		CustomMetaDataUnicastTagN322 tagN322;
		CustomMetaDataUnicastTagN323 tagN323;
		CustomMetaDataUnicastTagN324 tagN324;
		CustomMetaDataUnicastTagN325 tagN325;
		CustomMetaDataUnicastTagN3max tagN3max;
		
		if ((nei_sizes[2] > 0)and (neighbors_changed[2]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[2] = false;
			switch(nei_sizes[2])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[2].neighbors[0];
					tagN31.Setneighborid(new_neighborset1);
					tagN31.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN31);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[2].neighbors[i];
					}
					tagN32.Setneighborid(new_neighborset2);
					tagN32.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN32);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[2].neighbors[i];
					}
					tagN33.Setneighborid(new_neighborset3);
					tagN33.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN33);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[2].neighbors[i];
					}
					tagN34.Setneighborid(new_neighborset4);
					tagN34.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN34);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[2].neighbors[i];
					}
					tagN35.Setneighborid(new_neighborset5);
					tagN35.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN35);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[2].neighbors[i];
					}
					tagN36.Setneighborid(new_neighborset6);
					tagN36.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN36);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[2].neighbors[i];
					}
					tagN37.Setneighborid(new_neighborset7);
					tagN37.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN37);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[2].neighbors[i];
					}
					tagN38.Setneighborid(new_neighborset8);
					tagN38.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN38);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[2].neighbors[i];
					}
					tagN39.Setneighborid(new_neighborset9);
					tagN39.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN39);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[2].neighbors[i];
					}
					tagN310.Setneighborid(new_neighborset10);
					tagN310.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN310);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[2].neighbors[i];
					}
					tagN311.Setneighborid(new_neighborset11);
					tagN311.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN311);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[2].neighbors[i];
					}
					tagN312.Setneighborid(new_neighborset12);
					tagN312.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN312);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[2].neighbors[i];
					}
					tagN313.Setneighborid(new_neighborset13);
					tagN313.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN313);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[2].neighbors[i];
					}
					tagN314.Setneighborid(new_neighborset14);
					tagN314.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN314);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[2].neighbors[i];
					}
					tagN315.Setneighborid(new_neighborset15);
					tagN315.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN315);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[2].neighbors[i];
					}
					tagN316.Setneighborid(new_neighborset16);
					tagN316.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN316);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[2].neighbors[i];
					}
					tagN317.Setneighborid(new_neighborset17);
					tagN317.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN317);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[2].neighbors[i];
					}
					tagN318.Setneighborid(new_neighborset18);
					tagN318.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN318);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[2].neighbors[i];
					}
					tagN319.Setneighborid(new_neighborset19);
					tagN319.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN319);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[2].neighbors[i];
					}
					tagN320.Setneighborid(new_neighborset20);
					tagN320.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN320);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[2].neighbors[i];
					}
					tagN321.Setneighborid(new_neighborset21);
					tagN321.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN321);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[2].neighbors[i];
					}
					tagN322.Setneighborid(new_neighborset22);
					tagN322.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN322);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[2].neighbors[i];
					}
					tagN323.Setneighborid(new_neighborset23);
					tagN323.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN323);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[2].neighbors[i];
					}
					tagN324.Setneighborid(new_neighborset24);
					tagN324.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN324);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[2].neighbors[i];
					}
					tagN325.Setneighborid(new_neighborset25);
					tagN325.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN325);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is  "<<nei_sizes[2]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[2])
						{
							new_neighborsetmax[i] = neighbor_set[2].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN3max.Setneighborid(new_neighborsetmax);
					tagN3max.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN3max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN41 tagN41;
		CustomMetaDataUnicastTagN42 tagN42;
		CustomMetaDataUnicastTagN43 tagN43;
		CustomMetaDataUnicastTagN44 tagN44;
		CustomMetaDataUnicastTagN45 tagN45;
		CustomMetaDataUnicastTagN46 tagN46;
		CustomMetaDataUnicastTagN47 tagN47;
		CustomMetaDataUnicastTagN48 tagN48;
		CustomMetaDataUnicastTagN49 tagN49;
		CustomMetaDataUnicastTagN410 tagN410;
		CustomMetaDataUnicastTagN411 tagN411;
		CustomMetaDataUnicastTagN412 tagN412;
		CustomMetaDataUnicastTagN413 tagN413;
		CustomMetaDataUnicastTagN414 tagN414;
		CustomMetaDataUnicastTagN415 tagN415;
		CustomMetaDataUnicastTagN416 tagN416;
		CustomMetaDataUnicastTagN417 tagN417;
		CustomMetaDataUnicastTagN418 tagN418;
		CustomMetaDataUnicastTagN419 tagN419;
		CustomMetaDataUnicastTagN420 tagN420;
		CustomMetaDataUnicastTagN421 tagN421;
		CustomMetaDataUnicastTagN422 tagN422;
		CustomMetaDataUnicastTagN423 tagN423;
		CustomMetaDataUnicastTagN424 tagN424;
		CustomMetaDataUnicastTagN425 tagN425;
		CustomMetaDataUnicastTagN4max tagN4max;
		
		if ((nei_sizes[3] > 0)and (neighbors_changed[3]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[3] = false;
			switch(nei_sizes[3])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[3].neighbors[0];
					tagN41.Setneighborid(new_neighborset1);
					tagN41.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN41);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[3].neighbors[i];
					}
					tagN42.Setneighborid(new_neighborset2);
					tagN42.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN42);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[3].neighbors[i];
					}
					tagN43.Setneighborid(new_neighborset3);
					tagN43.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN43);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[3].neighbors[i];
					}
					tagN44.Setneighborid(new_neighborset4);
					tagN44.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN44);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[3].neighbors[i];
					}
					tagN45.Setneighborid(new_neighborset5);
					tagN45.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN45);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[3].neighbors[i];
					}
					tagN46.Setneighborid(new_neighborset6);
					tagN46.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN46);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[3].neighbors[i];
					}
					tagN47.Setneighborid(new_neighborset7);
					tagN47.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN47);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[3].neighbors[i];
					}
					tagN48.Setneighborid(new_neighborset8);
					tagN48.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN48);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[3].neighbors[i];
					}
					tagN49.Setneighborid(new_neighborset9);
					tagN49.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN49);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[3].neighbors[i];
					}
					tagN410.Setneighborid(new_neighborset10);
					tagN410.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN410);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[3].neighbors[i];
					}
					tagN411.Setneighborid(new_neighborset11);
					tagN411.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN411);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[3].neighbors[i];
					}
					tagN412.Setneighborid(new_neighborset12);
					tagN412.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN412);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[3].neighbors[i];
					}
					tagN413.Setneighborid(new_neighborset13);
					tagN413.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN413);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[3].neighbors[i];
					}
					tagN414.Setneighborid(new_neighborset14);
					tagN414.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN414);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[3].neighbors[i];
					}
					tagN415.Setneighborid(new_neighborset15);
					tagN415.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN415);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[3].neighbors[i];
					}
					tagN416.Setneighborid(new_neighborset16);
					tagN416.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN416);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[3].neighbors[i];
					}
					tagN417.Setneighborid(new_neighborset17);
					tagN417.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN417);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[3].neighbors[i];
					}
					tagN418.Setneighborid(new_neighborset18);
					tagN418.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN418);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[3].neighbors[i];
					}
					tagN419.Setneighborid(new_neighborset19);
					tagN419.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN419);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[3].neighbors[i];
					}
					tagN420.Setneighborid(new_neighborset20);
					tagN420.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN420);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[3].neighbors[i];
					}
					tagN421.Setneighborid(new_neighborset21);
					tagN421.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN421);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[3].neighbors[i];
					}
					tagN422.Setneighborid(new_neighborset22);
					tagN422.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN422);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[3].neighbors[i];
					}
					tagN423.Setneighborid(new_neighborset23);
					tagN423.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN423);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[3].neighbors[i];
					}
					tagN424.Setneighborid(new_neighborset24);
					tagN424.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN424);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[3].neighbors[i];
					}
					tagN425.Setneighborid(new_neighborset25);
					tagN425.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN425);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[3]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[3])
						{
							new_neighborsetmax[i] = neighbor_set[3].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN4max.Setneighborid(new_neighborsetmax);
					tagN4max.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN4max);
					break;
			}
		
		}
		
		
		
		CustomMetaDataUnicastTagN51 tagN51;
		CustomMetaDataUnicastTagN52 tagN52;
		CustomMetaDataUnicastTagN53 tagN53;
		CustomMetaDataUnicastTagN54 tagN54;
		CustomMetaDataUnicastTagN55 tagN55;
		CustomMetaDataUnicastTagN56 tagN56;
		CustomMetaDataUnicastTagN57 tagN57;
		CustomMetaDataUnicastTagN58 tagN58;
		CustomMetaDataUnicastTagN59 tagN59;
		CustomMetaDataUnicastTagN510 tagN510;
		CustomMetaDataUnicastTagN511 tagN511;
		CustomMetaDataUnicastTagN512 tagN512;
		CustomMetaDataUnicastTagN513 tagN513;
		CustomMetaDataUnicastTagN514 tagN514;
		CustomMetaDataUnicastTagN515 tagN515;
		CustomMetaDataUnicastTagN516 tagN516;
		CustomMetaDataUnicastTagN517 tagN517;
		CustomMetaDataUnicastTagN518 tagN518;
		CustomMetaDataUnicastTagN519 tagN519;
		CustomMetaDataUnicastTagN520 tagN520;
		CustomMetaDataUnicastTagN521 tagN521;
		CustomMetaDataUnicastTagN522 tagN522;
		CustomMetaDataUnicastTagN523 tagN523;
		CustomMetaDataUnicastTagN524 tagN524;
		CustomMetaDataUnicastTagN525 tagN525;
		CustomMetaDataUnicastTagN5max tagN5max;
		
		if ((nei_sizes[4] > 0) and (neighbors_changed[4]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[4] = false;
			switch(nei_sizes[4])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[4].neighbors[0];
					tagN51.Setneighborid(new_neighborset1);
					tagN51.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN51);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[4].neighbors[i];
					}
					tagN52.Setneighborid(new_neighborset2);
					tagN52.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN52);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[4].neighbors[i];
					}
					tagN53.Setneighborid(new_neighborset3);
					tagN53.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN53);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[4].neighbors[i];
					}
					tagN54.Setneighborid(new_neighborset4);
					tagN54.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN54);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[4].neighbors[i];
					}
					tagN55.Setneighborid(new_neighborset5);
					tagN55.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN55);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[4].neighbors[i];
					}
					tagN56.Setneighborid(new_neighborset6);
					tagN56.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN56);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[4].neighbors[i];
					}
					tagN57.Setneighborid(new_neighborset7);
					tagN57.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN57);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[4].neighbors[i];
					}
					tagN58.Setneighborid(new_neighborset8);
					tagN58.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN58);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[4].neighbors[i];
					}
					tagN59.Setneighborid(new_neighborset9);
					tagN59.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN59);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[4].neighbors[i];
					}
					tagN510.Setneighborid(new_neighborset10);
					tagN510.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN510);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[4].neighbors[i];
					}
					tagN511.Setneighborid(new_neighborset11);
					tagN511.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN511);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[4].neighbors[i];
					}
					tagN512.Setneighborid(new_neighborset12);
					tagN512.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN512);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[4].neighbors[i];
					}
					tagN513.Setneighborid(new_neighborset13);
					tagN513.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN513);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[4].neighbors[i];
					}
					tagN514.Setneighborid(new_neighborset14);
					tagN514.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN514);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[4].neighbors[i];
					}
					tagN515.Setneighborid(new_neighborset15);
					tagN515.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN515);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[4].neighbors[i];
					}
					tagN516.Setneighborid(new_neighborset16);
					tagN516.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN516);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[4].neighbors[i];
					}
					tagN517.Setneighborid(new_neighborset17);
					tagN517.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN517);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[4].neighbors[i];
					}
					tagN518.Setneighborid(new_neighborset18);
					tagN518.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN518);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[4].neighbors[i];
					}
					tagN519.Setneighborid(new_neighborset19);
					tagN519.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN519);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[4].neighbors[i];
					}
					tagN520.Setneighborid(new_neighborset20);
					tagN520.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN520);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[4].neighbors[i];
					}
					tagN521.Setneighborid(new_neighborset21);
					tagN521.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN521);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[4].neighbors[i];
					}
					tagN522.Setneighborid(new_neighborset22);
					tagN522.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN522);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[4].neighbors[i];
					}
					tagN523.Setneighborid(new_neighborset23);
					tagN523.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN523);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[4].neighbors[i];
					}
					tagN524.Setneighborid(new_neighborset24);
					tagN524.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN524);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[4].neighbors[i];
					}
					tagN525.Setneighborid(new_neighborset25);
					tagN525.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN525);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is  "<<nei_sizes[4]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[4])
						{
							new_neighborsetmax[i] = neighbor_set[4].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN5max.Setneighborid(new_neighborsetmax);
					tagN5max.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN5max);
					break;
			}
		
		}		

		CustomMetaDataUnicastTagN61 tagN61;
		CustomMetaDataUnicastTagN62 tagN62;
		CustomMetaDataUnicastTagN63 tagN63;
		CustomMetaDataUnicastTagN64 tagN64;
		CustomMetaDataUnicastTagN65 tagN65;
		CustomMetaDataUnicastTagN66 tagN66;
		CustomMetaDataUnicastTagN67 tagN67;
		CustomMetaDataUnicastTagN68 tagN68;
		CustomMetaDataUnicastTagN69 tagN69;
		CustomMetaDataUnicastTagN610 tagN610;
		CustomMetaDataUnicastTagN611 tagN611;
		CustomMetaDataUnicastTagN612 tagN612;
		CustomMetaDataUnicastTagN613 tagN613;
		CustomMetaDataUnicastTagN614 tagN614;
		CustomMetaDataUnicastTagN615 tagN615;
		CustomMetaDataUnicastTagN616 tagN616;
		CustomMetaDataUnicastTagN617 tagN617;
		CustomMetaDataUnicastTagN618 tagN618;
		CustomMetaDataUnicastTagN619 tagN619;
		CustomMetaDataUnicastTagN620 tagN620;
		CustomMetaDataUnicastTagN621 tagN621;
		CustomMetaDataUnicastTagN622 tagN622;
		CustomMetaDataUnicastTagN623 tagN623;
		CustomMetaDataUnicastTagN624 tagN624;
		CustomMetaDataUnicastTagN625 tagN625;
		CustomMetaDataUnicastTagN6max tagN6max;
		
		if ((nei_sizes[5] > 0)and (neighbors_changed[5]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[5] = false;
			switch(nei_sizes[5])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[5].neighbors[0];
					tagN61.Setneighborid(new_neighborset1);
					tagN61.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN61);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[5].neighbors[i];
					}
					tagN62.Setneighborid(new_neighborset2);
					tagN62.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN62);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[5].neighbors[i];
					}
					tagN63.Setneighborid(new_neighborset3);
					tagN63.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN63);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[5].neighbors[i];
					}
					tagN64.Setneighborid(new_neighborset4);
					tagN64.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN64);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[5].neighbors[i];
					}
					tagN65.Setneighborid(new_neighborset5);
					tagN65.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN65);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[5].neighbors[i];
					}
					tagN66.Setneighborid(new_neighborset6);
					tagN66.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN66);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[5].neighbors[i];
					}
					tagN67.Setneighborid(new_neighborset7);
					tagN67.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN67);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[5].neighbors[i];
					}
					tagN68.Setneighborid(new_neighborset8);
					tagN68.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN68);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[5].neighbors[i];
					}
					tagN69.Setneighborid(new_neighborset9);
					tagN69.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN69);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[5].neighbors[i];
					}
					tagN610.Setneighborid(new_neighborset10);
					tagN610.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN610);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[5].neighbors[i];
					}
					tagN611.Setneighborid(new_neighborset11);
					tagN611.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN611);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[5].neighbors[i];
					}
					tagN612.Setneighborid(new_neighborset12);
					tagN612.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN612);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[5].neighbors[i];
					}
					tagN613.Setneighborid(new_neighborset13);
					tagN613.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN613);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[5].neighbors[i];
					}
					tagN614.Setneighborid(new_neighborset14);
					tagN614.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN614);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[5].neighbors[i];
					}
					tagN615.Setneighborid(new_neighborset15);
					tagN615.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN615);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[5].neighbors[i];
					}
					tagN616.Setneighborid(new_neighborset16);
					tagN616.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN616);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[5].neighbors[i];
					}
					tagN617.Setneighborid(new_neighborset17);
					tagN617.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN617);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[5].neighbors[i];
					}
					tagN618.Setneighborid(new_neighborset18);
					tagN618.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN618);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[5].neighbors[i];
					}
					tagN619.Setneighborid(new_neighborset19);
					tagN619.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN619);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[5].neighbors[i];
					}
					tagN620.Setneighborid(new_neighborset20);
					tagN620.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN620);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[5].neighbors[i];
					}
					tagN621.Setneighborid(new_neighborset21);
					tagN621.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN621);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[5].neighbors[i];
					}
					tagN622.Setneighborid(new_neighborset22);
					tagN622.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN622);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[5].neighbors[i];
					}
					tagN623.Setneighborid(new_neighborset23);
					tagN623.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN623);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[5].neighbors[i];
					}
					tagN624.Setneighborid(new_neighborset24);
					tagN624.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN624);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[5].neighbors[i];
					}
					tagN625.Setneighborid(new_neighborset25);
					tagN625.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN625);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is  "<<nei_sizes[5]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[5])
						{
							new_neighborsetmax[i] = neighbor_set[5].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN6max.Setneighborid(new_neighborsetmax);
					tagN6max.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN6max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN71 tagN71;
		CustomMetaDataUnicastTagN72 tagN72;
		CustomMetaDataUnicastTagN73 tagN73;
		CustomMetaDataUnicastTagN74 tagN74;
		CustomMetaDataUnicastTagN75 tagN75;
		CustomMetaDataUnicastTagN76 tagN76;
		CustomMetaDataUnicastTagN77 tagN77;
		CustomMetaDataUnicastTagN78 tagN78;
		CustomMetaDataUnicastTagN79 tagN79;
		CustomMetaDataUnicastTagN710 tagN710;
		CustomMetaDataUnicastTagN711 tagN711;
		CustomMetaDataUnicastTagN712 tagN712;
		CustomMetaDataUnicastTagN713 tagN713;
		CustomMetaDataUnicastTagN714 tagN714;
		CustomMetaDataUnicastTagN715 tagN715;
		CustomMetaDataUnicastTagN716 tagN716;
		CustomMetaDataUnicastTagN717 tagN717;
		CustomMetaDataUnicastTagN718 tagN718;
		CustomMetaDataUnicastTagN719 tagN719;
		CustomMetaDataUnicastTagN720 tagN720;
		CustomMetaDataUnicastTagN721 tagN721;
		CustomMetaDataUnicastTagN722 tagN722;
		CustomMetaDataUnicastTagN723 tagN723;
		CustomMetaDataUnicastTagN724 tagN724;
		CustomMetaDataUnicastTagN725 tagN725;
		CustomMetaDataUnicastTagN7max tagN7max;
		
		if ((nei_sizes[6] > 0)and (neighbors_changed[6]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[6] = false;
			switch(nei_sizes[6])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[6].neighbors[0];
					tagN71.Setneighborid(new_neighborset1);
					tagN71.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN71);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[6].neighbors[i];
					}
					tagN72.Setneighborid(new_neighborset2);
					tagN72.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN72);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[6].neighbors[i];
					}
					tagN73.Setneighborid(new_neighborset3);
					tagN73.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN73);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[6].neighbors[i];
					}
					tagN74.Setneighborid(new_neighborset4);
					tagN74.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN74);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[6].neighbors[i];
					}
					tagN75.Setneighborid(new_neighborset5);
					tagN75.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN75);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[6].neighbors[i];
					}
					tagN76.Setneighborid(new_neighborset6);
					tagN76.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN76);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[6].neighbors[i];
					}
					tagN77.Setneighborid(new_neighborset7);
					tagN77.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN77);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[6].neighbors[i];
					}
					tagN78.Setneighborid(new_neighborset8);
					tagN78.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN78);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[6].neighbors[i];
					}
					tagN79.Setneighborid(new_neighborset9);
					tagN79.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN79);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[6].neighbors[i];
					}
					tagN710.Setneighborid(new_neighborset10);
					tagN710.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN710);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[6].neighbors[i];
					}
					tagN711.Setneighborid(new_neighborset11);
					tagN711.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN711);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[6].neighbors[i];
					}
					tagN712.Setneighborid(new_neighborset12);
					tagN712.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN712);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[6].neighbors[i];
					}
					tagN713.Setneighborid(new_neighborset13);
					tagN713.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN713);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[6].neighbors[i];
					}
					tagN714.Setneighborid(new_neighborset14);
					tagN714.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN714);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[6].neighbors[i];
					}
					tagN715.Setneighborid(new_neighborset15);
					tagN715.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN715);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[6].neighbors[i];
					}
					tagN716.Setneighborid(new_neighborset16);
					tagN716.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN716);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[6].neighbors[i];
					}
					tagN717.Setneighborid(new_neighborset17);
					tagN717.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN717);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[6].neighbors[i];
					}
					tagN718.Setneighborid(new_neighborset18);
					tagN718.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN718);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[6].neighbors[i];
					}
					tagN719.Setneighborid(new_neighborset19);
					tagN719.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN719);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[6].neighbors[i];
					}
					tagN720.Setneighborid(new_neighborset20);
					tagN720.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN720);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[6].neighbors[i];
					}
					tagN721.Setneighborid(new_neighborset21);
					tagN721.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN721);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[6].neighbors[i];
					}
					tagN722.Setneighborid(new_neighborset22);
					tagN722.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN722);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[6].neighbors[i];
					}
					tagN723.Setneighborid(new_neighborset23);
					tagN723.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN723);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[6].neighbors[i];
					}
					tagN724.Setneighborid(new_neighborset24);
					tagN724.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN724);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[6].neighbors[i];
					}
					tagN725.Setneighborid(new_neighborset25);
					tagN725.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN725);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[6]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[6])
						{
							new_neighborsetmax[i] = neighbor_set[6].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN7max.Setneighborid(new_neighborsetmax);
					tagN7max.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN7max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN81 tagN81;
		CustomMetaDataUnicastTagN82 tagN82;
		CustomMetaDataUnicastTagN83 tagN83;
		CustomMetaDataUnicastTagN84 tagN84;
		CustomMetaDataUnicastTagN85 tagN85;
		CustomMetaDataUnicastTagN86 tagN86;
		CustomMetaDataUnicastTagN87 tagN87;
		CustomMetaDataUnicastTagN88 tagN88;
		CustomMetaDataUnicastTagN89 tagN89;
		CustomMetaDataUnicastTagN810 tagN810;
		CustomMetaDataUnicastTagN811 tagN811;
		CustomMetaDataUnicastTagN812 tagN812;
		CustomMetaDataUnicastTagN813 tagN813;
		CustomMetaDataUnicastTagN814 tagN814;
		CustomMetaDataUnicastTagN815 tagN815;
		CustomMetaDataUnicastTagN816 tagN816;
		CustomMetaDataUnicastTagN817 tagN817;
		CustomMetaDataUnicastTagN818 tagN818;
		CustomMetaDataUnicastTagN819 tagN819;
		CustomMetaDataUnicastTagN820 tagN820;
		CustomMetaDataUnicastTagN821 tagN821;
		CustomMetaDataUnicastTagN822 tagN822;
		CustomMetaDataUnicastTagN823 tagN823;
		CustomMetaDataUnicastTagN824 tagN824;
		CustomMetaDataUnicastTagN825 tagN825;
		CustomMetaDataUnicastTagN8max tagN8max;
		
		if ((nei_sizes[7] > 0)and (neighbors_changed[7]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[7] = false;
			switch(nei_sizes[7])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[7].neighbors[0];
					tagN81.Setneighborid(new_neighborset1);
					tagN81.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN81);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[7].neighbors[i];
					}
					tagN82.Setneighborid(new_neighborset2);
					tagN82.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN82);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[7].neighbors[i];
					}
					tagN83.Setneighborid(new_neighborset3);
					tagN83.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN83);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[7].neighbors[i];
					}
					tagN84.Setneighborid(new_neighborset4);
					tagN84.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN84);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[7].neighbors[i];
					}
					tagN85.Setneighborid(new_neighborset5);
					tagN85.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN85);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[7].neighbors[i];
					}
					tagN86.Setneighborid(new_neighborset6);
					tagN86.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN86);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[7].neighbors[i];
					}
					tagN87.Setneighborid(new_neighborset7);
					tagN87.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN87);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[7].neighbors[i];
					}
					tagN88.Setneighborid(new_neighborset8);
					tagN88.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN88);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[7].neighbors[i];
					}
					tagN89.Setneighborid(new_neighborset9);
					tagN89.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN89);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[7].neighbors[i];
					}
					tagN810.Setneighborid(new_neighborset10);
					tagN810.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN810);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[7].neighbors[i];
					}
					tagN811.Setneighborid(new_neighborset11);
					tagN811.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN811);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[7].neighbors[i];
					}
					tagN812.Setneighborid(new_neighborset12);
					tagN812.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN812);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[7].neighbors[i];
					}
					tagN813.Setneighborid(new_neighborset13);
					tagN813.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN813);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[7].neighbors[i];
					}
					tagN814.Setneighborid(new_neighborset14);
					tagN814.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN814);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[7].neighbors[i];
					}
					tagN815.Setneighborid(new_neighborset15);
					tagN815.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN815);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[7].neighbors[i];
					}
					tagN816.Setneighborid(new_neighborset16);
					tagN816.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN816);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[7].neighbors[i];
					}
					tagN817.Setneighborid(new_neighborset17);
					tagN817.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN817);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[7].neighbors[i];
					}
					tagN818.Setneighborid(new_neighborset18);
					tagN818.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN818);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[7].neighbors[i];
					}
					tagN819.Setneighborid(new_neighborset19);
					tagN819.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN819);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[7].neighbors[i];
					}
					tagN820.Setneighborid(new_neighborset20);
					tagN820.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN820);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[7].neighbors[i];
					}
					tagN821.Setneighborid(new_neighborset21);
					tagN821.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN821);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[7].neighbors[i];
					}
					tagN822.Setneighborid(new_neighborset22);
					tagN822.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN822);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[7].neighbors[i];
					}
					tagN823.Setneighborid(new_neighborset23);
					tagN823.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN823);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[7].neighbors[i];
					}
					tagN824.Setneighborid(new_neighborset24);
					tagN824.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN824);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[7].neighbors[i];
					}
					tagN825.Setneighborid(new_neighborset25);
					tagN825.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN825);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[7]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[7])
						{
							new_neighborsetmax[i] = neighbor_set[7].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN8max.Setneighborid(new_neighborsetmax);
					tagN8max.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN8max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN91 tagN91;
		CustomMetaDataUnicastTagN92 tagN92;
		CustomMetaDataUnicastTagN93 tagN93;
		CustomMetaDataUnicastTagN94 tagN94;
		CustomMetaDataUnicastTagN95 tagN95;
		CustomMetaDataUnicastTagN96 tagN96;
		CustomMetaDataUnicastTagN97 tagN97;
		CustomMetaDataUnicastTagN98 tagN98;
		CustomMetaDataUnicastTagN99 tagN99;
		CustomMetaDataUnicastTagN910 tagN910;
		CustomMetaDataUnicastTagN911 tagN911;
		CustomMetaDataUnicastTagN912 tagN912;
		CustomMetaDataUnicastTagN913 tagN913;
		CustomMetaDataUnicastTagN914 tagN914;
		CustomMetaDataUnicastTagN915 tagN915;
		CustomMetaDataUnicastTagN916 tagN916;
		CustomMetaDataUnicastTagN917 tagN917;
		CustomMetaDataUnicastTagN918 tagN918;
		CustomMetaDataUnicastTagN919 tagN919;
		CustomMetaDataUnicastTagN920 tagN920;
		CustomMetaDataUnicastTagN921 tagN921;
		CustomMetaDataUnicastTagN922 tagN922;
		CustomMetaDataUnicastTagN923 tagN923;
		CustomMetaDataUnicastTagN924 tagN924;
		CustomMetaDataUnicastTagN925 tagN925;
		CustomMetaDataUnicastTagN9max tagN9max;
		
		if ((nei_sizes[8] > 0)and (neighbors_changed[8]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[8] = false;
			switch(nei_sizes[8])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[8].neighbors[0];
					tagN91.Setneighborid(new_neighborset1);
					tagN91.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN91);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[8].neighbors[i];
					}
					tagN92.Setneighborid(new_neighborset2);
					tagN92.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN92);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[8].neighbors[i];
					}
					tagN93.Setneighborid(new_neighborset3);
					tagN93.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN93);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[8].neighbors[i];
					}
					tagN94.Setneighborid(new_neighborset4);
					tagN94.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN94);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[8].neighbors[i];
					}
					tagN95.Setneighborid(new_neighborset5);
					tagN95.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN95);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[8].neighbors[i];
					}
					tagN96.Setneighborid(new_neighborset6);
					tagN96.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN96);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[8].neighbors[i];
					}
					tagN97.Setneighborid(new_neighborset7);
					tagN97.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN97);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[8].neighbors[i];
					}
					tagN98.Setneighborid(new_neighborset8);
					tagN98.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN98);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[8].neighbors[i];
					}
					tagN99.Setneighborid(new_neighborset9);
					tagN99.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN99);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[8].neighbors[i];
					}
					tagN910.Setneighborid(new_neighborset10);
					tagN910.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN910);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[8].neighbors[i];
					}
					tagN911.Setneighborid(new_neighborset11);
					tagN911.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN911);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[8].neighbors[i];
					}
					tagN912.Setneighborid(new_neighborset12);
					tagN912.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN912);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[8].neighbors[i];
					}
					tagN913.Setneighborid(new_neighborset13);
					tagN913.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN913);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[8].neighbors[i];
					}
					tagN914.Setneighborid(new_neighborset14);
					tagN914.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN914);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[8].neighbors[i];
					}
					tagN915.Setneighborid(new_neighborset15);
					tagN915.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN915);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[8].neighbors[i];
					}
					tagN916.Setneighborid(new_neighborset16);
					tagN916.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN916);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[8].neighbors[i];
					}
					tagN917.Setneighborid(new_neighborset17);
					tagN917.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN917);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[8].neighbors[i];
					}
					tagN918.Setneighborid(new_neighborset18);
					tagN918.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN918);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[8].neighbors[i];
					}
					tagN919.Setneighborid(new_neighborset19);
					tagN919.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN919);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[8].neighbors[i];
					}
					tagN920.Setneighborid(new_neighborset20);
					tagN920.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN920);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[8].neighbors[i];
					}
					tagN921.Setneighborid(new_neighborset21);
					tagN921.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN921);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[8].neighbors[i];
					}
					tagN922.Setneighborid(new_neighborset22);
					tagN922.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN922);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[8].neighbors[i];
					}
					tagN923.Setneighborid(new_neighborset23);
					tagN923.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN923);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[8].neighbors[i];
					}
					tagN924.Setneighborid(new_neighborset24);
					tagN924.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN924);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[8].neighbors[i];
					}
					tagN925.Setneighborid(new_neighborset25);
					tagN925.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN925);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is  "<<nei_sizes[8]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[8])
						{
							new_neighborsetmax[i] = neighbor_set[8].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN9max.Setneighborid(new_neighborsetmax);
					tagN9max.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN9max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN101 tagN101;
		CustomMetaDataUnicastTagN102 tagN102;
		CustomMetaDataUnicastTagN103 tagN103;
		CustomMetaDataUnicastTagN104 tagN104;
		CustomMetaDataUnicastTagN105 tagN105;
		CustomMetaDataUnicastTagN106 tagN106;
		CustomMetaDataUnicastTagN107 tagN107;
		CustomMetaDataUnicastTagN108 tagN108;
		CustomMetaDataUnicastTagN109 tagN109;
		CustomMetaDataUnicastTagN1010 tagN1010;
		CustomMetaDataUnicastTagN1011 tagN1011;
		CustomMetaDataUnicastTagN1012 tagN1012;
		CustomMetaDataUnicastTagN1013 tagN1013;
		CustomMetaDataUnicastTagN1014 tagN1014;
		CustomMetaDataUnicastTagN1015 tagN1015;
		CustomMetaDataUnicastTagN1016 tagN1016;
		CustomMetaDataUnicastTagN1017 tagN1017;
		CustomMetaDataUnicastTagN1018 tagN1018;
		CustomMetaDataUnicastTagN1019 tagN1019;
		CustomMetaDataUnicastTagN1020 tagN1020;
		CustomMetaDataUnicastTagN1021 tagN1021;
		CustomMetaDataUnicastTagN1022 tagN1022;
		CustomMetaDataUnicastTagN1023 tagN1023;
		CustomMetaDataUnicastTagN1024 tagN1024;
		CustomMetaDataUnicastTagN1025 tagN1025;
		CustomMetaDataUnicastTagN10max tagN10max;
		
		if ((nei_sizes[9] > 0)and (neighbors_changed[9]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[9] = false;
			switch(nei_sizes[9])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[9].neighbors[0];
					tagN101.Setneighborid(new_neighborset1);
					tagN101.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN101);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[9].neighbors[i];
					}
					tagN102.Setneighborid(new_neighborset2);
					tagN102.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN102);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[9].neighbors[i];
					}
					tagN103.Setneighborid(new_neighborset3);
					tagN103.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN103);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[9].neighbors[i];
					}
					tagN104.Setneighborid(new_neighborset4);
					tagN104.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN104);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[9].neighbors[i];
					}
					tagN105.Setneighborid(new_neighborset5);
					tagN105.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN105);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[9].neighbors[i];
					}
					tagN106.Setneighborid(new_neighborset6);
					tagN106.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN106);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[9].neighbors[i];
					}
					tagN107.Setneighborid(new_neighborset7);
					tagN107.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN107);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[9].neighbors[i];
					}
					tagN108.Setneighborid(new_neighborset8);
					tagN108.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN108);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[9].neighbors[i];
					}
					tagN109.Setneighborid(new_neighborset9);
					tagN109.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN109);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[9].neighbors[i];
					}
					tagN1010.Setneighborid(new_neighborset10);
					tagN1010.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1010);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[9].neighbors[i];
					}
					tagN1011.Setneighborid(new_neighborset11);
					tagN1011.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1011);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[9].neighbors[i];
					}
					tagN1012.Setneighborid(new_neighborset12);
					tagN1012.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1012);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[9].neighbors[i];
					}
					tagN1013.Setneighborid(new_neighborset13);
					tagN1013.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1013);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[9].neighbors[i];
					}
					tagN1014.Setneighborid(new_neighborset14);
					tagN1014.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1014);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[9].neighbors[i];
					}
					tagN1015.Setneighborid(new_neighborset15);
					tagN1015.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1015);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[9].neighbors[i];
					}
					tagN1016.Setneighborid(new_neighborset16);
					tagN1016.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1016);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[9].neighbors[i];
					}
					tagN1017.Setneighborid(new_neighborset17);
					tagN1017.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1017);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[9].neighbors[i];
					}
					tagN1018.Setneighborid(new_neighborset18);
					tagN1018.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1018);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[9].neighbors[i];
					}
					tagN1019.Setneighborid(new_neighborset19);
					tagN1019.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1019);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[9].neighbors[i];
					}
					tagN1020.Setneighborid(new_neighborset20);
					tagN1020.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1020);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[9].neighbors[i];
					}
					tagN1021.Setneighborid(new_neighborset21);
					tagN1021.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1021);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[9].neighbors[i];
					}
					tagN1022.Setneighborid(new_neighborset22);
					tagN1022.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1022);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[9].neighbors[i];
					}
					tagN1023.Setneighborid(new_neighborset23);
					tagN1023.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1023);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[9].neighbors[i];
					}
					tagN1024.Setneighborid(new_neighborset24);
					tagN1024.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1024);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[9].neighbors[i];
					}
					tagN1025.Setneighborid(new_neighborset25);
					tagN1025.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1025);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is  "<<nei_sizes[9]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[9])
						{
							new_neighborsetmax[i] = neighbor_set[9].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN10max.Setneighborid(new_neighborsetmax);
					tagN10max.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN10max);
					break;
			}
		
		}		
		
		CustomMetaDataUnicastTagN111 tagN111;
		CustomMetaDataUnicastTagN112 tagN112;
		CustomMetaDataUnicastTagN113 tagN113;
		CustomMetaDataUnicastTagN114 tagN114;
		CustomMetaDataUnicastTagN115 tagN115;
		CustomMetaDataUnicastTagN116 tagN116;
		CustomMetaDataUnicastTagN117 tagN117;
		CustomMetaDataUnicastTagN118 tagN118;
		CustomMetaDataUnicastTagN119 tagN119;
		CustomMetaDataUnicastTagN1110 tagN1110;
		CustomMetaDataUnicastTagN1111 tagN1111;
		CustomMetaDataUnicastTagN1112 tagN1112;
		CustomMetaDataUnicastTagN1113 tagN1113;
		CustomMetaDataUnicastTagN1114 tagN1114;
		CustomMetaDataUnicastTagN1115 tagN1115;
		CustomMetaDataUnicastTagN1116 tagN1116;
		CustomMetaDataUnicastTagN1117 tagN1117;
		CustomMetaDataUnicastTagN1118 tagN1118;
		CustomMetaDataUnicastTagN1119 tagN1119;
		CustomMetaDataUnicastTagN1120 tagN1120;
		CustomMetaDataUnicastTagN1121 tagN1121;
		CustomMetaDataUnicastTagN1122 tagN1122;
		CustomMetaDataUnicastTagN1123 tagN1123;
		CustomMetaDataUnicastTagN1124 tagN1124;
		CustomMetaDataUnicastTagN1125 tagN1125;
		CustomMetaDataUnicastTagN11max tagN11max;
		
		if ((nei_sizes[10] > 0)and (neighbors_changed[10]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[10] = false;
			switch(nei_sizes[10])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[10].neighbors[0];
					tagN111.Setneighborid(new_neighborset1);
					tagN111.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN111);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[10].neighbors[i];
					}
					tagN112.Setneighborid(new_neighborset2);
					tagN112.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN112);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[10].neighbors[i];
					}
					tagN113.Setneighborid(new_neighborset3);
					tagN113.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN113);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[10].neighbors[i];
					}
					tagN114.Setneighborid(new_neighborset4);
					tagN114.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN114);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[10].neighbors[i];
					}
					tagN115.Setneighborid(new_neighborset5);
					tagN115.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN115);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[10].neighbors[i];
					}
					tagN116.Setneighborid(new_neighborset6);
					tagN116.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN116);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[10].neighbors[i];
					}
					tagN117.Setneighborid(new_neighborset7);
					tagN117.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN117);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[10].neighbors[i];
					}
					tagN118.Setneighborid(new_neighborset8);
					tagN118.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN118);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[10].neighbors[i];
					}
					tagN119.Setneighborid(new_neighborset9);
					tagN119.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN119);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[10].neighbors[i];
					}
					tagN1110.Setneighborid(new_neighborset10);
					tagN1110.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1110);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[10].neighbors[i];
					}
					tagN1111.Setneighborid(new_neighborset11);
					tagN1111.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1111);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[10].neighbors[i];
					}
					tagN1112.Setneighborid(new_neighborset12);
					tagN1112.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1112);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[10].neighbors[i];
					}
					tagN1113.Setneighborid(new_neighborset13);
					tagN1113.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1113);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[10].neighbors[i];
					}
					tagN1114.Setneighborid(new_neighborset14);
					tagN1114.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1114);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[10].neighbors[i];
					}
					tagN1115.Setneighborid(new_neighborset15);
					tagN1115.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1115);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[10].neighbors[i];
					}
					tagN1116.Setneighborid(new_neighborset16);
					tagN1116.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1116);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[10].neighbors[i];
					}
					tagN1117.Setneighborid(new_neighborset17);
					tagN1117.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1117);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[10].neighbors[i];
					}
					tagN1118.Setneighborid(new_neighborset18);
					tagN1118.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1118);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[10].neighbors[i];
					}
					tagN1119.Setneighborid(new_neighborset19);
					tagN1119.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1119);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[10].neighbors[i];
					}
					tagN1120.Setneighborid(new_neighborset20);
					tagN1120.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1120);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[10].neighbors[i];
					}
					tagN1121.Setneighborid(new_neighborset21);
					tagN1121.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1121);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[10].neighbors[i];
					}
					tagN1122.Setneighborid(new_neighborset22);
					tagN1122.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1122);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[10].neighbors[i];
					}
					tagN1123.Setneighborid(new_neighborset23);
					tagN1123.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1123);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[10].neighbors[i];
					}
					tagN1124.Setneighborid(new_neighborset24);
					tagN1124.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1124);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[10].neighbors[i];
					}
					tagN1125.Setneighborid(new_neighborset25);
					tagN1125.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1125);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is  "<<nei_sizes[10]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[10])
						{
							new_neighborsetmax[i] = neighbor_set[10].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN11max.Setneighborid(new_neighborsetmax);
					tagN11max.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN11max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN121 tagN121;
		CustomMetaDataUnicastTagN122 tagN122;
		CustomMetaDataUnicastTagN123 tagN123;
		CustomMetaDataUnicastTagN124 tagN124;
		CustomMetaDataUnicastTagN125 tagN125;
		CustomMetaDataUnicastTagN126 tagN126;
		CustomMetaDataUnicastTagN127 tagN127;
		CustomMetaDataUnicastTagN128 tagN128;
		CustomMetaDataUnicastTagN129 tagN129;
		CustomMetaDataUnicastTagN1210 tagN1210;
		CustomMetaDataUnicastTagN1211 tagN1211;
		CustomMetaDataUnicastTagN1212 tagN1212;
		CustomMetaDataUnicastTagN1213 tagN1213;
		CustomMetaDataUnicastTagN1214 tagN1214;
		CustomMetaDataUnicastTagN1215 tagN1215;
		CustomMetaDataUnicastTagN1216 tagN1216;
		CustomMetaDataUnicastTagN1217 tagN1217;
		CustomMetaDataUnicastTagN1218 tagN1218;
		CustomMetaDataUnicastTagN1219 tagN1219;
		CustomMetaDataUnicastTagN1220 tagN1220;
		CustomMetaDataUnicastTagN1221 tagN1221;
		CustomMetaDataUnicastTagN1222 tagN1222;
		CustomMetaDataUnicastTagN1223 tagN1223;
		CustomMetaDataUnicastTagN1224 tagN1224;
		CustomMetaDataUnicastTagN1225 tagN1225;
		CustomMetaDataUnicastTagN12max tagN12max;
		
		
		if ((nei_sizes[11] > 0)and (neighbors_changed[11]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[11] = false;
			switch(nei_sizes[11])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[11].neighbors[0];
					tagN121.Setneighborid(new_neighborset1);
					tagN121.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN121);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[11].neighbors[i];
					}
					tagN122.Setneighborid(new_neighborset2);
					tagN122.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN122);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[11].neighbors[i];
					}
					tagN123.Setneighborid(new_neighborset3);
					tagN123.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN123);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[11].neighbors[i];
					}
					tagN124.Setneighborid(new_neighborset4);
					tagN124.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN124);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[11].neighbors[i];
					}
					tagN125.Setneighborid(new_neighborset5);
					tagN125.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN125);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[11].neighbors[i];
					}
					tagN126.Setneighborid(new_neighborset6);
					tagN126.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN126);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[11].neighbors[i];
					}
					tagN127.Setneighborid(new_neighborset7);
					tagN127.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN127);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[11].neighbors[i];
					}
					tagN128.Setneighborid(new_neighborset8);
					tagN128.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN128);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[11].neighbors[i];
					}
					tagN129.Setneighborid(new_neighborset9);
					tagN129.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN129);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[11].neighbors[i];
					}
					tagN1210.Setneighborid(new_neighborset10);
					tagN1210.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1210);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[11].neighbors[i];
					}
					tagN1211.Setneighborid(new_neighborset11);
					tagN1211.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1211);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[11].neighbors[i];
					}
					tagN1212.Setneighborid(new_neighborset12);
					tagN1212.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1212);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[11].neighbors[i];
					}
					tagN1213.Setneighborid(new_neighborset13);
					tagN1213.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1213);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[11].neighbors[i];
					}
					tagN1214.Setneighborid(new_neighborset14);
					tagN1214.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1214);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[11].neighbors[i];
					}
					tagN1215.Setneighborid(new_neighborset15);
					tagN1215.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1215);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[11].neighbors[i];
					}
					tagN1216.Setneighborid(new_neighborset16);
					tagN1216.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1216);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[11].neighbors[i];
					}
					tagN1217.Setneighborid(new_neighborset17);
					tagN1217.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1217);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[11].neighbors[i];
					}
					tagN1218.Setneighborid(new_neighborset18);
					tagN1218.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1218);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[11].neighbors[i];
					}
					tagN1219.Setneighborid(new_neighborset19);
					tagN1219.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1219);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[11].neighbors[i];
					}
					tagN1220.Setneighborid(new_neighborset20);
					tagN1220.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1220);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[11].neighbors[i];
					}
					tagN1221.Setneighborid(new_neighborset21);
					tagN1221.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1221);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[11].neighbors[i];
					}
					tagN1222.Setneighborid(new_neighborset22);
					tagN1222.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1222);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[11].neighbors[i];
					}
					tagN1223.Setneighborid(new_neighborset23);
					tagN1223.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1223);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[11].neighbors[i];
					}
					tagN1224.Setneighborid(new_neighborset24);
					tagN1224.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1224);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[11].neighbors[i];
					}
					tagN1225.Setneighborid(new_neighborset25);
					tagN1225.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1225);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[11]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[11])
						{
							new_neighborsetmax[i] = neighbor_set[11].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN12max.Setnodeid(nodeid[11]);
					tagN12max.Setneighborid(new_neighborsetmax);
					packet1->AddPacketTag(tagN12max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN131 tagN131;
		CustomMetaDataUnicastTagN132 tagN132;
		CustomMetaDataUnicastTagN133 tagN133;
		CustomMetaDataUnicastTagN134 tagN134;
		CustomMetaDataUnicastTagN135 tagN135;
		CustomMetaDataUnicastTagN136 tagN136;
		CustomMetaDataUnicastTagN137 tagN137;
		CustomMetaDataUnicastTagN138 tagN138;
		CustomMetaDataUnicastTagN139 tagN139;
		CustomMetaDataUnicastTagN1310 tagN1310;
		CustomMetaDataUnicastTagN1311 tagN1311;
		CustomMetaDataUnicastTagN1312 tagN1312;
		CustomMetaDataUnicastTagN1313 tagN1313;
		CustomMetaDataUnicastTagN1314 tagN1314;
		CustomMetaDataUnicastTagN1315 tagN1315;
		CustomMetaDataUnicastTagN1316 tagN1316;
		CustomMetaDataUnicastTagN1317 tagN1317;
		CustomMetaDataUnicastTagN1318 tagN1318;
		CustomMetaDataUnicastTagN1319 tagN1319;
		CustomMetaDataUnicastTagN1320 tagN1320;
		CustomMetaDataUnicastTagN1321 tagN1321;
		CustomMetaDataUnicastTagN1322 tagN1322;
		CustomMetaDataUnicastTagN1323 tagN1323;
		CustomMetaDataUnicastTagN1324 tagN1324;
		CustomMetaDataUnicastTagN1325 tagN1325;
		CustomMetaDataUnicastTagN13max tagN13max;
		
		if ((nei_sizes[12] > 0)and (neighbors_changed[12]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[12] = false;
			switch(nei_sizes[12])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[12].neighbors[0];
					tagN131.Setneighborid(new_neighborset1);
					tagN131.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN131);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[12].neighbors[i];
					}
					tagN132.Setneighborid(new_neighborset2);
					tagN132.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN132);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[12].neighbors[i];
					}
					tagN133.Setneighborid(new_neighborset3);
					tagN133.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN133);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[12].neighbors[i];
					}
					tagN134.Setneighborid(new_neighborset4);
					tagN134.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN134);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[12].neighbors[i];
					}
					tagN135.Setneighborid(new_neighborset5);
					tagN135.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN135);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[12].neighbors[i];
					}
					tagN136.Setneighborid(new_neighborset6);
					tagN136.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN136);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[12].neighbors[i];
					}
					tagN137.Setneighborid(new_neighborset7);
					tagN137.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN137);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[12].neighbors[i];
					}
					tagN138.Setneighborid(new_neighborset8);
					tagN138.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN138);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[12].neighbors[i];
					}
					tagN139.Setneighborid(new_neighborset9);
					tagN139.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN139);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[12].neighbors[i];
					}
					tagN1310.Setneighborid(new_neighborset10);
					tagN1310.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1310);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[12].neighbors[i];
					}
					tagN1311.Setneighborid(new_neighborset11);
					tagN1311.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1311);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[12].neighbors[i];
					}
					tagN1312.Setneighborid(new_neighborset12);
					tagN1312.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1312);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[12].neighbors[i];
					}
					tagN1313.Setneighborid(new_neighborset13);
					tagN1313.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1313);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[12].neighbors[i];
					}
					tagN1314.Setneighborid(new_neighborset14);
					tagN1314.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1314);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[12].neighbors[i];
					}
					tagN1315.Setneighborid(new_neighborset15);
					tagN1315.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1315);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[12].neighbors[i];
					}
					tagN1316.Setneighborid(new_neighborset16);
					tagN1316.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1316);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[12].neighbors[i];
					}
					tagN1317.Setneighborid(new_neighborset17);
					tagN1317.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1317);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[12].neighbors[i];
					}
					tagN1318.Setneighborid(new_neighborset18);
					tagN1318.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1318);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[12].neighbors[i];
					}
					tagN1319.Setneighborid(new_neighborset19);
					tagN1319.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1319);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[12].neighbors[i];
					}
					tagN1320.Setneighborid(new_neighborset20);
					tagN1320.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1320);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[12].neighbors[i];
					}
					tagN1321.Setneighborid(new_neighborset21);
					tagN1321.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1321);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[12].neighbors[i];
					}
					tagN1322.Setneighborid(new_neighborset22);
					tagN1322.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1322);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[12].neighbors[i];
					}
					tagN1323.Setneighborid(new_neighborset23);
					tagN1323.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1323);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[12].neighbors[i];
					}
					tagN1324.Setneighborid(new_neighborset24);
					tagN1324.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1324);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[12].neighbors[i];
					}
					tagN1325.Setneighborid(new_neighborset25);
					tagN1325.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1325);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[12]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[12])
						{
							new_neighborsetmax[i] = neighbor_set[12].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN13max.Setneighborid(new_neighborsetmax);
					tagN13max.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN13max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN141 tagN141;
		CustomMetaDataUnicastTagN142 tagN142;
		CustomMetaDataUnicastTagN143 tagN143;
		CustomMetaDataUnicastTagN144 tagN144;
		CustomMetaDataUnicastTagN145 tagN145;
		CustomMetaDataUnicastTagN146 tagN146;
		CustomMetaDataUnicastTagN147 tagN147;
		CustomMetaDataUnicastTagN148 tagN148;
		CustomMetaDataUnicastTagN149 tagN149;
		CustomMetaDataUnicastTagN1410 tagN1410;
		CustomMetaDataUnicastTagN1411 tagN1411;
		CustomMetaDataUnicastTagN1412 tagN1412;
		CustomMetaDataUnicastTagN1413 tagN1413;
		CustomMetaDataUnicastTagN1414 tagN1414;
		CustomMetaDataUnicastTagN1415 tagN1415;
		CustomMetaDataUnicastTagN1416 tagN1416;
		CustomMetaDataUnicastTagN1417 tagN1417;
		CustomMetaDataUnicastTagN1418 tagN1418;
		CustomMetaDataUnicastTagN1419 tagN1419;
		CustomMetaDataUnicastTagN1420 tagN1420;
		CustomMetaDataUnicastTagN1421 tagN1421;
		CustomMetaDataUnicastTagN1422 tagN1422;
		CustomMetaDataUnicastTagN1423 tagN1423;
		CustomMetaDataUnicastTagN1424 tagN1424;
		CustomMetaDataUnicastTagN1425 tagN1425;
		CustomMetaDataUnicastTagN14max tagN14max;
		
		if ((nei_sizes[13] > 0)and (neighbors_changed[13]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[13] = false;
			switch(nei_sizes[13])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[13].neighbors[0];
					tagN141.Setneighborid(new_neighborset1);
					tagN141.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN141);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[13].neighbors[i];
					}
					tagN142.Setneighborid(new_neighborset2);
					tagN142.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN142);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[13].neighbors[i];
					}
					tagN143.Setneighborid(new_neighborset3);
					tagN143.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN143);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[13].neighbors[i];
					}
					tagN144.Setneighborid(new_neighborset4);
					tagN144.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN144);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[13].neighbors[i];
					}
					tagN145.Setneighborid(new_neighborset5);
					tagN145.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN145);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[13].neighbors[i];
					}
					tagN146.Setneighborid(new_neighborset6);
					tagN146.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN146);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[13].neighbors[i];
					}
					tagN147.Setneighborid(new_neighborset7);
					tagN147.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN147);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[13].neighbors[i];
					}
					tagN148.Setneighborid(new_neighborset8);
					tagN148.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN148);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[13].neighbors[i];
					}
					tagN149.Setneighborid(new_neighborset9);
					tagN149.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN149);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[13].neighbors[i];
					}
					tagN1410.Setneighborid(new_neighborset10);
					tagN1410.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1410);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[13].neighbors[i];
					}
					tagN1411.Setneighborid(new_neighborset11);
					tagN1411.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1411);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[13].neighbors[i];
					}
					tagN1412.Setneighborid(new_neighborset12);
					tagN1412.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1412);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[13].neighbors[i];
					}
					tagN1413.Setneighborid(new_neighborset13);
					tagN1413.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1413);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[13].neighbors[i];
					}
					tagN1414.Setneighborid(new_neighborset14);
					tagN1414.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1414);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[13].neighbors[i];
					}
					tagN1415.Setneighborid(new_neighborset15);
					tagN1415.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1415);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[13].neighbors[i];
					}
					tagN1416.Setneighborid(new_neighborset16);
					tagN1416.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1416);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[13].neighbors[i];
					}
					tagN1417.Setneighborid(new_neighborset17);
					tagN1417.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1417);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[13].neighbors[i];
					}
					tagN1418.Setneighborid(new_neighborset18);
					tagN1418.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1418);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[13].neighbors[i];
					}
					tagN1419.Setneighborid(new_neighborset19);
					tagN1419.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1419);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[13].neighbors[i];
					}
					tagN1420.Setneighborid(new_neighborset20);
					tagN1420.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1420);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[13].neighbors[i];
					}
					tagN1421.Setneighborid(new_neighborset21);
					tagN1421.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1421);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[13].neighbors[i];
					}
					tagN1422.Setneighborid(new_neighborset22);
					tagN1422.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1422);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[13].neighbors[i];
					}
					tagN1423.Setneighborid(new_neighborset23);
					tagN1423.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1423);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[13].neighbors[i];
					}
					tagN1424.Setneighborid(new_neighborset24);
					tagN1424.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1424);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[13].neighbors[i];
					}
					tagN1425.Setneighborid(new_neighborset25);
					tagN1425.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1425);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[13]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[13])
						{
							new_neighborsetmax[i] = neighbor_set[13].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN14max.Setneighborid(new_neighborsetmax);
					tagN14max.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN14max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN151 tagN151;
		CustomMetaDataUnicastTagN152 tagN152;
		CustomMetaDataUnicastTagN153 tagN153;
		CustomMetaDataUnicastTagN154 tagN154;
		CustomMetaDataUnicastTagN155 tagN155;
		CustomMetaDataUnicastTagN156 tagN156;
		CustomMetaDataUnicastTagN157 tagN157;
		CustomMetaDataUnicastTagN158 tagN158;
		CustomMetaDataUnicastTagN159 tagN159;
		CustomMetaDataUnicastTagN1510 tagN1510;
		CustomMetaDataUnicastTagN1511 tagN1511;
		CustomMetaDataUnicastTagN1512 tagN1512;
		CustomMetaDataUnicastTagN1513 tagN1513;
		CustomMetaDataUnicastTagN1514 tagN1514;
		CustomMetaDataUnicastTagN1515 tagN1515;
		CustomMetaDataUnicastTagN1516 tagN1516;
		CustomMetaDataUnicastTagN1517 tagN1517;
		CustomMetaDataUnicastTagN1518 tagN1518;
		CustomMetaDataUnicastTagN1519 tagN1519;
		CustomMetaDataUnicastTagN1520 tagN1520;
		CustomMetaDataUnicastTagN1521 tagN1521;
		CustomMetaDataUnicastTagN1522 tagN1522;
		CustomMetaDataUnicastTagN1523 tagN1523;
		CustomMetaDataUnicastTagN1524 tagN1524;
		CustomMetaDataUnicastTagN1525 tagN1525;
		CustomMetaDataUnicastTagN15max tagN15max;
		
		if ((nei_sizes[14] > 0)and (neighbors_changed[14]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[14] = false;
			switch(nei_sizes[14])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[14].neighbors[0];
					tagN151.Setneighborid(new_neighborset1);
					tagN151.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN151);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[14].neighbors[i];
					}
					tagN152.Setneighborid(new_neighborset2);
					tagN152.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN152);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[14].neighbors[i];
					}
					tagN153.Setneighborid(new_neighborset3);
					tagN153.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN153);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[14].neighbors[i];
					}
					tagN154.Setneighborid(new_neighborset4);
					tagN154.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN154);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[14].neighbors[i];
					}
					tagN155.Setneighborid(new_neighborset5);
					tagN155.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN155);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[14].neighbors[i];
					}
					tagN156.Setneighborid(new_neighborset6);
					tagN156.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN156);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[14].neighbors[i];
					}
					tagN157.Setneighborid(new_neighborset7);
					tagN157.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN157);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[14].neighbors[i];
					}
					tagN158.Setneighborid(new_neighborset8);
					tagN158.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN158);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[14].neighbors[i];
					}
					tagN159.Setneighborid(new_neighborset9);
					tagN159.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN159);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[14].neighbors[i];
					}
					tagN1510.Setneighborid(new_neighborset10);
					tagN1510.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1510);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[14].neighbors[i];
					}
					tagN1511.Setneighborid(new_neighborset11);
					tagN1511.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1511);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[14].neighbors[i];
					}
					tagN1512.Setneighborid(new_neighborset12);
					tagN1512.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1512);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[14].neighbors[i];
					}
					tagN1513.Setneighborid(new_neighborset13);
					tagN1513.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1513);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[14].neighbors[i];
					}
					tagN1514.Setneighborid(new_neighborset14);
					tagN1514.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1514);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[14].neighbors[i];
					}
					tagN1515.Setneighborid(new_neighborset15);
					tagN1515.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1515);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[14].neighbors[i];
					}
					tagN1516.Setneighborid(new_neighborset16);
					tagN1516.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1516);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[14].neighbors[i];
					}
					tagN1517.Setneighborid(new_neighborset17);
					tagN1517.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1517);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[14].neighbors[i];
					}
					tagN1518.Setneighborid(new_neighborset18);
					tagN1518.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1518);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[14].neighbors[i];
					}
					tagN1519.Setneighborid(new_neighborset19);
					tagN1519.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1519);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[14].neighbors[i];
					}
					tagN1520.Setneighborid(new_neighborset20);
					tagN1520.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1520);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[14].neighbors[i];
					}
					tagN1521.Setneighborid(new_neighborset21);
					tagN1521.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1521);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[14].neighbors[i];
					}
					tagN1522.Setneighborid(new_neighborset22);
					tagN1522.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1522);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[14].neighbors[i];
					}
					tagN1523.Setneighborid(new_neighborset23);
					tagN1523.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1523);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[14].neighbors[i];
					}
					tagN1524.Setneighborid(new_neighborset24);
					tagN1524.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1524);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[14].neighbors[i];
					}
					tagN1525.Setneighborid(new_neighborset25);
					tagN1525.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1525);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is  "<<nei_sizes[14]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[14])
						{
							new_neighborsetmax[i] = neighbor_set[14].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN15max.Setneighborid(new_neighborsetmax);
					tagN15max.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN15max);
					break;
			}
		
		}
		CustomMetaDataUnicastTagN161 tagN161;
		CustomMetaDataUnicastTagN162 tagN162;
		CustomMetaDataUnicastTagN163 tagN163;
		CustomMetaDataUnicastTagN164 tagN164;
		CustomMetaDataUnicastTagN165 tagN165;
		CustomMetaDataUnicastTagN166 tagN166;
		CustomMetaDataUnicastTagN167 tagN167;
		CustomMetaDataUnicastTagN168 tagN168;
		CustomMetaDataUnicastTagN169 tagN169;
		CustomMetaDataUnicastTagN1610 tagN1610;
		CustomMetaDataUnicastTagN1611 tagN1611;
		CustomMetaDataUnicastTagN1612 tagN1612;
		CustomMetaDataUnicastTagN1613 tagN1613;
		CustomMetaDataUnicastTagN1614 tagN1614;
		CustomMetaDataUnicastTagN1615 tagN1615;
		CustomMetaDataUnicastTagN1616 tagN1616;
		CustomMetaDataUnicastTagN1617 tagN1617;
		CustomMetaDataUnicastTagN1618 tagN1618;
		CustomMetaDataUnicastTagN1619 tagN1619;
		CustomMetaDataUnicastTagN1620 tagN1620;
		CustomMetaDataUnicastTagN1621 tagN1621;
		CustomMetaDataUnicastTagN1622 tagN1622;
		CustomMetaDataUnicastTagN1623 tagN1623;
		CustomMetaDataUnicastTagN1624 tagN1624;
		CustomMetaDataUnicastTagN1625 tagN1625;
		CustomMetaDataUnicastTagN16max tagN16max;
		
		if ((nei_sizes[15] > 0)and (neighbors_changed[15]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[15] = false;
			switch(nei_sizes[15])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[15].neighbors[0];
					tagN161.Setneighborid(new_neighborset1);
					tagN161.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN161);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[15].neighbors[i];
					}
					tagN162.Setneighborid(new_neighborset2);
					tagN162.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN162);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[15].neighbors[i];
					}
					tagN163.Setneighborid(new_neighborset3);
					tagN163.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN163);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[15].neighbors[i];
					}
					tagN164.Setneighborid(new_neighborset4);
					tagN164.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN164);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[15].neighbors[i];
					}
					tagN165.Setneighborid(new_neighborset5);
					tagN165.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN165);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[15].neighbors[i];
					}
					tagN166.Setneighborid(new_neighborset6);
					tagN166.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN166);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[15].neighbors[i];
					}
					tagN167.Setneighborid(new_neighborset7);
					tagN167.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN167);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[15].neighbors[i];
					}
					tagN168.Setneighborid(new_neighborset8);
					tagN168.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN168);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[15].neighbors[i];
					}
					tagN169.Setneighborid(new_neighborset9);
					tagN169.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN169);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[15].neighbors[i];
					}
					tagN1610.Setneighborid(new_neighborset10);
					tagN1610.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1610);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[15].neighbors[i];
					}
					tagN1611.Setneighborid(new_neighborset11);
					tagN1611.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1611);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[15].neighbors[i];
					}
					tagN1612.Setneighborid(new_neighborset12);
					tagN1612.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1612);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[15].neighbors[i];
					}
					tagN1613.Setneighborid(new_neighborset13);
					tagN1613.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1613);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[15].neighbors[i];
					}
					tagN1614.Setneighborid(new_neighborset14);
					tagN1614.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1614);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[15].neighbors[i];
					}
					tagN1615.Setneighborid(new_neighborset15);
					tagN1615.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1615);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[15].neighbors[i];
					}
					tagN1616.Setneighborid(new_neighborset16);
					tagN1616.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1616);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[15].neighbors[i];
					}
					tagN1617.Setneighborid(new_neighborset17);
					tagN1617.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1617);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[15].neighbors[i];
					}
					tagN1618.Setneighborid(new_neighborset18);
					tagN1618.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1618);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[15].neighbors[i];
					}
					tagN1619.Setneighborid(new_neighborset19);
					tagN1619.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1619);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[15].neighbors[i];
					}
					tagN1620.Setneighborid(new_neighborset20);
					tagN1620.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1620);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[15].neighbors[i];
					}
					tagN1621.Setneighborid(new_neighborset21);
					tagN1621.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1621);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[15].neighbors[i];
					}
					tagN1622.Setneighborid(new_neighborset22);
					tagN1622.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1622);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[15].neighbors[i];
					}
					tagN1623.Setneighborid(new_neighborset23);
					tagN1623.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1623);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[15].neighbors[i];
					}
					tagN1624.Setneighborid(new_neighborset24);
					tagN1624.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1624);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[15].neighbors[i];
					}
					tagN1625.Setneighborid(new_neighborset25);
					tagN1625.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1625);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[15]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[15])
						{
							new_neighborsetmax[i] = neighbor_set[15].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN16max.Setneighborid(new_neighborsetmax);
					tagN16max.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN16max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN171 tagN171;
		CustomMetaDataUnicastTagN172 tagN172;
		CustomMetaDataUnicastTagN173 tagN173;
		CustomMetaDataUnicastTagN174 tagN174;
		CustomMetaDataUnicastTagN175 tagN175;
		CustomMetaDataUnicastTagN176 tagN176;
		CustomMetaDataUnicastTagN177 tagN177;
		CustomMetaDataUnicastTagN178 tagN178;
		CustomMetaDataUnicastTagN179 tagN179;
		CustomMetaDataUnicastTagN1710 tagN1710;
		CustomMetaDataUnicastTagN1711 tagN1711;
		CustomMetaDataUnicastTagN1712 tagN1712;
		CustomMetaDataUnicastTagN1713 tagN1713;
		CustomMetaDataUnicastTagN1714 tagN1714;
		CustomMetaDataUnicastTagN1715 tagN1715;
		CustomMetaDataUnicastTagN1716 tagN1716;
		CustomMetaDataUnicastTagN1717 tagN1717;
		CustomMetaDataUnicastTagN1718 tagN1718;
		CustomMetaDataUnicastTagN1719 tagN1719;
		CustomMetaDataUnicastTagN1720 tagN1720;
		CustomMetaDataUnicastTagN1721 tagN1721;
		CustomMetaDataUnicastTagN1722 tagN1722;
		CustomMetaDataUnicastTagN1723 tagN1723;
		CustomMetaDataUnicastTagN1724 tagN1724;
		CustomMetaDataUnicastTagN1725 tagN1725;
		CustomMetaDataUnicastTagN17max tagN17max;
		
		if ((nei_sizes[16] > 0) and (neighbors_changed[16]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[16] = false;
			switch(nei_sizes[16])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[16].neighbors[0];
					tagN171.Setneighborid(new_neighborset1);
					tagN171.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN171);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[16].neighbors[i];
					}
					tagN172.Setneighborid(new_neighborset2);
					tagN172.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN172);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[16].neighbors[i];
					}
					tagN173.Setneighborid(new_neighborset3);
					tagN173.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN173);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[16].neighbors[i];
					}
					tagN174.Setneighborid(new_neighborset4);
					tagN174.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN174);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[16].neighbors[i];
					}
					tagN175.Setneighborid(new_neighborset5);
					tagN175.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN175);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[16].neighbors[i];
					}
					tagN176.Setneighborid(new_neighborset6);
					tagN176.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN176);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[16].neighbors[i];
					}
					tagN177.Setneighborid(new_neighborset7);
					tagN177.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN177);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[16].neighbors[i];
					}
					tagN178.Setneighborid(new_neighborset8);
					tagN178.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN178);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[16].neighbors[i];
					}
					tagN179.Setneighborid(new_neighborset9);
					tagN179.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN179);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[16].neighbors[i];
					}
					tagN1710.Setneighborid(new_neighborset10);
					tagN1710.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1710);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[16].neighbors[i];
					}
					tagN1711.Setneighborid(new_neighborset11);
					tagN1711.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1711);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[16].neighbors[i];
					}
					tagN1712.Setneighborid(new_neighborset12);
					tagN1712.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1712);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[16].neighbors[i];
					}
					tagN1713.Setneighborid(new_neighborset13);
					tagN1713.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1713);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[16].neighbors[i];
					}
					tagN1714.Setneighborid(new_neighborset14);
					tagN1714.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1714);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[16].neighbors[i];
					}
					tagN1715.Setneighborid(new_neighborset15);
					tagN1715.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1715);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[16].neighbors[i];
					}
					tagN1716.Setneighborid(new_neighborset16);
					tagN1716.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1716);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[16].neighbors[i];
					}
					tagN1717.Setneighborid(new_neighborset17);
					tagN1717.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1717);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[16].neighbors[i];
					}
					tagN1718.Setneighborid(new_neighborset18);
					tagN1718.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1718);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[16].neighbors[i];
					}
					tagN1719.Setneighborid(new_neighborset19);
					tagN1719.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1719);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[16].neighbors[i];
					}
					tagN1720.Setneighborid(new_neighborset20);
					tagN1720.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1720);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[16].neighbors[i];
					}
					tagN1721.Setneighborid(new_neighborset21);
					tagN1721.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1721);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[16].neighbors[i];
					}
					tagN1722.Setneighborid(new_neighborset22);
					tagN1722.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1722);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[16].neighbors[i];
					}
					tagN1723.Setneighborid(new_neighborset23);
					tagN1723.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1723);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[16].neighbors[i];
					}
					tagN1724.Setneighborid(new_neighborset24);
					tagN1724.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1724);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[16].neighbors[i];
					}
					tagN1725.Setneighborid(new_neighborset25);
					tagN1725.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1725);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is  "<<nei_sizes[16]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[16])
						{
							new_neighborsetmax[i] = neighbor_set[16].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN17max.Setneighborid(new_neighborsetmax);
					tagN17max.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN17max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN181 tagN181;
		CustomMetaDataUnicastTagN182 tagN182;
		CustomMetaDataUnicastTagN183 tagN183;
		CustomMetaDataUnicastTagN184 tagN184;
		CustomMetaDataUnicastTagN185 tagN185;
		CustomMetaDataUnicastTagN186 tagN186;
		CustomMetaDataUnicastTagN187 tagN187;
		CustomMetaDataUnicastTagN188 tagN188;
		CustomMetaDataUnicastTagN189 tagN189;
		CustomMetaDataUnicastTagN1810 tagN1810;
		CustomMetaDataUnicastTagN1811 tagN1811;
		CustomMetaDataUnicastTagN1812 tagN1812;
		CustomMetaDataUnicastTagN1813 tagN1813;
		CustomMetaDataUnicastTagN1814 tagN1814;
		CustomMetaDataUnicastTagN1815 tagN1815;
		CustomMetaDataUnicastTagN1816 tagN1816;
		CustomMetaDataUnicastTagN1817 tagN1817;
		CustomMetaDataUnicastTagN1818 tagN1818;
		CustomMetaDataUnicastTagN1819 tagN1819;
		CustomMetaDataUnicastTagN1820 tagN1820;
		CustomMetaDataUnicastTagN1821 tagN1821;
		CustomMetaDataUnicastTagN1822 tagN1822;
		CustomMetaDataUnicastTagN1823 tagN1823;
		CustomMetaDataUnicastTagN1824 tagN1824;
		CustomMetaDataUnicastTagN1825 tagN1825;
		CustomMetaDataUnicastTagN18max tagN18max;
		
		if ((nei_sizes[17] > 0) and (neighbors_changed[17]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[17] = false;
			switch(nei_sizes[17])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[17].neighbors[0];
					tagN181.Setneighborid(new_neighborset1);
					tagN181.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN181);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[17].neighbors[i];
					}
					tagN182.Setneighborid(new_neighborset2);
					tagN182.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN182);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[17].neighbors[i];
					}
					tagN183.Setneighborid(new_neighborset3);
					tagN183.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN183);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[17].neighbors[i];
					}
					tagN184.Setneighborid(new_neighborset4);
					tagN184.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN184);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[17].neighbors[i];
					}
					tagN185.Setneighborid(new_neighborset5);
					tagN185.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN185);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[17].neighbors[i];
					}
					tagN186.Setneighborid(new_neighborset6);
					tagN186.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN186);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[17].neighbors[i];
					}
					tagN187.Setneighborid(new_neighborset7);
					tagN187.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN187);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[17].neighbors[i];
					}
					tagN188.Setneighborid(new_neighborset8);
					tagN188.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN188);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[17].neighbors[i];
					}
					tagN189.Setneighborid(new_neighborset9);
					tagN189.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN189);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[17].neighbors[i];
					}
					tagN1810.Setneighborid(new_neighborset10);
					tagN1810.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1810);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[17].neighbors[i];
					}
					tagN1811.Setneighborid(new_neighborset11);
					tagN1811.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1811);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[17].neighbors[i];
					}
					tagN1812.Setneighborid(new_neighborset12);
					tagN1812.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1812);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[17].neighbors[i];
					}
					tagN1813.Setneighborid(new_neighborset13);
					tagN1813.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1813);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[17].neighbors[i];
					}
					tagN1814.Setneighborid(new_neighborset14);
					tagN1814.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1814);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[17].neighbors[i];
					}
					tagN1815.Setneighborid(new_neighborset15);
					tagN1815.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1815);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[17].neighbors[i];
					}
					tagN1816.Setneighborid(new_neighborset16);
					tagN1816.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1816);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[17].neighbors[i];
					}
					tagN1817.Setneighborid(new_neighborset17);
					tagN1817.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1817);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[17].neighbors[i];
					}
					tagN1818.Setneighborid(new_neighborset18);
					tagN1818.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1818);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[17].neighbors[i];
					}
					tagN1819.Setneighborid(new_neighborset19);
					tagN1819.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1819);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[17].neighbors[i];
					}
					tagN1820.Setneighborid(new_neighborset20);
					tagN1820.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1820);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[17].neighbors[i];
					}
					tagN1821.Setneighborid(new_neighborset21);
					tagN1821.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1821);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[17].neighbors[i];
					}
					tagN1822.Setneighborid(new_neighborset22);
					tagN1822.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1822);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[17].neighbors[i];
					}
					tagN1823.Setneighborid(new_neighborset23);
					tagN1823.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1823);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[17].neighbors[i];
					}
					tagN1824.Setneighborid(new_neighborset24);
					tagN1824.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1824);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[17].neighbors[i];
					}
					tagN1825.Setneighborid(new_neighborset25);
					tagN1825.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1825);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[17]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[17])
						{
							new_neighborsetmax[i] = neighbor_set[17].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN18max.Setneighborid(new_neighborsetmax);
					tagN18max.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN18max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN191 tagN191;
		CustomMetaDataUnicastTagN192 tagN192;
		CustomMetaDataUnicastTagN193 tagN193;
		CustomMetaDataUnicastTagN194 tagN194;
		CustomMetaDataUnicastTagN195 tagN195;
		CustomMetaDataUnicastTagN196 tagN196;
		CustomMetaDataUnicastTagN197 tagN197;
		CustomMetaDataUnicastTagN198 tagN198;
		CustomMetaDataUnicastTagN199 tagN199;
		CustomMetaDataUnicastTagN1910 tagN1910;
		CustomMetaDataUnicastTagN1911 tagN1911;
		CustomMetaDataUnicastTagN1912 tagN1912;
		CustomMetaDataUnicastTagN1913 tagN1913;
		CustomMetaDataUnicastTagN1914 tagN1914;
		CustomMetaDataUnicastTagN1915 tagN1915;
		CustomMetaDataUnicastTagN1916 tagN1916;
		CustomMetaDataUnicastTagN1917 tagN1917;
		CustomMetaDataUnicastTagN1918 tagN1918;
		CustomMetaDataUnicastTagN1919 tagN1919;
		CustomMetaDataUnicastTagN1920 tagN1920;
		CustomMetaDataUnicastTagN1921 tagN1921;
		CustomMetaDataUnicastTagN1922 tagN1922;
		CustomMetaDataUnicastTagN1923 tagN1923;
		CustomMetaDataUnicastTagN1924 tagN1924;
		CustomMetaDataUnicastTagN1925 tagN1925;
		CustomMetaDataUnicastTagN19max tagN19max;
		
		if ((nei_sizes[18] > 0) and (neighbors_changed[18]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[18] = false;
			switch(nei_sizes[18])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[18].neighbors[0];
					tagN191.Setneighborid(new_neighborset1);
					tagN191.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN191);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[18].neighbors[i];
					}
					tagN192.Setneighborid(new_neighborset2);
					tagN192.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN192);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[18].neighbors[i];
					}
					tagN193.Setneighborid(new_neighborset3);
					tagN193.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN193);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[18].neighbors[i];
					}
					tagN194.Setneighborid(new_neighborset4);
					tagN194.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN194);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[18].neighbors[i];
					}
					tagN195.Setneighborid(new_neighborset5);
					tagN195.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN195);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[18].neighbors[i];
					}
					tagN196.Setneighborid(new_neighborset6);
					tagN196.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN196);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[18].neighbors[i];
					}
					tagN197.Setneighborid(new_neighborset7);
					tagN197.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN197);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[18].neighbors[i];
					}
					tagN198.Setneighborid(new_neighborset8);
					tagN198.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN198);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[18].neighbors[i];
					}
					tagN199.Setneighborid(new_neighborset9);
					tagN199.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN199);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[18].neighbors[i];
					}
					tagN1910.Setneighborid(new_neighborset10);
					tagN1910.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1910);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[18].neighbors[i];
					}
					tagN1911.Setneighborid(new_neighborset11);
					tagN1911.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1911);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[18].neighbors[i];
					}
					tagN1912.Setneighborid(new_neighborset12);
					tagN1912.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1912);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[18].neighbors[i];
					}
					tagN1913.Setneighborid(new_neighborset13);
					tagN1913.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1913);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[18].neighbors[i];
					}
					tagN1914.Setneighborid(new_neighborset14);
					tagN1914.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1914);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[18].neighbors[i];
					}
					tagN1915.Setneighborid(new_neighborset15);
					tagN1915.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1915);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[18].neighbors[i];
					}
					tagN1916.Setneighborid(new_neighborset16);
					tagN1916.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1916);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[18].neighbors[i];
					}
					tagN1917.Setneighborid(new_neighborset17);
					tagN1917.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1917);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[18].neighbors[i];
					}
					tagN1918.Setneighborid(new_neighborset18);
					tagN1918.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1918);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[18].neighbors[i];
					}
					tagN1919.Setneighborid(new_neighborset19);
					tagN1919.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1919);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[18].neighbors[i];
					}
					tagN1920.Setneighborid(new_neighborset20);
					tagN1920.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1920);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[18].neighbors[i];
					}
					tagN1921.Setneighborid(new_neighborset21);
					tagN1921.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1921);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[18].neighbors[i];
					}
					tagN1922.Setneighborid(new_neighborset22);
					tagN1922.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1922);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[18].neighbors[i];
					}
					tagN1923.Setneighborid(new_neighborset23);
					tagN1923.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1923);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[18].neighbors[i];
					}
					tagN1924.Setneighborid(new_neighborset24);
					tagN1924.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1924);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[18].neighbors[i];
					}
					tagN1925.Setneighborid(new_neighborset25);
					tagN1925.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1925);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[18]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[18])
						{
							new_neighborsetmax[i] = neighbor_set[18].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN19max.Setneighborid(new_neighborsetmax);
					tagN19max.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN19max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN2001 tagN2001;
		CustomMetaDataUnicastTagN2002 tagN2002;
		CustomMetaDataUnicastTagN2003 tagN2003;
		CustomMetaDataUnicastTagN2004 tagN2004;
		CustomMetaDataUnicastTagN2005 tagN2005;
		CustomMetaDataUnicastTagN2006 tagN2006;
		CustomMetaDataUnicastTagN2007 tagN2007;
		CustomMetaDataUnicastTagN2008 tagN2008;
		CustomMetaDataUnicastTagN2009 tagN2009;
		CustomMetaDataUnicastTagN2010 tagN2010;
		CustomMetaDataUnicastTagN2011 tagN2011;
		CustomMetaDataUnicastTagN2012 tagN2012;
		CustomMetaDataUnicastTagN2013 tagN2013;
		CustomMetaDataUnicastTagN2014 tagN2014;
		CustomMetaDataUnicastTagN2015 tagN2015;
		CustomMetaDataUnicastTagN2016 tagN2016;
		CustomMetaDataUnicastTagN2017 tagN2017;
		CustomMetaDataUnicastTagN2018 tagN2018;
		CustomMetaDataUnicastTagN2019 tagN2019;
		CustomMetaDataUnicastTagN2020 tagN2020;
		CustomMetaDataUnicastTagN2021 tagN2021;
		CustomMetaDataUnicastTagN2022 tagN2022;
		CustomMetaDataUnicastTagN2023 tagN2023;
		CustomMetaDataUnicastTagN2024 tagN2024;
		CustomMetaDataUnicastTagN2025 tagN2025;
		CustomMetaDataUnicastTagN20max tagN20max;
		
		if ((nei_sizes[19] > 0) and (neighbors_changed[19]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[19] = false;
			switch(nei_sizes[19])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[19].neighbors[0];
					tagN2001.Setneighborid(new_neighborset1);
					tagN2001.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2001);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[19].neighbors[i];
					}
					tagN2002.Setneighborid(new_neighborset2);
					tagN2002.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2002);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[19].neighbors[i];
					}
					tagN2003.Setneighborid(new_neighborset3);
					tagN2003.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2003);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[19].neighbors[i];
					}
					tagN2004.Setneighborid(new_neighborset4);
					tagN2004.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2004);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[19].neighbors[i];
					}
					tagN2005.Setneighborid(new_neighborset5);
					tagN2005.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2005);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[19].neighbors[i];
					}
					tagN2006.Setneighborid(new_neighborset6);
					tagN2006.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2006);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[19].neighbors[i];
					}
					tagN2007.Setneighborid(new_neighborset7);
					tagN2007.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2007);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[19].neighbors[i];
					}
					tagN2008.Setneighborid(new_neighborset8);
					tagN2008.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2008);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[19].neighbors[i];
					}
					tagN2009.Setneighborid(new_neighborset9);
					tagN2009.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2009);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[19].neighbors[i];
					}
					tagN2010.Setneighborid(new_neighborset10);
					tagN2010.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2010);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[19].neighbors[i];
					}
					tagN2011.Setneighborid(new_neighborset11);
					tagN2011.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2011);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[19].neighbors[i];
					}
					tagN2012.Setneighborid(new_neighborset12);
					tagN2012.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2012);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[19].neighbors[i];
					}
					tagN2013.Setneighborid(new_neighborset13);
					tagN2013.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2013);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[19].neighbors[i];
					}
					tagN2014.Setneighborid(new_neighborset14);
					tagN2014.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2014);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[19].neighbors[i];
					}
					tagN2015.Setneighborid(new_neighborset15);
					tagN2015.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2015);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[19].neighbors[i];
					}
					tagN2016.Setneighborid(new_neighborset16);
					tagN2016.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2016);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[19].neighbors[i];
					}
					tagN2017.Setneighborid(new_neighborset17);
					tagN2017.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2017);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[19].neighbors[i];
					}
					tagN2018.Setneighborid(new_neighborset18);
					tagN2018.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2018);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[19].neighbors[i];
					}
					tagN2019.Setneighborid(new_neighborset19);
					tagN2019.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2019);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[19].neighbors[i];
					}
					tagN2020.Setneighborid(new_neighborset20);
					tagN2020.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2020);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[19].neighbors[i];
					}
					tagN2021.Setneighborid(new_neighborset21);
					tagN2021.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2021);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[19].neighbors[i];
					}
					tagN2022.Setneighborid(new_neighborset22);
					tagN2022.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2022);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[19].neighbors[i];
					}
					tagN2023.Setneighborid(new_neighborset23);
					tagN2023.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2023);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[19].neighbors[i];
					}
					tagN2024.Setneighborid(new_neighborset24);
					tagN2024.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2024);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[19].neighbors[i];
					}
					tagN2025.Setneighborid(new_neighborset25);
					tagN2025.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2025);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[19]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[19])
						{
							new_neighborsetmax[i] = neighbor_set[19].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN20max.Setneighborid(new_neighborsetmax);
					tagN20max.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN20max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN2101 tagN2101;
		CustomMetaDataUnicastTagN2102 tagN2102;
		CustomMetaDataUnicastTagN2103 tagN2103;
		CustomMetaDataUnicastTagN2104 tagN2104;
		CustomMetaDataUnicastTagN2105 tagN2105;
		CustomMetaDataUnicastTagN2106 tagN2106;
		CustomMetaDataUnicastTagN2107 tagN2107;
		CustomMetaDataUnicastTagN2108 tagN2108;
		CustomMetaDataUnicastTagN2109 tagN2109;
		CustomMetaDataUnicastTagN2110 tagN2110;
		CustomMetaDataUnicastTagN2111 tagN2111;
		CustomMetaDataUnicastTagN2112 tagN2112;
		CustomMetaDataUnicastTagN2113 tagN2113;
		CustomMetaDataUnicastTagN2114 tagN2114;
		CustomMetaDataUnicastTagN2115 tagN2115;
		CustomMetaDataUnicastTagN2116 tagN2116;
		CustomMetaDataUnicastTagN2117 tagN2117;
		CustomMetaDataUnicastTagN2118 tagN2118;
		CustomMetaDataUnicastTagN2119 tagN2119;
		CustomMetaDataUnicastTagN2120 tagN2120;
		CustomMetaDataUnicastTagN2121 tagN2121;
		CustomMetaDataUnicastTagN2122 tagN2122;
		CustomMetaDataUnicastTagN2123 tagN2123;
		CustomMetaDataUnicastTagN2124 tagN2124;
		CustomMetaDataUnicastTagN2125 tagN2125;
		CustomMetaDataUnicastTagN21max tagN21max;
		
		if ((nei_sizes[20] > 0) and (neighbors_changed[20]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[20] = false;
			switch(nei_sizes[20])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[20].neighbors[0];
					tagN2101.Setneighborid(new_neighborset1);
					tagN2101.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2101);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[20].neighbors[i];
					}
					tagN2102.Setneighborid(new_neighborset2);
					tagN2102.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2102);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[20].neighbors[i];
					}
					tagN2103.Setneighborid(new_neighborset3);
					tagN2103.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2103);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[20].neighbors[i];
					}
					tagN2104.Setneighborid(new_neighborset4);
					tagN2104.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2104);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[20].neighbors[i];
					}
					tagN2105.Setneighborid(new_neighborset5);
					tagN2105.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2105);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[20].neighbors[i];
					}
					tagN2106.Setneighborid(new_neighborset6);
					tagN2106.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2106);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[20].neighbors[i];
					}
					tagN2107.Setneighborid(new_neighborset7);
					tagN2107.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2107);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[20].neighbors[i];
					}
					tagN2108.Setneighborid(new_neighborset8);
					tagN2108.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2108);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[20].neighbors[i];
					}
					tagN2109.Setneighborid(new_neighborset9);
					tagN2109.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2109);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[20].neighbors[i];
					}
					tagN2110.Setneighborid(new_neighborset10);
					tagN2110.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2110);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[20].neighbors[i];
					}
					tagN2111.Setneighborid(new_neighborset11);
					tagN2111.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2111);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[20].neighbors[i];
					}
					tagN2112.Setneighborid(new_neighborset12);
					tagN2112.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2112);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[20].neighbors[i];
					}
					tagN2113.Setneighborid(new_neighborset13);
					tagN2113.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2113);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[20].neighbors[i];
					}
					tagN2114.Setneighborid(new_neighborset14);
					tagN2114.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2114);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[20].neighbors[i];
					}
					tagN2115.Setneighborid(new_neighborset15);
					tagN2115.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2115);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[20].neighbors[i];
					}
					tagN2116.Setneighborid(new_neighborset16);
					tagN2116.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2116);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[20].neighbors[i];
					}
					tagN2117.Setneighborid(new_neighborset17);
					tagN2117.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2117);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[20].neighbors[i];
					}
					tagN2118.Setneighborid(new_neighborset18);
					tagN2118.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2118);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[20].neighbors[i];
					}
					tagN2119.Setneighborid(new_neighborset19);
					tagN2119.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2119);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[20].neighbors[i];
					}
					tagN2120.Setneighborid(new_neighborset20);
					tagN2120.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2120);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[20].neighbors[i];
					}
					tagN2121.Setneighborid(new_neighborset21);
					tagN2121.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2121);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[20].neighbors[i];
					}
					tagN2122.Setneighborid(new_neighborset22);
					tagN2122.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2122);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[20].neighbors[i];
					}
					tagN2123.Setneighborid(new_neighborset23);
					tagN2123.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2123);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[20].neighbors[i];
					}
					tagN2124.Setneighborid(new_neighborset24);
					tagN2124.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2124);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[20].neighbors[i];
					}
					tagN2125.Setneighborid(new_neighborset25);
					tagN2125.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2125);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is "<<nei_sizes[20]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[20])
						{
							new_neighborsetmax[i] = neighbor_set[20].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN21max.Setneighborid(new_neighborsetmax);
					tagN21max.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN21max);
					break;
			}
		}
		
		CustomMetaDataUnicastTagN2201 tagN2201;
		CustomMetaDataUnicastTagN2202 tagN2202;
		CustomMetaDataUnicastTagN2203 tagN2203;
		CustomMetaDataUnicastTagN2204 tagN2204;
		CustomMetaDataUnicastTagN2205 tagN2205;
		CustomMetaDataUnicastTagN2206 tagN2206;
		CustomMetaDataUnicastTagN2207 tagN2207;
		CustomMetaDataUnicastTagN2208 tagN2208;
		CustomMetaDataUnicastTagN2209 tagN2209;
		CustomMetaDataUnicastTagN2210 tagN2210;
		CustomMetaDataUnicastTagN2211 tagN2211;
		CustomMetaDataUnicastTagN2212 tagN2212;
		CustomMetaDataUnicastTagN2213 tagN2213;
		CustomMetaDataUnicastTagN2214 tagN2214;
		CustomMetaDataUnicastTagN2215 tagN2215;
		CustomMetaDataUnicastTagN2216 tagN2216;
		CustomMetaDataUnicastTagN2217 tagN2217;
		CustomMetaDataUnicastTagN2218 tagN2218;
		CustomMetaDataUnicastTagN2219 tagN2219;
		CustomMetaDataUnicastTagN2220 tagN2220;
		CustomMetaDataUnicastTagN2221 tagN2221;
		CustomMetaDataUnicastTagN2222 tagN2222;
		CustomMetaDataUnicastTagN2223 tagN2223;
		CustomMetaDataUnicastTagN2224 tagN2224;
		CustomMetaDataUnicastTagN2225 tagN2225;
		CustomMetaDataUnicastTagN22max tagN22max;
		
		if ((nei_sizes[21] > 0) and (neighbors_changed[21]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[21] = false;
			switch(nei_sizes[21])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[21].neighbors[0];
					tagN2201.Setneighborid(new_neighborset1);
					tagN2201.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2201);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[21].neighbors[i];
					}
					tagN2202.Setneighborid(new_neighborset2);
					tagN2202.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2202);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[21].neighbors[i];
					}
					tagN2203.Setneighborid(new_neighborset3);
					tagN2203.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2203);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[21].neighbors[i];
					}
					tagN2204.Setneighborid(new_neighborset4);
					tagN2204.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2204);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[21].neighbors[i];
					}
					tagN2205.Setneighborid(new_neighborset5);
					tagN2205.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2205);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[21].neighbors[i];
					}
					tagN2206.Setneighborid(new_neighborset6);
					tagN2206.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2206);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[21].neighbors[i];
					}
					tagN2207.Setneighborid(new_neighborset7);
					tagN2207.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2207);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[21].neighbors[i];
					}
					tagN2208.Setneighborid(new_neighborset8);
					tagN2208.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2208);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[21].neighbors[i];
					}
					tagN2209.Setneighborid(new_neighborset9);
					tagN2209.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2209);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[21].neighbors[i];
					}
					tagN2210.Setneighborid(new_neighborset10);
					tagN2210.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2210);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[21].neighbors[i];
					}
					tagN2211.Setneighborid(new_neighborset11);
					tagN2211.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2211);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[21].neighbors[i];
					}
					tagN2212.Setneighborid(new_neighborset12);
					tagN2212.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2212);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[21].neighbors[i];
					}
					tagN2213.Setneighborid(new_neighborset13);
					tagN2213.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2213);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[21].neighbors[i];
					}
					tagN2214.Setneighborid(new_neighborset14);
					tagN2214.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2214);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[21].neighbors[i];
					}
					tagN2215.Setneighborid(new_neighborset15);
					tagN2215.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2215);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[21].neighbors[i];
					}
					tagN2216.Setneighborid(new_neighborset16);
					tagN2216.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2216);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[21].neighbors[i];
					}
					tagN2217.Setneighborid(new_neighborset17);
					tagN2217.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2217);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[21].neighbors[i];
					}
					tagN2218.Setneighborid(new_neighborset18);
					tagN2218.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2218);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[21].neighbors[i];
					}
					tagN2219.Setneighborid(new_neighborset19);
					tagN2219.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2219);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[21].neighbors[i];
					}
					tagN2220.Setneighborid(new_neighborset20);
					tagN2220.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2220);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[21].neighbors[i];
					}
					tagN2221.Setneighborid(new_neighborset21);
					tagN2221.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2221);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[21].neighbors[i];
					}
					tagN2222.Setneighborid(new_neighborset22);
					tagN2222.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2222);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[21].neighbors[i];
					}
					tagN2223.Setneighborid(new_neighborset23);
					tagN2223.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2223);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[21].neighbors[i];
					}
					tagN2224.Setneighborid(new_neighborset24);
					tagN2224.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2224);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[21].neighbors[i];
					}
					tagN2225.Setneighborid(new_neighborset25);
					tagN2225.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2225);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is "<<nei_sizes[21]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[21])
						{
							new_neighborsetmax[i] = neighbor_set[21].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN22max.Setneighborid(new_neighborsetmax);
					tagN22max.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN22max);
					break;
			}
		}
		
		CustomMetaDataUnicastTagN2301 tagN2301;
		CustomMetaDataUnicastTagN2302 tagN2302;
		CustomMetaDataUnicastTagN2303 tagN2303;
		CustomMetaDataUnicastTagN2304 tagN2304;
		CustomMetaDataUnicastTagN2305 tagN2305;
		CustomMetaDataUnicastTagN2306 tagN2306;
		CustomMetaDataUnicastTagN2307 tagN2307;
		CustomMetaDataUnicastTagN2308 tagN2308;
		CustomMetaDataUnicastTagN2309 tagN2309;
		CustomMetaDataUnicastTagN2310 tagN2310;
		CustomMetaDataUnicastTagN2311 tagN2311;
		CustomMetaDataUnicastTagN2312 tagN2312;
		CustomMetaDataUnicastTagN2313 tagN2313;
		CustomMetaDataUnicastTagN2314 tagN2314;
		CustomMetaDataUnicastTagN2315 tagN2315;
		CustomMetaDataUnicastTagN2316 tagN2316;
		CustomMetaDataUnicastTagN2317 tagN2317;
		CustomMetaDataUnicastTagN2318 tagN2318;
		CustomMetaDataUnicastTagN2319 tagN2319;
		CustomMetaDataUnicastTagN2320 tagN2320;
		CustomMetaDataUnicastTagN2321 tagN2321;
		CustomMetaDataUnicastTagN2322 tagN2322;
		CustomMetaDataUnicastTagN2323 tagN2323;
		CustomMetaDataUnicastTagN2324 tagN2324;
		CustomMetaDataUnicastTagN2325 tagN2325;
		CustomMetaDataUnicastTagN23max tagN23max;
		
		if ((nei_sizes[22] > 0) and (neighbors_changed[22]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[22] = false;
			switch(nei_sizes[22])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[22].neighbors[0];
					tagN2301.Setneighborid(new_neighborset1);
					tagN2301.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2301);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[22].neighbors[i];
					}
					tagN2302.Setneighborid(new_neighborset2);
					tagN2302.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2302);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[22].neighbors[i];
					}
					tagN2303.Setneighborid(new_neighborset3);
					tagN2303.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2303);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[22].neighbors[i];
					}
					tagN2304.Setneighborid(new_neighborset4);
					tagN2304.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2304);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[22].neighbors[i];
					}
					tagN2305.Setneighborid(new_neighborset5);
					tagN2305.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2305);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[22].neighbors[i];
					}
					tagN2306.Setneighborid(new_neighborset6);
					tagN2306.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2306);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[22].neighbors[i];
					}
					tagN2307.Setneighborid(new_neighborset7);
					tagN2307.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2307);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[22].neighbors[i];
					}
					tagN2308.Setneighborid(new_neighborset8);
					tagN2308.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2308);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[22].neighbors[i];
					}
					tagN2309.Setneighborid(new_neighborset9);
					tagN2309.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2309);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[22].neighbors[i];
					}
					tagN2310.Setneighborid(new_neighborset10);
					tagN2310.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2310);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[22].neighbors[i];
					}
					tagN2311.Setneighborid(new_neighborset11);
					tagN2311.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2311);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[22].neighbors[i];
					}
					tagN2312.Setneighborid(new_neighborset12);
					tagN2312.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2312);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[22].neighbors[i];
					}
					tagN2313.Setneighborid(new_neighborset13);
					tagN2313.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN2313);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[0].neighbors[i];
					}
					tagN2314.Setneighborid(new_neighborset14);
					tagN2314.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2314);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[22].neighbors[i];
					}
					tagN2315.Setneighborid(new_neighborset15);
					tagN2315.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2315);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[22].neighbors[i];
					}
					tagN2316.Setneighborid(new_neighborset16);
					tagN2316.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2316);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[22].neighbors[i];
					}
					tagN2317.Setneighborid(new_neighborset17);
					tagN2317.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2317);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[22].neighbors[i];
					}
					tagN2318.Setneighborid(new_neighborset18);
					tagN2318.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2318);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[22].neighbors[i];
					}
					tagN2319.Setneighborid(new_neighborset19);
					tagN2319.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2319);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[22].neighbors[i];
					}
					tagN2320.Setneighborid(new_neighborset20);
					tagN2320.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2320);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[22].neighbors[i];
					}
					tagN2321.Setneighborid(new_neighborset21);
					tagN2321.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2321);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[22].neighbors[i];
					}
					tagN2322.Setneighborid(new_neighborset22);
					tagN2322.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2322);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[22].neighbors[i];
					}
					tagN2323.Setneighborid(new_neighborset23);
					tagN2323.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2323);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[22].neighbors[i];
					}
					tagN2324.Setneighborid(new_neighborset24);
					tagN2324.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2324);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[22].neighbors[i];
					}
					tagN2325.Setneighborid(new_neighborset25);
					tagN2325.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2325);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is "<<nei_sizes[22]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[22])
						{
							new_neighborsetmax[i] = neighbor_set[22].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN23max.Setneighborid(new_neighborsetmax);
					tagN23max.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN23max);
					break;
			}
		}
		
		CustomMetaDataUnicastTagN2401 tagN2401;
		CustomMetaDataUnicastTagN2402 tagN2402;
		CustomMetaDataUnicastTagN2403 tagN2403;
		CustomMetaDataUnicastTagN2404 tagN2404;
		CustomMetaDataUnicastTagN2405 tagN2405;
		CustomMetaDataUnicastTagN2406 tagN2406;
		CustomMetaDataUnicastTagN2407 tagN2407;
		CustomMetaDataUnicastTagN2408 tagN2408;
		CustomMetaDataUnicastTagN2409 tagN2409;
		CustomMetaDataUnicastTagN2410 tagN2410;
		CustomMetaDataUnicastTagN2411 tagN2411;
		CustomMetaDataUnicastTagN2412 tagN2412;
		CustomMetaDataUnicastTagN2413 tagN2413;
		CustomMetaDataUnicastTagN2414 tagN2414;
		CustomMetaDataUnicastTagN2415 tagN2415;
		CustomMetaDataUnicastTagN2416 tagN2416;
		CustomMetaDataUnicastTagN2417 tagN2417;
		CustomMetaDataUnicastTagN2418 tagN2418;
		CustomMetaDataUnicastTagN2419 tagN2419;
		CustomMetaDataUnicastTagN2420 tagN2420;
		CustomMetaDataUnicastTagN2421 tagN2421;
		CustomMetaDataUnicastTagN2422 tagN2422;
		CustomMetaDataUnicastTagN2423 tagN2423;
		CustomMetaDataUnicastTagN2424 tagN2424;
		CustomMetaDataUnicastTagN2425 tagN2425;
		CustomMetaDataUnicastTagN24max tagN24max;
		
		if ((nei_sizes[23] > 0) and (neighbors_changed[23]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[23] = false;
			switch(nei_sizes[23])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[23].neighbors[0];
					tagN2401.Setneighborid(new_neighborset1);
					tagN2401.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2401);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[23].neighbors[i];
					}
					tagN2402.Setneighborid(new_neighborset2);
					tagN2402.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2402);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[23].neighbors[i];
					}
					tagN2403.Setneighborid(new_neighborset3);
					tagN2403.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2403);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[23].neighbors[i];
					}
					tagN2404.Setneighborid(new_neighborset4);
					tagN2404.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2404);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[23].neighbors[i];
					}
					tagN2405.Setneighborid(new_neighborset5);
					tagN2405.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2405);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[23].neighbors[i];
					}
					tagN2406.Setneighborid(new_neighborset6);
					tagN2406.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2406);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[23].neighbors[i];
					}
					tagN2407.Setneighborid(new_neighborset7);
					tagN2407.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2407);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[23].neighbors[i];
					}
					tagN2408.Setneighborid(new_neighborset8);
					tagN2408.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2408);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[23].neighbors[i];
					}
					tagN2409.Setneighborid(new_neighborset9);
					tagN2409.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2409);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[23].neighbors[i];
					}
					tagN2410.Setneighborid(new_neighborset10);
					tagN2410.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2410);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[23].neighbors[i];
					}
					tagN2411.Setneighborid(new_neighborset11);
					tagN2411.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2411);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[23].neighbors[i];
					}
					tagN2412.Setneighborid(new_neighborset12);
					tagN2412.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2412);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[23].neighbors[i];
					}
					tagN2413.Setneighborid(new_neighborset13);
					tagN2413.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2413);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[23].neighbors[i];
					}
					tagN2414.Setneighborid(new_neighborset14);
					tagN2414.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2414);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[23].neighbors[i];
					}
					tagN2415.Setneighborid(new_neighborset15);
					tagN2415.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2415);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[23].neighbors[i];
					}
					tagN2416.Setneighborid(new_neighborset16);
					tagN2416.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2416);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[23].neighbors[i];
					}
					tagN2417.Setneighborid(new_neighborset17);
					tagN2417.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2417);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[23].neighbors[i];
					}
					tagN2418.Setneighborid(new_neighborset18);
					tagN2418.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2418);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[23].neighbors[i];
					}
					tagN2419.Setneighborid(new_neighborset19);
					tagN2419.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2419);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[23].neighbors[i];
					}
					tagN2420.Setneighborid(new_neighborset20);
					tagN2420.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2420);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[23].neighbors[i];
					}
					tagN2421.Setneighborid(new_neighborset21);
					tagN2421.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2421);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[23].neighbors[i];
					}
					tagN2422.Setneighborid(new_neighborset22);
					tagN2422.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2422);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[23].neighbors[i];
					}
					tagN2423.Setneighborid(new_neighborset23);
					tagN2423.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2423);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[23].neighbors[i];
					}
					tagN2424.Setneighborid(new_neighborset24);
					tagN2424.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2424);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[23].neighbors[i];
					}
					tagN2425.Setneighborid(new_neighborset25);
					tagN2425.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2425);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is "<<nei_sizes[23]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[23])
						{
							new_neighborsetmax[i] = neighbor_set[23].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN24max.Setneighborid(new_neighborsetmax);
					tagN24max.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN24max);
					break;
			}
		}
		
		CustomMetaDataUnicastTagN2501 tagN2501;
		CustomMetaDataUnicastTagN2502 tagN2502;
		CustomMetaDataUnicastTagN2503 tagN2503;
		CustomMetaDataUnicastTagN2504 tagN2504;
		CustomMetaDataUnicastTagN2505 tagN2505;
		CustomMetaDataUnicastTagN2506 tagN2506;
		CustomMetaDataUnicastTagN2507 tagN2507;
		CustomMetaDataUnicastTagN2508 tagN2508;
		CustomMetaDataUnicastTagN2509 tagN2509;
		CustomMetaDataUnicastTagN2510 tagN2510;
		CustomMetaDataUnicastTagN2511 tagN2511;
		CustomMetaDataUnicastTagN2512 tagN2512;
		CustomMetaDataUnicastTagN2513 tagN2513;
		CustomMetaDataUnicastTagN2514 tagN2514;
		CustomMetaDataUnicastTagN2515 tagN2515;
		CustomMetaDataUnicastTagN2516 tagN2516;
		CustomMetaDataUnicastTagN2517 tagN2517;
		CustomMetaDataUnicastTagN2518 tagN2518;
		CustomMetaDataUnicastTagN2519 tagN2519;
		CustomMetaDataUnicastTagN2520 tagN2520;
		CustomMetaDataUnicastTagN2521 tagN2521;
		CustomMetaDataUnicastTagN2522 tagN2522;
		CustomMetaDataUnicastTagN2523 tagN2523;
		CustomMetaDataUnicastTagN2524 tagN2524;
		CustomMetaDataUnicastTagN2525 tagN2525;
		CustomMetaDataUnicastTagN25max tagN25max;
		
		if ((nei_sizes[24] > 0) and (neighbors_changed[24]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[24] = false;
			switch(nei_sizes[24])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[24].neighbors[0];
					tagN2501.Setneighborid(new_neighborset1);
					tagN2501.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2501);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[24].neighbors[i];
					}
					tagN2502.Setneighborid(new_neighborset2);
					tagN2502.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2502);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[24].neighbors[i];
					}
					tagN2503.Setneighborid(new_neighborset3);
					tagN2503.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2503);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[24].neighbors[i];
					}
					tagN2504.Setneighborid(new_neighborset4);
					tagN2504.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2504);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[24].neighbors[i];
					}
					tagN2505.Setneighborid(new_neighborset5);
					tagN2505.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2505);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[24].neighbors[i];
					}
					tagN2506.Setneighborid(new_neighborset6);
					tagN2506.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2506);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[24].neighbors[i];
					}
					tagN2507.Setneighborid(new_neighborset7);
					tagN2507.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2507);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[24].neighbors[i];
					}
					tagN2508.Setneighborid(new_neighborset8);
					tagN2508.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2508);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[24].neighbors[i];
					}
					tagN2509.Setneighborid(new_neighborset9);
					tagN2509.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2509);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[24].neighbors[i];
					}
					tagN2510.Setneighborid(new_neighborset10);
					tagN2510.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2510);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[24].neighbors[i];
					}
					tagN2511.Setneighborid(new_neighborset11);
					tagN2511.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2511);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[24].neighbors[i];
					}
					tagN2512.Setneighborid(new_neighborset12);
					tagN2512.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2512);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[24].neighbors[i];
					}
					tagN2513.Setneighborid(new_neighborset13);
					tagN2513.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2513);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[24].neighbors[i];
					}
					tagN2514.Setneighborid(new_neighborset14);
					tagN2514.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2514);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[24].neighbors[i];
					}
					tagN2515.Setneighborid(new_neighborset15);
					tagN2515.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2515);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[24].neighbors[i];
					}
					tagN2516.Setneighborid(new_neighborset16);
					tagN2516.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2516);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[24].neighbors[i];
					}
					tagN2517.Setneighborid(new_neighborset17);
					tagN2517.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2517);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[24].neighbors[i];
					}
					tagN2518.Setneighborid(new_neighborset18);
					tagN2518.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2518);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[24].neighbors[i];
					}
					tagN2519.Setneighborid(new_neighborset19);
					tagN2519.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2519);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[24].neighbors[i];
					}
					tagN2520.Setneighborid(new_neighborset20);
					tagN2520.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2520);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[24].neighbors[i];
					}
					tagN2521.Setneighborid(new_neighborset21);
					tagN2521.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2521);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[24].neighbors[i];
					}
					tagN2522.Setneighborid(new_neighborset22);
					tagN2522.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2522);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[24].neighbors[i];
					}
					tagN2523.Setneighborid(new_neighborset23);
					tagN2523.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2523);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[24].neighbors[i];
					}
					tagN2524.Setneighborid(new_neighborset24);
					tagN2524.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2524);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[24].neighbors[i];
					}
					tagN2525.Setneighborid(new_neighborset25);
					tagN2525.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2525);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is "<<nei_sizes[24]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[24])
						{
							new_neighborsetmax[i] = neighbor_set[24].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN25max.Setneighborid(new_neighborsetmax);
					tagN25max.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN25max);
					break;
			}
		}
		
		CustomMetaDataUnicastTagN26max tagN26max;
		if ((nei_sizes[25] > 0) and (neighbors_changed[25]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[25] = false;
			cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[25]<<endl;
			uint32_t new_neighborsetmax[max];
			for(uint32_t i=0;i<max;i++)
			{
				if(i<nei_sizes[25])
				{
					new_neighborsetmax[i] = neighbor_set[25].neighbors[i];
				}
				else
				{
					new_neighborsetmax[i] = large;
				}
			}
			tagN26max.Setneighborid(new_neighborsetmax);
			tagN26max.Setnodeid(nodeid[25]);
			packet1->AddPacketTag(tagN26max);
		}
		
		CustomMetaDataUnicastTagN27max tagN27max;
		if ((nei_sizes[26] > 0) and (neighbors_changed[26]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[26] = false;
			cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[26]<<endl;
			uint32_t new_neighborsetmax[max];
			for(uint32_t i=0;i<max;i++)
			{
				if(i<nei_sizes[26])
				{
					new_neighborsetmax[i] = neighbor_set[26].neighbors[i];
				}
				else
				{
					new_neighborsetmax[i] = large;
				}
			}
			tagN27max.Setneighborid(new_neighborsetmax);
			tagN27max.Setnodeid(nodeid[26]);
			packet1->AddPacketTag(tagN27max);
		}
		
		CustomMetaDataUnicastTagN28max tagN28max;
		if ((nei_sizes[27] > 0) and (neighbors_changed[27]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[27] = false;
			cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[27]<<endl;
			uint32_t new_neighborsetmax[max];
			for(uint32_t i=0;i<max;i++)
			{
				if(i<nei_sizes[27])
				{
					new_neighborsetmax[i] = neighbor_set[27].neighbors[i];
				}
				else
				{
					new_neighborsetmax[i] = large;
				}
			}
			tagN28max.Setneighborid(new_neighborsetmax);
			tagN28max.Setnodeid(nodeid[27]);
			packet1->AddPacketTag(tagN28max);
		}
		
		CustomMetaDataUnicastTagN29max tagN29max;
		if ((nei_sizes[28] > 0) and (neighbors_changed[28]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[28] = false;
			cout<<"Cellular:maximum datasize exceeded . size is  "<<nei_sizes[28]<<endl;
			uint32_t new_neighborsetmax[max];
			for(uint32_t i=0;i<max;i++)
			{
				if(i<nei_sizes[28])
				{
					new_neighborsetmax[i] = neighbor_set[28].neighbors[i];
				}
				else
				{
					new_neighborsetmax[i] = large;
				}
			}
			tagN29max.Setneighborid(new_neighborsetmax);
			tagN29max.Setnodeid(nodeid[28]);
			packet1->AddPacketTag(tagN29max);
		}
		
		CustomMetaDataUnicastTagN30max tagN30max;
		if ((nei_sizes[29] > 0) and (neighbors_changed[29]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[29] = false;
			cout<<"Cellular:maximum datasize exceeded. size is  "<<nei_sizes[29]<<endl;
			uint32_t new_neighborsetmax[max];
			for(uint32_t i=0;i<max;i++)
			{
				if(i<nei_sizes[29])
				{
					new_neighborsetmax[i] = neighbor_set[29].neighbors[i];
				}
				else
				{
					new_neighborsetmax[i] = large;
				}
			}
			tagN30max.Setneighborid(new_neighborsetmax);
			tagN30max.Setnodeid(nodeid[29]);
			packet1->AddPacketTag(tagN30max);
		}
		
		CustomDataUnicastTag1 tag1;
		CustomDataUnicastTag2 tag2;
		CustomDataUnicastTag3 tag3;
		CustomDataUnicastTag4 tag4;
		CustomDataUnicastTag5 tag5;
		CustomDataUnicastTag6 tag6;
		CustomDataUnicastTag7 tag7;
		CustomDataUnicastTag8 tag8;
		CustomDataUnicastTag9 tag9;
		CustomDataUnicastTag10 tag10;
		CustomDataUnicastTag11 tag11;
		CustomDataUnicastTag12 tag12;
		CustomDataUnicastTag13 tag13;
		CustomDataUnicastTag14 tag14;
		CustomDataUnicastTag15 tag15;
		CustomDataUnicastTag16 tag16;
		CustomDataUnicastTag17 tag17;
		CustomDataUnicastTag18 tag18;
		CustomDataUnicastTag19 tag19;
		CustomDataUnicastTag20 tag20;
		CustomDataUnicastTag21 tag21;
		CustomDataUnicastTag22 tag22;
		CustomDataUnicastTag23 tag23;
		CustomDataUnicastTag24 tag24;
		CustomDataUnicastTag25 tag25;
		CustomDataUnicastTag tag;
		switch (size)
		{	
			case 1:
				tag1.SetsenderId(nid);
				tag1.SetNodeId(nodeid);
				tag1.Setposition(position);
				tag1.Setvelocity(velocity);
				tag1.Setacceleration(acceleration);
				tag1.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag1);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 2:
				tag2.SetsenderId(nid);
				tag2.SetNodeId(nodeid);
				tag2.Setposition(position);
				tag2.Setvelocity(velocity);
				tag2.Setacceleration(acceleration);
				tag2.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag2);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 3:
				tag3.SetsenderId(nid);
				tag3.SetNodeId(nodeid);
				tag3.Setposition(position);
				tag3.Setvelocity(velocity);
				tag3.Setacceleration(acceleration);
				tag3.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag3);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 4:
				tag4.SetsenderId(nid);
				tag4.SetNodeId(nodeid);
				tag4.Setposition(position);
				tag4.Setvelocity(velocity);
				tag4.Setacceleration(acceleration);
				tag4.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag4);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 5:
				tag5.SetsenderId(nid);
				tag5.SetNodeId(nodeid);
				tag5.Setposition(position);
				tag5.Setvelocity(velocity);
				tag5.Setacceleration(acceleration);
				tag5.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag5);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 6:
				tag6.SetsenderId(nid);
				tag6.SetNodeId(nodeid);
				tag6.Setposition(position);
				tag6.Setvelocity(velocity);
				tag6.Setacceleration(acceleration);
				tag6.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag6);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 7:
				tag7.SetsenderId(nid);
				tag7.SetNodeId(nodeid);
				tag7.Setposition(position);
				tag7.Setvelocity(velocity);
				tag7.Setacceleration(acceleration);
				tag7.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag7);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 8:
				tag8.SetsenderId(nid);
				tag8.SetNodeId(nodeid);
				tag8.Setposition(position);
				tag8.Setvelocity(velocity);
				tag8.Setacceleration(acceleration);
				tag8.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag8);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 9:
				tag9.SetsenderId(nid);
				tag9.SetNodeId(nodeid);
				tag9.Setposition(position);
				tag9.Setvelocity(velocity);
				tag9.Setacceleration(acceleration);
				tag9.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag9);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 10:
				tag10.SetsenderId(nid);
				tag10.SetNodeId(nodeid);
				tag10.Setposition(position);
				tag10.Setvelocity(velocity);
				tag10.Setacceleration(acceleration);
				tag10.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag10);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 11:
				tag11.SetsenderId(nid);
				tag11.SetNodeId(nodeid);
				tag11.Setposition(position);
				tag11.Setvelocity(velocity);
				tag11.Setacceleration(acceleration);
				tag11.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag11);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 12:
				tag12.SetsenderId(nid);
				tag12.SetNodeId(nodeid);
				tag12.Setposition(position);
				tag12.Setvelocity(velocity);
				tag12.Setacceleration(acceleration);
				tag12.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag12);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 13:
				tag13.SetsenderId(nid);
				tag13.SetNodeId(nodeid);
				tag13.Setposition(position);
				tag13.Setvelocity(velocity);
				tag13.Setacceleration(acceleration);
				tag13.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag13);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;	
			case 14:
				tag14.SetsenderId(nid);
				tag14.SetNodeId(nodeid);
				tag14.Setposition(position);
				tag14.Setvelocity(velocity);
				tag14.Setacceleration(acceleration);
				tag14.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag14);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 15:
				tag15.SetsenderId(nid);
				tag15.SetNodeId(nodeid);
				tag15.Setposition(position);
				tag15.Setvelocity(velocity);
				tag15.Setacceleration(acceleration);
				tag15.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag15);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;

			case 16:
				tag16.SetsenderId(nid);
				tag16.SetNodeId(nodeid);
				tag16.Setposition(position);
				tag16.Setvelocity(velocity);
				tag16.Setacceleration(acceleration);
				tag16.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag16);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 17:
				tag17.SetsenderId(nid);
				tag17.SetNodeId(nodeid);
				tag17.Setposition(position);
				tag17.Setvelocity(velocity);
				tag17.Setacceleration(acceleration);
				tag17.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag17);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 18:	
				tag18.SetsenderId(nid);
				tag18.SetNodeId(nodeid);
				tag18.Setposition(position);
				tag18.Setvelocity(velocity);
				tag18.Setacceleration(acceleration);
				tag18.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag18);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 19:
				tag19.SetsenderId(nid);
				tag19.SetNodeId(nodeid);
				tag19.Setposition(position);
				tag19.Setvelocity(velocity);
				tag19.Setacceleration(acceleration);
				tag19.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag19);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 20:
				tag20.SetsenderId(nid);
				tag20.SetNodeId(nodeid);
				tag20.Setposition(position);
				tag20.Setvelocity(velocity);
				tag20.Setacceleration(acceleration);
				tag20.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag20);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 21:
				tag21.SetsenderId(nid);
				tag21.SetNodeId(nodeid);
				tag21.Setposition(position);
				tag21.Setvelocity(velocity);
				tag21.Setacceleration(acceleration);
				tag21.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag21);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 22:
				tag22.SetsenderId(nid);
				tag22.SetNodeId(nodeid);
				tag22.Setposition(position);
				tag22.Setvelocity(velocity);
				tag22.Setacceleration(acceleration);
				tag22.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag22);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 23:
				tag23.SetsenderId(nid);
				tag23.SetNodeId(nodeid);
				tag23.Setposition(position);
				tag23.Setvelocity(velocity);
				tag23.Setacceleration(acceleration);
				tag23.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag23);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 24:
				tag24.SetsenderId(nid);
				tag24.SetNodeId(nodeid);
				tag24.Setposition(position);
				tag24.Setvelocity(velocity);
				tag24.Setacceleration(acceleration);
				tag24.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag24);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 25:
				tag25.SetsenderId(nid);
				tag25.SetNodeId(nodeid);
				tag25.Setposition(position);
				tag25.Setvelocity(velocity);
				tag25.Setacceleration(acceleration);
				tag25.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag25);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			default:
				cout<<"Cellular:maximum status datasize exceeded . size is  "<<size<<endl;
				tag.SetsenderId(nid);
				tag.SetNodeId((data_at_nodes_inst+nid)->nodeid);
				tag.Setposition((data_at_nodes_inst+nid)->position);
				tag.Setvelocity((data_at_nodes_inst+nid)->velocity);
				tag.Setacceleration((data_at_nodes_inst+nid)->acceleration);
				tag.SetTimestamp((data_at_nodes_inst+nid)->timestamp);
				packet1->AddPacketTag(tag);
				lte_total_packet_size = lte_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;	
		}
		cout<<"lte total packet size is "<<lte_total_packet_size<<endl;

	}
	
}

void begin_sending_LTE_data_agent()
{
 	list<uint32_t> agent_ids;
 	for (uint32_t i=2;i<(N_Vehicles+2);i++)
 	{
 		if(X_nodes[i] == 1)
 		{
 			agent_ids.push_back(i);
 		}
 	}
 	int count = 0;
	for (auto it=agent_ids.begin(); it!=agent_ids.end(); ++it)
	{
		uint32_t u = *it;
		//cout<<"u is "<<u<<endl;
	  	Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (apps.Get(u));
		Simulator::Schedule(Seconds(0.000025*count),send_LTE_data_agent,udp_app,Vehicle_Nodes.Get(u-2),management_Node.Get(0), u-2);
		count++;
	}
}

void RSU_dataunicast_agent(Ptr <SimpleUdpApplication> udp_app, Ptr <Node> source_node, Ptr <Node> destination_node)
{

	Ptr <Node> nu = DynamicCast <Node> (source_node);
	uint32_t nid = uint32_t(nu->GetId());
	if (X_nodes[nid] == 1)
	{
		
		Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (source_node->GetObject<MobilityModel>());
		Vector posi = mdl->GetPosition();
		Vector veli = mdl->GetVelocity();
		Vector acci = Vector(0,0,0);
		uint32_t size_nei = getNeighborsize((neighbordata_inst+nid));
		uint32_t neighborid[size_nei];
		for (uint32_t i=0;i<size_nei;i++)
		{
			neighborid[i] = large;
		}
		
		uint32_t j=0;
		for (uint32_t i=0;i<max;i++)
		{
			if ((((neighbordata_inst+nid)->neighborid[i]) != large) and (j<size_nei))
			{
				neighborid[j] = (neighbordata_inst+nid)->neighborid[i];
		  		j++;
		  	}
		}
		add_received_data_at_nodes(data_at_nodes_inst+nid, posi, veli, acci, nid, neighborid, size_nei);
		uint32_t size = get_size_of_data_at_nodes(data_at_nodes_inst+nid);
		//cout<<size<<endl;
		uint32_t nodeid[size];
		Vector position[size];
		Vector acceleration[size];
		Vector velocity[size];
		Time timestamp[size];
		bool neighbors_changed[size];
		
		struct set_of_neighbors neighbor_set[size];
		
		for(uint32_t i=0;i<size;i++)
		{
			nodeid[i] = large;
			position[i] = Vector(0,0,0);
			acceleration[i] = Vector(0,0,0);
			velocity[i] = Vector(0,0,0);
			timestamp[i] = Simulator::Now();
			for (uint32_t j=0;j<max;j++)
			{
				neighbor_set[i].neighbors[j] = large;
			}
			neighbors_changed[i] = false;
		}
		
		uint32_t k=0;
		for(uint32_t i=0;i<max;i++)
		{
			if (((data_at_nodes_inst+nid)->nodeid[i] != large) and (k<size))
			{
				nodeid[k] = (data_at_nodes_inst+nid)->nodeid[i];
				position[k] = (data_at_nodes_inst+nid)->position[i];
				velocity[k] = (data_at_nodes_inst+nid)->velocity[i];
				acceleration[k] = (data_at_nodes_inst+nid)->acceleration[i];
				timestamp[k] = (data_at_nodes_inst+nid)->timestamp[i];
				neighbor_set[k] = (data_at_nodes_inst+nid)->neighbor_set[i];
				neighbors_changed[k] = (data_at_nodes_inst+nid)->neighbors_changed[i];
				k++;
			}
			
		}
		
		uint32_t nei_sizes[max];
		for(uint32_t i=0;i<max;i++)
		{
			nei_sizes[i] = 0;
		}
		
		for(uint32_t i=0;i<size;i++)
		{
			for(uint32_t j=0;j<max;j++)
			{

				if((neighbor_set[i].neighbors[j]) != large)
				{
					nei_sizes[i] = nei_sizes[i] + 1;
				}	
			}
		}
		
		/*
		for(uint32_t i=0;i<max;i++)
		{
			cout<<"neighbor sizes of agent "<<nid<<"is "<<nei_sizes[i]<<endl;
		}
		*/
		
		Ptr <Ipv4> ipv4;  	
		ipv4 = destination_node->GetObject<Ipv4>();
		Ipv4InterfaceAddress iaddr;
		if (N_Vehicles > 0)
		{
			iaddr = ipv4->GetAddress(1,0);//2nd IPv4 interface,0th address index
		}
		else if (N_Vehicles==0)
		{
			iaddr = ipv4->GetAddress(0,0);//1st IPv4 interface,0th address index
		}
		Ipv4Address dest_ip = iaddr.GetLocal();
		Ptr <Packet> packet1 = Create <Packet> (0);
		
		CustomMetaDataUnicastTagN011 tagN011;
		CustomMetaDataUnicastTagN012 tagN012;
		CustomMetaDataUnicastTagN013 tagN013;
		CustomMetaDataUnicastTagN014 tagN014;
		CustomMetaDataUnicastTagN015 tagN015;
		CustomMetaDataUnicastTagN016 tagN016;
		CustomMetaDataUnicastTagN017 tagN017;
		CustomMetaDataUnicastTagN018 tagN018;
		CustomMetaDataUnicastTagN019 tagN019;
		CustomMetaDataUnicastTagN0110 tagN0110;
		CustomMetaDataUnicastTagN0111 tagN0111;
		CustomMetaDataUnicastTagN0112 tagN0112;
		CustomMetaDataUnicastTagN0113 tagN0113;
		CustomMetaDataUnicastTagN0114 tagN0114;
		CustomMetaDataUnicastTagN0115 tagN0115;
		CustomMetaDataUnicastTagN0116 tagN0116;
		CustomMetaDataUnicastTagN0117 tagN0117;
		CustomMetaDataUnicastTagN0118 tagN0118;
		CustomMetaDataUnicastTagN0119 tagN0119;
		CustomMetaDataUnicastTagN0120 tagN0120;
		CustomMetaDataUnicastTagN0121 tagN0121;
		CustomMetaDataUnicastTagN0122 tagN0122;
		CustomMetaDataUnicastTagN0123 tagN0123;
		CustomMetaDataUnicastTagN0124 tagN0124;
		CustomMetaDataUnicastTagN0125 tagN0125;
		CustomMetaDataUnicastTagN01max tagN01max;
		
		if ((nei_sizes[0] > 0) and (neighbors_changed[0]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[0] = false;
			switch(nei_sizes[0])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[0].neighbors[0];
					tagN011.Setneighborid(new_neighborset1);
					tagN011.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN011);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[0].neighbors[i];
					}
					tagN012.Setneighborid(new_neighborset2);
					tagN012.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN012);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[0].neighbors[i];
					}
					tagN013.Setneighborid(new_neighborset3);
					tagN013.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN013);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[0].neighbors[i];
					}
					tagN014.Setneighborid(new_neighborset4);
					tagN014.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN014);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[0].neighbors[i];
					}
					tagN015.Setneighborid(new_neighborset5);
					tagN015.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN015);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[0].neighbors[i];
					}
					tagN016.Setneighborid(new_neighborset6);
					tagN016.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN016);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[0].neighbors[i];
					}
					tagN017.Setneighborid(new_neighborset7);
					tagN017.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN017);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[0].neighbors[i];
					}
					tagN018.Setneighborid(new_neighborset8);
					tagN018.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN018);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[0].neighbors[i];
					}
					tagN019.Setneighborid(new_neighborset9);
					tagN019.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN019);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[0].neighbors[i];
					}
					tagN0110.Setneighborid(new_neighborset10);
					tagN0110.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0110);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[0].neighbors[i];
					}
					tagN0111.Setneighborid(new_neighborset11);
					tagN0111.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0111);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[0].neighbors[i];
					}
					tagN0112.Setneighborid(new_neighborset12);
					tagN0112.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0112);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[0].neighbors[i];
					}
					tagN0113.Setneighborid(new_neighborset13);
					tagN0113.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0113);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[0].neighbors[i];
					}
					tagN0114.Setneighborid(new_neighborset14);
					tagN0114.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0114);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[0].neighbors[i];
					}
					tagN0115.Setneighborid(new_neighborset15);
					tagN0115.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0115);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[0].neighbors[i];
					}
					tagN0116.Setneighborid(new_neighborset16);
					tagN0116.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0116);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[0].neighbors[i];
					}
					tagN0117.Setneighborid(new_neighborset17);
					tagN0117.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0117);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[0].neighbors[i];
					}
					tagN0118.Setneighborid(new_neighborset18);
					tagN0118.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0118);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[0].neighbors[i];
					}
					tagN0119.Setneighborid(new_neighborset19);
					tagN0119.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0119);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[0].neighbors[i];
					}
					tagN0120.Setneighborid(new_neighborset20);
					tagN0120.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0120);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[0].neighbors[i];
					}
					tagN0121.Setneighborid(new_neighborset21);
					tagN0121.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0121);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[0].neighbors[i];
					}
					tagN0122.Setneighborid(new_neighborset22);
					tagN0122.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0122);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[0].neighbors[i];
					}
					tagN0123.Setneighborid(new_neighborset23);
					tagN0123.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0123);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[0].neighbors[i];
					}
					tagN0124.Setneighborid(new_neighborset24);
					tagN0124.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0124);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[0].neighbors[i];
					}
					tagN0125.Setneighborid(new_neighborset25);
					tagN0125.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN0125);
					break;
				default:
					cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[0]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[0])
						{
							new_neighborsetmax[i] = neighbor_set[0].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN01max.Setneighborid(new_neighborsetmax);
					tagN01max.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN01max);
					break;
			}
		}
		
	

		CustomMetaDataUnicastTagN021 tagN021;
		CustomMetaDataUnicastTagN022 tagN022;
		CustomMetaDataUnicastTagN023 tagN023;
		CustomMetaDataUnicastTagN024 tagN024;
		CustomMetaDataUnicastTagN025 tagN025;
		CustomMetaDataUnicastTagN026 tagN026;
		CustomMetaDataUnicastTagN027 tagN027;
		CustomMetaDataUnicastTagN028 tagN028;
		CustomMetaDataUnicastTagN029 tagN029;
		CustomMetaDataUnicastTagN0210 tagN0210;
		CustomMetaDataUnicastTagN0211 tagN0211;
		CustomMetaDataUnicastTagN0212 tagN0212;
		CustomMetaDataUnicastTagN0213 tagN0213;
		CustomMetaDataUnicastTagN0214 tagN0214;
		CustomMetaDataUnicastTagN0215 tagN0215;
		CustomMetaDataUnicastTagN0216 tagN0216;
		CustomMetaDataUnicastTagN0217 tagN0217;
		CustomMetaDataUnicastTagN0218 tagN0218;
		CustomMetaDataUnicastTagN0219 tagN0219;
		CustomMetaDataUnicastTagN0220 tagN0220;
		CustomMetaDataUnicastTagN0221 tagN0221;
		CustomMetaDataUnicastTagN0222 tagN0222;
		CustomMetaDataUnicastTagN0223 tagN0223;
		CustomMetaDataUnicastTagN0224 tagN0224;
		CustomMetaDataUnicastTagN0225 tagN0225;
		CustomMetaDataUnicastTagN2max tagN2max;
		
		if ((nei_sizes[1] > 0) and (neighbors_changed[1]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[1] = false;
			switch(nei_sizes[1])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[1].neighbors[0];
					tagN021.Setneighborid(new_neighborset1);
					tagN021.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN021);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[1].neighbors[i];
					}
					tagN022.Setneighborid(new_neighborset2);
					tagN022.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN022);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[1].neighbors[i];
					}
					tagN023.Setneighborid(new_neighborset3);
					tagN023.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN023);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[1].neighbors[i];
					}
					tagN024.Setneighborid(new_neighborset4);
					tagN024.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN024);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[1].neighbors[i];
					}
					tagN025.Setneighborid(new_neighborset5);
					tagN025.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN025);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[1].neighbors[i];
					}
					tagN026.Setneighborid(new_neighborset6);
					tagN026.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN026);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[1].neighbors[i];
					}
					tagN027.Setneighborid(new_neighborset7);
					tagN027.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN027);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[1].neighbors[i];
					}
					tagN028.Setneighborid(new_neighborset8);
					tagN028.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN028);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[1].neighbors[i];
					}
					tagN029.Setneighborid(new_neighborset9);
					tagN029.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN029);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[1].neighbors[i];
					}
					tagN0210.Setneighborid(new_neighborset10);
					tagN0210.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0210);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[1].neighbors[i];
					}
					tagN0211.Setneighborid(new_neighborset11);
					tagN0211.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0211);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[1].neighbors[i];
					}
					tagN0212.Setneighborid(new_neighborset12);
					tagN0212.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0212);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[1].neighbors[i];
					}
					tagN0213.Setneighborid(new_neighborset13);
					tagN0213.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0213);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[1].neighbors[i];
					}
					tagN0214.Setneighborid(new_neighborset14);
					tagN0214.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0214);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[1].neighbors[i];
					}
					tagN0215.Setneighborid(new_neighborset15);
					tagN0215.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0215);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[1].neighbors[i];
					}
					tagN0216.Setneighborid(new_neighborset16);
					tagN0216.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0216);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[1].neighbors[i];
					}
					tagN0217.Setneighborid(new_neighborset17);
					tagN0217.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0217);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[1].neighbors[i];
					}
					tagN0218.Setneighborid(new_neighborset18);
					tagN0218.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0218);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[1].neighbors[i];
					}
					tagN0219.Setneighborid(new_neighborset19);
					tagN0219.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0219);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[1].neighbors[i];
					}
					tagN0220.Setneighborid(new_neighborset20);
					tagN0220.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0220);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[1].neighbors[i];
					}
					tagN0221.Setneighborid(new_neighborset21);
					tagN0221.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0221);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[1].neighbors[i];
					}
					tagN0222.Setneighborid(new_neighborset22);
					tagN0222.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0222);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[1].neighbors[i];
					}
					tagN0223.Setneighborid(new_neighborset23);
					tagN0223.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0223);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[1].neighbors[i];
					}
					tagN0224.Setneighborid(new_neighborset24);
					tagN0224.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0224);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[1].neighbors[i];
					}
					tagN0225.Setneighborid(new_neighborset25);
					tagN0225.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN0225);
					break;
				default:
					cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[1]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[1])
						{
							new_neighborsetmax[i] = neighbor_set[1].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN2max.Setneighborid(new_neighborsetmax);
					tagN2max.Setnodeid(nodeid[1]);
					packet1->AddPacketTag(tagN2max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN31 tagN31;
		CustomMetaDataUnicastTagN32 tagN32;
		CustomMetaDataUnicastTagN33 tagN33;
		CustomMetaDataUnicastTagN34 tagN34;
		CustomMetaDataUnicastTagN35 tagN35;
		CustomMetaDataUnicastTagN36 tagN36;
		CustomMetaDataUnicastTagN37 tagN37;
		CustomMetaDataUnicastTagN38 tagN38;
		CustomMetaDataUnicastTagN39 tagN39;
		CustomMetaDataUnicastTagN310 tagN310;
		CustomMetaDataUnicastTagN311 tagN311;
		CustomMetaDataUnicastTagN312 tagN312;
		CustomMetaDataUnicastTagN313 tagN313;
		CustomMetaDataUnicastTagN314 tagN314;
		CustomMetaDataUnicastTagN315 tagN315;
		CustomMetaDataUnicastTagN316 tagN316;
		CustomMetaDataUnicastTagN317 tagN317;
		CustomMetaDataUnicastTagN318 tagN318;
		CustomMetaDataUnicastTagN319 tagN319;
		CustomMetaDataUnicastTagN320 tagN320;
		CustomMetaDataUnicastTagN321 tagN321;
		CustomMetaDataUnicastTagN322 tagN322;
		CustomMetaDataUnicastTagN323 tagN323;
		CustomMetaDataUnicastTagN324 tagN324;
		CustomMetaDataUnicastTagN325 tagN325;
		CustomMetaDataUnicastTagN3max tagN3max;
		
		if ((nei_sizes[2] > 0) and (neighbors_changed[2]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[2] = false;
			switch(nei_sizes[2])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[2].neighbors[0];
					tagN31.Setneighborid(new_neighborset1);
					tagN31.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN31);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[2].neighbors[i];
					}
					tagN32.Setneighborid(new_neighborset2);
					tagN32.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN32);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[2].neighbors[i];
					}
					tagN33.Setneighborid(new_neighborset3);
					tagN33.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN33);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[2].neighbors[i];
					}
					tagN34.Setneighborid(new_neighborset4);
					tagN34.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN34);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[2].neighbors[i];
					}
					tagN35.Setneighborid(new_neighborset5);
					tagN35.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN35);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[2].neighbors[i];
					}
					tagN36.Setneighborid(new_neighborset6);
					tagN36.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN36);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[2].neighbors[i];
					}
					tagN37.Setneighborid(new_neighborset7);
					tagN37.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN37);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[2].neighbors[i];
					}
					tagN38.Setneighborid(new_neighborset8);
					tagN38.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN38);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[2].neighbors[i];
					}
					tagN39.Setneighborid(new_neighborset9);
					tagN39.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN39);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[2].neighbors[i];
					}
					tagN310.Setneighborid(new_neighborset10);
					tagN310.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN310);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[2].neighbors[i];
					}
					tagN311.Setneighborid(new_neighborset11);
					tagN311.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN311);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[2].neighbors[i];
					}
					tagN312.Setneighborid(new_neighborset12);
					tagN312.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN312);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[2].neighbors[i];
					}
					tagN313.Setneighborid(new_neighborset13);
					tagN313.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN313);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[2].neighbors[i];
					}
					tagN314.Setneighborid(new_neighborset14);
					tagN314.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN314);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[2].neighbors[i];
					}
					tagN315.Setneighborid(new_neighborset15);
					tagN315.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN315);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[2].neighbors[i];
					}
					tagN316.Setneighborid(new_neighborset16);
					tagN316.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN316);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[2].neighbors[i];
					}
					tagN317.Setneighborid(new_neighborset17);
					tagN317.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN317);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[2].neighbors[i];
					}
					tagN318.Setneighborid(new_neighborset18);
					tagN318.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN318);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[2].neighbors[i];
					}
					tagN319.Setneighborid(new_neighborset19);
					tagN319.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN319);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[2].neighbors[i];
					}
					tagN320.Setneighborid(new_neighborset20);
					tagN320.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN320);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[2].neighbors[i];
					}
					tagN321.Setneighborid(new_neighborset21);
					tagN321.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN321);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[2].neighbors[i];
					}
					tagN322.Setneighborid(new_neighborset22);
					tagN322.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN322);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[2].neighbors[i];
					}
					tagN323.Setneighborid(new_neighborset23);
					tagN323.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN323);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[2].neighbors[i];
					}
					tagN324.Setneighborid(new_neighborset24);
					tagN324.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN324);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[2].neighbors[i];
					}
					tagN325.Setneighborid(new_neighborset25);
					tagN325.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN325);
					break;
				default:
					cout<<"Ethernet:maximum neighbor datasize exceeded. size is  "<<nei_sizes[2]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[2])
						{
							new_neighborsetmax[i] = neighbor_set[2].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN3max.Setneighborid(new_neighborsetmax);
					tagN3max.Setnodeid(nodeid[2]);
					packet1->AddPacketTag(tagN3max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN41 tagN41;
		CustomMetaDataUnicastTagN42 tagN42;
		CustomMetaDataUnicastTagN43 tagN43;
		CustomMetaDataUnicastTagN44 tagN44;
		CustomMetaDataUnicastTagN45 tagN45;
		CustomMetaDataUnicastTagN46 tagN46;
		CustomMetaDataUnicastTagN47 tagN47;
		CustomMetaDataUnicastTagN48 tagN48;
		CustomMetaDataUnicastTagN49 tagN49;
		CustomMetaDataUnicastTagN410 tagN410;
		CustomMetaDataUnicastTagN411 tagN411;
		CustomMetaDataUnicastTagN412 tagN412;
		CustomMetaDataUnicastTagN413 tagN413;
		CustomMetaDataUnicastTagN414 tagN414;
		CustomMetaDataUnicastTagN415 tagN415;
		CustomMetaDataUnicastTagN416 tagN416;
		CustomMetaDataUnicastTagN417 tagN417;
		CustomMetaDataUnicastTagN418 tagN418;
		CustomMetaDataUnicastTagN419 tagN419;
		CustomMetaDataUnicastTagN420 tagN420;
		CustomMetaDataUnicastTagN421 tagN421;
		CustomMetaDataUnicastTagN422 tagN422;
		CustomMetaDataUnicastTagN423 tagN423;
		CustomMetaDataUnicastTagN424 tagN424;
		CustomMetaDataUnicastTagN425 tagN425;
		CustomMetaDataUnicastTagN4max tagN4max;
		
		if ((nei_sizes[3] > 0)  and (neighbors_changed[3]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[3] = false;
			switch(nei_sizes[3])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[3].neighbors[0];
					tagN41.Setneighborid(new_neighborset1);
					tagN41.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN41);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[3].neighbors[i];
					}
					tagN42.Setneighborid(new_neighborset2);
					tagN42.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN42);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[3].neighbors[i];
					}
					tagN43.Setneighborid(new_neighborset3);
					tagN43.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN43);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[3].neighbors[i];
					}
					tagN44.Setneighborid(new_neighborset4);
					tagN44.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN44);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[3].neighbors[i];
					}
					tagN45.Setneighborid(new_neighborset5);
					tagN45.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN45);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[3].neighbors[i];
					}
					tagN46.Setneighborid(new_neighborset6);
					tagN46.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN46);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[3].neighbors[i];
					}
					tagN47.Setneighborid(new_neighborset7);
					tagN47.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN47);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[3].neighbors[i];
					}
					tagN48.Setneighborid(new_neighborset8);
					tagN48.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN48);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[3].neighbors[i];
					}
					tagN49.Setneighborid(new_neighborset9);
					tagN49.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN49);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[3].neighbors[i];
					}
					tagN410.Setneighborid(new_neighborset10);
					tagN410.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN410);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[3].neighbors[i];
					}
					tagN411.Setneighborid(new_neighborset11);
					tagN411.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN411);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[3].neighbors[i];
					}
					tagN412.Setneighborid(new_neighborset12);
					tagN412.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN412);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[3].neighbors[i];
					}
					tagN413.Setneighborid(new_neighborset13);
					tagN413.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN413);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[3].neighbors[i];
					}
					tagN414.Setneighborid(new_neighborset14);
					tagN414.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN414);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[3].neighbors[i];
					}
					tagN415.Setneighborid(new_neighborset15);
					tagN415.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN415);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[3].neighbors[i];
					}
					tagN416.Setneighborid(new_neighborset16);
					tagN416.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN416);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[3].neighbors[i];
					}
					tagN417.Setneighborid(new_neighborset17);
					tagN417.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN417);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[3].neighbors[i];
					}
					tagN418.Setneighborid(new_neighborset18);
					tagN418.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN418);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[3].neighbors[i];
					}
					tagN419.Setneighborid(new_neighborset19);
					tagN419.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN419);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[3].neighbors[i];
					}
					tagN420.Setneighborid(new_neighborset20);
					tagN420.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN420);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[3].neighbors[i];
					}
					tagN421.Setneighborid(new_neighborset21);
					tagN421.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN421);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[3].neighbors[i];
					}
					tagN422.Setneighborid(new_neighborset22);
					tagN422.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN422);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[3].neighbors[i];
					}
					tagN423.Setneighborid(new_neighborset23);
					tagN423.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN423);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[3].neighbors[i];
					}
					tagN424.Setneighborid(new_neighborset24);
					tagN424.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN424);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[3].neighbors[i];
					}
					tagN425.Setneighborid(new_neighborset25);
					tagN425.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN425);
					break;
				default:
					cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[3]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[3])
						{
							new_neighborsetmax[i] = neighbor_set[3].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN4max.Setneighborid(new_neighborsetmax);
					tagN4max.Setnodeid(nodeid[3]);
					packet1->AddPacketTag(tagN4max);
					break;
			}
		
		}
		
		
		
		CustomMetaDataUnicastTagN51 tagN51;
		CustomMetaDataUnicastTagN52 tagN52;
		CustomMetaDataUnicastTagN53 tagN53;
		CustomMetaDataUnicastTagN54 tagN54;
		CustomMetaDataUnicastTagN55 tagN55;
		CustomMetaDataUnicastTagN56 tagN56;
		CustomMetaDataUnicastTagN57 tagN57;
		CustomMetaDataUnicastTagN58 tagN58;
		CustomMetaDataUnicastTagN59 tagN59;
		CustomMetaDataUnicastTagN510 tagN510;
		CustomMetaDataUnicastTagN511 tagN511;
		CustomMetaDataUnicastTagN512 tagN512;
		CustomMetaDataUnicastTagN513 tagN513;
		CustomMetaDataUnicastTagN514 tagN514;
		CustomMetaDataUnicastTagN515 tagN515;
		CustomMetaDataUnicastTagN516 tagN516;
		CustomMetaDataUnicastTagN517 tagN517;
		CustomMetaDataUnicastTagN518 tagN518;
		CustomMetaDataUnicastTagN519 tagN519;
		CustomMetaDataUnicastTagN520 tagN520;
		CustomMetaDataUnicastTagN521 tagN521;
		CustomMetaDataUnicastTagN522 tagN522;
		CustomMetaDataUnicastTagN523 tagN523;
		CustomMetaDataUnicastTagN524 tagN524;
		CustomMetaDataUnicastTagN525 tagN525;
		CustomMetaDataUnicastTagN5max tagN5max;
		
		if ((nei_sizes[4] > 0) and (neighbors_changed[4]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[4] = false;
			switch(nei_sizes[4])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[4].neighbors[0];
					tagN51.Setneighborid(new_neighborset1);
					tagN51.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN51);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[4].neighbors[i];
					}
					tagN52.Setneighborid(new_neighborset2);
					tagN52.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN52);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[4].neighbors[i];
					}
					tagN53.Setneighborid(new_neighborset3);
					tagN53.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN53);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[4].neighbors[i];
					}
					tagN54.Setneighborid(new_neighborset4);
					tagN54.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN54);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[4].neighbors[i];
					}
					tagN55.Setneighborid(new_neighborset5);
					tagN55.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN55);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[4].neighbors[i];
					}
					tagN56.Setneighborid(new_neighborset6);
					tagN56.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN56);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[4].neighbors[i];
					}
					tagN57.Setneighborid(new_neighborset7);
					tagN57.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN57);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[4].neighbors[i];
					}
					tagN58.Setneighborid(new_neighborset8);
					tagN58.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN58);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[4].neighbors[i];
					}
					tagN59.Setneighborid(new_neighborset9);
					tagN59.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN59);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[4].neighbors[i];
					}
					tagN510.Setneighborid(new_neighborset10);
					tagN510.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN510);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[4].neighbors[i];
					}
					tagN511.Setneighborid(new_neighborset11);
					tagN511.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN511);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[4].neighbors[i];
					}
					tagN512.Setneighborid(new_neighborset12);
					tagN512.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN512);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[4].neighbors[i];
					}
					tagN513.Setneighborid(new_neighborset13);
					tagN513.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN513);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[4].neighbors[i];
					}
					tagN514.Setneighborid(new_neighborset14);
					tagN514.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN514);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[4].neighbors[i];
					}
					tagN515.Setneighborid(new_neighborset15);
					tagN515.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN515);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[4].neighbors[i];
					}
					tagN516.Setneighborid(new_neighborset16);
					tagN516.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN516);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[4].neighbors[i];
					}
					tagN517.Setneighborid(new_neighborset17);
					tagN517.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN517);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[4].neighbors[i];
					}
					tagN518.Setneighborid(new_neighborset18);
					tagN518.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN518);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[4].neighbors[i];
					}
					tagN519.Setneighborid(new_neighborset19);
					tagN519.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN519);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[4].neighbors[i];
					}
					tagN520.Setneighborid(new_neighborset20);
					tagN520.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN520);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[4].neighbors[i];
					}
					tagN521.Setneighborid(new_neighborset21);
					tagN521.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN521);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[4].neighbors[i];
					}
					tagN522.Setneighborid(new_neighborset22);
					tagN522.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN522);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[4].neighbors[i];
					}
					tagN523.Setneighborid(new_neighborset23);
					tagN523.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN523);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[4].neighbors[i];
					}
					tagN524.Setneighborid(new_neighborset24);
					tagN524.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN524);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[4].neighbors[i];
					}
					tagN525.Setneighborid(new_neighborset25);
					tagN525.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN525);
					break;
				default:
					cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[4]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[4])
						{
							new_neighborsetmax[i] = neighbor_set[4].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN5max.Setneighborid(new_neighborsetmax);
					tagN5max.Setnodeid(nodeid[4]);
					packet1->AddPacketTag(tagN5max);
					break;
			}
		
		}		

		CustomMetaDataUnicastTagN61 tagN61;
		CustomMetaDataUnicastTagN62 tagN62;
		CustomMetaDataUnicastTagN63 tagN63;
		CustomMetaDataUnicastTagN64 tagN64;
		CustomMetaDataUnicastTagN65 tagN65;
		CustomMetaDataUnicastTagN66 tagN66;
		CustomMetaDataUnicastTagN67 tagN67;
		CustomMetaDataUnicastTagN68 tagN68;
		CustomMetaDataUnicastTagN69 tagN69;
		CustomMetaDataUnicastTagN610 tagN610;
		CustomMetaDataUnicastTagN611 tagN611;
		CustomMetaDataUnicastTagN612 tagN612;
		CustomMetaDataUnicastTagN613 tagN613;
		CustomMetaDataUnicastTagN614 tagN614;
		CustomMetaDataUnicastTagN615 tagN615;
		CustomMetaDataUnicastTagN616 tagN616;
		CustomMetaDataUnicastTagN617 tagN617;
		CustomMetaDataUnicastTagN618 tagN618;
		CustomMetaDataUnicastTagN619 tagN619;
		CustomMetaDataUnicastTagN620 tagN620;
		CustomMetaDataUnicastTagN621 tagN621;
		CustomMetaDataUnicastTagN622 tagN622;
		CustomMetaDataUnicastTagN623 tagN623;
		CustomMetaDataUnicastTagN624 tagN624;
		CustomMetaDataUnicastTagN625 tagN625;
		CustomMetaDataUnicastTagN6max tagN6max;
		
		if ((nei_sizes[5] > 0) and (neighbors_changed[5]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[5] = false;
			switch(nei_sizes[5])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[5].neighbors[0];
					tagN61.Setneighborid(new_neighborset1);
					tagN61.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN61);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[5].neighbors[i];
					}
					tagN62.Setneighborid(new_neighborset2);
					tagN62.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN62);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[5].neighbors[i];
					}
					tagN63.Setneighborid(new_neighborset3);
					tagN63.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN63);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[5].neighbors[i];
					}
					tagN64.Setneighborid(new_neighborset4);
					tagN64.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN64);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[5].neighbors[i];
					}
					tagN65.Setneighborid(new_neighborset5);
					tagN65.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN65);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[5].neighbors[i];
					}
					tagN66.Setneighborid(new_neighborset6);
					tagN66.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN66);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[5].neighbors[i];
					}
					tagN67.Setneighborid(new_neighborset7);
					tagN67.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN67);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[5].neighbors[i];
					}
					tagN68.Setneighborid(new_neighborset8);
					tagN68.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN68);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[5].neighbors[i];
					}
					tagN69.Setneighborid(new_neighborset9);
					tagN69.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN69);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[5].neighbors[i];
					}
					tagN610.Setneighborid(new_neighborset10);
					tagN610.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN610);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[5].neighbors[i];
					}
					tagN611.Setneighborid(new_neighborset11);
					tagN611.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN611);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[5].neighbors[i];
					}
					tagN612.Setneighborid(new_neighborset12);
					tagN612.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN612);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[5].neighbors[i];
					}
					tagN613.Setneighborid(new_neighborset13);
					tagN613.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN613);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[5].neighbors[i];
					}
					tagN614.Setneighborid(new_neighborset14);
					tagN614.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN614);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[5].neighbors[i];
					}
					tagN615.Setneighborid(new_neighborset15);
					tagN615.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN615);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[5].neighbors[i];
					}
					tagN616.Setneighborid(new_neighborset16);
					tagN616.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN616);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[5].neighbors[i];
					}
					tagN617.Setneighborid(new_neighborset17);
					tagN617.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN617);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[5].neighbors[i];
					}
					tagN618.Setneighborid(new_neighborset18);
					tagN618.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN618);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[5].neighbors[i];
					}
					tagN619.Setneighborid(new_neighborset19);
					tagN619.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN619);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[5].neighbors[i];
					}
					tagN620.Setneighborid(new_neighborset20);
					tagN620.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN620);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[5].neighbors[i];
					}
					tagN621.Setneighborid(new_neighborset21);
					tagN621.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN621);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[5].neighbors[i];
					}
					tagN622.Setneighborid(new_neighborset22);
					tagN622.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN622);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[5].neighbors[i];
					}
					tagN623.Setneighborid(new_neighborset23);
					tagN623.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN623);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[5].neighbors[i];
					}
					tagN624.Setneighborid(new_neighborset24);
					tagN624.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN624);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[5].neighbors[i];
					}
					tagN625.Setneighborid(new_neighborset25);
					tagN625.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN625);
					break;
				default:
					cout<<"Etheret:maximum neighbor datasize exceeded "<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[5])
						{
							new_neighborsetmax[i] = neighbor_set[5].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN6max.Setneighborid(new_neighborsetmax);
					tagN6max.Setnodeid(nodeid[5]);
					packet1->AddPacketTag(tagN6max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN71 tagN71;
		CustomMetaDataUnicastTagN72 tagN72;
		CustomMetaDataUnicastTagN73 tagN73;
		CustomMetaDataUnicastTagN74 tagN74;
		CustomMetaDataUnicastTagN75 tagN75;
		CustomMetaDataUnicastTagN76 tagN76;
		CustomMetaDataUnicastTagN77 tagN77;
		CustomMetaDataUnicastTagN78 tagN78;
		CustomMetaDataUnicastTagN79 tagN79;
		CustomMetaDataUnicastTagN710 tagN710;
		CustomMetaDataUnicastTagN711 tagN711;
		CustomMetaDataUnicastTagN712 tagN712;
		CustomMetaDataUnicastTagN713 tagN713;
		CustomMetaDataUnicastTagN714 tagN714;
		CustomMetaDataUnicastTagN715 tagN715;
		CustomMetaDataUnicastTagN716 tagN716;
		CustomMetaDataUnicastTagN717 tagN717;
		CustomMetaDataUnicastTagN718 tagN718;
		CustomMetaDataUnicastTagN719 tagN719;
		CustomMetaDataUnicastTagN720 tagN720;
		CustomMetaDataUnicastTagN721 tagN721;
		CustomMetaDataUnicastTagN722 tagN722;
		CustomMetaDataUnicastTagN723 tagN723;
		CustomMetaDataUnicastTagN724 tagN724;
		CustomMetaDataUnicastTagN725 tagN725;
		CustomMetaDataUnicastTagN7max tagN7max;
		
		if ((nei_sizes[6] > 0) and (neighbors_changed[6]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[6] = false;
			switch(nei_sizes[6])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[6].neighbors[0];
					tagN71.Setneighborid(new_neighborset1);
					tagN71.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN71);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[6].neighbors[i];
					}
					tagN72.Setneighborid(new_neighborset2);
					tagN72.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN72);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[6].neighbors[i];
					}
					tagN73.Setneighborid(new_neighborset3);
					tagN73.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN73);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[6].neighbors[i];
					}
					tagN74.Setneighborid(new_neighborset4);
					tagN74.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN74);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[6].neighbors[i];
					}
					tagN75.Setneighborid(new_neighborset5);
					tagN75.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN75);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[6].neighbors[i];
					}
					tagN76.Setneighborid(new_neighborset6);
					tagN76.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN76);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[6].neighbors[i];
					}
					tagN77.Setneighborid(new_neighborset7);
					tagN77.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN77);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[6].neighbors[i];
					}
					tagN78.Setneighborid(new_neighborset8);
					tagN78.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN78);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[6].neighbors[i];
					}
					tagN79.Setneighborid(new_neighborset9);
					tagN79.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN79);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[6].neighbors[i];
					}
					tagN710.Setneighborid(new_neighborset10);
					tagN710.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN710);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[6].neighbors[i];
					}
					tagN711.Setneighborid(new_neighborset11);
					tagN711.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN711);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[6].neighbors[i];
					}
					tagN712.Setneighborid(new_neighborset12);
					tagN712.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN712);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[6].neighbors[i];
					}
					tagN713.Setneighborid(new_neighborset13);
					tagN713.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN713);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[6].neighbors[i];
					}
					tagN714.Setneighborid(new_neighborset14);
					tagN714.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN714);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[6].neighbors[i];
					}
					tagN715.Setneighborid(new_neighborset15);
					tagN715.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN715);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[6].neighbors[i];
					}
					tagN716.Setneighborid(new_neighborset16);
					tagN716.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN716);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[6].neighbors[i];
					}
					tagN717.Setneighborid(new_neighborset17);
					tagN717.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN717);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[6].neighbors[i];
					}
					tagN718.Setneighborid(new_neighborset18);
					tagN718.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN718);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[6].neighbors[i];
					}
					tagN719.Setneighborid(new_neighborset19);
					tagN719.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN719);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[6].neighbors[i];
					}
					tagN720.Setneighborid(new_neighborset20);
					tagN720.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN720);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[6].neighbors[i];
					}
					tagN721.Setneighborid(new_neighborset21);
					tagN721.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN721);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[6].neighbors[i];
					}
					tagN722.Setneighborid(new_neighborset22);
					tagN722.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN722);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[6].neighbors[i];
					}
					tagN723.Setneighborid(new_neighborset23);
					tagN723.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN723);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[6].neighbors[i];
					}
					tagN724.Setneighborid(new_neighborset24);
					tagN724.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN724);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[6].neighbors[i];
					}
					tagN725.Setneighborid(new_neighborset25);
					tagN725.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN725);
					break;
				default:
					cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[5]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[6])
						{
							new_neighborsetmax[i] = neighbor_set[6].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN7max.Setneighborid(new_neighborsetmax);
					tagN7max.Setnodeid(nodeid[6]);
					packet1->AddPacketTag(tagN7max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN81 tagN81;
		CustomMetaDataUnicastTagN82 tagN82;
		CustomMetaDataUnicastTagN83 tagN83;
		CustomMetaDataUnicastTagN84 tagN84;
		CustomMetaDataUnicastTagN85 tagN85;
		CustomMetaDataUnicastTagN86 tagN86;
		CustomMetaDataUnicastTagN87 tagN87;
		CustomMetaDataUnicastTagN88 tagN88;
		CustomMetaDataUnicastTagN89 tagN89;
		CustomMetaDataUnicastTagN810 tagN810;
		CustomMetaDataUnicastTagN811 tagN811;
		CustomMetaDataUnicastTagN812 tagN812;
		CustomMetaDataUnicastTagN813 tagN813;
		CustomMetaDataUnicastTagN814 tagN814;
		CustomMetaDataUnicastTagN815 tagN815;
		CustomMetaDataUnicastTagN816 tagN816;
		CustomMetaDataUnicastTagN817 tagN817;
		CustomMetaDataUnicastTagN818 tagN818;
		CustomMetaDataUnicastTagN819 tagN819;
		CustomMetaDataUnicastTagN820 tagN820;
		CustomMetaDataUnicastTagN821 tagN821;
		CustomMetaDataUnicastTagN822 tagN822;
		CustomMetaDataUnicastTagN823 tagN823;
		CustomMetaDataUnicastTagN824 tagN824;
		CustomMetaDataUnicastTagN825 tagN825;
		CustomMetaDataUnicastTagN8max tagN8max;
		
		if ((nei_sizes[7] > 0)  and (neighbors_changed[7]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[7] = false;
			switch(nei_sizes[7])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[7].neighbors[0];
					tagN81.Setneighborid(new_neighborset1);
					tagN81.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN81);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[7].neighbors[i];
					}
					tagN82.Setneighborid(new_neighborset2);
					tagN82.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN82);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[7].neighbors[i];
					}
					tagN83.Setneighborid(new_neighborset3);
					tagN83.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN83);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[7].neighbors[i];
					}
					tagN84.Setneighborid(new_neighborset4);
					tagN84.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN84);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[7].neighbors[i];
					}
					tagN85.Setneighborid(new_neighborset5);
					tagN85.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN85);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[7].neighbors[i];
					}
					tagN86.Setneighborid(new_neighborset6);
					tagN86.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN86);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[7].neighbors[i];
					}
					tagN87.Setneighborid(new_neighborset7);
					tagN87.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN87);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[7].neighbors[i];
					}
					tagN88.Setneighborid(new_neighborset8);
					tagN88.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN88);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[7].neighbors[i];
					}
					tagN89.Setneighborid(new_neighborset9);
					tagN89.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN89);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[7].neighbors[i];
					}
					tagN810.Setneighborid(new_neighborset10);
					tagN810.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN810);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[7].neighbors[i];
					}
					tagN811.Setneighborid(new_neighborset11);
					tagN811.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN811);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[7].neighbors[i];
					}
					tagN812.Setneighborid(new_neighborset12);
					tagN812.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN812);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[7].neighbors[i];
					}
					tagN813.Setneighborid(new_neighborset13);
					tagN813.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN813);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[7].neighbors[i];
					}
					tagN814.Setneighborid(new_neighborset14);
					tagN814.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN814);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[7].neighbors[i];
					}
					tagN815.Setneighborid(new_neighborset15);
					tagN815.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN815);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[7].neighbors[i];
					}
					tagN816.Setneighborid(new_neighborset16);
					tagN816.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN816);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[7].neighbors[i];
					}
					tagN817.Setneighborid(new_neighborset17);
					tagN817.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN817);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[7].neighbors[i];
					}
					tagN818.Setneighborid(new_neighborset18);
					tagN818.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN818);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[7].neighbors[i];
					}
					tagN819.Setneighborid(new_neighborset19);
					tagN819.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN819);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[7].neighbors[i];
					}
					tagN820.Setneighborid(new_neighborset20);
					tagN820.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN820);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[7].neighbors[i];
					}
					tagN821.Setneighborid(new_neighborset21);
					tagN821.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN821);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[7].neighbors[i];
					}
					tagN822.Setneighborid(new_neighborset22);
					tagN822.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN822);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[7].neighbors[i];
					}
					tagN823.Setneighborid(new_neighborset23);
					tagN823.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN823);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[7].neighbors[i];
					}
					tagN824.Setneighborid(new_neighborset24);
					tagN824.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN824);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[7].neighbors[i];
					}
					tagN825.Setneighborid(new_neighborset25);
					tagN825.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN825);
					break;
				default:
					cout<<"Ethernte:maximum neighbor datasize exceeded "<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[7])
						{
							new_neighborsetmax[i] = neighbor_set[7].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN8max.Setneighborid(new_neighborsetmax);
					tagN8max.Setnodeid(nodeid[7]);
					packet1->AddPacketTag(tagN8max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN91 tagN91;
		CustomMetaDataUnicastTagN92 tagN92;
		CustomMetaDataUnicastTagN93 tagN93;
		CustomMetaDataUnicastTagN94 tagN94;
		CustomMetaDataUnicastTagN95 tagN95;
		CustomMetaDataUnicastTagN96 tagN96;
		CustomMetaDataUnicastTagN97 tagN97;
		CustomMetaDataUnicastTagN98 tagN98;
		CustomMetaDataUnicastTagN99 tagN99;
		CustomMetaDataUnicastTagN910 tagN910;
		CustomMetaDataUnicastTagN911 tagN911;
		CustomMetaDataUnicastTagN912 tagN912;
		CustomMetaDataUnicastTagN913 tagN913;
		CustomMetaDataUnicastTagN914 tagN914;
		CustomMetaDataUnicastTagN915 tagN915;
		CustomMetaDataUnicastTagN916 tagN916;
		CustomMetaDataUnicastTagN917 tagN917;
		CustomMetaDataUnicastTagN918 tagN918;
		CustomMetaDataUnicastTagN919 tagN919;
		CustomMetaDataUnicastTagN920 tagN920;
		CustomMetaDataUnicastTagN921 tagN921;
		CustomMetaDataUnicastTagN922 tagN922;
		CustomMetaDataUnicastTagN923 tagN923;
		CustomMetaDataUnicastTagN924 tagN924;
		CustomMetaDataUnicastTagN925 tagN925;
		CustomMetaDataUnicastTagN9max tagN9max;
		
		if ((nei_sizes[8] > 0) and (neighbors_changed[8]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[8] = false;
			switch(nei_sizes[8])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[8].neighbors[0];
					tagN91.Setneighborid(new_neighborset1);
					tagN91.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN91);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[8].neighbors[i];
					}
					tagN92.Setneighborid(new_neighborset2);
					tagN92.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN92);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[8].neighbors[i];
					}
					tagN93.Setneighborid(new_neighborset3);
					tagN93.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN93);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[8].neighbors[i];
					}
					tagN94.Setneighborid(new_neighborset4);
					tagN94.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN94);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[8].neighbors[i];
					}
					tagN95.Setneighborid(new_neighborset5);
					tagN95.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN95);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[8].neighbors[i];
					}
					tagN96.Setneighborid(new_neighborset6);
					tagN96.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN96);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[8].neighbors[i];
					}
					tagN97.Setneighborid(new_neighborset7);
					tagN97.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN97);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[8].neighbors[i];
					}
					tagN98.Setneighborid(new_neighborset8);
					tagN98.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN98);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[8].neighbors[i];
					}
					tagN99.Setneighborid(new_neighborset9);
					tagN99.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN99);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[8].neighbors[i];
					}
					tagN910.Setneighborid(new_neighborset10);
					tagN910.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN910);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[8].neighbors[i];
					}
					tagN911.Setneighborid(new_neighborset11);
					tagN911.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN911);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[8].neighbors[i];
					}
					tagN912.Setneighborid(new_neighborset12);
					tagN912.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN912);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[8].neighbors[i];
					}
					tagN913.Setneighborid(new_neighborset13);
					tagN913.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN913);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[8].neighbors[i];
					}
					tagN914.Setneighborid(new_neighborset14);
					tagN914.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN914);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[8].neighbors[i];
					}
					tagN915.Setneighborid(new_neighborset15);
					tagN915.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN915);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[8].neighbors[i];
					}
					tagN916.Setneighborid(new_neighborset16);
					tagN916.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN916);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[8].neighbors[i];
					}
					tagN917.Setneighborid(new_neighborset17);
					tagN917.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN917);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[8].neighbors[i];
					}
					tagN918.Setneighborid(new_neighborset18);
					tagN918.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN918);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[8].neighbors[i];
					}
					tagN919.Setneighborid(new_neighborset19);
					tagN919.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN919);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[8].neighbors[i];
					}
					tagN920.Setneighborid(new_neighborset20);
					tagN920.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN920);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[8].neighbors[i];
					}
					tagN921.Setneighborid(new_neighborset21);
					tagN921.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN921);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[8].neighbors[i];
					}
					tagN922.Setneighborid(new_neighborset22);
					tagN922.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN922);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[8].neighbors[i];
					}
					tagN923.Setneighborid(new_neighborset23);
					tagN923.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN923);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[8].neighbors[i];
					}
					tagN924.Setneighborid(new_neighborset24);
					tagN924.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN924);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[8].neighbors[i];
					}
					tagN925.Setneighborid(new_neighborset25);
					tagN925.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN925);
					break;
				default:
					cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[8]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[8])
						{
							new_neighborsetmax[i] = neighbor_set[8].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN9max.Setneighborid(new_neighborsetmax);
					tagN9max.Setnodeid(nodeid[8]);
					packet1->AddPacketTag(tagN9max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN101 tagN101;
		CustomMetaDataUnicastTagN102 tagN102;
		CustomMetaDataUnicastTagN103 tagN103;
		CustomMetaDataUnicastTagN104 tagN104;
		CustomMetaDataUnicastTagN105 tagN105;
		CustomMetaDataUnicastTagN106 tagN106;
		CustomMetaDataUnicastTagN107 tagN107;
		CustomMetaDataUnicastTagN108 tagN108;
		CustomMetaDataUnicastTagN109 tagN109;
		CustomMetaDataUnicastTagN1010 tagN1010;
		CustomMetaDataUnicastTagN1011 tagN1011;
		CustomMetaDataUnicastTagN1012 tagN1012;
		CustomMetaDataUnicastTagN1013 tagN1013;
		CustomMetaDataUnicastTagN1014 tagN1014;
		CustomMetaDataUnicastTagN1015 tagN1015;
		CustomMetaDataUnicastTagN1016 tagN1016;
		CustomMetaDataUnicastTagN1017 tagN1017;
		CustomMetaDataUnicastTagN1018 tagN1018;
		CustomMetaDataUnicastTagN1019 tagN1019;
		CustomMetaDataUnicastTagN1020 tagN1020;
		CustomMetaDataUnicastTagN1021 tagN1021;
		CustomMetaDataUnicastTagN1022 tagN1022;
		CustomMetaDataUnicastTagN1023 tagN1023;
		CustomMetaDataUnicastTagN1024 tagN1024;
		CustomMetaDataUnicastTagN1025 tagN1025;
		CustomMetaDataUnicastTagN10max tagN10max;
		
		if ((nei_sizes[9] > 0) and (neighbors_changed[9]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[9] = false;
			switch(nei_sizes[9])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[9].neighbors[0];
					tagN101.Setneighborid(new_neighborset1);
					tagN101.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN101);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[9].neighbors[i];
					}
					tagN102.Setneighborid(new_neighborset2);
					tagN102.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN102);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[9].neighbors[i];
					}
					tagN103.Setneighborid(new_neighborset3);
					tagN103.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN103);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[9].neighbors[i];
					}
					tagN104.Setneighborid(new_neighborset4);
					tagN104.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN104);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[9].neighbors[i];
					}
					tagN105.Setneighborid(new_neighborset5);
					tagN105.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN105);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[9].neighbors[i];
					}
					tagN106.Setneighborid(new_neighborset6);
					tagN106.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN106);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[9].neighbors[i];
					}
					tagN107.Setneighborid(new_neighborset7);
					tagN107.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN107);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[9].neighbors[i];
					}
					tagN108.Setneighborid(new_neighborset8);
					tagN108.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN108);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[9].neighbors[i];
					}
					tagN109.Setneighborid(new_neighborset9);
					tagN109.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN109);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[9].neighbors[i];
					}
					tagN1010.Setneighborid(new_neighborset10);
					tagN1010.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1010);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[9].neighbors[i];
					}
					tagN1011.Setneighborid(new_neighborset11);
					tagN1011.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1011);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[9].neighbors[i];
					}
					tagN1012.Setneighborid(new_neighborset12);
					tagN1012.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1012);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[9].neighbors[i];
					}
					tagN1013.Setneighborid(new_neighborset13);
					tagN1013.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1013);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[9].neighbors[i];
					}
					tagN1014.Setneighborid(new_neighborset14);
					tagN1014.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1014);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[9].neighbors[i];
					}
					tagN1015.Setneighborid(new_neighborset15);
					tagN1015.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1015);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[9].neighbors[i];
					}
					tagN1016.Setneighborid(new_neighborset16);
					tagN1016.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1016);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[9].neighbors[i];
					}
					tagN1017.Setneighborid(new_neighborset17);
					tagN1017.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1017);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[9].neighbors[i];
					}
					tagN1018.Setneighborid(new_neighborset18);
					tagN1018.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1018);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[9].neighbors[i];
					}
					tagN1019.Setneighborid(new_neighborset19);
					tagN1019.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1019);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[9].neighbors[i];
					}
					tagN1020.Setneighborid(new_neighborset20);
					tagN1020.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1020);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[9].neighbors[i];
					}
					tagN1021.Setneighborid(new_neighborset21);
					tagN1021.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1021);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[9].neighbors[i];
					}
					tagN1022.Setneighborid(new_neighborset22);
					tagN1022.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1022);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[9].neighbors[i];
					}
					tagN1023.Setneighborid(new_neighborset23);
					tagN1023.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1023);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[9].neighbors[i];
					}
					tagN1024.Setneighborid(new_neighborset24);
					tagN1024.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1024);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[9].neighbors[i];
					}
					tagN1025.Setneighborid(new_neighborset25);
					tagN1025.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN1025);
					break;
				default:
					cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[9]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[9])
						{
							new_neighborsetmax[i] = neighbor_set[9].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN10max.Setneighborid(new_neighborsetmax);
					tagN10max.Setnodeid(nodeid[9]);
					packet1->AddPacketTag(tagN10max);
					break;
			}
		
		}		
		
		CustomMetaDataUnicastTagN111 tagN111;
		CustomMetaDataUnicastTagN112 tagN112;
		CustomMetaDataUnicastTagN113 tagN113;
		CustomMetaDataUnicastTagN114 tagN114;
		CustomMetaDataUnicastTagN115 tagN115;
		CustomMetaDataUnicastTagN116 tagN116;
		CustomMetaDataUnicastTagN117 tagN117;
		CustomMetaDataUnicastTagN118 tagN118;
		CustomMetaDataUnicastTagN119 tagN119;
		CustomMetaDataUnicastTagN1110 tagN1110;
		CustomMetaDataUnicastTagN1111 tagN1111;
		CustomMetaDataUnicastTagN1112 tagN1112;
		CustomMetaDataUnicastTagN1113 tagN1113;
		CustomMetaDataUnicastTagN1114 tagN1114;
		CustomMetaDataUnicastTagN1115 tagN1115;
		CustomMetaDataUnicastTagN1116 tagN1116;
		CustomMetaDataUnicastTagN1117 tagN1117;
		CustomMetaDataUnicastTagN1118 tagN1118;
		CustomMetaDataUnicastTagN1119 tagN1119;
		CustomMetaDataUnicastTagN1120 tagN1120;
		CustomMetaDataUnicastTagN1121 tagN1121;
		CustomMetaDataUnicastTagN1122 tagN1122;
		CustomMetaDataUnicastTagN1123 tagN1123;
		CustomMetaDataUnicastTagN1124 tagN1124;
		CustomMetaDataUnicastTagN1125 tagN1125;
		CustomMetaDataUnicastTagN11max tagN11max;
		
		if ((nei_sizes[10] > 0) and (neighbors_changed[10]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[10] = false;
			switch(nei_sizes[10])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[10].neighbors[0];
					tagN111.Setneighborid(new_neighborset1);
					tagN111.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN111);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[10].neighbors[i];
					}
					tagN112.Setneighborid(new_neighborset2);
					tagN112.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN112);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[10].neighbors[i];
					}
					tagN113.Setneighborid(new_neighborset3);
					tagN113.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN113);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[10].neighbors[i];
					}
					tagN114.Setneighborid(new_neighborset4);
					tagN114.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN114);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[10].neighbors[i];
					}
					tagN115.Setneighborid(new_neighborset5);
					tagN115.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN115);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[10].neighbors[i];
					}
					tagN116.Setneighborid(new_neighborset6);
					tagN116.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN116);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[10].neighbors[i];
					}
					tagN117.Setneighborid(new_neighborset7);
					tagN117.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN117);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[10].neighbors[i];
					}
					tagN118.Setneighborid(new_neighborset8);
					tagN118.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN118);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[10].neighbors[i];
					}
					tagN119.Setneighborid(new_neighborset9);
					tagN119.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN119);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[10].neighbors[i];
					}
					tagN1110.Setneighborid(new_neighborset10);
					tagN1110.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1110);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[10].neighbors[i];
					}
					tagN1111.Setneighborid(new_neighborset11);
					tagN1111.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1111);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[10].neighbors[i];
					}
					tagN1112.Setneighborid(new_neighborset12);
					tagN1112.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1112);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[10].neighbors[i];
					}
					tagN1113.Setneighborid(new_neighborset13);
					tagN1113.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1113);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[10].neighbors[i];
					}
					tagN1114.Setneighborid(new_neighborset14);
					tagN1114.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1114);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[10].neighbors[i];
					}
					tagN1115.Setneighborid(new_neighborset15);
					tagN1115.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1115);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[10].neighbors[i];
					}
					tagN1116.Setneighborid(new_neighborset16);
					tagN1116.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1116);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[10].neighbors[i];
					}
					tagN1117.Setneighborid(new_neighborset17);
					tagN1117.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1117);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[10].neighbors[i];
					}
					tagN1118.Setneighborid(new_neighborset18);
					tagN1118.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1118);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[10].neighbors[i];
					}
					tagN1119.Setneighborid(new_neighborset19);
					tagN1119.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1119);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[10].neighbors[i];
					}
					tagN1120.Setneighborid(new_neighborset20);
					tagN1120.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1120);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[10].neighbors[i];
					}
					tagN1121.Setneighborid(new_neighborset21);
					tagN1121.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1121);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[10].neighbors[i];
					}
					tagN1122.Setneighborid(new_neighborset22);
					tagN1122.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1122);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[10].neighbors[i];
					}
					tagN1123.Setneighborid(new_neighborset23);
					tagN1123.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1123);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[10].neighbors[i];
					}
					tagN1124.Setneighborid(new_neighborset24);
					tagN1124.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1124);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[10].neighbors[i];
					}
					tagN1125.Setneighborid(new_neighborset25);
					tagN1125.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN1125);
					break;
				default:
					cout<<"Etheret:maximum neighbor datasize exceeded. size is "<<nei_sizes[10]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[10])
						{
							new_neighborsetmax[i] = neighbor_set[10].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN11max.Setneighborid(new_neighborsetmax);
					tagN11max.Setnodeid(nodeid[10]);
					packet1->AddPacketTag(tagN11max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN121 tagN121;
		CustomMetaDataUnicastTagN122 tagN122;
		CustomMetaDataUnicastTagN123 tagN123;
		CustomMetaDataUnicastTagN124 tagN124;
		CustomMetaDataUnicastTagN125 tagN125;
		CustomMetaDataUnicastTagN126 tagN126;
		CustomMetaDataUnicastTagN127 tagN127;
		CustomMetaDataUnicastTagN128 tagN128;
		CustomMetaDataUnicastTagN129 tagN129;
		CustomMetaDataUnicastTagN1210 tagN1210;
		CustomMetaDataUnicastTagN1211 tagN1211;
		CustomMetaDataUnicastTagN1212 tagN1212;
		CustomMetaDataUnicastTagN1213 tagN1213;
		CustomMetaDataUnicastTagN1214 tagN1214;
		CustomMetaDataUnicastTagN1215 tagN1215;
		CustomMetaDataUnicastTagN1216 tagN1216;
		CustomMetaDataUnicastTagN1217 tagN1217;
		CustomMetaDataUnicastTagN1218 tagN1218;
		CustomMetaDataUnicastTagN1219 tagN1219;
		CustomMetaDataUnicastTagN1220 tagN1220;
		CustomMetaDataUnicastTagN1221 tagN1221;
		CustomMetaDataUnicastTagN1222 tagN1222;
		CustomMetaDataUnicastTagN1223 tagN1223;
		CustomMetaDataUnicastTagN1224 tagN1224;
		CustomMetaDataUnicastTagN1225 tagN1225;
		CustomMetaDataUnicastTagN12max tagN12max;
		
		
		if ((nei_sizes[11] > 0) and (neighbors_changed[11]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[11] = false;
			switch(nei_sizes[11])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[11].neighbors[0];
					tagN121.Setneighborid(new_neighborset1);
					tagN121.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN121);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[11].neighbors[i];
					}
					tagN122.Setneighborid(new_neighborset2);
					tagN122.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN122);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[11].neighbors[i];
					}
					tagN123.Setneighborid(new_neighborset3);
					tagN123.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN123);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[11].neighbors[i];
					}
					tagN124.Setneighborid(new_neighborset4);
					tagN124.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN124);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[11].neighbors[i];
					}
					tagN125.Setneighborid(new_neighborset5);
					tagN125.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN125);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[11].neighbors[i];
					}
					tagN126.Setneighborid(new_neighborset6);
					tagN126.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN126);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[11].neighbors[i];
					}
					tagN127.Setneighborid(new_neighborset7);
					tagN127.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN127);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[11].neighbors[i];
					}
					tagN128.Setneighborid(new_neighborset8);
					tagN128.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN128);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[11].neighbors[i];
					}
					tagN129.Setneighborid(new_neighborset9);
					tagN129.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN129);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[11].neighbors[i];
					}
					tagN1210.Setneighborid(new_neighborset10);
					tagN1210.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1210);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[11].neighbors[i];
					}
					tagN1211.Setneighborid(new_neighborset11);
					tagN1211.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1211);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[11].neighbors[i];
					}
					tagN1212.Setneighborid(new_neighborset12);
					tagN1212.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1212);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[11].neighbors[i];
					}
					tagN1213.Setneighborid(new_neighborset13);
					tagN1213.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1213);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[11].neighbors[i];
					}
					tagN1214.Setneighborid(new_neighborset14);
					tagN1214.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1214);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[11].neighbors[i];
					}
					tagN1215.Setneighborid(new_neighborset15);
					tagN1215.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1215);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[11].neighbors[i];
					}
					tagN1216.Setneighborid(new_neighborset16);
					tagN1216.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1216);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[11].neighbors[i];
					}
					tagN1217.Setneighborid(new_neighborset17);
					tagN1217.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1217);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[11].neighbors[i];
					}
					tagN1218.Setneighborid(new_neighborset18);
					tagN1218.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1218);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[11].neighbors[i];
					}
					tagN1219.Setneighborid(new_neighborset19);
					tagN1219.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1219);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[11].neighbors[i];
					}
					tagN1220.Setneighborid(new_neighborset20);
					tagN1220.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1220);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[11].neighbors[i];
					}
					tagN1221.Setneighborid(new_neighborset21);
					tagN1221.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1221);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[11].neighbors[i];
					}
					tagN1222.Setneighborid(new_neighborset22);
					tagN1222.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1222);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[11].neighbors[i];
					}
					tagN1223.Setneighborid(new_neighborset23);
					tagN1223.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1223);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[11].neighbors[i];
					}
					tagN1224.Setneighborid(new_neighborset24);
					tagN1224.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1224);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[11].neighbors[i];
					}
					tagN1225.Setneighborid(new_neighborset25);
					tagN1225.Setnodeid(nodeid[11]);
					packet1->AddPacketTag(tagN1225);
					break;
				default:
					cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[11]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[11])
						{
							new_neighborsetmax[i] = neighbor_set[11].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN12max.Setnodeid(nodeid[11]);
					tagN12max.Setneighborid(new_neighborsetmax);
					packet1->AddPacketTag(tagN12max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN131 tagN131;
		CustomMetaDataUnicastTagN132 tagN132;
		CustomMetaDataUnicastTagN133 tagN133;
		CustomMetaDataUnicastTagN134 tagN134;
		CustomMetaDataUnicastTagN135 tagN135;
		CustomMetaDataUnicastTagN136 tagN136;
		CustomMetaDataUnicastTagN137 tagN137;
		CustomMetaDataUnicastTagN138 tagN138;
		CustomMetaDataUnicastTagN139 tagN139;
		CustomMetaDataUnicastTagN1310 tagN1310;
		CustomMetaDataUnicastTagN1311 tagN1311;
		CustomMetaDataUnicastTagN1312 tagN1312;
		CustomMetaDataUnicastTagN1313 tagN1313;
		CustomMetaDataUnicastTagN1314 tagN1314;
		CustomMetaDataUnicastTagN1315 tagN1315;
		CustomMetaDataUnicastTagN1316 tagN1316;
		CustomMetaDataUnicastTagN1317 tagN1317;
		CustomMetaDataUnicastTagN1318 tagN1318;
		CustomMetaDataUnicastTagN1319 tagN1319;
		CustomMetaDataUnicastTagN1320 tagN1320;
		CustomMetaDataUnicastTagN1321 tagN1321;
		CustomMetaDataUnicastTagN1322 tagN1322;
		CustomMetaDataUnicastTagN1323 tagN1323;
		CustomMetaDataUnicastTagN1324 tagN1324;
		CustomMetaDataUnicastTagN1325 tagN1325;
		CustomMetaDataUnicastTagN13max tagN13max;
		
		if ((nei_sizes[12] > 0) and (neighbors_changed[12]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[12] = false;
			switch(nei_sizes[12])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[12].neighbors[0];
					tagN131.Setneighborid(new_neighborset1);
					tagN131.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN131);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[12].neighbors[i];
					}
					tagN132.Setneighborid(new_neighborset2);
					tagN132.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN132);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[12].neighbors[i];
					}
					tagN133.Setneighborid(new_neighborset3);
					tagN133.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN133);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[12].neighbors[i];
					}
					tagN134.Setneighborid(new_neighborset4);
					tagN134.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN134);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[12].neighbors[i];
					}
					tagN135.Setneighborid(new_neighborset5);
					tagN135.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN135);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[12].neighbors[i];
					}
					tagN136.Setneighborid(new_neighborset6);
					tagN136.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN136);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[12].neighbors[i];
					}
					tagN137.Setneighborid(new_neighborset7);
					tagN137.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN137);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[12].neighbors[i];
					}
					tagN138.Setneighborid(new_neighborset8);
					tagN138.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN138);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[12].neighbors[i];
					}
					tagN139.Setneighborid(new_neighborset9);
					tagN139.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN139);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[12].neighbors[i];
					}
					tagN1310.Setneighborid(new_neighborset10);
					tagN1310.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1310);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[12].neighbors[i];
					}
					tagN1311.Setneighborid(new_neighborset11);
					tagN1311.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1311);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[12].neighbors[i];
					}
					tagN1312.Setneighborid(new_neighborset12);
					tagN1312.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1312);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[12].neighbors[i];
					}
					tagN1313.Setneighborid(new_neighborset13);
					tagN1313.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1313);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[12].neighbors[i];
					}
					tagN1314.Setneighborid(new_neighborset14);
					tagN1314.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1314);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[12].neighbors[i];
					}
					tagN1315.Setneighborid(new_neighborset15);
					tagN1315.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1315);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[12].neighbors[i];
					}
					tagN1316.Setneighborid(new_neighborset16);
					tagN1316.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1316);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[12].neighbors[i];
					}
					tagN1317.Setneighborid(new_neighborset17);
					tagN1317.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1317);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[12].neighbors[i];
					}
					tagN1318.Setneighborid(new_neighborset18);
					tagN1318.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1318);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[12].neighbors[i];
					}
					tagN1319.Setneighborid(new_neighborset19);
					tagN1319.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1319);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[12].neighbors[i];
					}
					tagN1320.Setneighborid(new_neighborset20);
					tagN1320.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1320);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[12].neighbors[i];
					}
					tagN1321.Setneighborid(new_neighborset21);
					tagN1321.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1321);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[12].neighbors[i];
					}
					tagN1322.Setneighborid(new_neighborset22);
					tagN1322.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1322);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[12].neighbors[i];
					}
					tagN1323.Setneighborid(new_neighborset23);
					tagN1323.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1323);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[12].neighbors[i];
					}
					tagN1324.Setneighborid(new_neighborset24);
					tagN1324.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1324);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[12].neighbors[i];
					}
					tagN1325.Setneighborid(new_neighborset25);
					tagN1325.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN1325);
					break;
				default:
					cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[12]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[12])
						{
							new_neighborsetmax[i] = neighbor_set[12].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN13max.Setneighborid(new_neighborsetmax);
					tagN13max.Setnodeid(nodeid[12]);
					packet1->AddPacketTag(tagN13max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN141 tagN141;
		CustomMetaDataUnicastTagN142 tagN142;
		CustomMetaDataUnicastTagN143 tagN143;
		CustomMetaDataUnicastTagN144 tagN144;
		CustomMetaDataUnicastTagN145 tagN145;
		CustomMetaDataUnicastTagN146 tagN146;
		CustomMetaDataUnicastTagN147 tagN147;
		CustomMetaDataUnicastTagN148 tagN148;
		CustomMetaDataUnicastTagN149 tagN149;
		CustomMetaDataUnicastTagN1410 tagN1410;
		CustomMetaDataUnicastTagN1411 tagN1411;
		CustomMetaDataUnicastTagN1412 tagN1412;
		CustomMetaDataUnicastTagN1413 tagN1413;
		CustomMetaDataUnicastTagN1414 tagN1414;
		CustomMetaDataUnicastTagN1415 tagN1415;
		CustomMetaDataUnicastTagN1416 tagN1416;
		CustomMetaDataUnicastTagN1417 tagN1417;
		CustomMetaDataUnicastTagN1418 tagN1418;
		CustomMetaDataUnicastTagN1419 tagN1419;
		CustomMetaDataUnicastTagN1420 tagN1420;
		CustomMetaDataUnicastTagN1421 tagN1421;
		CustomMetaDataUnicastTagN1422 tagN1422;
		CustomMetaDataUnicastTagN1423 tagN1423;
		CustomMetaDataUnicastTagN1424 tagN1424;
		CustomMetaDataUnicastTagN1425 tagN1425;
		CustomMetaDataUnicastTagN14max tagN14max;
		
		if ((nei_sizes[13] > 0) and (neighbors_changed[13]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[13] = false;
			switch(nei_sizes[13])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[13].neighbors[0];
					tagN141.Setneighborid(new_neighborset1);
					tagN141.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN141);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[13].neighbors[i];
					}
					tagN142.Setneighborid(new_neighborset2);
					tagN142.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN142);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[13].neighbors[i];
					}
					tagN143.Setneighborid(new_neighborset3);
					tagN143.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN143);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[13].neighbors[i];
					}
					tagN144.Setneighborid(new_neighborset4);
					tagN144.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN144);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[13].neighbors[i];
					}
					tagN145.Setneighborid(new_neighborset5);
					tagN145.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN145);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[13].neighbors[i];
					}
					tagN146.Setneighborid(new_neighborset6);
					tagN146.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN146);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[13].neighbors[i];
					}
					tagN147.Setneighborid(new_neighborset7);
					tagN147.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN147);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[13].neighbors[i];
					}
					tagN148.Setneighborid(new_neighborset8);
					tagN148.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN148);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[13].neighbors[i];
					}
					tagN149.Setneighborid(new_neighborset9);
					tagN149.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN149);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[13].neighbors[i];
					}
					tagN1410.Setneighborid(new_neighborset10);
					tagN1410.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1410);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[13].neighbors[i];
					}
					tagN1411.Setneighborid(new_neighborset11);
					tagN1411.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1411);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[13].neighbors[i];
					}
					tagN1412.Setneighborid(new_neighborset12);
					tagN1412.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1412);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[13].neighbors[i];
					}
					tagN1413.Setneighborid(new_neighborset13);
					tagN1413.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1413);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[13].neighbors[i];
					}
					tagN1414.Setneighborid(new_neighborset14);
					tagN1414.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1414);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[13].neighbors[i];
					}
					tagN1415.Setneighborid(new_neighborset15);
					tagN1415.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1415);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[13].neighbors[i];
					}
					tagN1416.Setneighborid(new_neighborset16);
					tagN1416.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1416);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[13].neighbors[i];
					}
					tagN1417.Setneighborid(new_neighborset17);
					tagN1417.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1417);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[13].neighbors[i];
					}
					tagN1418.Setneighborid(new_neighborset18);
					tagN1418.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1418);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[13].neighbors[i];
					}
					tagN1419.Setneighborid(new_neighborset19);
					tagN1419.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1419);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[13].neighbors[i];
					}
					tagN1420.Setneighborid(new_neighborset20);
					tagN1420.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1420);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[13].neighbors[i];
					}
					tagN1421.Setneighborid(new_neighborset21);
					tagN1421.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1421);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[13].neighbors[i];
					}
					tagN1422.Setneighborid(new_neighborset22);
					tagN1422.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1422);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[13].neighbors[i];
					}
					tagN1423.Setneighborid(new_neighborset23);
					tagN1423.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1423);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[13].neighbors[i];
					}
					tagN1424.Setneighborid(new_neighborset24);
					tagN1424.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1424);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[13].neighbors[i];
					}
					tagN1425.Setneighborid(new_neighborset25);
					tagN1425.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN1425);
					break;
				default:
					cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[13]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[13])
						{
							new_neighborsetmax[i] = neighbor_set[13].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN14max.Setneighborid(new_neighborsetmax);
					tagN14max.Setnodeid(nodeid[13]);
					packet1->AddPacketTag(tagN14max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN151 tagN151;
		CustomMetaDataUnicastTagN152 tagN152;
		CustomMetaDataUnicastTagN153 tagN153;
		CustomMetaDataUnicastTagN154 tagN154;
		CustomMetaDataUnicastTagN155 tagN155;
		CustomMetaDataUnicastTagN156 tagN156;
		CustomMetaDataUnicastTagN157 tagN157;
		CustomMetaDataUnicastTagN158 tagN158;
		CustomMetaDataUnicastTagN159 tagN159;
		CustomMetaDataUnicastTagN1510 tagN1510;
		CustomMetaDataUnicastTagN1511 tagN1511;
		CustomMetaDataUnicastTagN1512 tagN1512;
		CustomMetaDataUnicastTagN1513 tagN1513;
		CustomMetaDataUnicastTagN1514 tagN1514;
		CustomMetaDataUnicastTagN1515 tagN1515;
		CustomMetaDataUnicastTagN1516 tagN1516;
		CustomMetaDataUnicastTagN1517 tagN1517;
		CustomMetaDataUnicastTagN1518 tagN1518;
		CustomMetaDataUnicastTagN1519 tagN1519;
		CustomMetaDataUnicastTagN1520 tagN1520;
		CustomMetaDataUnicastTagN1521 tagN1521;
		CustomMetaDataUnicastTagN1522 tagN1522;
		CustomMetaDataUnicastTagN1523 tagN1523;
		CustomMetaDataUnicastTagN1524 tagN1524;
		CustomMetaDataUnicastTagN1525 tagN1525;
		CustomMetaDataUnicastTagN15max tagN15max;
		
		if ((nei_sizes[14] > 0) and (neighbors_changed[14]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[14] = false;
			switch(nei_sizes[14])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[14].neighbors[0];
					tagN151.Setneighborid(new_neighborset1);
					tagN151.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN151);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[14].neighbors[i];
					}
					tagN152.Setneighborid(new_neighborset2);
					tagN152.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN152);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[14].neighbors[i];
					}
					tagN153.Setneighborid(new_neighborset3);
					tagN153.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN153);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[14].neighbors[i];
					}
					tagN154.Setneighborid(new_neighborset4);
					tagN154.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN154);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[14].neighbors[i];
					}
					tagN155.Setneighborid(new_neighborset5);
					tagN155.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN155);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[14].neighbors[i];
					}
					tagN156.Setneighborid(new_neighborset6);
					tagN156.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN156);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[14].neighbors[i];
					}
					tagN157.Setneighborid(new_neighborset7);
					tagN157.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN157);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[14].neighbors[i];
					}
					tagN158.Setneighborid(new_neighborset8);
					tagN158.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN158);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[14].neighbors[i];
					}
					tagN159.Setneighborid(new_neighborset9);
					tagN159.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN159);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[14].neighbors[i];
					}
					tagN1510.Setneighborid(new_neighborset10);
					tagN1510.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1510);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[14].neighbors[i];
					}
					tagN1511.Setneighborid(new_neighborset11);
					tagN1511.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1511);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[14].neighbors[i];
					}
					tagN1512.Setneighborid(new_neighborset12);
					tagN1512.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1512);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[14].neighbors[i];
					}
					tagN1513.Setneighborid(new_neighborset13);
					tagN1513.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1513);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[14].neighbors[i];
					}
					tagN1514.Setneighborid(new_neighborset14);
					tagN1514.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1514);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[14].neighbors[i];
					}
					tagN1515.Setneighborid(new_neighborset15);
					tagN1515.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1515);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[14].neighbors[i];
					}
					tagN1516.Setneighborid(new_neighborset16);
					tagN1516.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1516);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[14].neighbors[i];
					}
					tagN1517.Setneighborid(new_neighborset17);
					tagN1517.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1517);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[14].neighbors[i];
					}
					tagN1518.Setneighborid(new_neighborset18);
					tagN1518.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1518);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[14].neighbors[i];
					}
					tagN1519.Setneighborid(new_neighborset19);
					tagN1519.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1519);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[14].neighbors[i];
					}
					tagN1520.Setneighborid(new_neighborset20);
					tagN1520.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1520);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[14].neighbors[i];
					}
					tagN1521.Setneighborid(new_neighborset21);
					tagN1521.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1521);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[14].neighbors[i];
					}
					tagN1522.Setneighborid(new_neighborset22);
					tagN1522.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1522);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[14].neighbors[i];
					}
					tagN1523.Setneighborid(new_neighborset23);
					tagN1523.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1523);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[14].neighbors[i];
					}
					tagN1524.Setneighborid(new_neighborset24);
					tagN1524.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1524);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[14].neighbors[i];
					}
					tagN1525.Setneighborid(new_neighborset25);
					tagN1525.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN1525);
					break;
				default:
					cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[14]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[14])
						{
							new_neighborsetmax[i] = neighbor_set[14].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN15max.Setneighborid(new_neighborsetmax);
					tagN15max.Setnodeid(nodeid[14]);
					packet1->AddPacketTag(tagN15max);
					break;
			}
		
		}
		CustomMetaDataUnicastTagN161 tagN161;
		CustomMetaDataUnicastTagN162 tagN162;
		CustomMetaDataUnicastTagN163 tagN163;
		CustomMetaDataUnicastTagN164 tagN164;
		CustomMetaDataUnicastTagN165 tagN165;
		CustomMetaDataUnicastTagN166 tagN166;
		CustomMetaDataUnicastTagN167 tagN167;
		CustomMetaDataUnicastTagN168 tagN168;
		CustomMetaDataUnicastTagN169 tagN169;
		CustomMetaDataUnicastTagN1610 tagN1610;
		CustomMetaDataUnicastTagN1611 tagN1611;
		CustomMetaDataUnicastTagN1612 tagN1612;
		CustomMetaDataUnicastTagN1613 tagN1613;
		CustomMetaDataUnicastTagN1614 tagN1614;
		CustomMetaDataUnicastTagN1615 tagN1615;
		CustomMetaDataUnicastTagN1616 tagN1616;
		CustomMetaDataUnicastTagN1617 tagN1617;
		CustomMetaDataUnicastTagN1618 tagN1618;
		CustomMetaDataUnicastTagN1619 tagN1619;
		CustomMetaDataUnicastTagN1620 tagN1620;
		CustomMetaDataUnicastTagN1621 tagN1621;
		CustomMetaDataUnicastTagN1622 tagN1622;
		CustomMetaDataUnicastTagN1623 tagN1623;
		CustomMetaDataUnicastTagN1624 tagN1624;
		CustomMetaDataUnicastTagN1625 tagN1625;
		CustomMetaDataUnicastTagN16max tagN16max;
		
		if ((nei_sizes[15] > 0) and (neighbors_changed[15]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[15] = false;
			switch(nei_sizes[15])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[15].neighbors[0];
					tagN161.Setneighborid(new_neighborset1);
					tagN161.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN161);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[15].neighbors[i];
					}
					tagN162.Setneighborid(new_neighborset2);
					tagN162.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN162);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[15].neighbors[i];
					}
					tagN163.Setneighborid(new_neighborset3);
					tagN163.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN163);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[15].neighbors[i];
					}
					tagN164.Setneighborid(new_neighborset4);
					tagN164.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN164);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[15].neighbors[i];
					}
					tagN165.Setneighborid(new_neighborset5);
					tagN165.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN165);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[15].neighbors[i];
					}
					tagN166.Setneighborid(new_neighborset6);
					tagN166.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN166);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[15].neighbors[i];
					}
					tagN167.Setneighborid(new_neighborset7);
					tagN167.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN167);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[15].neighbors[i];
					}
					tagN168.Setneighborid(new_neighborset8);
					tagN168.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN168);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[15].neighbors[i];
					}
					tagN169.Setneighborid(new_neighborset9);
					tagN169.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN169);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[15].neighbors[i];
					}
					tagN1610.Setneighborid(new_neighborset10);
					tagN1610.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1610);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[15].neighbors[i];
					}
					tagN1611.Setneighborid(new_neighborset11);
					tagN1611.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1611);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[15].neighbors[i];
					}
					tagN1612.Setneighborid(new_neighborset12);
					tagN1612.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1612);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[15].neighbors[i];
					}
					tagN1613.Setneighborid(new_neighborset13);
					tagN1613.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1613);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[15].neighbors[i];
					}
					tagN1614.Setneighborid(new_neighborset14);
					tagN1614.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1614);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[15].neighbors[i];
					}
					tagN1615.Setneighborid(new_neighborset15);
					tagN1615.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1615);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[15].neighbors[i];
					}
					tagN1616.Setneighborid(new_neighborset16);
					tagN1616.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1616);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[15].neighbors[i];
					}
					tagN1617.Setneighborid(new_neighborset17);
					tagN1617.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1617);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[15].neighbors[i];
					}
					tagN1618.Setneighborid(new_neighborset18);
					tagN1618.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1618);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[15].neighbors[i];
					}
					tagN1619.Setneighborid(new_neighborset19);
					tagN1619.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1619);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[15].neighbors[i];
					}
					tagN1620.Setneighborid(new_neighborset20);
					tagN1620.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1620);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[15].neighbors[i];
					}
					tagN1621.Setneighborid(new_neighborset21);
					tagN1621.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1621);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[15].neighbors[i];
					}
					tagN1622.Setneighborid(new_neighborset22);
					tagN1622.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1622);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[15].neighbors[i];
					}
					tagN1623.Setneighborid(new_neighborset23);
					tagN1623.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1623);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[15].neighbors[i];
					}
					tagN1624.Setneighborid(new_neighborset24);
					tagN1624.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1624);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[15].neighbors[i];
					}
					tagN1625.Setneighborid(new_neighborset25);
					tagN1625.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN1625);
					break;
				default:
					cout<<"Ethernet :maximum datasize exceeded. size is "<<nei_sizes[15]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[15])
						{
							new_neighborsetmax[i] = neighbor_set[15].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN16max.Setneighborid(new_neighborsetmax);
					tagN16max.Setnodeid(nodeid[15]);
					packet1->AddPacketTag(tagN16max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN171 tagN171;
		CustomMetaDataUnicastTagN172 tagN172;
		CustomMetaDataUnicastTagN173 tagN173;
		CustomMetaDataUnicastTagN174 tagN174;
		CustomMetaDataUnicastTagN175 tagN175;
		CustomMetaDataUnicastTagN176 tagN176;
		CustomMetaDataUnicastTagN177 tagN177;
		CustomMetaDataUnicastTagN178 tagN178;
		CustomMetaDataUnicastTagN179 tagN179;
		CustomMetaDataUnicastTagN1710 tagN1710;
		CustomMetaDataUnicastTagN1711 tagN1711;
		CustomMetaDataUnicastTagN1712 tagN1712;
		CustomMetaDataUnicastTagN1713 tagN1713;
		CustomMetaDataUnicastTagN1714 tagN1714;
		CustomMetaDataUnicastTagN1715 tagN1715;
		CustomMetaDataUnicastTagN1716 tagN1716;
		CustomMetaDataUnicastTagN1717 tagN1717;
		CustomMetaDataUnicastTagN1718 tagN1718;
		CustomMetaDataUnicastTagN1719 tagN1719;
		CustomMetaDataUnicastTagN1720 tagN1720;
		CustomMetaDataUnicastTagN1721 tagN1721;
		CustomMetaDataUnicastTagN1722 tagN1722;
		CustomMetaDataUnicastTagN1723 tagN1723;
		CustomMetaDataUnicastTagN1724 tagN1724;
		CustomMetaDataUnicastTagN1725 tagN1725;
		CustomMetaDataUnicastTagN17max tagN17max;
		
		if ((nei_sizes[16] > 0) and (neighbors_changed[16]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[16] = false;
			switch(nei_sizes[16])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[16].neighbors[0];
					tagN171.Setneighborid(new_neighborset1);
					tagN171.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN171);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[16].neighbors[i];
					}
					tagN172.Setneighborid(new_neighborset2);
					tagN172.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN172);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[16].neighbors[i];
					}
					tagN173.Setneighborid(new_neighborset3);
					tagN173.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN173);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[16].neighbors[i];
					}
					tagN174.Setneighborid(new_neighborset4);
					tagN174.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN174);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[16].neighbors[i];
					}
					tagN175.Setneighborid(new_neighborset5);
					tagN175.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN175);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[16].neighbors[i];
					}
					tagN176.Setneighborid(new_neighborset6);
					tagN176.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN176);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[16].neighbors[i];
					}
					tagN177.Setneighborid(new_neighborset7);
					tagN177.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN177);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[16].neighbors[i];
					}
					tagN178.Setneighborid(new_neighborset8);
					tagN178.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN178);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[16].neighbors[i];
					}
					tagN179.Setneighborid(new_neighborset9);
					tagN179.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN179);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[16].neighbors[i];
					}
					tagN1710.Setneighborid(new_neighborset10);
					tagN1710.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1710);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[16].neighbors[i];
					}
					tagN1711.Setneighborid(new_neighborset11);
					tagN1711.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1711);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[16].neighbors[i];
					}
					tagN1712.Setneighborid(new_neighborset12);
					tagN1712.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1712);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[16].neighbors[i];
					}
					tagN1713.Setneighborid(new_neighborset13);
					tagN1713.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1713);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[16].neighbors[i];
					}
					tagN1714.Setneighborid(new_neighborset14);
					tagN1714.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1714);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[16].neighbors[i];
					}
					tagN1715.Setneighborid(new_neighborset15);
					tagN1715.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1715);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[16].neighbors[i];
					}
					tagN1716.Setneighborid(new_neighborset16);
					tagN1716.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1716);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[16].neighbors[i];
					}
					tagN1717.Setneighborid(new_neighborset17);
					tagN1717.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1717);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[16].neighbors[i];
					}
					tagN1718.Setneighborid(new_neighborset18);
					tagN1718.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1718);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[16].neighbors[i];
					}
					tagN1719.Setneighborid(new_neighborset19);
					tagN1719.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1719);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[16].neighbors[i];
					}
					tagN1720.Setneighborid(new_neighborset20);
					tagN1720.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1720);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[16].neighbors[i];
					}
					tagN1721.Setneighborid(new_neighborset21);
					tagN1721.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1721);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[16].neighbors[i];
					}
					tagN1722.Setneighborid(new_neighborset22);
					tagN1722.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1722);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[16].neighbors[i];
					}
					tagN1723.Setneighborid(new_neighborset23);
					tagN1723.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1723);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[16].neighbors[i];
					}
					tagN1724.Setneighborid(new_neighborset24);
					tagN1724.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1724);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[16].neighbors[i];
					}
					tagN1725.Setneighborid(new_neighborset25);
					tagN1725.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN1725);
					break;
				default:
					cout<<"ethernet:maximum datasize exceeded . size is  "<<nei_sizes[16]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[16])
						{
							new_neighborsetmax[i] = neighbor_set[16].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN17max.Setneighborid(new_neighborsetmax);
					tagN17max.Setnodeid(nodeid[16]);
					packet1->AddPacketTag(tagN17max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN181 tagN181;
		CustomMetaDataUnicastTagN182 tagN182;
		CustomMetaDataUnicastTagN183 tagN183;
		CustomMetaDataUnicastTagN184 tagN184;
		CustomMetaDataUnicastTagN185 tagN185;
		CustomMetaDataUnicastTagN186 tagN186;
		CustomMetaDataUnicastTagN187 tagN187;
		CustomMetaDataUnicastTagN188 tagN188;
		CustomMetaDataUnicastTagN189 tagN189;
		CustomMetaDataUnicastTagN1810 tagN1810;
		CustomMetaDataUnicastTagN1811 tagN1811;
		CustomMetaDataUnicastTagN1812 tagN1812;
		CustomMetaDataUnicastTagN1813 tagN1813;
		CustomMetaDataUnicastTagN1814 tagN1814;
		CustomMetaDataUnicastTagN1815 tagN1815;
		CustomMetaDataUnicastTagN1816 tagN1816;
		CustomMetaDataUnicastTagN1817 tagN1817;
		CustomMetaDataUnicastTagN1818 tagN1818;
		CustomMetaDataUnicastTagN1819 tagN1819;
		CustomMetaDataUnicastTagN1820 tagN1820;
		CustomMetaDataUnicastTagN1821 tagN1821;
		CustomMetaDataUnicastTagN1822 tagN1822;
		CustomMetaDataUnicastTagN1823 tagN1823;
		CustomMetaDataUnicastTagN1824 tagN1824;
		CustomMetaDataUnicastTagN1825 tagN1825;
		CustomMetaDataUnicastTagN18max tagN18max;
		
		if ((nei_sizes[17] > 0) and (neighbors_changed[17]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[17] = false;
			switch(nei_sizes[17])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[17].neighbors[0];
					tagN181.Setneighborid(new_neighborset1);
					tagN181.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN181);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[17].neighbors[i];
					}
					tagN182.Setneighborid(new_neighborset2);
					tagN182.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN182);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[17].neighbors[i];
					}
					tagN183.Setneighborid(new_neighborset3);
					tagN183.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN183);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[17].neighbors[i];
					}
					tagN184.Setneighborid(new_neighborset4);
					tagN184.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN184);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[17].neighbors[i];
					}
					tagN185.Setneighborid(new_neighborset5);
					tagN185.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN185);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[17].neighbors[i];
					}
					tagN186.Setneighborid(new_neighborset6);
					tagN186.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN186);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[17].neighbors[i];
					}
					tagN187.Setneighborid(new_neighborset7);
					tagN187.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN187);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[17].neighbors[i];
					}
					tagN188.Setneighborid(new_neighborset8);
					tagN188.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN188);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[17].neighbors[i];
					}
					tagN189.Setneighborid(new_neighborset9);
					tagN189.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN189);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[17].neighbors[i];
					}
					tagN1810.Setneighborid(new_neighborset10);
					tagN1810.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1810);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[17].neighbors[i];
					}
					tagN1811.Setneighborid(new_neighborset11);
					tagN1811.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1811);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[17].neighbors[i];
					}
					tagN1812.Setneighborid(new_neighborset12);
					tagN1812.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1812);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[17].neighbors[i];
					}
					tagN1813.Setneighborid(new_neighborset13);
					tagN1813.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1813);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[17].neighbors[i];
					}
					tagN1814.Setneighborid(new_neighborset14);
					tagN1814.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1814);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[17].neighbors[i];
					}
					tagN1815.Setneighborid(new_neighborset15);
					tagN1815.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1815);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[17].neighbors[i];
					}
					tagN1816.Setneighborid(new_neighborset16);
					tagN1816.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1816);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[17].neighbors[i];
					}
					tagN1817.Setneighborid(new_neighborset17);
					tagN1817.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1817);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[17].neighbors[i];
					}
					tagN1818.Setneighborid(new_neighborset18);
					tagN1818.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1818);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[17].neighbors[i];
					}
					tagN1819.Setneighborid(new_neighborset19);
					tagN1819.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1819);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[17].neighbors[i];
					}
					tagN1820.Setneighborid(new_neighborset20);
					tagN1820.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1820);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[17].neighbors[i];
					}
					tagN1821.Setneighborid(new_neighborset21);
					tagN1821.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1821);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[17].neighbors[i];
					}
					tagN1822.Setneighborid(new_neighborset22);
					tagN1822.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1822);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[17].neighbors[i];
					}
					tagN1823.Setneighborid(new_neighborset23);
					tagN1823.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1823);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[17].neighbors[i];
					}
					tagN1824.Setneighborid(new_neighborset24);
					tagN1824.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1824);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[17].neighbors[i];
					}
					tagN1825.Setneighborid(new_neighborset25);
					tagN1825.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN1825);
					break;
				default:
					cout<<"ethernet:maximum datasize exceeded . size is  "<<nei_sizes[17]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[17])
						{
							new_neighborsetmax[i] = neighbor_set[17].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN18max.Setneighborid(new_neighborsetmax);
					tagN18max.Setnodeid(nodeid[17]);
					packet1->AddPacketTag(tagN18max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN191 tagN191;
		CustomMetaDataUnicastTagN192 tagN192;
		CustomMetaDataUnicastTagN193 tagN193;
		CustomMetaDataUnicastTagN194 tagN194;
		CustomMetaDataUnicastTagN195 tagN195;
		CustomMetaDataUnicastTagN196 tagN196;
		CustomMetaDataUnicastTagN197 tagN197;
		CustomMetaDataUnicastTagN198 tagN198;
		CustomMetaDataUnicastTagN199 tagN199;
		CustomMetaDataUnicastTagN1910 tagN1910;
		CustomMetaDataUnicastTagN1911 tagN1911;
		CustomMetaDataUnicastTagN1912 tagN1912;
		CustomMetaDataUnicastTagN1913 tagN1913;
		CustomMetaDataUnicastTagN1914 tagN1914;
		CustomMetaDataUnicastTagN1915 tagN1915;
		CustomMetaDataUnicastTagN1916 tagN1916;
		CustomMetaDataUnicastTagN1917 tagN1917;
		CustomMetaDataUnicastTagN1918 tagN1918;
		CustomMetaDataUnicastTagN1919 tagN1919;
		CustomMetaDataUnicastTagN1920 tagN1920;
		CustomMetaDataUnicastTagN1921 tagN1921;
		CustomMetaDataUnicastTagN1922 tagN1922;
		CustomMetaDataUnicastTagN1923 tagN1923;
		CustomMetaDataUnicastTagN1924 tagN1924;
		CustomMetaDataUnicastTagN1925 tagN1925;
		CustomMetaDataUnicastTagN19max tagN19max;
		
		if ((nei_sizes[18] > 0) and (neighbors_changed[18]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[18] = false;
			switch(nei_sizes[18])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[18].neighbors[0];
					tagN191.Setneighborid(new_neighborset1);
					tagN191.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN191);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[18].neighbors[i];
					}
					tagN192.Setneighborid(new_neighborset2);
					tagN192.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN192);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[18].neighbors[i];
					}
					tagN193.Setneighborid(new_neighborset3);
					tagN193.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN193);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[18].neighbors[i];
					}
					tagN194.Setneighborid(new_neighborset4);
					tagN194.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN194);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[18].neighbors[i];
					}
					tagN195.Setneighborid(new_neighborset5);
					tagN195.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN195);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[18].neighbors[i];
					}
					tagN196.Setneighborid(new_neighborset6);
					tagN196.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN196);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[18].neighbors[i];
					}
					tagN197.Setneighborid(new_neighborset7);
					tagN197.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN197);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[18].neighbors[i];
					}
					tagN198.Setneighborid(new_neighborset8);
					tagN198.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN198);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[18].neighbors[i];
					}
					tagN199.Setneighborid(new_neighborset9);
					tagN199.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN199);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[18].neighbors[i];
					}
					tagN1910.Setneighborid(new_neighborset10);
					tagN1910.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1910);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[18].neighbors[i];
					}
					tagN1911.Setneighborid(new_neighborset11);
					tagN1911.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1911);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[18].neighbors[i];
					}
					tagN1912.Setneighborid(new_neighborset12);
					tagN1912.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1912);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[18].neighbors[i];
					}
					tagN1913.Setneighborid(new_neighborset13);
					tagN1913.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1913);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[18].neighbors[i];
					}
					tagN1914.Setneighborid(new_neighborset14);
					tagN1914.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1914);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[18].neighbors[i];
					}
					tagN1915.Setneighborid(new_neighborset15);
					tagN1915.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1915);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[18].neighbors[i];
					}
					tagN1916.Setneighborid(new_neighborset16);
					tagN1916.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1916);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[18].neighbors[i];
					}
					tagN1917.Setneighborid(new_neighborset17);
					tagN1917.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1917);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[18].neighbors[i];
					}
					tagN1918.Setneighborid(new_neighborset18);
					tagN1918.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1918);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[18].neighbors[i];
					}
					tagN1919.Setneighborid(new_neighborset19);
					tagN1919.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1919);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[18].neighbors[i];
					}
					tagN1920.Setneighborid(new_neighborset20);
					tagN1920.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1920);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[18].neighbors[i];
					}
					tagN1921.Setneighborid(new_neighborset21);
					tagN1921.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1921);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[18].neighbors[i];
					}
					tagN1922.Setneighborid(new_neighborset22);
					tagN1922.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1922);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[18].neighbors[i];
					}
					tagN1923.Setneighborid(new_neighborset23);
					tagN1923.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1923);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[18].neighbors[i];
					}
					tagN1924.Setneighborid(new_neighborset24);
					tagN1924.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1924);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[18].neighbors[i];
					}
					tagN1925.Setneighborid(new_neighborset25);
					tagN1925.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN1925);
					break;
				default:
					cout<<"ethernet:maximum datasize exceeded . size is  "<<nei_sizes[18]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[18])
						{
							new_neighborsetmax[i] = neighbor_set[18].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN19max.Setneighborid(new_neighborsetmax);
					tagN19max.Setnodeid(nodeid[18]);
					packet1->AddPacketTag(tagN19max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN2001 tagN2001;
		CustomMetaDataUnicastTagN2002 tagN2002;
		CustomMetaDataUnicastTagN2003 tagN2003;
		CustomMetaDataUnicastTagN2004 tagN2004;
		CustomMetaDataUnicastTagN2005 tagN2005;
		CustomMetaDataUnicastTagN2006 tagN2006;
		CustomMetaDataUnicastTagN2007 tagN2007;
		CustomMetaDataUnicastTagN2008 tagN2008;
		CustomMetaDataUnicastTagN2009 tagN2009;
		CustomMetaDataUnicastTagN2010 tagN2010;
		CustomMetaDataUnicastTagN2011 tagN2011;
		CustomMetaDataUnicastTagN2012 tagN2012;
		CustomMetaDataUnicastTagN2013 tagN2013;
		CustomMetaDataUnicastTagN2014 tagN2014;
		CustomMetaDataUnicastTagN2015 tagN2015;
		CustomMetaDataUnicastTagN2016 tagN2016;
		CustomMetaDataUnicastTagN2017 tagN2017;
		CustomMetaDataUnicastTagN2018 tagN2018;
		CustomMetaDataUnicastTagN2019 tagN2019;
		CustomMetaDataUnicastTagN2020 tagN2020;
		CustomMetaDataUnicastTagN2021 tagN2021;
		CustomMetaDataUnicastTagN2022 tagN2022;
		CustomMetaDataUnicastTagN2023 tagN2023;
		CustomMetaDataUnicastTagN2024 tagN2024;
		CustomMetaDataUnicastTagN2025 tagN2025;
		CustomMetaDataUnicastTagN20max tagN20max;
		
		if ((nei_sizes[19] > 0) and (neighbors_changed[19]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[19] = false;
			switch(nei_sizes[19])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[19].neighbors[0];
					tagN2001.Setneighborid(new_neighborset1);
					tagN2001.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2001);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[19].neighbors[i];
					}
					tagN2002.Setneighborid(new_neighborset2);
					tagN2002.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2002);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[19].neighbors[i];
					}
					tagN2003.Setneighborid(new_neighborset3);
					tagN2003.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2003);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[19].neighbors[i];
					}
					tagN2004.Setneighborid(new_neighborset4);
					tagN2004.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2004);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[19].neighbors[i];
					}
					tagN2005.Setneighborid(new_neighborset5);
					tagN2005.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2005);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[19].neighbors[i];
					}
					tagN2006.Setneighborid(new_neighborset6);
					tagN2006.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2006);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[19].neighbors[i];
					}
					tagN2007.Setneighborid(new_neighborset7);
					tagN2007.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2007);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[19].neighbors[i];
					}
					tagN2008.Setneighborid(new_neighborset8);
					tagN2008.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2008);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[19].neighbors[i];
					}
					tagN2009.Setneighborid(new_neighborset9);
					tagN2009.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2009);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[19].neighbors[i];
					}
					tagN2010.Setneighborid(new_neighborset10);
					tagN2010.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2010);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[19].neighbors[i];
					}
					tagN2011.Setneighborid(new_neighborset11);
					tagN2011.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2011);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[19].neighbors[i];
					}
					tagN2012.Setneighborid(new_neighborset12);
					tagN2012.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2012);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[19].neighbors[i];
					}
					tagN2013.Setneighborid(new_neighborset13);
					tagN2013.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2013);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[19].neighbors[i];
					}
					tagN2014.Setneighborid(new_neighborset14);
					tagN2014.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2014);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[19].neighbors[i];
					}
					tagN2015.Setneighborid(new_neighborset15);
					tagN2015.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2015);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[19].neighbors[i];
					}
					tagN2016.Setneighborid(new_neighborset16);
					tagN2016.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2016);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[19].neighbors[i];
					}
					tagN2017.Setneighborid(new_neighborset17);
					tagN2017.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2017);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[19].neighbors[i];
					}
					tagN2018.Setneighborid(new_neighborset18);
					tagN2018.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2018);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[19].neighbors[i];
					}
					tagN2019.Setneighborid(new_neighborset19);
					tagN2019.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2019);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[19].neighbors[i];
					}
					tagN2020.Setneighborid(new_neighborset20);
					tagN2020.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2020);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[19].neighbors[i];
					}
					tagN2021.Setneighborid(new_neighborset21);
					tagN2021.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2021);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[19].neighbors[i];
					}
					tagN2022.Setneighborid(new_neighborset22);
					tagN2022.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2022);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[19].neighbors[i];
					}
					tagN2023.Setneighborid(new_neighborset23);
					tagN2023.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2023);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[19].neighbors[i];
					}
					tagN2024.Setneighborid(new_neighborset24);
					tagN2024.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2024);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[19].neighbors[i];
					}
					tagN2025.Setneighborid(new_neighborset25);
					tagN2025.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN2025);
					break;
				default:
					cout<<"ethernet:maximum datasize exceeded . size is  "<<nei_sizes[19]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[19])
						{
							new_neighborsetmax[i] = neighbor_set[19].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN20max.Setneighborid(new_neighborsetmax);
					tagN20max.Setnodeid(nodeid[19]);
					packet1->AddPacketTag(tagN20max);
					break;
			}
		
		}
		
		CustomMetaDataUnicastTagN2101 tagN2101;
		CustomMetaDataUnicastTagN2102 tagN2102;
		CustomMetaDataUnicastTagN2103 tagN2103;
		CustomMetaDataUnicastTagN2104 tagN2104;
		CustomMetaDataUnicastTagN2105 tagN2105;
		CustomMetaDataUnicastTagN2106 tagN2106;
		CustomMetaDataUnicastTagN2107 tagN2107;
		CustomMetaDataUnicastTagN2108 tagN2108;
		CustomMetaDataUnicastTagN2109 tagN2109;
		CustomMetaDataUnicastTagN2110 tagN2110;
		CustomMetaDataUnicastTagN2111 tagN2111;
		CustomMetaDataUnicastTagN2112 tagN2112;
		CustomMetaDataUnicastTagN2113 tagN2113;
		CustomMetaDataUnicastTagN2114 tagN2114;
		CustomMetaDataUnicastTagN2115 tagN2115;
		CustomMetaDataUnicastTagN2116 tagN2116;
		CustomMetaDataUnicastTagN2117 tagN2117;
		CustomMetaDataUnicastTagN2118 tagN2118;
		CustomMetaDataUnicastTagN2119 tagN2119;
		CustomMetaDataUnicastTagN2120 tagN2120;
		CustomMetaDataUnicastTagN2121 tagN2121;
		CustomMetaDataUnicastTagN2122 tagN2122;
		CustomMetaDataUnicastTagN2123 tagN2123;
		CustomMetaDataUnicastTagN2124 tagN2124;
		CustomMetaDataUnicastTagN2125 tagN2125;
		CustomMetaDataUnicastTagN21max tagN21max;
		
		if ((nei_sizes[20] > 0) and (neighbors_changed[20]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[20] = false;
			switch(nei_sizes[20])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[20].neighbors[0];
					tagN2101.Setneighborid(new_neighborset1);
					tagN2101.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2101);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[20].neighbors[i];
					}
					tagN2102.Setneighborid(new_neighborset2);
					tagN2102.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2102);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[20].neighbors[i];
					}
					tagN2103.Setneighborid(new_neighborset3);
					tagN2103.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2103);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[20].neighbors[i];
					}
					tagN2104.Setneighborid(new_neighborset4);
					tagN2104.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2104);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[20].neighbors[i];
					}
					tagN2105.Setneighborid(new_neighborset5);
					tagN2105.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2105);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[20].neighbors[i];
					}
					tagN2106.Setneighborid(new_neighborset6);
					tagN2106.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2106);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[20].neighbors[i];
					}
					tagN2107.Setneighborid(new_neighborset7);
					tagN2107.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2107);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[20].neighbors[i];
					}
					tagN2108.Setneighborid(new_neighborset8);
					tagN2108.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2108);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[20].neighbors[i];
					}
					tagN2109.Setneighborid(new_neighborset9);
					tagN2109.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2109);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[20].neighbors[i];
					}
					tagN2110.Setneighborid(new_neighborset10);
					tagN2110.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2110);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[20].neighbors[i];
					}
					tagN2111.Setneighborid(new_neighborset11);
					tagN2111.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2111);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[20].neighbors[i];
					}
					tagN2112.Setneighborid(new_neighborset12);
					tagN2112.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2112);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[20].neighbors[i];
					}
					tagN2113.Setneighborid(new_neighborset13);
					tagN2113.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2113);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[20].neighbors[i];
					}
					tagN2114.Setneighborid(new_neighborset14);
					tagN2114.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2114);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[20].neighbors[i];
					}
					tagN2115.Setneighborid(new_neighborset15);
					tagN2115.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2115);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[20].neighbors[i];
					}
					tagN2116.Setneighborid(new_neighborset16);
					tagN2116.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2116);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[20].neighbors[i];
					}
					tagN2117.Setneighborid(new_neighborset17);
					tagN2117.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2117);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[20].neighbors[i];
					}
					tagN2118.Setneighborid(new_neighborset18);
					tagN2118.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2118);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[20].neighbors[i];
					}
					tagN2119.Setneighborid(new_neighborset19);
					tagN2119.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2119);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[20].neighbors[i];
					}
					tagN2120.Setneighborid(new_neighborset20);
					tagN2120.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2120);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[20].neighbors[i];
					}
					tagN2121.Setneighborid(new_neighborset21);
					tagN2121.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2121);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[20].neighbors[i];
					}
					tagN2122.Setneighborid(new_neighborset22);
					tagN2122.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2122);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[20].neighbors[i];
					}
					tagN2123.Setneighborid(new_neighborset23);
					tagN2123.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2123);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[20].neighbors[i];
					}
					tagN2124.Setneighborid(new_neighborset24);
					tagN2124.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2124);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[20].neighbors[i];
					}
					tagN2125.Setneighborid(new_neighborset25);
					tagN2125.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN2125);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is "<<nei_sizes[20]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[20])
						{
							new_neighborsetmax[i] = neighbor_set[20].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN21max.Setneighborid(new_neighborsetmax);
					tagN21max.Setnodeid(nodeid[20]);
					packet1->AddPacketTag(tagN21max);
					break;
			}
		}
		
		CustomMetaDataUnicastTagN2201 tagN2201;
		CustomMetaDataUnicastTagN2202 tagN2202;
		CustomMetaDataUnicastTagN2203 tagN2203;
		CustomMetaDataUnicastTagN2204 tagN2204;
		CustomMetaDataUnicastTagN2205 tagN2205;
		CustomMetaDataUnicastTagN2206 tagN2206;
		CustomMetaDataUnicastTagN2207 tagN2207;
		CustomMetaDataUnicastTagN2208 tagN2208;
		CustomMetaDataUnicastTagN2209 tagN2209;
		CustomMetaDataUnicastTagN2210 tagN2210;
		CustomMetaDataUnicastTagN2211 tagN2211;
		CustomMetaDataUnicastTagN2212 tagN2212;
		CustomMetaDataUnicastTagN2213 tagN2213;
		CustomMetaDataUnicastTagN2214 tagN2214;
		CustomMetaDataUnicastTagN2215 tagN2215;
		CustomMetaDataUnicastTagN2216 tagN2216;
		CustomMetaDataUnicastTagN2217 tagN2217;
		CustomMetaDataUnicastTagN2218 tagN2218;
		CustomMetaDataUnicastTagN2219 tagN2219;
		CustomMetaDataUnicastTagN2220 tagN2220;
		CustomMetaDataUnicastTagN2221 tagN2221;
		CustomMetaDataUnicastTagN2222 tagN2222;
		CustomMetaDataUnicastTagN2223 tagN2223;
		CustomMetaDataUnicastTagN2224 tagN2224;
		CustomMetaDataUnicastTagN2225 tagN2225;
		CustomMetaDataUnicastTagN22max tagN22max;
		
		if ((nei_sizes[21] > 0) and (neighbors_changed[21]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[21] = false;
			switch(nei_sizes[21])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[21].neighbors[0];
					tagN2201.Setneighborid(new_neighborset1);
					tagN2201.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2201);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[21].neighbors[i];
					}
					tagN2202.Setneighborid(new_neighborset2);
					tagN2202.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2202);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[21].neighbors[i];
					}
					tagN2203.Setneighborid(new_neighborset3);
					tagN2203.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2203);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[21].neighbors[i];
					}
					tagN2204.Setneighborid(new_neighborset4);
					tagN2204.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2204);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[21].neighbors[i];
					}
					tagN2205.Setneighborid(new_neighborset5);
					tagN2205.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2205);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[21].neighbors[i];
					}
					tagN2206.Setneighborid(new_neighborset6);
					tagN2206.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2206);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[21].neighbors[i];
					}
					tagN2207.Setneighborid(new_neighborset7);
					tagN2207.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2207);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[21].neighbors[i];
					}
					tagN2208.Setneighborid(new_neighborset8);
					tagN2208.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2208);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[21].neighbors[i];
					}
					tagN2209.Setneighborid(new_neighborset9);
					tagN2209.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2209);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[21].neighbors[i];
					}
					tagN2210.Setneighborid(new_neighborset10);
					tagN2210.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2210);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[21].neighbors[i];
					}
					tagN2211.Setneighborid(new_neighborset11);
					tagN2211.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2211);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[21].neighbors[i];
					}
					tagN2212.Setneighborid(new_neighborset12);
					tagN2212.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2212);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[21].neighbors[i];
					}
					tagN2213.Setneighborid(new_neighborset13);
					tagN2213.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2213);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[21].neighbors[i];
					}
					tagN2214.Setneighborid(new_neighborset14);
					tagN2214.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2214);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[21].neighbors[i];
					}
					tagN2215.Setneighborid(new_neighborset15);
					tagN2215.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2215);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[21].neighbors[i];
					}
					tagN2216.Setneighborid(new_neighborset16);
					tagN2216.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2216);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[21].neighbors[i];
					}
					tagN2217.Setneighborid(new_neighborset17);
					tagN2217.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2217);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[21].neighbors[i];
					}
					tagN2218.Setneighborid(new_neighborset18);
					tagN2218.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2218);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[21].neighbors[i];
					}
					tagN2219.Setneighborid(new_neighborset19);
					tagN2219.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2219);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[21].neighbors[i];
					}
					tagN2220.Setneighborid(new_neighborset20);
					tagN2220.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2220);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[21].neighbors[i];
					}
					tagN2221.Setneighborid(new_neighborset21);
					tagN2221.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2221);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[21].neighbors[i];
					}
					tagN2222.Setneighborid(new_neighborset22);
					tagN2222.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2222);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[21].neighbors[i];
					}
					tagN2223.Setneighborid(new_neighborset23);
					tagN2223.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2223);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[21].neighbors[i];
					}
					tagN2224.Setneighborid(new_neighborset24);
					tagN2224.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2224);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[21].neighbors[i];
					}
					tagN2225.Setneighborid(new_neighborset25);
					tagN2225.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN2225);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is "<<nei_sizes[21]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[21])
						{
							new_neighborsetmax[i] = neighbor_set[21].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN22max.Setneighborid(new_neighborsetmax);
					tagN22max.Setnodeid(nodeid[21]);
					packet1->AddPacketTag(tagN22max);
					break;
			}
		}
		
		CustomMetaDataUnicastTagN2301 tagN2301;
		CustomMetaDataUnicastTagN2302 tagN2302;
		CustomMetaDataUnicastTagN2303 tagN2303;
		CustomMetaDataUnicastTagN2304 tagN2304;
		CustomMetaDataUnicastTagN2305 tagN2305;
		CustomMetaDataUnicastTagN2306 tagN2306;
		CustomMetaDataUnicastTagN2307 tagN2307;
		CustomMetaDataUnicastTagN2308 tagN2308;
		CustomMetaDataUnicastTagN2309 tagN2309;
		CustomMetaDataUnicastTagN2310 tagN2310;
		CustomMetaDataUnicastTagN2311 tagN2311;
		CustomMetaDataUnicastTagN2312 tagN2312;
		CustomMetaDataUnicastTagN2313 tagN2313;
		CustomMetaDataUnicastTagN2314 tagN2314;
		CustomMetaDataUnicastTagN2315 tagN2315;
		CustomMetaDataUnicastTagN2316 tagN2316;
		CustomMetaDataUnicastTagN2317 tagN2317;
		CustomMetaDataUnicastTagN2318 tagN2318;
		CustomMetaDataUnicastTagN2319 tagN2319;
		CustomMetaDataUnicastTagN2320 tagN2320;
		CustomMetaDataUnicastTagN2321 tagN2321;
		CustomMetaDataUnicastTagN2322 tagN2322;
		CustomMetaDataUnicastTagN2323 tagN2323;
		CustomMetaDataUnicastTagN2324 tagN2324;
		CustomMetaDataUnicastTagN2325 tagN2325;
		CustomMetaDataUnicastTagN23max tagN23max;
		
		if ((nei_sizes[22] > 0) and (neighbors_changed[22]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[22] = false;
			switch(nei_sizes[22])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[22].neighbors[0];
					tagN2301.Setneighborid(new_neighborset1);
					tagN2301.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2301);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[22].neighbors[i];
					}
					tagN2302.Setneighborid(new_neighborset2);
					tagN2302.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2302);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[22].neighbors[i];
					}
					tagN2303.Setneighborid(new_neighborset3);
					tagN2303.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2303);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[22].neighbors[i];
					}
					tagN2304.Setneighborid(new_neighborset4);
					tagN2304.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2304);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[22].neighbors[i];
					}
					tagN2305.Setneighborid(new_neighborset5);
					tagN2305.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2305);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[22].neighbors[i];
					}
					tagN2306.Setneighborid(new_neighborset6);
					tagN2306.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2306);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[22].neighbors[i];
					}
					tagN2307.Setneighborid(new_neighborset7);
					tagN2307.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2307);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[22].neighbors[i];
					}
					tagN2308.Setneighborid(new_neighborset8);
					tagN2308.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2308);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[22].neighbors[i];
					}
					tagN2309.Setneighborid(new_neighborset9);
					tagN2309.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2309);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[22].neighbors[i];
					}
					tagN2310.Setneighborid(new_neighborset10);
					tagN2310.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2310);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[22].neighbors[i];
					}
					tagN2311.Setneighborid(new_neighborset11);
					tagN2311.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2311);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[22].neighbors[i];
					}
					tagN2312.Setneighborid(new_neighborset12);
					tagN2312.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2312);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[22].neighbors[i];
					}
					tagN2313.Setneighborid(new_neighborset13);
					tagN2313.Setnodeid(nodeid[0]);
					packet1->AddPacketTag(tagN2313);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[0].neighbors[i];
					}
					tagN2314.Setneighborid(new_neighborset14);
					tagN2314.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2314);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[22].neighbors[i];
					}
					tagN2315.Setneighborid(new_neighborset15);
					tagN2315.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2315);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[22].neighbors[i];
					}
					tagN2316.Setneighborid(new_neighborset16);
					tagN2316.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2316);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[22].neighbors[i];
					}
					tagN2317.Setneighborid(new_neighborset17);
					tagN2317.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2317);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[22].neighbors[i];
					}
					tagN2318.Setneighborid(new_neighborset18);
					tagN2318.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2318);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[22].neighbors[i];
					}
					tagN2319.Setneighborid(new_neighborset19);
					tagN2319.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2319);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[22].neighbors[i];
					}
					tagN2320.Setneighborid(new_neighborset20);
					tagN2320.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2320);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[22].neighbors[i];
					}
					tagN2321.Setneighborid(new_neighborset21);
					tagN2321.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2321);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[22].neighbors[i];
					}
					tagN2322.Setneighborid(new_neighborset22);
					tagN2322.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2322);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[22].neighbors[i];
					}
					tagN2323.Setneighborid(new_neighborset23);
					tagN2323.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2323);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[22].neighbors[i];
					}
					tagN2324.Setneighborid(new_neighborset24);
					tagN2324.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2324);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[22].neighbors[i];
					}
					tagN2325.Setneighborid(new_neighborset25);
					tagN2325.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN2325);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is "<<nei_sizes[22]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[22])
						{
							new_neighborsetmax[i] = neighbor_set[22].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN23max.Setneighborid(new_neighborsetmax);
					tagN23max.Setnodeid(nodeid[22]);
					packet1->AddPacketTag(tagN23max);
					break;
			}
		}
		
		CustomMetaDataUnicastTagN2401 tagN2401;
		CustomMetaDataUnicastTagN2402 tagN2402;
		CustomMetaDataUnicastTagN2403 tagN2403;
		CustomMetaDataUnicastTagN2404 tagN2404;
		CustomMetaDataUnicastTagN2405 tagN2405;
		CustomMetaDataUnicastTagN2406 tagN2406;
		CustomMetaDataUnicastTagN2407 tagN2407;
		CustomMetaDataUnicastTagN2408 tagN2408;
		CustomMetaDataUnicastTagN2409 tagN2409;
		CustomMetaDataUnicastTagN2410 tagN2410;
		CustomMetaDataUnicastTagN2411 tagN2411;
		CustomMetaDataUnicastTagN2412 tagN2412;
		CustomMetaDataUnicastTagN2413 tagN2413;
		CustomMetaDataUnicastTagN2414 tagN2414;
		CustomMetaDataUnicastTagN2415 tagN2415;
		CustomMetaDataUnicastTagN2416 tagN2416;
		CustomMetaDataUnicastTagN2417 tagN2417;
		CustomMetaDataUnicastTagN2418 tagN2418;
		CustomMetaDataUnicastTagN2419 tagN2419;
		CustomMetaDataUnicastTagN2420 tagN2420;
		CustomMetaDataUnicastTagN2421 tagN2421;
		CustomMetaDataUnicastTagN2422 tagN2422;
		CustomMetaDataUnicastTagN2423 tagN2423;
		CustomMetaDataUnicastTagN2424 tagN2424;
		CustomMetaDataUnicastTagN2425 tagN2425;
		CustomMetaDataUnicastTagN24max tagN24max;
		
		if ((nei_sizes[23] > 0) and (neighbors_changed[23]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[23] = false;
			switch(nei_sizes[23])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[23].neighbors[0];
					tagN2401.Setneighborid(new_neighborset1);
					tagN2401.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2401);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[23].neighbors[i];
					}
					tagN2402.Setneighborid(new_neighborset2);
					tagN2402.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2402);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[23].neighbors[i];
					}
					tagN2403.Setneighborid(new_neighborset3);
					tagN2403.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2403);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[23].neighbors[i];
					}
					tagN2404.Setneighborid(new_neighborset4);
					tagN2404.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2404);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[23].neighbors[i];
					}
					tagN2405.Setneighborid(new_neighborset5);
					tagN2405.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2405);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[23].neighbors[i];
					}
					tagN2406.Setneighborid(new_neighborset6);
					tagN2406.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2406);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[23].neighbors[i];
					}
					tagN2407.Setneighborid(new_neighborset7);
					tagN2407.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2407);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[23].neighbors[i];
					}
					tagN2408.Setneighborid(new_neighborset8);
					tagN2408.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2408);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[23].neighbors[i];
					}
					tagN2409.Setneighborid(new_neighborset9);
					tagN2409.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2409);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[23].neighbors[i];
					}
					tagN2410.Setneighborid(new_neighborset10);
					tagN2410.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2410);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[23].neighbors[i];
					}
					tagN2411.Setneighborid(new_neighborset11);
					tagN2411.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2411);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[23].neighbors[i];
					}
					tagN2412.Setneighborid(new_neighborset12);
					tagN2412.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2412);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[23].neighbors[i];
					}
					tagN2413.Setneighborid(new_neighborset13);
					tagN2413.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2413);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[23].neighbors[i];
					}
					tagN2414.Setneighborid(new_neighborset14);
					tagN2414.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2414);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[23].neighbors[i];
					}
					tagN2415.Setneighborid(new_neighborset15);
					tagN2415.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2415);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[23].neighbors[i];
					}
					tagN2416.Setneighborid(new_neighborset16);
					tagN2416.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2416);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[23].neighbors[i];
					}
					tagN2417.Setneighborid(new_neighborset17);
					tagN2417.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2417);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[23].neighbors[i];
					}
					tagN2418.Setneighborid(new_neighborset18);
					tagN2418.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2418);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[23].neighbors[i];
					}
					tagN2419.Setneighborid(new_neighborset19);
					tagN2419.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2419);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[23].neighbors[i];
					}
					tagN2420.Setneighborid(new_neighborset20);
					tagN2420.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2420);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[23].neighbors[i];
					}
					tagN2421.Setneighborid(new_neighborset21);
					tagN2421.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2421);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[23].neighbors[i];
					}
					tagN2422.Setneighborid(new_neighborset22);
					tagN2422.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2422);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[23].neighbors[i];
					}
					tagN2423.Setneighborid(new_neighborset23);
					tagN2423.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2423);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[23].neighbors[i];
					}
					tagN2424.Setneighborid(new_neighborset24);
					tagN2424.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2424);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[23].neighbors[i];
					}
					tagN2425.Setneighborid(new_neighborset25);
					tagN2425.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN2425);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is "<<nei_sizes[23]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[23])
						{
							new_neighborsetmax[i] = neighbor_set[23].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN24max.Setneighborid(new_neighborsetmax);
					tagN24max.Setnodeid(nodeid[23]);
					packet1->AddPacketTag(tagN24max);
					break;
			}
		}
		
		CustomMetaDataUnicastTagN2501 tagN2501;
		CustomMetaDataUnicastTagN2502 tagN2502;
		CustomMetaDataUnicastTagN2503 tagN2503;
		CustomMetaDataUnicastTagN2504 tagN2504;
		CustomMetaDataUnicastTagN2505 tagN2505;
		CustomMetaDataUnicastTagN2506 tagN2506;
		CustomMetaDataUnicastTagN2507 tagN2507;
		CustomMetaDataUnicastTagN2508 tagN2508;
		CustomMetaDataUnicastTagN2509 tagN2509;
		CustomMetaDataUnicastTagN2510 tagN2510;
		CustomMetaDataUnicastTagN2511 tagN2511;
		CustomMetaDataUnicastTagN2512 tagN2512;
		CustomMetaDataUnicastTagN2513 tagN2513;
		CustomMetaDataUnicastTagN2514 tagN2514;
		CustomMetaDataUnicastTagN2515 tagN2515;
		CustomMetaDataUnicastTagN2516 tagN2516;
		CustomMetaDataUnicastTagN2517 tagN2517;
		CustomMetaDataUnicastTagN2518 tagN2518;
		CustomMetaDataUnicastTagN2519 tagN2519;
		CustomMetaDataUnicastTagN2520 tagN2520;
		CustomMetaDataUnicastTagN2521 tagN2521;
		CustomMetaDataUnicastTagN2522 tagN2522;
		CustomMetaDataUnicastTagN2523 tagN2523;
		CustomMetaDataUnicastTagN2524 tagN2524;
		CustomMetaDataUnicastTagN2525 tagN2525;
		CustomMetaDataUnicastTagN25max tagN25max;
		
		if ((nei_sizes[24] > 0) and (neighbors_changed[24]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[24] = false;
			switch(nei_sizes[24])
			{
				case (1):
					uint32_t new_neighborset1[1];
					new_neighborset1[0] = neighbor_set[24].neighbors[0];
					tagN2501.Setneighborid(new_neighborset1);
					tagN2501.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2501);
					break;
				case (2):
					uint32_t new_neighborset2[2];
					for(uint32_t i=0;i<2;i++)
					{
						new_neighborset2[i] = neighbor_set[24].neighbors[i];
					}
					tagN2502.Setneighborid(new_neighborset2);
					tagN2502.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2502);
					break;
				case (3):
					uint32_t new_neighborset3[3];
					for(uint32_t i=0;i<3;i++)
					{
						new_neighborset3[i] = neighbor_set[24].neighbors[i];
					}
					tagN2503.Setneighborid(new_neighborset3);
					tagN2503.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2503);
					break;
				case (4):
					uint32_t new_neighborset4[4];
					for(uint32_t i=0;i<4;i++)
					{
						new_neighborset4[i] = neighbor_set[24].neighbors[i];
					}
					tagN2504.Setneighborid(new_neighborset4);
					tagN2504.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2504);
					break;
				case (5):
					uint32_t new_neighborset5[5];
					for(uint32_t i=0;i<5;i++)
					{
						new_neighborset5[i] = neighbor_set[24].neighbors[i];
					}
					tagN2505.Setneighborid(new_neighborset5);
					tagN2505.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2505);
					break;
				case (6):
					uint32_t new_neighborset6[6];
					for(uint32_t i=0;i<6;i++)
					{
						new_neighborset6[i] = neighbor_set[24].neighbors[i];
					}
					tagN2506.Setneighborid(new_neighborset6);
					tagN2506.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2506);
					break;
				case (7):
					uint32_t new_neighborset7[7];
					for(uint32_t i=0;i<7;i++)
					{
						new_neighborset7[i] = neighbor_set[24].neighbors[i];
					}
					tagN2507.Setneighborid(new_neighborset7);
					tagN2507.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2507);
					break;
				case (8):
					uint32_t new_neighborset8[8];
					for(uint32_t i=0;i<8;i++)
					{
						new_neighborset8[i] = neighbor_set[24].neighbors[i];
					}
					tagN2508.Setneighborid(new_neighborset8);
					tagN2508.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2508);
					break;
				case (9):
					uint32_t new_neighborset9[9];
					for(uint32_t i=0;i<9;i++)
					{
						new_neighborset9[i] = neighbor_set[24].neighbors[i];
					}
					tagN2509.Setneighborid(new_neighborset9);
					tagN2509.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2509);
					break;
				case (10):
					uint32_t new_neighborset10[10];
					for(uint32_t i=0;i<10;i++)
					{
						new_neighborset10[i] = neighbor_set[24].neighbors[i];
					}
					tagN2510.Setneighborid(new_neighborset10);
					tagN2510.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2510);
					break;
				case (11):
					uint32_t new_neighborset11[11];
					for(uint32_t i=0;i<11;i++)
					{
						new_neighborset11[i] = neighbor_set[24].neighbors[i];
					}
					tagN2511.Setneighborid(new_neighborset11);
					tagN2511.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2511);
					break;
				case (12):
					uint32_t new_neighborset12[12];
					for(uint32_t i=0;i<12;i++)
					{
						new_neighborset12[i] = neighbor_set[24].neighbors[i];
					}
					tagN2512.Setneighborid(new_neighborset12);
					tagN2512.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2512);
					break;
				case (13):
					uint32_t new_neighborset13[13];
					for(uint32_t i=0;i<13;i++)
					{
						new_neighborset13[i] = neighbor_set[24].neighbors[i];
					}
					tagN2513.Setneighborid(new_neighborset13);
					tagN2513.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2513);
					break;
				case (14):
					uint32_t new_neighborset14[14];
					for(uint32_t i=0;i<14;i++)
					{
						new_neighborset14[i] = neighbor_set[24].neighbors[i];
					}
					tagN2514.Setneighborid(new_neighborset14);
					tagN2514.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2514);
					break;
				case (15):
					uint32_t new_neighborset15[15];
					for(uint32_t i=0;i<15;i++)
					{
						new_neighborset15[i] = neighbor_set[24].neighbors[i];
					}
					tagN2515.Setneighborid(new_neighborset15);
					tagN2515.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2515);
					break;
				case (16):
					uint32_t new_neighborset16[16];
					for(uint32_t i=0;i<16;i++)
					{
						new_neighborset16[i] = neighbor_set[24].neighbors[i];
					}
					tagN2516.Setneighborid(new_neighborset16);
					tagN2516.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2516);
					break;
				case (17):
					uint32_t new_neighborset17[17];
					for(uint32_t i=0;i<17;i++)
					{
						new_neighborset17[i] = neighbor_set[24].neighbors[i];
					}
					tagN2517.Setneighborid(new_neighborset17);
					tagN2517.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2517);
					break;
				case (18):
					uint32_t new_neighborset18[18];
					for(uint32_t i=0;i<18;i++)
					{
						new_neighborset18[i] = neighbor_set[24].neighbors[i];
					}
					tagN2518.Setneighborid(new_neighborset18);
					tagN2518.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2518);
					break;
				case (19):
					uint32_t new_neighborset19[19];
					for(uint32_t i=0;i<19;i++)
					{
						new_neighborset19[i] = neighbor_set[24].neighbors[i];
					}
					tagN2519.Setneighborid(new_neighborset19);
					tagN2519.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2519);
					break;
				case (20):
					uint32_t new_neighborset20[20];
					for(uint32_t i=0;i<20;i++)
					{
						new_neighborset20[i] = neighbor_set[24].neighbors[i];
					}
					tagN2520.Setneighborid(new_neighborset20);
					tagN2520.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2520);
					break;
				case (21):
					uint32_t new_neighborset21[21];
					for(uint32_t i=0;i<21;i++)
					{
						new_neighborset21[i] = neighbor_set[24].neighbors[i];
					}
					tagN2521.Setneighborid(new_neighborset21);
					tagN2521.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2521);
					break;
				case (22):
					uint32_t new_neighborset22[22];
					for(uint32_t i=0;i<22;i++)
					{
						new_neighborset22[i] = neighbor_set[24].neighbors[i];
					}
					tagN2522.Setneighborid(new_neighborset22);
					tagN2522.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2522);
					break;
				case (23):
					uint32_t new_neighborset23[23];
					for(uint32_t i=0;i<23;i++)
					{
						new_neighborset23[i] = neighbor_set[24].neighbors[i];
					}
					tagN2523.Setneighborid(new_neighborset23);
					tagN2523.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2523);
					break;
				case (24):
					uint32_t new_neighborset24[24];
					for(uint32_t i=0;i<24;i++)
					{
						new_neighborset24[i] = neighbor_set[24].neighbors[i];
					}
					tagN2524.Setneighborid(new_neighborset24);
					tagN2524.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2524);
					break;
				case (25):
					uint32_t new_neighborset25[25];
					for(uint32_t i=0;i<25;i++)
					{
						new_neighborset25[i] = neighbor_set[24].neighbors[i];
					}
					tagN2525.Setneighborid(new_neighborset25);
					tagN2525.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN2525);
					break;
				default:
					cout<<"Cellular:maximum datasize exceeded. size is "<<nei_sizes[24]<<endl;
					uint32_t new_neighborsetmax[max];
					for(uint32_t i=0;i<max;i++)
					{
						if(i<nei_sizes[24])
						{
							new_neighborsetmax[i] = neighbor_set[24].neighbors[i];
						}
						else
						{
							new_neighborsetmax[i] = large;
						}
					}
					tagN25max.Setneighborid(new_neighborsetmax);
					tagN25max.Setnodeid(nodeid[24]);
					packet1->AddPacketTag(tagN25max);
					break;
			}
		}
		
		CustomMetaDataUnicastTagN26max tagN26max;
		if ((nei_sizes[25] > 0) and (neighbors_changed[25]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[25] = false;
			cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[25]<<endl;
			uint32_t new_neighborsetmax[max];
			for(uint32_t i=0;i<max;i++)
			{
				if(i<nei_sizes[25])
				{
					new_neighborsetmax[i] = neighbor_set[25].neighbors[i];
				}
				else
				{
					new_neighborsetmax[i] = large;
				}
			}
			tagN26max.Setneighborid(new_neighborsetmax);
			tagN26max.Setnodeid(nodeid[25]);
			packet1->AddPacketTag(tagN26max);
		}
		
		CustomMetaDataUnicastTagN27max tagN27max;
		if ((nei_sizes[26] > 0) and (neighbors_changed[26]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[26] = false;
			cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[26]<<endl;
			uint32_t new_neighborsetmax[max];
			for(uint32_t i=0;i<max;i++)
			{
				if(i<nei_sizes[26])
				{
					new_neighborsetmax[i] = neighbor_set[26].neighbors[i];
				}
				else
				{
					new_neighborsetmax[i] = large;
				}
			}
			tagN27max.Setneighborid(new_neighborsetmax);
			tagN27max.Setnodeid(nodeid[26]);
			packet1->AddPacketTag(tagN27max);
		}
		
		CustomMetaDataUnicastTagN28max tagN28max;
		if ((nei_sizes[27] > 0) and (neighbors_changed[27]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[27] = false;
			cout<<"Ethernet:maximum neighbor datasize exceeded . size is  "<<nei_sizes[27]<<endl;
			uint32_t new_neighborsetmax[max];
			for(uint32_t i=0;i<max;i++)
			{
				if(i<nei_sizes[27])
				{
					new_neighborsetmax[i] = neighbor_set[27].neighbors[i];
				}
				else
				{
					new_neighborsetmax[i] = large;
				}
			}
			tagN28max.Setneighborid(new_neighborsetmax);
			tagN28max.Setnodeid(nodeid[27]);
			packet1->AddPacketTag(tagN28max);
		}
		
		CustomMetaDataUnicastTagN29max tagN29max;
		if ((nei_sizes[28] > 0) and (neighbors_changed[28]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[28] = false;
			cout<<"Ethernet :maximum neighbor datasize exceeded . size is  "<<nei_sizes[28]<<endl;
			uint32_t new_neighborsetmax[max];
			for(uint32_t i=0;i<max;i++)
			{
				if(i<nei_sizes[28])
				{
					new_neighborsetmax[i] = neighbor_set[28].neighbors[i];
				}
				else
				{
					new_neighborsetmax[i] = large;
				}
			}
			tagN29max.Setneighborid(new_neighborsetmax);
			tagN29max.Setnodeid(nodeid[28]);
			packet1->AddPacketTag(tagN29max);
		}
		
		CustomMetaDataUnicastTagN30max tagN30max;
		if ((nei_sizes[29] > 0) and (neighbors_changed[29]==true))
		{
			(data_at_nodes_inst+nid)->neighbors_changed[29] = false;
			cout<<"Ethernet :maximum neighbor datasize exceeded. size is  "<<nei_sizes[29]<<endl;
			uint32_t new_neighborsetmax[max];
			for(uint32_t i=0;i<max;i++)
			{
				if(i<nei_sizes[29])
				{
					new_neighborsetmax[i] = neighbor_set[29].neighbors[i];
				}
				else
				{
					new_neighborsetmax[i] = large;
				}
			}
			tagN30max.Setneighborid(new_neighborsetmax);
			tagN30max.Setnodeid(nodeid[29]);
			packet1->AddPacketTag(tagN30max);
		}
		
		
		CustomDataUnicastTag1 tag1;
		CustomDataUnicastTag2 tag2;
		CustomDataUnicastTag3 tag3;
		CustomDataUnicastTag4 tag4;
		CustomDataUnicastTag5 tag5;
		CustomDataUnicastTag6 tag6;
		CustomDataUnicastTag7 tag7;
		CustomDataUnicastTag8 tag8;
		CustomDataUnicastTag9 tag9;
		CustomDataUnicastTag10 tag10;
		CustomDataUnicastTag11 tag11;
		CustomDataUnicastTag12 tag12;
		CustomDataUnicastTag13 tag13;
		CustomDataUnicastTag14 tag14;
		CustomDataUnicastTag15 tag15;
		CustomDataUnicastTag16 tag16;
		CustomDataUnicastTag17 tag17;
		CustomDataUnicastTag18 tag18;
		CustomDataUnicastTag19 tag19;
		CustomDataUnicastTag20 tag20;
		CustomDataUnicastTag21 tag21;
		CustomDataUnicastTag22 tag22;
		CustomDataUnicastTag23 tag23;
		CustomDataUnicastTag24 tag24;
		CustomDataUnicastTag25 tag25;
		CustomDataUnicastTag tag;
		switch (size)
		{	
			case 1:
				tag1.SetsenderId(nid);
				tag1.SetNodeId(nodeid);
				tag1.Setposition(position);
				tag1.Setvelocity(velocity);
				tag1.Setacceleration(acceleration);
				tag1.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag1);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 2:
				tag2.SetsenderId(nid);
				tag2.SetNodeId(nodeid);
				tag2.Setposition(position);
				tag2.Setvelocity(velocity);
				tag2.Setacceleration(acceleration);
				tag2.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag2);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 3:
				tag3.SetsenderId(nid);
				tag3.SetNodeId(nodeid);
				tag3.Setposition(position);
				tag3.Setvelocity(velocity);
				tag3.Setacceleration(acceleration);
				tag3.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag3);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 4:
				tag4.SetsenderId(nid);
				tag4.SetNodeId(nodeid);
				tag4.Setposition(position);
				tag4.Setvelocity(velocity);
				tag4.Setacceleration(acceleration);
				tag4.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag4);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 5:
				tag5.SetsenderId(nid);
				tag5.SetNodeId(nodeid);
				tag5.Setposition(position);
				tag5.Setvelocity(velocity);
				tag5.Setacceleration(acceleration);
				tag5.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag5);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 6:
				tag6.SetsenderId(nid);
				tag6.SetNodeId(nodeid);
				tag6.Setposition(position);
				tag6.Setvelocity(velocity);
				tag6.Setacceleration(acceleration);
				tag6.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag6);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 7:
				tag7.SetsenderId(nid);
				tag7.SetNodeId(nodeid);
				tag7.Setposition(position);
				tag7.Setvelocity(velocity);
				tag7.Setacceleration(acceleration);
				tag7.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag7);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 8:
				tag8.SetsenderId(nid);
				tag8.SetNodeId(nodeid);
				tag8.Setposition(position);
				tag8.Setvelocity(velocity);
				tag8.Setacceleration(acceleration);
				tag8.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag8);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 9:
				tag9.SetsenderId(nid);
				tag9.SetNodeId(nodeid);
				tag9.Setposition(position);
				tag9.Setvelocity(velocity);
				tag9.Setacceleration(acceleration);
				tag9.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag9);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			
			case 10:
				tag10.SetsenderId(nid);
				tag10.SetNodeId(nodeid);
				tag10.Setposition(position);
				tag10.Setvelocity(velocity);
				tag10.Setacceleration(acceleration);
				tag10.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag10);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 11:
				tag11.SetsenderId(nid);
				tag11.SetNodeId(nodeid);
				tag11.Setposition(position);
				tag11.Setvelocity(velocity);
				tag11.Setacceleration(acceleration);
				tag11.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag11);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 12:
				tag12.SetsenderId(nid);
				tag12.SetNodeId(nodeid);
				tag12.Setposition(position);
				tag12.Setvelocity(velocity);
				tag12.Setacceleration(acceleration);
				tag12.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag12);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 13:
				tag13.SetsenderId(nid);
				tag13.SetNodeId(nodeid);
				tag13.Setposition(position);
				tag13.Setvelocity(velocity);
				tag13.Setacceleration(acceleration);
				tag13.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag13);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;	
			case 14:
				tag14.SetsenderId(nid);
				tag14.SetNodeId(nodeid);
				tag14.Setposition(position);
				tag14.Setvelocity(velocity);
				tag14.Setacceleration(acceleration);
				tag14.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag14);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 15:
				tag15.SetsenderId(nid);
				tag15.SetNodeId(nodeid);
				tag15.Setposition(position);
				tag15.Setvelocity(velocity);
				tag15.Setacceleration(acceleration);
				tag15.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag15);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 16:
				tag16.SetsenderId(nid);
				tag16.SetNodeId(nodeid);
				tag16.Setposition(position);
				tag16.Setvelocity(velocity);
				tag16.Setacceleration(acceleration);
				tag16.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag16);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 17:
				tag17.SetsenderId(nid);
				tag17.SetNodeId(nodeid);
				tag17.Setposition(position);
				tag17.Setvelocity(velocity);
				tag17.Setacceleration(acceleration);
				tag17.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag17);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 18:
				tag18.SetsenderId(nid);
				tag18.SetNodeId(nodeid);
				tag18.Setposition(position);
				tag18.Setvelocity(velocity);
				tag18.Setacceleration(acceleration);
				tag18.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag18);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 19:
				tag19.SetsenderId(nid);
				tag19.SetNodeId(nodeid);
				tag19.Setposition(position);
				tag19.Setvelocity(velocity);
				tag19.Setacceleration(acceleration);
				tag19.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag19);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 20:
				tag20.SetsenderId(nid);
				tag20.SetNodeId(nodeid);
				tag20.Setposition(position);
				tag20.Setvelocity(velocity);
				tag20.Setacceleration(acceleration);
				tag20.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag20);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 21:
				tag21.SetsenderId(nid);
				tag21.SetNodeId(nodeid);
				tag21.Setposition(position);
				tag21.Setvelocity(velocity);
				tag21.Setacceleration(acceleration);
				tag21.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag21);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 22:
				tag22.SetsenderId(nid);
				tag22.SetNodeId(nodeid);
				tag22.Setposition(position);
				tag22.Setvelocity(velocity);
				tag22.Setacceleration(acceleration);
				tag22.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag22);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 23:
				tag23.SetsenderId(nid);
				tag23.SetNodeId(nodeid);
				tag23.Setposition(position);
				tag23.Setvelocity(velocity);
				tag23.Setacceleration(acceleration);
				tag23.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag23);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 24:
				tag24.SetsenderId(nid);
				tag24.SetNodeId(nodeid);
				tag24.Setposition(position);
				tag24.Setvelocity(velocity);
				tag24.Setacceleration(acceleration);
				tag24.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag24);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			case 25:
				tag25.SetsenderId(nid);
				tag25.SetNodeId(nodeid);
				tag25.Setposition(position);
				tag25.Setvelocity(velocity);
				tag25.Setacceleration(acceleration);
				tag25.SetTimestamp(timestamp);
				packet1->AddPacketTag(tag25);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;
			default:
				cout<<"Ethernet :maximum status datasize exceeded . size is  "<<size<<endl;
				tag.SetsenderId(nid);
				tag.SetNodeId((data_at_nodes_inst+nid)->nodeid);
				tag.Setposition((data_at_nodes_inst+nid)->position);
				tag.Setvelocity((data_at_nodes_inst+nid)->velocity);
				tag.Setacceleration((data_at_nodes_inst+nid)->acceleration);
				tag.SetTimestamp((data_at_nodes_inst+nid)->timestamp);
				packet1->AddPacketTag(tag);
				ethernet_total_packet_size = ethernet_total_packet_size + packet1->GetSerializedSize();
				Simulator::Schedule(Seconds(0),&SimpleUdpApplication::SendPacket,udp_app,packet1,dest_ip,7777);
				break;	
		}
		cout<<"RSU total packet size is "<<ethernet_total_packet_size<<endl;

	}
}



void begin_sending_RSU_data_agent()
{
	list<uint32_t> agent_ids;
 	for (uint32_t i=(N_Vehicles+2);i<(total_size+2);i++)
 	{
 		if(X_nodes[i] == 1)
 		{
 			agent_ids.push_back(i);
 		}
 	}
 	int count = 0;
	for (auto it=agent_ids.begin(); it!=agent_ids.end(); ++it)
	{
		uint32_t u = *it;
		//cout<<"agent u is "<<u<<endl;
	  	Ptr <Node> nu = DynamicCast <Node> (RSU_Nodes.Get(u-N_Vehicles-2));	
	  	Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (RSU_apps.Get(u-N_Vehicles-2));
		Simulator::Schedule(Seconds(0.000050*count),RSU_dataunicast_agent, udp_app, nu, management_Node.Get(0));
		count++;
	}
}

void print_time()
{
	cout<<"current time is "<<Simulator::Now().GetSeconds()<<endl;
}

double inv_factorial(long int n)
{
	if(n>1)
	{
		return (1.0/n)*(inv_factorial(n-1));
	}
	
	else
	{
		return 1.0;
	}
}


bool GetBooleanWithProbability(double percent) {
    return ((double) rand() / RAND_MAX) < (percent / 100.0);
}

Ptr<Node> getControllerNode(int idx) {
    return controller_Node.Get(idx);
}


void declare_attackers() {
    // For nodes
    if (present_wormhole_attack_nodes) {
        for (int i = 0; i < total_size; ++i) {
            bool attacking_state = GetBooleanWithProbability(attack_percentage);
            wormhole_malicious_nodes[i] = attacking_state;
            // Optionally print
            // std::cout << "Node " << i << " wormhole state: " << attacking_state << std::endl;
        }
    }
    if (present_blackhole_attack_nodes) {
        for (int i = 0; i < total_size; ++i) {
            bool attacking_state = GetBooleanWithProbability(attack_percentage);
            blackhole_malicious_nodes[i] = attacking_state;
            // Optionally print
            // std::cout << "Node " << i << " blackhole state: " << attacking_state << std::endl;
        }
    }

    if (present_reply_attack_nodes) {
        for (int i = 0; i < total_size; ++i) {
            bool attacking_state = GetBooleanWithProbability(attack_percentage);
            reply_malicious_nodes[i] = attacking_state;
            // Optionally print
            // std::cout << "Node " << i << " replay state: " << attacking_state << std::endl;
        }
        }
    

    // For controllers
    if (present_wormhole_attack_controllers) {
        for (int i = 0; i < controllers; ++i) {
            bool attacking_state = GetBooleanWithProbability(attack_percentage);
            wormhole_malicious_controllers[i] = attacking_state;
            // std::cout << "Controller " << i << " wormhole state: " << attacking_state << std::endl;
        }
    }
	    if (present_blackhole_attack_controllers) {
        for (int i = 0; i < controllers; ++i) {
            bool attacking_state = GetBooleanWithProbability(attack_percentage);
            blackhole_malicious_controllers[i] = attacking_state;
            // std::cout << "Controller " << i << " blackhole state: " << attacking_state << std::endl;
        }
    }

    if (present_reply_attack_controllers) {
        for (int i = 0; i < controllers; ++i) {
            bool attacking_state = GetBooleanWithProbability(attack_percentage);
            reply_malicious_controllers[i] = attacking_state;
            // std::cout << "Controller " << i << " replay state: " << attacking_state << std::endl;
        }
    }




}


void setup_wormhole_tunnels(AnimationInterface& anim) {
    // Collect malicious node indices
    std::vector<int> wormhole_nodes;
    for (int i = 0; i < total_size; ++i) {
        if (wormhole_malicious_nodes[i]) wormhole_nodes.push_back(i);
    }
    // Add controller indices (e.g., 0 to controllers-1) if malicious
    std::vector<int> wormhole_ctrls;
    for (int i = 0; i < controllers; ++i) {
        if (wormhole_malicious_controllers[i]) wormhole_ctrls.push_back(i);
    }

    // Optionally combine node and controller indices
    std::vector<int> wormhole_participants = wormhole_nodes;
    for (int ctrl : wormhole_ctrls) wormhole_participants.push_back(total_size + ctrl); // assume controller nodes follow normal nodes

    // Pair them for wormholes
    for (size_t idx = 0; idx + 1 < wormhole_participants.size(); idx += 2) {
        int nodeA_idx = wormhole_participants[idx];
        int nodeB_idx = wormhole_participants[idx+1];

        Ptr<Node> nodeA = nullptr;
        Ptr<Node> nodeB = nullptr;
        if (nodeA_idx < total_size)
            nodeA = ns3::NodeList::GetNode(nodeA_idx);
        else
            nodeA = controller_Node.Get(nodeA_idx - total_size); // adjust index for controllers

        if (nodeB_idx < total_size)
            nodeB = ns3::NodeList::GetNode(nodeB_idx);
        else
            nodeB = controller_Node.Get(nodeB_idx - total_size);

        // Create fast wormhole link
        PointToPointHelper wormholeLink;
        wormholeLink.SetDeviceAttribute("DataRate", StringValue("1000Mbps"));
        wormholeLink.SetChannelAttribute("Delay", TimeValue(MicroSeconds(1))); // Very fast, simulates tunnel

        NetDeviceContainer wormholeDevices = wormholeLink.Install(nodeA, nodeB);

        // Assign IP addresses for wormhole link
        Ipv4AddressHelper wormholeAddress;
        std::string base = "100." + std::to_string(idx) + ".0.0";
        wormholeAddress.SetBase(base.c_str(), "255.255.255.0");
        Ipv4InterfaceContainer wormholeInterfaces = wormholeAddress.Assign(wormholeDevices);

        // Visualize malicious nodes in animation
        anim.UpdateNodeColor(nodeA, 255, 0, 0); // Red
        anim.UpdateNodeColor(nodeB, 255, 0, 0); // Red
    }
}


class BlackholeApp : public Application {
public:
    BlackholeApp() {}
    virtual ~BlackholeApp() {}

protected:
    virtual void StartApplication() override {
        // Listen for packets on all devices and drop them (do nothing)
        for (uint32_t i = 0; i < GetNode()->GetNDevices(); ++i) {
            Ptr<NetDevice> dev = GetNode()->GetDevice(i);
            dev->SetReceiveCallback(MakeCallback(&BlackholeApp::DropPacket, this));
        }
    }

    bool DropPacket(Ptr<NetDevice> device, Ptr<const Packet> packet, uint16_t protocol, const Address &from) {
        // Do nothing -- drop all received packets
        return true;
    }
};

// ---- Blackhole Attack Setup Function ----
void setup_blackhole_attack(
    const std::vector<bool>& blackhole_malicious_nodes, 
    int total_size, 
    double simTime, 
    AnimationInterface& anim,
    const std::vector<bool>& blackhole_malicious_controllers = {},
    int controllers = 0,
    Ptr<Node> (*getControllerNode)(int) = nullptr
) {
    // Mark malicious nodes
    for (int i = 0; i < total_size; ++i) {
        if (blackhole_malicious_nodes[i]) {
            Ptr<Node> node = ns3::NodeList::GetNode(i);
            Ptr<BlackholeApp> app = CreateObject<BlackholeApp>();
            node->AddApplication(app);
            app->SetStartTime(Seconds(0.0));
            app->SetStopTime(Seconds(simTime));
            // Optionally color malicious nodes in animation
            anim.UpdateNodeColor(node, 0, 0, 0); // Black
        }
    }
    // Mark malicious controllers if provided
    if (controllers > 0 && getControllerNode != nullptr && !blackhole_malicious_controllers.empty()) {
        for (int i = 0; i < controllers; ++i) {
            if (blackhole_malicious_controllers[i]) {
                Ptr<Node> node = getControllerNode(i);
                Ptr<BlackholeApp> app = CreateObject<BlackholeApp>();
                node->AddApplication(app);
                app->SetStartTime(Seconds(0.0));
                app->SetStopTime(Seconds(simTime));
                // Optionally color malicious controllers in animation
                anim.UpdateNodeColor(node, 0, 0, 0); // Black
            }
        }
    }
}

class ReplayApp : public Application {
public:
    ReplayApp() {}
    virtual ~ReplayApp() {}

    void Setup(double replayDelay = 1.0) { m_replayDelay = replayDelay; }

protected:
    virtual void StartApplication() override {
        for (uint32_t i = 0; i < GetNode()->GetNDevices(); ++i) {
            Ptr<NetDevice> dev = GetNode()->GetDevice(i);
            dev->SetReceiveCallback(MakeCallback(&ReplayApp::ReceivePacket, this));
        }
    }

    bool ReceivePacket(Ptr<NetDevice> device, Ptr<const Packet> packet, uint16_t protocol, const Address &from) {
        // Store a copy and schedule replay
        Ptr<Packet> copy = packet->Copy();
        Simulator::Schedule(Seconds(m_replayDelay), &ReplayApp::ReplayPacket, this, device, copy, protocol, from);
        return false; // allow normal processing too
    }

    void ReplayPacket(Ptr<NetDevice> device, Ptr<Packet> packet, uint16_t protocol, Address from) {
        // Replay to all devices except the receiving one
        for (uint32_t i = 0; i < GetNode()->GetNDevices(); ++i) {
            Ptr<NetDevice> dev = GetNode()->GetDevice(i);
            if (dev != device) {
                dev->Send(packet->Copy(), from, protocol);
            }
        }
    }

    double m_replayDelay = 1.0; // seconds
};

// ---- Replay Attack Setup Function ----
void setup_replay_attack(
    const std::vector<bool>& replay_malicious_nodes, 
    int total_size, 
    double simTime, 
    AnimationInterface& anim,
    const std::vector<bool>& replay_malicious_controllers = {},
    int controllers = 0,
    Ptr<Node> (*getControllerNode)(int) = nullptr,
    double replayDelay = 1.0
) {
    // Mark malicious nodes
    for (int i = 0; i < total_size; ++i) {
        if (replay_malicious_nodes[i]) {
            Ptr<Node> node = ns3::NodeList::GetNode(i);
            Ptr<ReplayApp> app = CreateObject<ReplayApp>();
            app->Setup(replayDelay);
            node->AddApplication(app);
            app->SetStartTime(Seconds(0.0));
            app->SetStopTime(Seconds(simTime));
            anim.UpdateNodeColor(node, 255, 128, 0); // Orange for replay attack
        }
    }
    // Mark malicious controllers if provided
    if (controllers > 0 && getControllerNode != nullptr && !replay_malicious_controllers.empty()) {
        for (int i = 0; i < controllers; ++i) {
            if (replay_malicious_controllers[i]) {
                Ptr<Node> node = getControllerNode(i);
                Ptr<ReplayApp> app = CreateObject<ReplayApp>();
                app->Setup(replayDelay);
                node->AddApplication(app);
                app->SetStartTime(Seconds(0.0));
                app->SetStopTime(Seconds(simTime));
                anim.UpdateNodeColor(node, 255, 128, 0); // Orange
            }
        }
    }
}



class SybilApp : public Application {
public:
    SybilApp() {}
    virtual ~SybilApp() {}

    void Setup(int sybilIdentities = 2) { m_sybilIdentities = sybilIdentities; }

protected:
    virtual void StartApplication() override {
        // Log to indicate activation of Sybil attack
        NS_LOG_UNCOND("Sybil attack started at node " << GetNode()->GetId() << " with " << m_sybilIdentities << " identities.");
        

    }

    int m_sybilIdentities = 2; // Number of fake identities
};

// ---- Sybil Attack Setup Function ----
void setup_sybil_attack(
    const std::vector<bool>& sybil_malicious_nodes, 
    int total_size, 
    double simTime, 
    AnimationInterface& anim,
    const std::vector<bool>& sybil_malicious_controllers = {},
    int controllers = 0,
    Ptr<Node> (*getControllerNode)(int) = nullptr,
    int sybilIdentities = 2
) {
    // Mark sybil malicious nodes
    for (int i = 0; i < total_size; ++i) {
        if (sybil_malicious_nodes[i]) {
            Ptr<Node> node = ns3::NodeList::GetNode(i);
            Ptr<SybilApp> app = CreateObject<SybilApp>();
            app->Setup(sybilIdentities);
            node->AddApplication(app);
            app->SetStartTime(Seconds(0.0));
            app->SetStopTime(Seconds(simTime));
            anim.UpdateNodeColor(node, 128, 0, 255); // Purple for Sybil attack
        }
    }
    // Mark sybil malicious controllers if provided
    if (controllers > 0 && getControllerNode != nullptr && !sybil_malicious_controllers.empty()) {
        for (int i = 0; i < controllers; ++i) {
            if (sybil_malicious_controllers[i]) {
                Ptr<Node> node = getControllerNode(i);
                Ptr<SybilApp> app = CreateObject<SybilApp>();
                app->Setup(sybilIdentities);
                node->AddApplication(app);
                app->SetStartTime(Seconds(0.0));
                app->SetStopTime(Seconds(simTime));
                anim.UpdateNodeColor(node, 128, 0, 255); // Purple
            }
        }
    }
}

class RoutingTablePoisoningApp : public Application {
public:
    RoutingTablePoisoningApp() {}
    virtual ~RoutingTablePoisoningApp() {}

    void Setup(Ipv4Address bogusDest = Ipv4Address("99.99.99.0"), Ipv4Mask bogusMask = Ipv4Mask("255.255.255.0"), uint32_t bogusInterface = 1) {
        m_bogusDest = bogusDest;
        m_bogusMask = bogusMask;
        m_bogusInterface = bogusInterface;
    }

protected:
    virtual void StartApplication() override {
        Ptr<Ipv4> ipv4 = GetNode()->GetObject<Ipv4>();
        Ipv4StaticRoutingHelper helper;
        Ptr<Ipv4StaticRouting> staticRouting = helper.GetStaticRouting(ipv4);

        // Poison the routing table: add bogus route
        staticRouting->AddNetworkRouteTo(m_bogusDest, m_bogusMask, m_bogusInterface);
        NS_LOG_UNCOND("RoutingTablePoisoningApp: Node " << GetNode()->GetId() << " added poisoned route to " << m_bogusDest);
    }

    Ipv4Address m_bogusDest;
    Ipv4Mask m_bogusMask;
    uint32_t m_bogusInterface;
};

// ---- Routing Table Poisoning Attack Setup Function ----
void setup_routing_table_poisoning_attack(
    const std::vector<bool>& poisoning_malicious_nodes,
    int total_size,
    double simTime,
    AnimationInterface& anim,
    const std::vector<bool>& poisoning_malicious_controllers = {},
    int controllers = 0,
    Ptr<Node> (*getControllerNode)(int) = nullptr,
    Ipv4Address bogusDest = Ipv4Address("99.99.99.0"),
    Ipv4Mask bogusMask = Ipv4Mask("255.255.255.0"),
    uint32_t bogusInterface = 1
) {
    // Mark malicious nodes
    for (int i = 0; i < total_size; ++i) {
        if (poisoning_malicious_nodes[i]) {
            Ptr<Node> node = ns3::NodeList::GetNode(i);
            Ptr<RoutingTablePoisoningApp> app = CreateObject<RoutingTablePoisoningApp>();
            app->Setup(bogusDest, bogusMask, bogusInterface);
            node->AddApplication(app);
            app->SetStartTime(Seconds(0.0));
            app->SetStopTime(Seconds(simTime));
            anim.UpdateNodeColor(node, 255, 0, 128); // Pink for poisoning
        }
    }
    // Mark malicious controllers if provided
    if (controllers > 0 && getControllerNode != nullptr && !poisoning_malicious_controllers.empty()) {
        for (int i = 0; i < controllers; ++i) {
            if (poisoning_malicious_controllers[i]) {
                Ptr<Node> node = getControllerNode(i);
                Ptr<RoutingTablePoisoningApp> app = CreateObject<RoutingTablePoisoningApp>();
                app->Setup(bogusDest, bogusMask, bogusInterface);
                node->AddApplication(app);
                app->SetStartTime(Seconds(0.0));
                app->SetStopTime(Seconds(simTime));
                anim.UpdateNodeColor(node, 255, 0, 128); // Pink
            }
        }
    }
}

int main(int argc, char *argv[])
{        
    initialize_empty();
    nodeid_sum();   
    
    CommandLine cmd;
    cmd.AddValue ("N_RSUs", "N_RSUs", N_RSUs);
    cmd.AddValue ("N_Vehicles", "N_Vehicles", N_Vehicles);
    cmd.AddValue ("data_transmission_frequency", "data_transmission_frequency", data_transmission_frequency);
    cmd.AddValue ("link_lifetime_threshold", "link_lifetime_threshold", link_lifetime_threshold);
    cmd.AddValue ("simTime", "simTime", simTime);
    cmd.AddValue ("mobility_scenario", "mobility_scenario", mobility_scenario);
    cmd.AddValue ("architecture", "architecture", architecture);
    cmd.AddValue ("maxspeed", "maxspeed", maxspeed);
    cmd.AddValue ("lambda", "lambda", lambda);
    cmd.AddValue ("experiment_number", "experiment_number", experiment_number);
    cmd.AddValue ("routing_test", "routing_test", routing_test);
    cmd.AddValue ("routing_algorithm", "routing_algorithm", routing_algorithm);
    cmd.AddValue ("qf", "qf", qf);
    
    // Enhanced Wormhole Attack Parameters
    cmd.AddValue ("use_enhanced_wormhole", "Use enhanced wormhole implementation", use_enhanced_wormhole);
    cmd.AddValue ("attack_percentage", "Percentage of attacking nodes", attack_percentage);
    cmd.AddValue ("wormhole_bandwidth", "Wormhole tunnel bandwidth", wormhole_tunnel_bandwidth);
    cmd.AddValue ("wormhole_delay_us", "Wormhole tunnel delay (microseconds)", wormhole_tunnel_delay_us);
    cmd.AddValue ("wormhole_random_pairing", "Random pairing of wormhole nodes", wormhole_random_pairing);
    cmd.AddValue ("wormhole_drop_packets", "Drop packets instead of tunneling", wormhole_drop_packets);
	cmd.AddValue ("wormhole_tunnel_routing", "Tunnel routing protocol packets", wormhole_tunnel_routing);
	cmd.AddValue ("wormhole_tunnel_data", "Tunnel data packets", wormhole_tunnel_data);
	cmd.AddValue ("wormhole_start_time", "Wormhole attack start time (seconds)", wormhole_start_time);
	cmd.AddValue ("wormhole_stop_time", "Wormhole attack stop time (seconds, 0=simTime)", wormhole_stop_time);
	cmd.AddValue ("wormhole_enable_verification_flows", "Enable background verification traffic for wormhole attack", wormhole_enable_verification_flows);
	cmd.AddValue ("wormhole_verification_flow_count", "Number of verification flow pairs to install", wormhole_verification_flow_count);
	cmd.AddValue ("wormhole_verification_packet_rate", "Packets per second per verification flow", wormhole_verification_packet_rate);
	cmd.AddValue ("wormhole_verification_packet_size", "Verification flow packet size (bytes)", wormhole_verification_packet_size);
	cmd.AddValue ("wormhole_verification_start_offset", "Seconds after attack start before verification flows begin", wormhole_verification_start_offset);
	cmd.AddValue ("wormhole_verification_base_port", "Base UDP destination port for verification flows", wormhole_verification_base_port);
	
	// Wormhole Detection and Mitigation Parameters
	cmd.AddValue ("enable_wormhole_detection", "Enable latency-based wormhole detection", enable_wormhole_detection);
	cmd.AddValue ("enable_wormhole_mitigation", "Enable automatic mitigation (route changes)", enable_wormhole_mitigation);
	cmd.AddValue ("detection_latency_threshold", "Latency multiplier for detection (e.g., 2.0 = 200%)", detection_latency_threshold);
	cmd.AddValue ("detection_check_interval", "Seconds between detection checks", detection_check_interval);
	cmd.AddValue ("experiment_number", "experiment_number", experiment_number);
    cmd.AddValue ("routing_test", "routing_test", routing_test);
    cmd.AddValue ("routing_algorithm", "routing_algorithm", routing_algorithm);
    cmd.AddValue ("qf", "qf", qf);
    cmd.Parse (argc, argv);	
    
    if (routing_test == true)
    {
     	N_Vehicles = 22;
     	N_RSUs = 1;
     	//flows = 1;
    }
	
    // Update actual_total_nodes based on runtime configuration
    actual_total_nodes = N_Vehicles + N_RSUs;
    std::cout << "Network configuration: N_Vehicles=" << N_Vehicles 
              << ", N_RSUs=" << N_RSUs 
              << ", actual_total_nodes=" << actual_total_nodes 
              << ", total_size=" << total_size << " (compile-time max)" << std::endl;
    
    routing_frequency = data_transmission_frequency;
    N_eNodeBs = 1 + N_Vehicles/320;
    var = N_Vehicles+N_RSUs;
    large=50000;
    optimization_period = 1.0/optimization_frequency;
    data_transmission_period = 1.0/data_transmission_frequency;
    //APB apb(memblock_key);
    //std::cout << a << "+" << b << "=" << apb.Func(a, b) << std::endl;
    //std::cout << a+2 << "+" << b+2 << "=" << apb.Func(a+2, b+2) << std::endl;
    
    LogComponentEnable ("vanet", LOG_LEVEL_INFO);
    LogComponentEnable ("UdpClient", LOG_LEVEL_INFO);
    LogComponentEnable ("UdpEchoClientApplication", LOG_LEVEL_INFO);
    LogComponentEnable ("UdpEchoServerApplication", LOG_LEVEL_INFO);
    LogComponentEnable ("PacketSink", LOG_LEVEL_INFO);
    
    clear_RQY();
    
    for (int i = 0; i<total_size+2; i++)
    {
    	clear_neighbordata(neighbordata_inst+i);
    	clear_controllerdata(con_data_inst+i);
    	clear_data_at_nodes(data_at_nodes_inst+i);
    	clear_routing_data_at_nodes(routing_data_at_nodes_inst+i-2);
    	clear_data_at_manager(data_at_manager_inst+i);
    }
    clear_delta_at_controller(delta_at_controller_inst);
    clear_solution();
    initialize_all_routing_tables();
  
  controller_Node.Create(1);
  management_Node.Create(1); 
  if (routing_test == false)
  {
  	  if(N_Vehicles > 0)
  	{ 
  		Vehicle_Nodes.Create(N_Vehicles); 
  	}
  }
  
  else
  {
  
  	    Vehicle_Nodes.Create(N_Vehicles);
    	    double x = 250;
	    MobilityHelper custom_mobility;
	    custom_mobility.SetMobilityModel ("ns3::ConstantVelocityMobilityModel");
	    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();
	    positionAlloc->Add(Vector(0.0, 0.0, 0.0)); // Custom position for Node 0
	    positionAlloc->Add(Vector(0.0, -x*1, 0.0)); // Custom position for Node 1
	    positionAlloc->Add(Vector(0.0, -x*2, 0.0)); // Custom position for Node 2
	    positionAlloc->Add(Vector(0.0, -x*3, 0.0)); // Custom position for Node 3
	    positionAlloc->Add(Vector(0.0, -x*4, 0.0)); // Custom position for Node 4
	    positionAlloc->Add(Vector(x, -x*4, 0.0)); // Custom position for Node 5
	    positionAlloc->Add(Vector(2*x, -x*4, 0.0)); // Custom position for Node 6
	    positionAlloc->Add(Vector(3*x, -x*4, 0.0)); // Custom position for Node 7
	    positionAlloc->Add(Vector(3*x, -x*3, 0.0)); // Custom position for Node 8
	    positionAlloc->Add(Vector(3*x, -x*2, 0.0)); // Custom position for Node 9
	    positionAlloc->Add(Vector(3*x, -x, 0.0)); // Custom position for Node 10
	    positionAlloc->Add(Vector(3*x, 0.0, 0.0)); // Custom position for Node 11
	    positionAlloc->Add(Vector(x, 0.0, 0.0)); // Custom position for Node 12
	    positionAlloc->Add(Vector(2*x, 0.0, 0.0)); // Custom position for Node 13
	    positionAlloc->Add(Vector(0.0, x, 0.0)); // Custom position for Node 14
	    positionAlloc->Add(Vector(0.0, x*2, 0.0)); // Custom position for Node 15
	    positionAlloc->Add(Vector(x, x*2, 0.0)); // Custom position for Node 16
	    positionAlloc->Add(Vector(x*2, x*2, 0.0)); // Custom position for Node 17
	    positionAlloc->Add(Vector(x*3, x*2, 0.0)); // Custom position for Node 18
	    positionAlloc->Add(Vector(x*3, x, 0.0)); // Custom position for Node 19
	    positionAlloc->Add(Vector(x, x, 0.0)); // Custom position for Node 20
	    positionAlloc->Add(Vector(2*x, x, 0.0)); // Custom position for Node 21
	    custom_mobility.SetPositionAllocator(positionAlloc);
	    custom_mobility.Install(Vehicle_Nodes);

	  // Set custom velocity and acceleration for each node
	    for (uint32_t i = 0; i < Vehicle_Nodes.GetN(); i++) 
	    {
	    
	    	Ptr<ConstantVelocityMobilityModel> cvmm = DynamicCast <ConstantVelocityMobilityModel> (Vehicle_Nodes.Get(i)->GetObject<MobilityModel>());
	    	if (i == 1)
	    	{
	    		cvmm->SetVelocity(Vector(0.0, -0.0, 0.0));
	    	}
	    	else if (i == 12)
	    	{
	    		cvmm->SetVelocity(Vector(1, 0.0, 0.0));
	    	}
	   
	    	else if (i == 13)
	    	{
	    		cvmm->SetVelocity(Vector(-18.0, 0.0, 0.0));
	    	}
	    	
	    	else if (i == 14)
	    	{
	    		cvmm->SetVelocity(Vector(0.0, 0.0, 0.0));
	    	}
	    	else
	    	{
	    		cvmm->SetVelocity(Vector(0.0, 0.0, 0.0));
	    	} 	
	    	//cvmm->SetAcceleration(Vector(0.0, 0.0, 0.0)); // Custom acceleration for each node

	    }
  }
  

 
  //Install and configure the RSUs  
  if(N_RSUs > 0)
  {
  	RSU_Nodes.Create (N_RSUs);  
  }
  
  //configuring the CSMA interface    
  CsmaHelper csma;
  csma.SetChannelAttribute ("DataRate", StringValue ("1000Mbps"));
  csma.SetChannelAttribute ("Delay", TimeValue (MicroSeconds (10)));
  
  NodeContainer csma_nodes;
  Ipv4AddressHelper address;
  Ipv4InterfaceContainer csmaInterfaces;
  NetDeviceContainer csmaDevices;
  InternetStackHelper stack;
  
  if (architecture != 1)
  {
	  csma_nodes.Add(RSU_Nodes);
	  csma_nodes.Add(controller_Node);
	  csma_nodes.Add(management_Node);  
	  csmaDevices = csma.Install (csma_nodes);
  	  address.SetBase ("10.1.1.0", "255.255.255.0");
  	  stack.Install (csma_nodes);
  	  csmaInterfaces = address.Assign (csmaDevices);
  } 
  
  AodvHelper aodv;
  InternetStackHelper stack_AODV;
  stack_AODV.SetRoutingHelper(aodv);
  if (architecture == 1)
  {
  	if (paper == 1)
  	{
  		stack_AODV.Install(RSU_Nodes);
  	}
  	if (paper == 0)
  	{
  		stack.Install(RSU_Nodes);
  	}
  }
  
  //configuring the point to point interfaces
  if (N_RSUs > 0)
  {
	  uint32_t length = (N_RSUs-1)/20;
	  PointToPointHelper p2p_horizontal[N_RSUs-length];
	  NetDeviceContainer p2pdevices_horizontal[N_RSUs-length];
	  Ipv4InterfaceContainer p2p_horizontal_interfaces[N_RSUs-length];
	  
	  
	  uint32_t width;
	  if (N_RSUs >20)
	  {
	  	width = N_RSUs - 20;
	  }
	  else
	  {
	  	width = 0;
	  }
	  PointToPointHelper p2p_vertical[width];
	  NetDeviceContainer p2pdevices_vertical[width];
	  Ipv4InterfaceContainer p2p_vertical_interfaces[width];
	  
	   
	   uint32_t z = 0;
	   for (uint32_t i=0; i<N_RSUs; i++)
	   {
		  uint32_t x = (i+1)%20;
		  if ((x != 0) and (i < (N_RSUs-1)))
		  {
		  	p2p_horizontal[z].SetDeviceAttribute ("DataRate", StringValue ("1000Mbps"));
		  	p2p_horizontal[z].SetChannelAttribute ("Delay", TimeValue (MicroSeconds (10)));
		  	p2pdevices_horizontal[z] = p2p_horizontal[z].Install (RSU_Nodes.Get(i), RSU_Nodes.Get(i+1));
		 	string part1 = "20.1.";
		  	string st = to_string(z);
		  	string part3 = ".0";
		  	string baseaddress = part1 + st + part3;
		  	char const * baseaddress_converted = baseaddress.c_str();
		  	Ipv4AddressHelper address;
		 	address.SetBase (Ipv4Address(baseaddress_converted), "255.255.255.0");
		 	p2p_horizontal_interfaces[z] = address.Assign (p2pdevices_horizontal[z]);
		 	z++;
		 }
		 
		 if (i < width)
		 {
		 	p2p_vertical[i].SetDeviceAttribute ("DataRate", StringValue ("1000Mbps"));
		  	p2p_vertical[i].SetChannelAttribute ("Delay", TimeValue (MicroSeconds (10)));
		  	p2pdevices_vertical[i] = p2p_vertical[i].Install (RSU_Nodes.Get(i), RSU_Nodes.Get(i+20));
		 	string part1 = "30.1.";
		  	string st = to_string(i);
		  	string part3 = ".0";
		  	string baseaddress = part1 + st + part3;
		  	char const * baseaddress_converted = baseaddress.c_str();
		  	Ipv4AddressHelper address;
		 	address.SetBase (Ipv4Address(baseaddress_converted), "255.255.255.0");
		 	p2p_vertical_interfaces[i] = address.Assign (p2pdevices_vertical[i]);
		 }	  
	   }
	   
	  //installing udp applications in RSUs

	  for (uint32_t u=0; u<RSU_Nodes.GetN(); u++)
	  {
	  	Ptr <SimpleUdpApplication> udp_app = Create <SimpleUdpApplication> ();
		RSU_Nodes.Get(u)->AddApplication(udp_app);
		RSU_apps.Add(udp_app);
	  }
	  RSU_apps.Start(Seconds(0.00));
	  RSU_apps.Stop(Seconds(simTime));
  }
  
  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
  Config::SetDefault("ns3::Ipv4GlobalRouting::RespondToInterfaceEvents", BooleanValue(true));
  NodeContainer enbnodes;
  NodeContainer remotehostcontainer;
  Ptr<Node> pgw;
  Ptr<PointToPointEpcHelper> epchelper;
  Ptr<Node> remotehost;
  Ptr<LteHelper> ltehelper;
  InternetStackHelper internet;

  if (N_Vehicles > 0)
  {
  	if (architecture != 1)
  	{
		  ltehelper = CreateObject<LteHelper> ();
		  ltehelper->SetAttribute("FadingModel",StringValue("ns3::TraceFadingLossModel"));
		  std::ifstream TraceFile;
		  TraceFile.open("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/src/lte/model/fading-traces/fading_trace_EVA_60kmph.fad", std::ifstream::in);
		  if(TraceFile.good())
		  {
		  	ltehelper->SetFadingModelAttribute("TraceFilename", StringValue("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/src/lte/model/fading-traces/fading_trace_EVA_60kmph.fad"));
		  }
		  
		  ltehelper->SetFadingModelAttribute("TraceLength",TimeValue(Seconds(10.0)));
		  ltehelper->SetFadingModelAttribute("SamplesNum",UintegerValue(10000));
		  ltehelper->SetFadingModelAttribute("WindowSize",TimeValue(Seconds(0.5)));
		  ltehelper->SetFadingModelAttribute("RbNum",UintegerValue(100));
		  ltehelper->SetEnbDeviceAttribute("DlEarfcn",UintegerValue(100));
		  ltehelper->SetEnbDeviceAttribute("UlEarfcn",UintegerValue(18100));
		  //ltehelper->SetSpectrumChannelAttribute ("Bandwidth", UintegerValue (10000000));
  		  
		  
		  //epc-evolved packet core for LTE
		  epchelper = CreateObject<PointToPointEpcHelper> ();
		  ltehelper->SetEpcHelper(epchelper);
		  pgw = epchelper->GetPgwNode();
		  
		  //creating remote-host
		  remotehostcontainer.Create(1);
		  remotehost = remotehostcontainer.Get(0);
		  internet.Install(remotehostcontainer);
		  
		  //Config::SetDefault("ns3::LteHelper::PathlossModel",StringValue("ns3::FriisPropagationLossModel"));
		  Config::SetDefault("ns3::LteHelper::PathlossModel",StringValue("ns3::Cost231PropagationLossModel"));
		  Config::SetDefault("ns3::LteHelper::UseIdealRrc",BooleanValue(true));
		  Config::SetDefault("ns3::LteHelper::UsePdschForCqiGeneration",BooleanValue(true));
		  Config::SetDefault("ns3::LteSpectrumPhy::CtrlErrorModelEnabled",BooleanValue(true));
		  Config::SetDefault("ns3::LteSpectrumPhy::DataErrorModelEnabled",BooleanValue(true));
		  //Config::SetDefault ("ns3::LteEnbPhy::DlBandwidth", UintegerValue (5000000));  Set DL bandwidth to 10 MHz
  		  //Config::SetDefault ("ns3::LteEnbPhy::UlBandwidth", UintegerValue (5000000));  Set UL bandwidth to 10 MHz

		  
		  Config::SetDefault("ns3::LteUePhy::TxPower",DoubleValue(23));//maximum ue transmit power of 23 dBm
		  Config::SetDefault("ns3::LteUePhy::EnableUplinkPowerControl",BooleanValue(true));
		  Config::SetDefault("ns3::LteUePowerControl::ClosedLoop",BooleanValue(true));
		  Config::SetDefault("ns3::LteUePowerControl::AccumulationEnabled",BooleanValue(false));
		  
		  
		  if ((N_Vehicles+5) < 2)
		  {
		  	Config::SetDefault("ns3::LteEnbRrc::SrsPeriodicity",UintegerValue(2));
		  }
		  else if ((N_Vehicles+5) < 5)
		  {
		  	Config::SetDefault("ns3::LteEnbRrc::SrsPeriodicity",UintegerValue(5));
		  }
		  else if ((N_Vehicles+5) < 10)
		  {
		  	Config::SetDefault("ns3::LteEnbRrc::SrsPeriodicity",UintegerValue(10));
		  }
		    else if ((N_Vehicles+8) < 20)
		  {
		  	Config::SetDefault("ns3::LteEnbRrc::SrsPeriodicity",UintegerValue(20));
		  }
		    else if ((N_Vehicles+20) < 40)
		  {
		  	Config::SetDefault("ns3::LteEnbRrc::SrsPeriodicity",UintegerValue(40));
		  }
		    else if ((N_Vehicles+25) < 80)
		  {
		  	Config::SetDefault("ns3::LteEnbRrc::SrsPeriodicity",UintegerValue(80));
		  }
		    else if ((N_Vehicles+30) < 160)
		  {
		  	Config::SetDefault("ns3::LteEnbRrc::SrsPeriodicity",UintegerValue(160));
		  }
		  else
		  {
		  	Config::SetDefault("ns3::LteEnbRrc::SrsPeriodicity",UintegerValue(320));
		  }
		 
		  
		  Config::SetDefault("ns3::LteAmc::AmcModel", EnumValue(LteAmc::PiroEW2010));
		  Config::SetDefault("ns3::LteAmc::Ber", DoubleValue(0.00005));
		  enbnodes.Create(N_eNodeBs); 
  	}
  	dsrc_Nodes.Add(Vehicle_Nodes);
  }
  if (N_RSUs > 0)
  {
  	dsrc_Nodes.Add(RSU_Nodes);
  }
  
  if (routing_test == false)
  {
  //vehicular nodes mobility trace files
  string trace_file; 
  if (mobility_scenario == 0) //urban mobility
  {
  	switch(maxspeed)
  	{
  		case (0):
  			trace_file = "/home/kanisa/Downloads/mobility/mobility_urban_0.tcl";
  			break;
  		case (10):
	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_urban_10.tcl";
	  		break;
	  	case (20):
	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_urban_20.tcl";
	  		break;
	  	case (30):
	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_urban_30.tcl";
	  		break;
	  	case (40):
	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_urban_40.tcl";
	  		break;
	  	case (50):
	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_urban_50.tcl";
	  		break;
	  	case (60):
	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_urban_60.tcl";
	  		break;
	  	default:
	  		break;
	 }
   }
   
   if (mobility_scenario == 1) //non-urban mobility
   {
   	switch(maxspeed)
   	{
   		case (0):
   			trace_file = "/home/kanisa/Downloads/mobility/mobility_rural_0.tcl";
   	  		break;
   		case (10):
   	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_rural_10.tcl";
   	  		break;
   	  	case (20):
	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_rural_20.tcl";
	  		break;
	  	case (30):
	   		trace_file = "/home/kanisa/Downloads/mobility/mobility_rural_30.tcl";
	   		break;
	   	case (40):
	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_rural_40.tcl";
	  		break;
	  	case (50):
	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_rural_50.tcl";
	  		break;
	  	case (60):
	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_rural_60.tcl";
	  		break;
   	  	case (70):
   	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_rural_70.tcl";
   	  		break;
   	  	case (80):
   	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_rural_80.tcl";
   	  		break;
   	  	case (90):
   	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_rural_90.tcl";
   	  		break;
   	  	case (100):
   	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_rural_100.tcl";
   	  		break;
   	  	default:
   	  		break;
	 }
   }
   
   if (mobility_scenario == 2)//highway
   {
   	  switch(maxspeed)
   	  {
   	  	case (0):
   	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_0.tcl";
   	  		break;	
   	  	case (10):
   	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_10.tcl";
   	  		break;
   	  	case (30):
   	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_30.tcl";
   	  		break;
   	  	case (50):
   	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_50.tcl";
   	  		break;
   	  	case (70):
   	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_70.tcl";
   	  		break;
   	  	case (90):
   	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_90.tcl";
   	  		break;
   	  	case (110):
   	  		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_110.tcl";
   	  		break;
	 	case (130):
	 		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_130.tcl";
	 		break;
	 	case (150):
	 		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_150.tcl";
	 		break;
	 	case (170):
	 		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_170.tcl";
	 		break;
	 	case (190):
	 		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_190.tcl";
	 		break;
	 	case (210):
	 		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_210.tcl";
	 		break;
	 	case (230):
	 		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_230.tcl";
	 		break;
	 	case (250):
	 		trace_file = "/home/kanisa/Downloads/mobility/mobility_autobahn_250.tcl";
	 		break;
	 	default:
	 		break;
	  }
   }


  
  //Ns2MobilityHelper vehicle_mobility  = Ns2MobilityHelper (trace_file);
  
 
  
  MobilityHelper vehicle_mobility2;
  vehicle_mobility2.SetMobilityModel ("ns3::ConstantVelocityMobilityModel");
  if (N_Vehicles > 0)
  {
  	
  	if (experiment_number != 5)
  	{
  		//vehicle_mobility.Install(Vehicle_Nodes.Begin(),Vehicle_Nodes.End());
  	}
  	else if (experiment_number == 5)
  	{
  		vehicle_mobility2.SetPositionAllocator ("ns3::GridPositionAllocator","MinX", DoubleValue (0.0),"MinY", DoubleValue (0.0),"DeltaX", DoubleValue (260.0),"DeltaY", DoubleValue (1000),"GridWidth", UintegerValue (2),"LayoutType", StringValue ("RowFirst"));
  		vehicle_mobility2.Install(Vehicle_Nodes);
  		
  		for (uint32_t i=0; i<Vehicle_Nodes.GetN(); i++)
	  	{
	  		Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (Vehicle_Nodes.Get(i)->GetObject<MobilityModel>());
	  		if (i%2 == 1)
	  		{
	  			mdl->SetVelocity(Vector(1, 0, 0));
	  		}
	  	}
  	}
  }
  }
  
 
  
  int x = ((N_RSUs)/12) + 1;
  double delta_x;
  double delta_y; 
  int lte_base_posx;
  int lte_base_posy;
  int man_base_posx;
  int man_base_posy;
  int con_base_posx;
  int con_base_posy;
  MobilityHelper RSU_mobility;
  RSU_mobility.SetMobilityModel ("ns3::ConstantVelocityMobilityModel");
  vehicle_mobility.SetMobilityModel ("ns3::ConstantVelocityMobilityModel");
  if (mobility_scenario == 0)//urban mobility
  {
  	man_base_posx = 1700;
  	man_base_posy = 1700;
  	con_base_posx = 1600;
  	con_base_posy = 1600;
  	lte_base_posx = 1500;
  	lte_base_posy = 1500;
  	
  	//delta_y = 800/x;
  	delta_y = 280;
  	//delta_x = 1600/5;
  	delta_x = 280;
	  	if (N_RSUs < 13)
	  	{		
	  		RSU_mobility.SetPositionAllocator ("ns3::GridPositionAllocator","MinX", DoubleValue (750.0),"MinY", DoubleValue (1200.0),"DeltaX", DoubleValue (delta_x),"DeltaY", DoubleValue (delta_y),"GridWidth", UintegerValue (7),"LayoutType", StringValue ("RowFirst"));
	  		vehicle_mobility.SetPositionAllocator ("ns3::GridPositionAllocator","MinX", DoubleValue (650.0),"MinY", DoubleValue (1000.0), "DeltaX", DoubleValue (delta_x/2),"DeltaY", DoubleValue (delta_y),"GridWidth", UintegerValue (14),"LayoutType", StringValue ("RowFirst"));
	  		
	  	}
	  	else
	  	{
	  		RSU_mobility.SetPositionAllocator ("ns3::GridPositionAllocator","MinX", DoubleValue (750.0),"MinY", DoubleValue (900.0),"DeltaX", DoubleValue (delta_x),"DeltaY", DoubleValue (delta_y),"GridWidth", UintegerValue (7),"LayoutType", StringValue ("RowFirst"));
	  		vehicle_mobility.SetPositionAllocator ("ns3::GridPositionAllocator","MinX", DoubleValue (650.0),"MinY", DoubleValue (1000.0), "DeltaX", DoubleValue (delta_x/2),"DeltaY", DoubleValue (delta_y),"GridWidth", UintegerValue (14),"LayoutType", StringValue ("RowFirst"));
	  	}
  }
  if(routing_test == false)
  {
  	vehicle_mobility.Install(Vehicle_Nodes);
  }
  update_mobility();
 
  
   if (mobility_scenario == 1)//non-urban mobility
  {

  	man_base_posx = 4600;
  	man_base_posy = 4600;
  	con_base_posx = 4700;
  	con_base_posy = 4700;
  	lte_base_posx = 4500;
  	lte_base_posy = 4500;
  	delta_x = 7000/9;
  	delta_y = 6500/(2*x);
  	RSU_mobility.SetPositionAllocator ("ns3::GridPositionAllocator","MinX", DoubleValue (1000.0),"MinY", DoubleValue (2000.0),"DeltaX", DoubleValue (delta_x),"DeltaY", DoubleValue (delta_y),"GridWidth", UintegerValue (10),"LayoutType", StringValue ("RowFirst"));  	
  }
  
  if (mobility_scenario == 2)//autobahn mobility
  {
  	man_base_posx = 2200;
  	man_base_posy = 3700;
  	con_base_posx = 2100;
  	con_base_posy = 3600;
  	lte_base_posx = 2000;
  	lte_base_posy = 3500;
  	delta_x = 4000/9;
  	delta_y = 7500/(2*x);
  	RSU_mobility.SetPositionAllocator ("ns3::GridPositionAllocator","MinX", DoubleValue (0),"MinY", DoubleValue (500),"DeltaX", DoubleValue (delta_x),"DeltaY", DoubleValue (delta_y),"GridWidth", UintegerValue (10),"LayoutType", StringValue ("RowFirst"));  	
  }
  
  if (routing_test == true)//routing_test
  {
  	man_base_posx = 500;
  	man_base_posy = 0;
  	con_base_posx = 550;
  	con_base_posy = 0;
  	lte_base_posx = 525;
  	lte_base_posy = 0;
  }
  
  if (N_RSUs > 0)
  {
  	RSU_mobility.Install(RSU_Nodes);
  }
  
  Ptr <Node> nd;
  NodeContainer other_stationary_LTE_nodes;
  if (N_Vehicles > 0)
  {
  	if (architecture != 1)
  	{
	  nd = ns3::NodeList::GetNode(N_Vehicles+N_RSUs+4);
	  other_stationary_LTE_nodes.Add(enbnodes);
	  other_stationary_LTE_nodes.Add(remotehostcontainer);
	  other_stationary_LTE_nodes.Add(pgw);
	  other_stationary_LTE_nodes.Add(epchelper->GetSgwNode());
	  other_stationary_LTE_nodes.Add(nd);
	}
  }
  
  if (architecture != 1)
  {
  
	  MobilityHelper other_stationary_mobility;
	  other_stationary_mobility.SetMobilityModel ("ns3::ConstantVelocityMobilityModel");
	  other_stationary_mobility.Install(controller_Node);
	  other_stationary_mobility.Install(management_Node);
	  if (N_Vehicles > 0)
	  {
	  	other_stationary_mobility.Install(other_stationary_LTE_nodes);
	  }
	  
	  //srand(time(0));
	  //int lte_base_posx = rand()%3000;
	  //int lte_base_posy = rand()%3000;
	  
	  if (N_Vehicles > 0)
	  {
		  for (uint32_t i=0; i<other_stationary_LTE_nodes.GetN(); i++)
		  {
		  	Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (other_stationary_LTE_nodes.Get(i)->GetObject<MobilityModel>());
		  	mdl->SetPosition(Vector(lte_base_posx+10*i, lte_base_posy+10*i, 0));
		  	mdl->SetVelocity(Vector(0, 0, 0));//other stationary LTE nodes
		  }
	  }
  }
  
  if (N_RSUs > 0)
  {
	  for (uint32_t i=0; i<RSU_Nodes.GetN(); i++)
	  {
	  	Ptr<ConstantVelocityMobilityModel> mdl = DynamicCast <ConstantVelocityMobilityModel> (RSU_Nodes.Get(i)->GetObject<MobilityModel>());
	  	mdl->SetVelocity(Vector(0, 0, 0));//RSUs nodes are stationary. Their position is already defined
	  }
  }
  
  //setting the position of controller node 
  //int con_base_posx = rand()%3000;
  //int con_base_posy = rand()%3000;

   if (architecture != 1)
   {
	   Ptr<ConstantVelocityMobilityModel> mdl_controller = DynamicCast <ConstantVelocityMobilityModel> (controller_Node.Get(0)->GetObject<MobilityModel>());
	   mdl_controller->SetPosition(Vector(con_base_posx, con_base_posy, 0));
	   mdl_controller->SetVelocity(Vector(0, 0, 0));//centralized controller placement
	   
	  //setting the position of management node
	  //int man_base_posx = rand()%3000;
	  //int man_base_posy = rand()%3000;

	   Ptr<ConstantVelocityMobilityModel> mdl_management = DynamicCast <ConstantVelocityMobilityModel> (management_Node.Get(0)->GetObject<MobilityModel>());
	   mdl_management->SetPosition(Vector(man_base_posx, man_base_posy, 0));
	   mdl_management->SetVelocity(Vector(0, 0, 0));//centralized management server placement
   }
  
  Ipv4StaticRoutingHelper ipv4routinghelper_con;
  if (N_Vehicles > 0)
  {
  	if (architecture != 1)
  	{
		  //point to point connection for pgw and remotehost 
		  PointToPointHelper p2ph;
		  p2ph.SetDeviceAttribute("DataRate", DataRateValue(DataRate("1000Mb/s")));
		  p2ph.SetDeviceAttribute("Mtu", UintegerValue(1500));
		  p2ph.SetChannelAttribute("Delay", TimeValue(MicroSeconds(10)));
		  NetDeviceContainer internetdevices = p2ph.Install(pgw,remotehost);
		  Ipv4AddressHelper ipv4h;
		  ipv4h.SetBase("1.0.0.0","255.0.0.0");
		  Ipv4InterfaceContainer internetipfaces = ipv4h.Assign(internetdevices);
		  //Ipv4Address remoteHostAddr = internetipfaces.GetAddress (1);
		  
		  //point to point connction for controller
		  PointToPointHelper p2p_controllers;
		  p2p_controllers.SetDeviceAttribute("DataRate", DataRateValue(DataRate("1000Mb/s")));
		  p2p_controllers.SetChannelAttribute("Delay", TimeValue(MicroSeconds(10)));
		  NetDeviceContainer p2pcontroller_devices = p2p_controllers.Install(pgw,controller_Node.Get(0));
		  Ipv4AddressHelper ipv4helper;
		  ipv4helper.SetBase("40.1.1.0","255.255.255.0");
		  Ipv4InterfaceContainer controller_interfaces = ipv4helper.Assign(p2pcontroller_devices);
		  
		  //point to point connection for management server
		  PointToPointHelper p2p_management;
		  p2p_management.SetDeviceAttribute("DataRate", DataRateValue(DataRate("1000Mb/s")));
		  p2p_management.SetChannelAttribute("Delay", TimeValue(MicroSeconds(10)));
		  NetDeviceContainer p2pmanagement_devices = p2p_management.Install(pgw,management_Node.Get(0));
		  Ipv4AddressHelper ipv4helper2;
		  ipv4helper2.SetBase("80.1.1.0","255.255.255.0");
		  Ipv4InterfaceContainer management_interfaces = ipv4helper2.Assign(p2pmanagement_devices);
		  
		  
		  Ipv4StaticRoutingHelper ipv4routinghelper;
		  Ptr<Ipv4StaticRouting> remotehoststaticrouting = ipv4routinghelper.GetStaticRouting(remotehost->GetObject<Ipv4>());
		  remotehoststaticrouting->AddNetworkRouteTo (Ipv4Address("7.0.0.0"),Ipv4Mask("255.0.0.0"),1);

		  Ptr<Ipv4StaticRouting> controller_staticrouting = ipv4routinghelper_con.GetStaticRouting(controller_Node.Get(0)->GetObject<Ipv4>());
		  controller_staticrouting->AddNetworkRouteTo (Ipv4Address("7.0.0.0"),Ipv4Mask("255.0.0.0"),2);

		  Ipv4StaticRoutingHelper ipv4routinghelper_man;
		  Ptr<Ipv4StaticRouting> management_staticrouting = ipv4routinghelper_man.GetStaticRouting(management_Node.Get(0)->GetObject<Ipv4>());
		  management_staticrouting->AddNetworkRouteTo (Ipv4Address("7.0.0.0"),Ipv4Mask("255.0.0.0"),2);
	}
}

  //broadcast data in RSU nodes
  /*
  for (uint32_t t=0 ; t<simTime-1; t++)
  {
	  for (uint32_t u=0; u<RSU_Nodes.GetN(); u++)
	  {
	  	Ptr <Node> nu = DynamicCast <Node> (RSU_Nodes.Get(u));	
	  	Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (RSU_apps.Get(u));
		Simulator::Schedule(Seconds(t+1+0.0001*u),p2p_data_broadcast, udp_app, nu);
   	  }
  }
  */
  
  //broadcast metadata in RSU nodes
  /*
  for (uint32_t t=0 ; t<simTime-1; t++)
  {
	  for (uint32_t u=0; u<RSU_Nodes.GetN(); u++)
	  {
	  	Ptr <Node> nu = DynamicCast <Node> (RSU_Nodes.Get(u));	
	  	Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (RSU_apps.Get(u));
		Simulator::Schedule(Seconds(t+1+0.0001*u),p2p_metadata_broadcast, udp_app, nu);
   	  }
  }
  */
 
  //YansWifiHelper to create WifiNetDevice
  
  switch(qf)
  {
  	//Background
  	case (0):
 
		flow_packet_size = 750;
		CW_min = 15;
		CW_max = 1023;
		SIFS = 12;
		T_slot = 20.0;
		AIFSN = 9;
		B_max = log2(1+(CW_max/CW_min));
		latency_max = 0.100;
		loss_max = 0.001;
		AIFS = SIFS + (AIFSN*T_slot);
  		break;
  	//Best effort	
  	case (1):
  		flow_packet_size = 750;
		CW_min = 15;
		CW_max = 127;
		SIFS = 12;
		T_slot = 20.0;
		AIFSN = 6;
		B_max = log2(1+(CW_max/CW_min));
		latency_max = 0.050;
		loss_max = 0.001;
		AIFS = SIFS + (AIFSN*T_slot);
  		break;
  	//Video
  	case (2):
  		flow_packet_size = 750;
		CW_min = 7;
		CW_max = 15;
		SIFS = 12;
		T_slot = 20.0;
		AIFSN = 3;
		B_max = log2(1+(CW_max/CW_min));
		latency_max = 0.025;
		loss_max = 0.005;
		AIFS = SIFS + (AIFSN*T_slot);
  		break;
  	//Audio
 	case (3):
  		flow_packet_size = 750;
		CW_min = 3;
		CW_max = 7;
		SIFS = 12;
		T_slot = 20.0;
		AIFSN = 2;
		B_max = log2(1+(CW_max/CW_min));
		latency_max = 0.010;
		loss_max = 0.005;
		AIFS = SIFS + (AIFSN*T_slot);
  		break;
 
 	default:
 		break;
  }
  
  YansWifiChannelHelper channel;
  YansWifiChannelHelper channel_172;
  YansWifiChannelHelper channel_174;
  YansWifiChannelHelper channel_176;
  YansWifiChannelHelper channel_180;
  YansWifiChannelHelper channel_182;
  YansWifiChannelHelper channel_184;
  
  channel.SetPropagationDelay("ns3::ConstantSpeedPropagationDelayModel");//set propagation delay model as constant speed
  channel_172.SetPropagationDelay("ns3::ConstantSpeedPropagationDelayModel");//set propagation delay model as constant speed
  channel_174.SetPropagationDelay("ns3::ConstantSpeedPropagationDelayModel");//set propagation delay model as constant speed
  channel_176.SetPropagationDelay("ns3::ConstantSpeedPropagationDelayModel");//set propagation delay model as constant speed
  channel_180.SetPropagationDelay("ns3::ConstantSpeedPropagationDelayModel");//set propagation delay model as constant speed
  channel_182.SetPropagationDelay("ns3::ConstantSpeedPropagationDelayModel");//set propagation delay model as constant speed
  channel_184.SetPropagationDelay("ns3::ConstantSpeedPropagationDelayModel");//set propagation delay model as constant speed

  
  if(mobility_scenario == 0)
  {
  	channel.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For urban -v2v
  	channel_172.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For urban -v2v
  	channel_174.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For urban -v2v
  	channel_176.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For urban -v2v
  	channel_180.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For urban -v2v
  	channel_182.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For urban -v2v
  	channel_184.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For urban -v2v
  	//channel.AddPropagationLoss("ns3::LogDistancePropagationLossModel");
  	//channel.AddPropagationLoss("ns3::FriisPropagationLossModel");
  }
  if ((mobility_scenario==1) or (mobility_scenario==2))
  {
  	//channel.AddPropagationLoss("ns3::LogDistancePropagationLossModel");
  	channel.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For sub-urban and highway
  	channel_172.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For sub-urban and highway
  	channel_174.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For sub-urban and highway
  	channel_176.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For sub-urban and highway
  	channel_180.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For sub-urban and highway
  	channel_182.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For sub-urban and highway
  	channel_184.AddPropagationLoss("ns3::Cost231PropagationLossModel");//For sub-urban and highway
  	
  	//channel.AddPropagationLoss("ns3::FriisPropagationLossModel");
  }
  
  //Physical layer helper for wave
  YansWifiPhyHelper Phy;
  YansWifiPhyHelper Phy_172;
  YansWifiPhyHelper Phy_174;
  YansWifiPhyHelper Phy_176;
  YansWifiPhyHelper Phy_180;
  YansWifiPhyHelper Phy_182;
  YansWifiPhyHelper Phy_184;
  
  Phy.SetErrorRateModel("ns3::NistErrorRateModel");
  Phy.SetPcapDataLinkType (WifiPhyHelper::DLT_IEEE802_11_RADIO);
  Phy.Set("TxPowerLevels", UintegerValue(2));//number of transmission power levels
  Phy_172.SetErrorRateModel("ns3::NistErrorRateModel");
  Phy_172.SetPcapDataLinkType (WifiPhyHelper::DLT_IEEE802_11_RADIO);
  Phy_172.Set("TxPowerLevels", UintegerValue(2));//number of transmission power levels
  Phy_174.SetErrorRateModel("ns3::NistErrorRateModel");
  Phy_174.SetPcapDataLinkType (WifiPhyHelper::DLT_IEEE802_11_RADIO);
  Phy_174.Set("TxPowerLevels", UintegerValue(2));//number of transmission power levels
  Phy_176.SetErrorRateModel("ns3::NistErrorRateModel");
  Phy_176.SetPcapDataLinkType (WifiPhyHelper::DLT_IEEE802_11_RADIO);
  Phy_176.Set("TxPowerLevels", UintegerValue(2));//number of transmission power levels
  Phy_180.SetErrorRateModel("ns3::NistErrorRateModel");
  Phy_180.SetPcapDataLinkType (WifiPhyHelper::DLT_IEEE802_11_RADIO);
  Phy_180.Set("TxPowerLevels", UintegerValue(2));//number of transmission power levels
  Phy_182.SetErrorRateModel("ns3::NistErrorRateModel");
  Phy_182.SetPcapDataLinkType (WifiPhyHelper::DLT_IEEE802_11_RADIO);
  Phy_182.Set("TxPowerLevels", UintegerValue(2));//number of transmission power levels
  Phy_184.SetErrorRateModel("ns3::NistErrorRateModel");
  Phy_184.SetPcapDataLinkType (WifiPhyHelper::DLT_IEEE802_11_RADIO);
  Phy_184.Set("TxPowerLevels", UintegerValue(2));//number of transmission power levels
  if (mobility_scenario == 0)
  {
  	Phy.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_172.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy_172.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_174.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy_174.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_176.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy_176.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_180.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy_180.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_182.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy_182.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_184.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy_184.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  }
  if (mobility_scenario == 1)
  {
  	Phy.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = non-urban
  	Phy_172.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy_172.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_174.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy_174.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_176.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy_176.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_180.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy_180.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_182.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy_182.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_184.Set ("TxPowerStart", DoubleValue (41));//TxPowerStart is the minimum power
  	Phy_184.Set ("TxPowerEnd", DoubleValue (41));//TxPowerEnd is the maximum power. 41 dBm = urban
  }
  if (mobility_scenario == 2)
  {
  	Phy.Set ("TxPowerStart", DoubleValue (44));//TxPowerStart is the minimum power
  	Phy.Set ("TxPowerEnd", DoubleValue (44));//TxPowerEnd is the maximum power. 44 dBm = highway
  	Phy_172.Set ("TxPowerStart", DoubleValue (44));//TxPowerStart is the minimum power
  	Phy_172.Set ("TxPowerEnd", DoubleValue (44));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_174.Set ("TxPowerStart", DoubleValue (44));//TxPowerStart is the minimum power
  	Phy_174.Set ("TxPowerEnd", DoubleValue (44));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_176.Set ("TxPowerStart", DoubleValue (44));//TxPowerStart is the minimum power
  	Phy_176.Set ("TxPowerEnd", DoubleValue (44));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_180.Set ("TxPowerStart", DoubleValue (44));//TxPowerStart is the minimum power
  	Phy_180.Set ("TxPowerEnd", DoubleValue (44));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_182.Set ("TxPowerStart", DoubleValue (44));//TxPowerStart is the minimum power
  	Phy_182.Set ("TxPowerEnd", DoubleValue (44));//TxPowerEnd is the maximum power. 41 dBm = urban
  	Phy_184.Set ("TxPowerStart", DoubleValue (44));//TxPowerStart is the minimum power
  	Phy_184.Set ("TxPowerEnd", DoubleValue (44));//TxPowerEnd is the maximum power. 41 dBm = urban
  }
  Phy.Set ("Frequency", UintegerValue(5890));//center frequency
  Phy.Set ("ChannelNumber", UintegerValue(178));//channel number
  Phy_172.Set ("Frequency", UintegerValue(5860));//center frequency
  Phy_172.Set ("ChannelNumber", UintegerValue(172));//channel number
  Phy_174.Set ("Frequency", UintegerValue(5870));//center frequency
  Phy_174.Set ("ChannelNumber", UintegerValue(174));//channel number
  Phy_176.Set ("Frequency", UintegerValue(5880));//center frequency
  Phy_176.Set ("ChannelNumber", UintegerValue(176));//channel number
  Phy_180.Set ("Frequency", UintegerValue(5900));//center frequency
  Phy_180.Set ("ChannelNumber", UintegerValue(180));//channel number
  Phy_182.Set ("Frequency", UintegerValue(5910));//center frequency
  Phy_182.Set ("ChannelNumber", UintegerValue(182));//channel number
  Phy_184.Set ("Frequency", UintegerValue(5920));//center frequency
  Phy_184.Set ("ChannelNumber", UintegerValue(184));//channel number
  
  Phy.Set ("ChannelWidth", UintegerValue(10));//channel width
  //Phy.Set ("Primary20MHzIndex", UintegerValue(3));//0 for least
  Phy.Set ("RxSensitivity", DoubleValue(-105));//
  Phy.Set ("TxGain", DoubleValue(0));//
  Phy.Set ("RxGain", DoubleValue(0));//
  Phy.Set ("RxNoiseFigure", DoubleValue(0));//
  Phy.Set ("Antennas", UintegerValue(1));//
  Phy.Set ("PowerDensityLimit", DoubleValue(100));// 
  Phy.Set ("Slot", ns3::TimeValue(ns3::MicroSeconds(T_slot)));//set slot time
  Phy.Set ("Sifs", ns3::TimeValue(ns3::MicroSeconds(SIFS)));//set SIFS
 
  Phy_172.Set ("ChannelWidth", UintegerValue(10));//channel width
  //Phy_172.Set ("Primary20MHzIndex", UintegerValue(0));//0 for least
  Phy_172.Set ("RxSensitivity", DoubleValue(-105));//
  Phy_172.Set ("TxGain", DoubleValue(0));//
  Phy_172.Set ("RxGain", DoubleValue(0));//
  Phy_172.Set ("RxNoiseFigure", DoubleValue(0));//
  Phy_172.Set ("Antennas", UintegerValue(1));//
  Phy_172.Set ("PowerDensityLimit", DoubleValue(100));// 
  Phy_172.Set ("Slot", ns3::TimeValue(ns3::MicroSeconds(T_slot)));//set slot time
  Phy_172.Set ("Sifs", ns3::TimeValue(ns3::MicroSeconds(SIFS)));//set SIFS
  
  Phy_174.Set ("ChannelWidth", UintegerValue(10));//channel width
  //Phy_174.Set ("Primary20MHzIndex", UintegerValue(1));//0 for least
  Phy_174.Set ("RxSensitivity", DoubleValue(-105));//
  Phy_174.Set ("TxGain", DoubleValue(0));//
  Phy_174.Set ("RxGain", DoubleValue(0));//
  Phy_174.Set ("RxNoiseFigure", DoubleValue(0));//
  Phy_174.Set ("Antennas", UintegerValue(1));//
  Phy_174.Set ("PowerDensityLimit", DoubleValue(100));// 
  Phy_174.Set ("Slot", ns3::TimeValue(ns3::MicroSeconds(T_slot)));//set slot time
  Phy_174.Set ("Sifs", ns3::TimeValue(ns3::MicroSeconds(SIFS)));//set SIFS
 
  Phy_176.Set ("ChannelWidth", UintegerValue(10));//channel width
  //Phy_176.Set ("Primary20MHzIndex", UintegerValue(2));//0 for least
  Phy_176.Set ("RxSensitivity", DoubleValue(-105));//
  Phy_176.Set ("TxGain", DoubleValue(0));//
  Phy_176.Set ("RxGain", DoubleValue(0));//
  Phy_176.Set ("RxNoiseFigure", DoubleValue(0));//
  Phy_176.Set ("Antennas", UintegerValue(1));//
  Phy_176.Set ("PowerDensityLimit", DoubleValue(100));// 
  Phy_176.Set ("Slot", ns3::TimeValue(ns3::MicroSeconds(T_slot)));//set slot time
  Phy_176.Set ("Sifs", ns3::TimeValue(ns3::MicroSeconds(SIFS)));//set SIFS
  
  Phy_180.Set ("ChannelWidth", UintegerValue(10));//channel width
  //Phy_180.Set ("Primary20MHzIndex", UintegerValue(4));//0 for least
  Phy_180.Set ("RxSensitivity", DoubleValue(-105));//
  Phy_180.Set ("TxGain", DoubleValue(0));//
  Phy_180.Set ("RxGain", DoubleValue(0));//
  Phy_180.Set ("RxNoiseFigure", DoubleValue(0));//
  Phy_180.Set ("Antennas", UintegerValue(1));//
  Phy_180.Set ("PowerDensityLimit", DoubleValue(100));// 
  Phy_180.Set ("Slot", ns3::TimeValue(ns3::MicroSeconds(T_slot)));//set slot time
  Phy_180.Set ("Sifs", ns3::TimeValue(ns3::MicroSeconds(SIFS)));//set SIFS
  
  Phy_182.Set ("ChannelWidth", UintegerValue(10));//channel width
  //Phy_182.Set ("Primary20MHzIndex", UintegerValue(5));//0 for least
  Phy_182.Set ("RxSensitivity", DoubleValue(-105));//
  Phy_182.Set ("TxGain", DoubleValue(0));//
  Phy_182.Set ("RxGain", DoubleValue(0));//
  Phy_182.Set ("RxNoiseFigure", DoubleValue(0));//
  Phy_182.Set ("Antennas", UintegerValue(1));//
  Phy_182.Set ("PowerDensityLimit", DoubleValue(100));// 
  Phy_182.Set ("Slot", ns3::TimeValue(ns3::MicroSeconds(T_slot)));//set slot time
  Phy_182.Set ("Sifs", ns3::TimeValue(ns3::MicroSeconds(SIFS)));//set SIFS
  
  Phy_184.Set ("ChannelWidth", UintegerValue(10));//channel width
  //Phy_184.Set ("Primary20MHzIndex", UintegerValue(6));//0 for least
  Phy_184.Set ("RxSensitivity", DoubleValue(-105));//
  Phy_184.Set ("TxGain", DoubleValue(0));//
  Phy_184.Set ("RxGain", DoubleValue(0));//
  Phy_184.Set ("RxNoiseFigure", DoubleValue(0));//
  Phy_184.Set ("Antennas", UintegerValue(1));//
  Phy_184.Set ("PowerDensityLimit", DoubleValue(100));// 
  Phy_184.Set ("Slot", ns3::TimeValue(ns3::MicroSeconds(T_slot)));//set slot time
  Phy_184.Set ("Sifs", ns3::TimeValue(ns3::MicroSeconds(SIFS)));//set SIFS
  
  
  //Phy.Set ("ChannelSettings", StringValue ("{176, 10, BAND_5GHZ, 0}"));
  //Config::SetDefault ("ns3::WifiPhy::ChannelSettings", StringValue ("{176, 10, BAND_5GHZ, 0}"));
  Phy.SetChannel (channel.Create ());
  Phy_172.SetChannel (channel_172.Create ());
  Phy_174.SetChannel (channel_174.Create ());
  Phy_176.SetChannel (channel_176.Create ());
  Phy_180.SetChannel (channel_180.Create ());
  Phy_182.SetChannel (channel_182.Create ());
  Phy_184.SetChannel (channel_184.Create ());
  
  
  //Set the number of power levels.
  
  //Config::Set("/NodeList/*/DeviceList/*/$ns3::WaveNetDevice/PhyEntities/*/TxPowerLevels", ns3::UintegerValue(7)); 

  
  //setting up the MAC layer
  
  Ssid ssid = Ssid ("ns-3-ssid");
  WifiMacHelper Mac;
  Mac.SetType("ns3::AdhocWifiMac","Ssid", SsidValue (ssid),"QosSupported", BooleanValue(true));
  

  WifiHelper wifi;
  wifi.SetStandard (WIFI_STANDARD_80211p);
  wifi.SetRemoteStationManager ("ns3::ConstantRateWifiManager",
  						"DataMode", StringValue ("OfdmRate12MbpsBW10MHz"),
  						"ControlMode",StringValue ("OfdmRate12MbpsBW10MHz"),
  						"NonUnicastMode", StringValue ("Invalid-WifiMode"),
						"MaxSsrc",UintegerValue(B_max),
						"MaxSlrc",UintegerValue(B_max),
						"RtsCtsThreshold",UintegerValue(1000));
						
  Ssid ssid_172 = Ssid ("ns-3-ssid-172");
  WifiMacHelper Mac_172;
  Mac_172.SetType("ns3::AdhocWifiMac","Ssid", SsidValue (ssid_172),"QosSupported", BooleanValue(true));
  

  WifiHelper wifi_172;
  wifi_172.SetStandard (WIFI_STANDARD_80211p);
  wifi_172.SetRemoteStationManager ("ns3::ConstantRateWifiManager",
  						"DataMode", StringValue ("OfdmRate12MbpsBW5MHz"),
  						"ControlMode",StringValue ("OfdmRate12MbpsBW5MHz"),
  						"NonUnicastMode", StringValue ("Invalid-WifiMode"),
						"MaxSsrc",UintegerValue(B_max),
						"MaxSlrc",UintegerValue(B_max),
						"RtsCtsThreshold",UintegerValue(1000));
						
  Ssid ssid_174 = Ssid ("ns-3-ssid-174");
  WifiMacHelper Mac_174;
  Mac_174.SetType("ns3::AdhocWifiMac","Ssid", SsidValue (ssid_174),"QosSupported", BooleanValue(true));
  

  WifiHelper wifi_174;
  wifi_174.SetStandard (WIFI_STANDARD_80211p);
  wifi_174.SetRemoteStationManager ("ns3::ConstantRateWifiManager",
  						"DataMode", StringValue ("OfdmRate12MbpsBW10MHz"),
  						"ControlMode",StringValue ("OfdmRate12MbpsBW10MHz"),
  						"NonUnicastMode", StringValue ("Invalid-WifiMode"),
						"MaxSsrc",UintegerValue(B_max),
						"MaxSlrc",UintegerValue(B_max),
						"RtsCtsThreshold",UintegerValue(1000));
 
  Ssid ssid_176 = Ssid ("ns-3-ssid-176");
  WifiMacHelper Mac_176;
  Mac_176.SetType("ns3::AdhocWifiMac","Ssid", SsidValue (ssid_176),"QosSupported", BooleanValue(true));
  

  WifiHelper wifi_176;
  wifi_176.SetStandard (WIFI_STANDARD_80211p);
  wifi_176.SetRemoteStationManager ("ns3::ConstantRateWifiManager",
  						"DataMode", StringValue ("OfdmRate12MbpsBW10MHz"),
  						"ControlMode",StringValue ("OfdmRate12MbpsBW10MHz"),
  						"NonUnicastMode", StringValue ("Invalid-WifiMode"),
						"MaxSsrc",UintegerValue(B_max),
						"MaxSlrc",UintegerValue(B_max),
						"RtsCtsThreshold",UintegerValue(1000));

  Ssid ssid_180 = Ssid ("ns-3-ssid-180");
  WifiMacHelper Mac_180;
  Mac_180.SetType("ns3::AdhocWifiMac","Ssid", SsidValue (ssid_180),"QosSupported", BooleanValue(true));
  

  WifiHelper wifi_180;
  wifi_180.SetStandard (WIFI_STANDARD_80211p);
  wifi_180.SetRemoteStationManager ("ns3::ConstantRateWifiManager",
  						"DataMode", StringValue ("OfdmRate12MbpsBW10MHz"),
  						"ControlMode",StringValue ("OfdmRate12MbpsBW10MHz"),
  						"NonUnicastMode", StringValue ("Invalid-WifiMode"),
						"MaxSsrc",UintegerValue(B_max),
						"MaxSlrc",UintegerValue(B_max),
						"RtsCtsThreshold",UintegerValue(1000));
  
  Ssid ssid_182 = Ssid ("ns-3-ssid-182");
  WifiMacHelper Mac_182;
  Mac_182.SetType("ns3::AdhocWifiMac","Ssid", SsidValue (ssid_182),"QosSupported", BooleanValue(true));
  

  WifiHelper wifi_182;
  wifi_182.SetStandard (WIFI_STANDARD_80211p);
  wifi_182.SetRemoteStationManager ("ns3::ConstantRateWifiManager",
  						"DataMode", StringValue ("OfdmRate12MbpsBW10MHz"),
  						"ControlMode",StringValue ("OfdmRate12MbpsBW10MHz"),
  						"NonUnicastMode", StringValue ("Invalid-WifiMode"),
						"MaxSsrc",UintegerValue(B_max),
						"MaxSlrc",UintegerValue(B_max),
						"RtsCtsThreshold",UintegerValue(1000));

  Ssid ssid_184 = Ssid ("ns-3-ssid-184");
  WifiMacHelper Mac_184;
  Mac_184.SetType("ns3::AdhocWifiMac","Ssid", SsidValue (ssid_184),"QosSupported", BooleanValue(true));
  

  WifiHelper wifi_184;
  wifi_184.SetStandard (WIFI_STANDARD_80211p);
  wifi_184.SetRemoteStationManager ("ns3::ConstantRateWifiManager",
  						"DataMode", StringValue ("OfdmRate12MbpsBW10MHz"),
  						"ControlMode",StringValue ("OfdmRate12MbpsBW10MHz"),
  						"NonUnicastMode", StringValue ("Invalid-WifiMode"),
						"MaxSsrc",UintegerValue(B_max),
						"MaxSlrc",UintegerValue(B_max),
						"RtsCtsThreshold",UintegerValue(1000));
						

  //MaxSsrc - maximum retransmission for packets lower than RTSCTS threshold.
  //MaxSlrc - maximum retransmissions for packets larger than RTSCTS threshold.
  
 
 
  Config::Set("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/ns3::AdhocWifiMac/DcaTxop/Queue/Mode",EnumValue(1000000*qf));
  Config::Set("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/ns3::AdhocWifiMac/DcaTxop/Queue/MaxPackets",UintegerValue(50000));
  Config::Set("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/ns3::AdhocWifiMac/DcaTxop/Queue/MaxBytes",UintegerValue(5000000));
  Config::Set("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/ns3::AdhocWifiMac/DcaTxop/Queue/MaxDelay",TimeValue(MilliSeconds(500000)));
  Config::Set("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/ns3::AdhocWifiMac/DcaTxop/MinCw",UintegerValue(CW_min));//set minimum contention window
  Config::Set("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/ns3::AdhocWifiMac/DcaTxop/MaxCw",UintegerValue(CW_max));//set maximum contention window
  Config::Set("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/ns3::AdhocWifiMac/DcaTxop/Aifsn",UintegerValue(AIFSN));//set AIFSN
  Config::Set("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/ns3::AdhocWifiMac/DcaTxop/TxopLimit",TimeValue(NanoSeconds(5000000)));
  
  //Mac.SetAifs(ns3::UintegerValue(AIFS));//set AIFS
 
  wifidevices = wifi.Install (Phy, Mac, dsrc_Nodes);
  wifidevices_172 = wifi_172.Install (Phy_172, Mac_172, dsrc_Nodes);
  wifidevices_174 = wifi_174.Install (Phy_174, Mac_174, dsrc_Nodes);
  wifidevices_176 = wifi_176.Install (Phy_176, Mac_176, dsrc_Nodes);
  wifidevices_180 = wifi_180.Install (Phy_180, Mac_180, dsrc_Nodes);
  wifidevices_182 = wifi_182.Install (Phy_182, Mac_182, dsrc_Nodes);
  wifidevices_184 = wifi_184.Install (Phy_184, Mac_184, dsrc_Nodes);
  
  NetDeviceContainer enbdevices;
  NetDeviceContainer uedevices;
  NodeContainer LTE_Nodes;
  LTE_Nodes.Add(controller_Node);
  LTE_Nodes.Add(management_Node);
  
  if (N_Vehicles >0)
  {
  	if (architecture != 1)
  	{
	  	  enbdevices = ltehelper->InstallEnbDevice(enbnodes);
		  uedevices = ltehelper->InstallUeDevice(Vehicle_Nodes);
	  	  internet.Install(Vehicle_Nodes);
	  	  Ipv4InterfaceContainer ueIpinterface;
	  	  ueIpinterface = epchelper->AssignUeIpv4Address(uedevices);

	  	  //Assign default gateway of the UEs, attach ues to enodebs.
		  for(uint32_t i=0; i<uedevices.GetN();i++)
		  {
		  	Ptr <Node> uenode = Vehicle_Nodes.Get(i);
		  	Ptr <Ipv4StaticRouting> ueStaticRouting = ipv4routinghelper_con.GetStaticRouting(uenode->GetObject<Ipv4>());//get the ip
		  	ueStaticRouting->SetDefaultRoute (epchelper->GetUeDefaultGatewayAddress(),1);  	
		  	uint32_t x = N_Vehicles/N_eNodeBs;
		  	uint32_t index = i/x;
		  	ltehelper->Attach (uedevices.Get(i), enbdevices.Get(index));
		  }
		  //tft stands for traffic flow template
		  Ptr <EpcTft> tft = Create <EpcTft> ();
		  EpcTft::PacketFilter pf;
		  pf.localPortStart =1234;
		  pf.localPortEnd = 1234;
		  tft->Add(pf);
		  ltehelper->ActivateDedicatedEpsBearer(uedevices, EpsBearer(EpsBearer::NGBR_VIDEO_TCP_DEFAULT), tft); 
	  	  //Install UDP applications in the  controller, management node, vehicular nodes,
	  	  LTE_Nodes.Add(Vehicle_Nodes);
		  
		  //uint16_t protocolip = 0x86DD;//ethertype for Ipv4 is set here.
		  
		  ltehelper->EnablePhyTraces();
		  ltehelper->EnableMacTraces();
		  ltehelper->EnableRlcTraces();
		  
		  //Phy.EnablePcap ("WaveTest", wifidevices);
	}
	if (architecture == 1)
	{
		if (paper == 1)
		{
			stack_AODV.Install(Vehicle_Nodes);
		}
		if (paper == 0)
		{
			stack.Install(Vehicle_Nodes);
		}
	}
}

  Ipv4AddressHelper address_dsrc;
  Ipv4AddressHelper address_dsrc_172;
  Ipv4AddressHelper address_dsrc_174;
  Ipv4AddressHelper address_dsrc_176;
  Ipv4AddressHelper address_dsrc_180;
  Ipv4AddressHelper address_dsrc_182;
  Ipv4AddressHelper address_dsrc_184;
 
  Ipv4InterfaceContainer dsrc_interfaces;
  Ipv4InterfaceContainer dsrc_interfaces_172;
  Ipv4InterfaceContainer dsrc_interfaces_174;
  Ipv4InterfaceContainer dsrc_interfaces_176;
  Ipv4InterfaceContainer dsrc_interfaces_180;
  Ipv4InterfaceContainer dsrc_interfaces_182;
  Ipv4InterfaceContainer dsrc_interfaces_184;
  address_dsrc.SetBase ("3.0.0.0", "255.0.0.0");
  dsrc_interfaces = address_dsrc.Assign (wifidevices);
  address_dsrc_172.SetBase ("4.0.0.0", "255.0.0.0");
  dsrc_interfaces_172 = address_dsrc_172.Assign (wifidevices_172);
  address_dsrc_174.SetBase ("5.0.0.0", "255.0.0.0");
  dsrc_interfaces_174 = address_dsrc_174.Assign (wifidevices_174);
  address_dsrc_176.SetBase ("6.0.0.0", "255.0.0.0");
  dsrc_interfaces_176 = address_dsrc_176.Assign (wifidevices_176);
  address_dsrc_180.SetBase ("11.0.0.0", "255.0.0.0");
  dsrc_interfaces_180 = address_dsrc_180.Assign (wifidevices_180);
  address_dsrc_182.SetBase ("8.0.0.0", "255.0.0.0");
  dsrc_interfaces_182 = address_dsrc_182.Assign (wifidevices_182);
  address_dsrc_184.SetBase ("9.0.0.0", "255.0.0.0");
  dsrc_interfaces_184 = address_dsrc_184.Assign (wifidevices_184);
 
 if (architecture != 1)
 {
	 for (uint32_t u=0; u<LTE_Nodes.GetN(); u++)
	 {
	  	Ptr <SimpleUdpApplication> udp_app = Create <SimpleUdpApplication> ();
		LTE_Nodes.Get(u)->AddApplication(udp_app);
		apps.Add(udp_app);
	 }
	 apps.Start(Seconds(0.00));
	 apps.Stop(Seconds(simTime)); 
 }
 
 if (architecture == 1)
 {
	 for (uint32_t u=0; u<Vehicle_Nodes.GetN(); u++)
	 {
	  	Ptr <SimpleUdpApplication> udp_app = Create <SimpleUdpApplication> ();
		Vehicle_Nodes.Get(u)->AddApplication(udp_app);
		apps.Add(udp_app);
	 }
	 apps.Start(Seconds(0.00));
	 apps.Stop(Seconds(simTime)); 
 }

 //if (architecture == 0)//centralized architecture
// { 
	  //unicast its own data packets to management node from vehicles.
	  /*
	  if (N_Vehicles < 50)
	  {
	  	//DSRC nodes data broadcast 
		for (double t=0.40; t<simTime-1; t=t+data_transmission_period)//All official data transmissions begin at t=0
		{	
			  //Go over all the wifi devices
			  for (uint32_t i=0; i<wifidevices.GetN() ; i++)
			  {     
				 Simulator::Schedule (Seconds (t+0.0001*i), centralized_dsrc_data_broadcast, wifidevices.Get (i), dsrc_Nodes.Get(i), i);
			  }
			  Simulator::Schedule (Seconds (t), set_dsrc_initial_timestamp);
		}
	  	for (double t=0.407 ; t<simTime-1; t=t+data_transmission_period)
	  	{
			  for (uint32_t u=0; u<Vehicle_Nodes.GetN(); u++)
			  {
			  	Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (apps.Get(u+2));
				Simulator::Schedule(Seconds(t+0.000025*u),send_LTE_data_alone,udp_app,Vehicle_Nodes.Get(u),management_Node.Get(0), u);
			  }
			  Simulator::Schedule (Seconds (t), set_lte_initial_timestamp);
			  Simulator::Schedule (Seconds (t+0.090), calculate_centralized_metrics);
	  	}
	  	
	  	//unicast data from RSU nodes alone to management server
	  	if (N_RSUs > 0)
	  	{
			for (double t=0.407 ; t<simTime-1; t=t+data_transmission_period)
			{
				  for (uint32_t u=0; u<RSU_Nodes.GetN(); u++)
				  {
				  	Ptr <Node> nu = DynamicCast <Node> (RSU_Nodes.Get(u));	
				  	Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (RSU_apps.Get(u));
					Simulator::Schedule(Seconds(t+0.000050*u),RSU_dataunicast_alone, udp_app, nu, management_Node.Get(0));
			   	  }
			   	  Simulator::Schedule (Seconds (t), set_ethernet_initial_timestamp);
			 }
		 }
	  }
	  */
	  //else
	  //{
	  	//if (experiment_number != 5)
	  	//{
	  		/*
	  		//DSRC nodes data broadcast 
			for (double t=0.970; t<simTime-1; t=t+data_transmission_period)//All official data transmissions begin at t=0
			{	
				  //Go over all the wifi devices
				  for (uint32_t i=0; i<wifidevices.GetN() ; i++)
				  {     
					 Simulator::Schedule (Seconds (t+0.0001*i), centralized_dsrc_data_broadcast, wifidevices.Get (i), dsrc_Nodes.Get(i), i);
				  }
				  Simulator::Schedule (Seconds (t), set_dsrc_initial_timestamp);
			}
			*/
			
		  	//DSRC flow instantiation
		  	double t0 = 0;
			for (double t=t0+0.999; t<simTime-1; t=t+data_transmission_period)//All official data transmissions begin at t=0
			{	
				  //Go over all the wifi devices
				vector<uint32_t> path_list[2*flows];
				vector<uint32_t> sources_list[2*flows];
				vector<uint32_t> destinations_list[2*flows];
				for (uint32_t i=0; i<(2*flows); i++)
				{
					
					uint32_t destination;
					uint32_t source;
					
					if (routing_test == true)
    					{
    						if(i==0)
    						{
    							destination = 11;
    							source = 0;
    						}
    						else
    						{
    							source = 11;
    							destination = 0;
    						}
    					}
    					else
    					{
    					
						srand(t*i);
				  		destination = rand()%total_size;
				  		srand(1.15*t*i);
				  		source = rand()%total_size;
				  		bool found_both = false;
				  		bool found_source = false;
				  		bool found_destination = false;
				  		for (uint32_t j=0; j<(2*flows); j++)
						{
							if (path_list[j].size()==2)
							{
								if ((path_list[j][0]==source) && ((path_list[j][1]==destination)))
								{
									found_both = true;
								}
							}
							if (sources_list[j].size()==1)
							{
								if ((sources_list[j][0]==source))
								{
									found_source = true;
								}
							}
							if (destinations_list[j].size()==1)
							{
								if ((destinations_list[j][0]==destination))
								{
									found_destination = true;
								}
							}
						}	
				  		
				  		if ((source == destination) || (found_both==true) || (found_source==true) || (found_destination==true))
				  		{
				  			uint32_t attempt = 2;
				  			while ((found_both == true) || (source == destination) || (found_source==true) || (found_destination==true))
				  			{
				  				uint32_t not_found = 0;
				  				uint32_t not_found_source = 0;
				  				uint32_t not_found_dest = 0;
				  				uint32_t list_size = 0;
				  				uint32_t list_source_size = 0;
				  				uint32_t list_dest_size = 0;
					  			destination = (2*attempt+destination)%total_size;
					  			source = (3*attempt+source)%total_size;
					  			//cout<<"updated destination is "<<destination<<"source is "<<source<<endl;
					  			for (uint32_t j=0; j<(2*flows); j++)
								{
									if (source == destination)
									{
										found_both = true;
										not_found = 0;
							
									}
									if (path_list[j].size()==2)
									{
										list_size++;
										if ((path_list[j][0]==source) && ((path_list[j][1]==destination)))
										{
											found_both = true;
											not_found = 0;
										}
										else
										{
											not_found++;
										}
									}
									
									if (sources_list[j].size()==1)
									{
										list_source_size++;
										if ((sources_list[j][0]==source))
										{
											found_source = true;
											not_found_source = 0;
										}
										else
										{
											not_found_source++;
										}
									}
									if (destinations_list[j].size()==1)
									{
										list_dest_size++;
										if ((destinations_list[j][0]==destination))
										{
											found_destination = true;
											not_found_dest = 0;
										}
										else
										{
											not_found_dest++;
										}
									}
								}
								if ((not_found == list_size) && (not_found !=0))
								{
									found_both = false;
								}
								if ((not_found_source == list_source_size) && (not_found_source !=0))
								{
									found_source = false;
								}
								if ((not_found_dest == list_dest_size) && (not_found_dest !=0))
								{
									found_destination = false;
								}
								attempt++;
								//cout<<"found both "<<found_both<<"found source "<<found_source<<"found destination "<<found_destination<<"source "<<source<<"destination "<<destination<<endl;
							}
						}
			  		}		
			  		
			  		path_list[i].push_back(source);
			  		path_list[i].push_back(destination);
			  		sources_list[i].push_back(source);
					destinations_list[i].push_back(destination);
			  		
			  		cout<<"flow id "<<i<<"source is "<<source<<"destination is "<<destination<<endl;
			  		srand(t*i);
				  	uint32_t index = rand()%(2*flow_size);
				  	double poison_probability = ((exp(-lambda))*(pow(lambda, index)))*(inv_factorial(index));
				  	//cout<<"inverse factorial of "<<index<<" is "<< inv_factorial(index)<<endl;
				  	double prob_threshold = 0.05;
				  	while(poison_probability < prob_threshold)
				  	{
				  		index = (index + rand())%(2*flow_size);
				  		poison_probability = ((exp(-lambda))*(pow(lambda, index)))*(inv_factorial(index));
				  		//cout<<"inverse factorial of "<<index<<" is "<< inv_factorial(index)<<endl;
				  	}
			  		uint32_t x = index;
			  		cout<<"Poisson flow size is "<<x<<endl;
			  		uint32_t z = flow_packet_size;
			  		uint32_t q = qf;
			  		Simulator::Schedule (Seconds (t+0.000002*i), add_demanding_flow_struct_nodes, demanding_flow_struct_nodes_inst+i, source, destination, x, z, q);
			  		if(routing_test == false)
			  		{
			  			Simulator::Schedule(Seconds(t-0.002), update_mobility);
			  		}
		  		}
		  		
		  		
				for (uint32_t i=0; i<wifidevices.GetN() ; i++)
				{     
					 Simulator::Schedule (Seconds (t+0.000002*i), update_previous_velocity, wifidevices.Get (i), dsrc_Nodes.Get(i));
					 Simulator::Schedule (Seconds (t+0.000002*(i+100)), add_routing_data_at_nodes, routing_data_at_nodes_inst+i, wifidevices.Get (i), dsrc_Nodes.Get(i));
				}
			        
				  //Simulator::Schedule (Seconds (t), set_dsrc_initial_timestamp);
			}
			
			
			if (N_Vehicles > 0)
			{
			  	for (double t=t0+1.000 ; t<simTime-1; t=t+data_transmission_period)
			  	{	
			  		  Simulator::Schedule(Seconds(t),clear_delta_at_nodes, delta_at_nodes_inst);
			  		 
					  for (uint32_t u=0; u<Vehicle_Nodes.GetN(); u++)
					  {
					  	Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (apps.Get(u+2));
						Simulator::Schedule(Seconds(t+0.000025*u),send_LTE_routing_data_alone,udp_app,Vehicle_Nodes.Get(u),management_Node.Get(0), u);
					  }
					  //calculate the routing solution
					  //unicast the solution back to nodes
					  
					  Simulator::Schedule(Seconds(t+0.034500),run_optimization_link_lifetime);
					  Simulator::Schedule(Seconds(t+0.034800),update_flows);
					  Simulator::Schedule(Seconds(t+0.034900+(2*(flows+1)*0.000050)),filter_flows);
					  
					  switch(routing_algorithm)
				   	  {
				   	  	//ECMP
				   	  	case (0):
				   	  		Simulator::Schedule(Seconds(t+0.035900),run_ECMP);
				   	  		break;
				   	  	//RR	
				   	  	case (1):
				   	  		Simulator::Schedule(Seconds(t+0.035900),run_ECMP);
				   	  		break;
				   	  	//QR-SDN
				   	  	case (2):
				   	  		Simulator::Schedule(Seconds(t+0.0359900),run_QRSDN);
				   	  		break;
				   	  	//RLMR
				   	 	case (3):
				   	  		Simulator::Schedule(Seconds(t+0.035900),run_RLMR);
				   	  		break;
				   	  	case (4):
				   	  		Simulator::Schedule(Seconds(t+0.035900),run_proposed_RL);
				   	  		break;
				   	  	case (5):
				   	  		Simulator::Schedule(Seconds(t+0.035900),run_DCMR);
				   	  		break;
					 	default:
					 		break;
					  }
					 
					  Simulator::Schedule(Seconds(t+0.036000),transmit_delta_values);
					  
					  Simulator::Schedule(Seconds(t+0.099500),initialize_flow_counters);
					  Simulator::Schedule(Seconds(t+0.100000),initiate_all_flows); 
					  Simulator::Schedule(Seconds(t+data_transmission_period-0.002),calculate_performance_evaluation_metrics);
 		          		  
				   	  
					  //Simulator::Schedule (Seconds (t), set_lte_initial_timestamp);
			
			  	}
		  	}
		  	
		  	
		  	//unicast data from RSU nodes alone to management server
		  	
		  	
		  	if (N_RSUs > 0)
		  	{
				  for (double t=t0+1.000; t<simTime-1; t=t+data_transmission_period)
				  {
					  for (uint32_t u=0; u<RSU_Nodes.GetN(); u++)
					  {
					  	Ptr <Node> nu = DynamicCast <Node> (RSU_Nodes.Get(u));	
					  	Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (RSU_apps.Get(u));
						Simulator::Schedule(Seconds(t+0.000050*u),RSU_routing_statusdataunicast_alone, udp_app, nu, management_Node.Get(0));
						if (u == (RSU_Nodes.GetN() - 1))
						{
							Simulator::Schedule(Seconds(t+0.000060*u),RSU_flowdata_unicast_alone, udp_app, nu, management_Node.Get(0));
						}
						
						//Simulator::Schedule (Seconds (t), set_ethernet_initial_timestamp);
				   	  }

				  }
			}
			
		
			
			

			
			/*			  	
		  	for (double t=1.000 ; t<simTime-1; t=t+data_transmission_period)
		  	{
		  		  if (paper == 0)
		  		  {
				  	Simulator::Schedule (Seconds (t+0.100), calculate_centralized_metrics);
				  }
				  if (paper == 1)
				  {
				  	Simulator::Schedule (Seconds (t+(data_transmission_period - 0.005)), calculate_centralized_metrics_routing);
				  }
		  	}
		  	*/
		//}
	  	/*
	  	else if (experiment_number == 5)
	      	{
	      		//DSRC nodes data broadcast from vehicle
			for (double t=0.40; t<simTime-1; t=t+data_transmission_period)//All official data transmissions begin at t=0
			{	
			  	//Go over all the vehicle devices
			  	for (uint32_t i=1; i<N_Vehicles ; i=i+2)
			  	{     
				 	Simulator::Schedule (Seconds (t+0.0001*i), distributed_dsrc_data_broadcast, wifidevices.Get (i), dsrc_Nodes.Get(i), i);
			  	}
			  	Simulator::Schedule (Seconds (t+0.090), write_distance_metrics);
			}
	      	}
	      	*/

	  //}
 //}
 
 /*
 if (architecture == 1)//distributed architecture
 { 
 
 	if (paper == 1)
 	{
		for (double t=1.00; t<simTime-1; t=t+data_transmission_period)
		{
			//for (uint32_t u=0; u<Vehicle_Nodes.GetN(); u++)
			//{
		  	srand(data_transmission_frequency*t);
	  		uint32_t destination = rand()%total_size;
	  		//uint32_t destination = 7;
	  		cout<<"destination id: "<<destination+2<<endl;
	  		Simulator::Schedule (Seconds (t+0.10), send_distributed_packets, destination);
			Simulator::Schedule (Seconds (t+0.10), set_dsrc_initial_timestamp);
			Simulator::Schedule (Seconds (t+(data_transmission_period - 0.005)), calculate_aodv_metrics);
			if (experiment_number == 11)
		  	{
		  		if (data_transmission_period > 0.20)
		  		{
		  			Simulator::Schedule (Seconds (t+(0.20)),calculate_aodv_packet_delivery_ratio);
		  		}
		  		else
		  		{
		  			Simulator::Schedule (Seconds (t+(data_transmission_period - 0.006)),calculate_aodv_packet_delivery_ratio);
		  		}
		  	}
		   	//}	  
		  }
	      	  Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper> ("aodv.routes", std::ios::out);
	      	  aodv.PrintRoutingTableAllAt (Seconds (5), routingStream);
      	  }
      	  
      	  if (paper == 0)
      	  {
      	  	//DSRC nodes data broadcast 
		for (double t=0.40; t<simTime-1; t=t+data_transmission_period)//All official data transmissions begin at t=0
		{	
			  //Go over all the wifi devices
			  for (uint32_t i=0; i<wifidevices.GetN() ; i++)
			  {     
				 Simulator::Schedule (Seconds (t+0.0001*i), distributed_dsrc_data_broadcast, wifidevices.Get (i), dsrc_Nodes.Get(i), i);
			  }
			  Simulator::Schedule (Seconds (t), set_dsrc_initial_timestamp);
			  Simulator::Schedule (Seconds (t+0.090), calculate_distributed_metrics);
		}
      	  }	  
 }
 
  if (architecture == 2)//hybrid architecture
  {
  	  //DSRC initial metadata broadcast - Go over all the wifi devices - only in first data cycle
	  for (uint32_t i=0; i<wifidevices.GetN() ; i++)
	  {    
	  	Simulator::Schedule (Seconds (0.4000+0.0001*i) , dsrc_metadata_broadcast, wifidevices.Get (i), dsrc_Nodes.Get(i), i);
	  }
	  
	  //unicast metadata from RSU nodes to management server - only in the first data cycle
	  if (N_RSUs > 0)
	  {
		  for (uint32_t u=0; u<RSU_Nodes.GetN(); u++)
		  {
		  	Ptr <Node> nu = DynamicCast <Node> (RSU_Nodes.Get(u));	
		  	Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (RSU_apps.Get(u));
			Simulator::Schedule(Seconds(0.4300+0.000050*u),RSU_metadata_uplink_unicast, udp_app, nu, controller_Node.Get(0));
		  }
	   }
	  if (N_Vehicles > 0)
	  {
	  	  //unicast metadata from vehicles to controller using LTE uplink - only in the first data cycle
		  for (uint32_t u=0; u<Vehicle_Nodes.GetN(); u++)
		  {
		  	Ptr <SimpleUdpApplication> udp_app = DynamicCast <SimpleUdpApplication> (apps.Get(u+2));
			Simulator::Schedule(Seconds(0.4300+0.000025*u),send_LTE_metadata_uplink_alone,udp_app,Vehicle_Nodes.Get(u),controller_Node.Get(0), u);

		  } 
	  }
	  Simulator::Schedule (Seconds (0.50), run_optimization_first_time);	  
	  //unicast all collected data packets to management node from lte agents (vehicles).
	  */
	  /*
	  if(N_Vehicles < 50)
	  {
	  	  //DSRC metadata subsequent broadcast at optimization frequency
		  for (double t=1.000; t<simTime-1; t = t+data_transmission_period)
		  {
		  	  for (uint32_t i=0; i<wifidevices.GetN() ; i++)
			  { 
		  		Simulator::Schedule (Seconds (t+0.0001*i) , dsrc_metadata_broadcast_subsequent, wifidevices.Get (i), dsrc_Nodes.Get(i), i);
		  	  }
		  	  	  
		  }
	  	  //DSRC nodes data broadcast 
		  for (double t=1.000; t<simTime-1; t=t+data_transmission_period)//All official data transmissions begin at t=1
		  {	
			  //Go over all the wifi devices
			  for (uint32_t i=0; i<wifidevices.GetN() ; i++)
			  {     
				 Simulator::Schedule (Seconds (t+0.0001*i), dsrc_data_broadcast, wifidevices.Get (i), dsrc_Nodes.Get(i), i);	
			  }
			  Simulator::Schedule (Seconds (t), set_dsrc_initial_timestamp);
		  } 
		  
		  for (double t=1.000; t<simTime-1; t = t + optimization_period)
		  {
		  	Simulator::Schedule (Seconds (t+0.053), run_optimization_subsequent); 
		  } 
		  
		  for (double t=1.007; t<simTime-1; t=t+data_transmission_period)
		  {	
		  	  Simulator::Schedule(Seconds(t), begin_sending_LTE_data_agent);
			  Simulator::Schedule (Seconds (t), set_lte_initial_timestamp);
		  }
		  
		   //unicast data from collected from RSU agent to management server
		  if (N_RSUs > 0)
		  {
			  for (double t=1.007 ; t<simTime-1; t=t+data_transmission_period)
			  {
			   	  Simulator::Schedule(Seconds(t), begin_sending_RSU_data_agent);
			   	  Simulator::Schedule (Seconds (t), set_ethernet_initial_timestamp);
			  }	
		   }
		  
 	 	*/
	  //}
	
	  //else
	  //{	
	  	/*
	  	 //DSRC metadata subsequent broadcast at optimization frequency
		  for (double t=1.000; t<simTime-1; t = t+data_transmission_period)
		  {
		  	  for (uint32_t i=0; i<wifidevices.GetN() ; i++)
			  { 
		  		Simulator::Schedule (Seconds (t+0.0001*i) , dsrc_metadata_broadcast_subsequent, wifidevices.Get (i), dsrc_Nodes.Get(i), i);
		  	  } 
		  	  if (paper == 1)
			  {
			  	Simulator::Schedule (Seconds (t+(data_transmission_period - 0.005)), calculate_hybrid_metrics_routing);
			  }
		  }
	  	  //DSRC nodes data broadcast 
		  for (double t=1.000; t<simTime-1; t=t+data_transmission_period)//All official data transmissions begin at t=1
		  {	
			  //Go over all the wifi devices
			  for (uint32_t i=0; i<wifidevices.GetN() ; i++)
			  {     
				 Simulator::Schedule (Seconds (t+0.0001*i), dsrc_data_broadcast, wifidevices.Get (i), dsrc_Nodes.Get(i), i);	
			  }
			  Simulator::Schedule (Seconds (t), set_dsrc_initial_timestamp);
		  } 
		  
		  for (double t=1.000; t<simTime-1; t = t + optimization_period)
		  {
		  	Simulator::Schedule (Seconds (t+0.090), run_optimization_subsequent); 
		  } 
		  
		  if (N_Vehicles > 0)
		  {
			  for (double t=1.030; t<simTime-1; t=t+data_transmission_period)
			  {	
			  	  Simulator::Schedule(Seconds(t), begin_sending_LTE_data_agent);
				  Simulator::Schedule (Seconds (t), set_lte_initial_timestamp);
			  }
		  }
		   //unicast data from collected from RSU agent to management server
		  if (N_RSUs > 0)
		  {
			  for (double t=1.030 ; t<simTime-1; t=t+data_transmission_period)
			  {
			   	  Simulator::Schedule(Seconds(t), begin_sending_RSU_data_agent);
			   	  Simulator::Schedule (Seconds (t), set_ethernet_initial_timestamp);
			  }
		  }
	  	
	  	for (double t=1.100; t<simTime-1; t=t+data_transmission_period)
		{
		  	srand(data_transmission_frequency*t);
	  		uint32_t destination = rand()%total_size;
	  		//uint32_t destination = 5;
	  		cout<<"destination id: "<<destination+2<<endl;
	  		Simulator::Schedule (Seconds (t), send_hybrid_packets, destination);
	  		//Simulator::Schedule (Seconds (t+0.100), calculate_centralized_metrics_routing); 
		}
		*/	  
	  //}
	  //Simulator::Schedule(Seconds(7.0), print_management_data);
  //}
  
 
  
  for (double t=0; t< simTime-1;t=t+1)
  {
  	Simulator::Schedule (Seconds (t), print_time);
  }
 
  Config::ConnectFailSafe("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/MonitorSnifferRx", MakeCallback (&Rx) );
  Config::ConnectFailSafe("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/$ns3::RegularWifiMac/MacRx", MakeCallback (&MacRx) );
  Config::ConnectFailSafe("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/$ns3::RegularWifiMac/MacTx", MakeCallback (&MacTx) );
  Config::ConnectFailSafe("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/ns3::RegularWifiMac/DcaTxop/Queue/Enqueue",MakeCallback (&Enqueue));
  //Config::ConnectFailSafe("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/ns3::RegularWifiMac/DcaTxop/Queue/Dequeue",MakeCallback (&Dequeue)); 
  
  AnimationInterface anim("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/routing.xml");  

  if (N_RSUs > 0)
  {
	  for (uint32_t i=0; i<RSU_Nodes.GetN() ; i++)
	  {
	  	anim.UpdateNodeColor(RSU_Nodes.Get(i),255,255,0);//RSUs in yellow color
	  	Ptr <Node> ni = DynamicCast <Node> (RSU_Nodes.Get(i));
	  	anim.UpdateNodeSize(ni->GetId(),20.0,20.0);
	  }
  }
  
  if (N_Vehicles > 0)
  {
	  for (uint32_t i=0; i<Vehicle_Nodes.GetN() ; i++)
	  {
	  	anim.UpdateNodeColor(Vehicle_Nodes.Get(i),0,255,0);//vehicle nodes are green color
	  	Ptr <Node> ni = DynamicCast <Node> (Vehicle_Nodes.Get(i));
	  	anim.UpdateNodeSize(ni->GetId(),20.0,20.0);
	  }
	   
	  if (architecture !=1)
	  {
		  for (uint32_t i=0; i<other_stationary_LTE_nodes.GetN() ; i++)
		  {
		  	anim.UpdateNodeColor(other_stationary_LTE_nodes.Get(i),0,0,255);//LTE stationary nodes are blue color
		  	Ptr <Node> ni = DynamicCast <Node> (other_stationary_LTE_nodes.Get(i));
		  	anim.UpdateNodeSize(ni->GetId(),20.0,20.0);
		  }
	  }
  }
  
    if (architecture != 1)
    {
	    anim.UpdateNodeColor(controller_Node.Get(0),255,0,255);//controller node is purple color.
	    Ptr <Node> node_controller = DynamicCast <Node> (controller_Node.Get(0));
	    anim.UpdateNodeSize(node_controller->GetId(),20.0,20.0);
	    
	    anim.UpdateNodeColor(management_Node.Get(0),255,0,0);//management node is red color.
	    Ptr <Node> node_management = DynamicCast <Node> (management_Node.Get(0));
	    anim.UpdateNodeSize(node_management->GetId(),20.0,20.0);
    }
 
  //AnimationInterface anim("/home/kanisa/Downloads/ns-allinone-3.35/ns-3.35/routing.xml"); 
  
  /*
  for (uint32_t i=0; i<Custom_Nodes.GetN() ; i++)
  {
  	anim.UpdateNodeColor(Custom_Nodes.Get(i),255,255,0);//RSUs in yellow color
  	Ptr <Node> ni = DynamicCast <Node> (Custom_Nodes.Get(i));
  	anim.UpdateNodeSize(ni->GetId(),20.0,20.0);
  }
  */
  
	declare_attackers();            // Mark wormhole malicious nodes/controllers
    
    // Enhanced Wormhole Attack Implementation
    if (present_wormhole_attack_nodes && use_enhanced_wormhole) {
        // Get actual node count from NS-3 (IMPORTANT: use actual count, not hardcoded value)
        uint32_t actual_node_count = ns3::NodeList::GetNNodes();
        
        // Resize wormhole_malicious_nodes vector if needed to match actual node count
        if (wormhole_malicious_nodes.size() < actual_node_count) {
            wormhole_malicious_nodes.resize(actual_node_count, false);
        }
        
        // Count malicious nodes
        int malicious_count = 0;
        for (size_t i = 0; i < wormhole_malicious_nodes.size(); ++i) {
            if (wormhole_malicious_nodes[i]) malicious_count++;
        }
        
        // Ensure minimum of 2 malicious nodes for wormhole tunnels
        if (malicious_count < 2 && actual_node_count >= 2) {
            std::cout << "Warning: Only " << malicious_count << " malicious node(s) selected. ";
            std::cout << "Forcing minimum of 2 nodes for wormhole tunnels..." << std::endl;
            // Force nodes in middle of network (more likely to be in paths)
            int node1 = actual_node_count / 3;     // 1/3 position
            int node2 = 2 * actual_node_count / 3; // 2/3 position
            wormhole_malicious_nodes[node1] = true;
            wormhole_malicious_nodes[node2] = true;
            malicious_count = 2;
        }
        
        // Or force more nodes for better coverage (optional - increase if needed)
        if (malicious_count < 6 && actual_node_count >= 10) {
            std::cout << "Info: Increasing malicious nodes to 6 for better coverage..." << std::endl;
            for (int i = 0; i < 6 && i < (int)wormhole_malicious_nodes.size(); i++) {
                int node_id = (i * actual_node_count) / 10; // Spread across network using ACTUAL count
                wormhole_malicious_nodes[node_id] = true;
            }
            malicious_count = 6;
        }
        
        std::cout << "\n=== Enhanced Wormhole Attack Configuration ===" << std::endl;
        std::cout << "Total Nodes (actual): " << actual_node_count << std::endl;
        std::cout << "Malicious Nodes Selected: " << malicious_count << std::endl;
        std::cout << "Attack Percentage: " << (attack_percentage * 100) << "%" << std::endl;
        std::cout << "Tunnel Bandwidth: " << wormhole_tunnel_bandwidth << std::endl;
        std::cout << "Tunnel Delay: " << wormhole_tunnel_delay_us << " microseconds" << std::endl;
        std::cout << "Random Pairing: " << (wormhole_random_pairing ? "Yes" : "No") << std::endl;
        std::cout << "Drop Packets: " << (wormhole_drop_packets ? "Yes" : "No") << std::endl;
        std::cout << "Tunnel Routing Packets: " << (wormhole_tunnel_routing ? "Yes" : "No") << std::endl;
        std::cout << "Tunnel Data Packets: " << (wormhole_tunnel_data ? "Yes" : "No") << std::endl;
        
        // Create wormhole manager
        g_wormholeManager = new ns3::WormholeAttackManager();
        
        // Initialize with malicious nodes (use actual_node_count instead of total_size)
        g_wormholeManager->Initialize(wormhole_malicious_nodes, attack_percentage, actual_node_count);
        
        // Set wormhole behavior
		g_wormholeManager->SetWormholeBehavior(wormhole_drop_packets, 
											   wormhole_tunnel_routing, 
											   wormhole_tunnel_data);

		g_wormholeManager->ConfigureVerificationTraffic(
			wormhole_enable_verification_flows,
			wormhole_verification_flow_count,
			wormhole_verification_packet_rate,
			wormhole_verification_packet_size,
			wormhole_verification_start_offset,
			wormhole_verification_base_port);

		// Create wormhole tunnels
		ns3::Time tunnelDelay = ns3::MicroSeconds(wormhole_tunnel_delay_us);
        g_wormholeManager->CreateWormholeTunnels(wormhole_tunnel_bandwidth, 
                                                 tunnelDelay, 
                                                 wormhole_random_pairing);
        
        // Determine stop time
        double stopTime = (wormhole_stop_time > 0) ? wormhole_stop_time : simTime;
        
        // Activate attack
        g_wormholeManager->ActivateAttack(ns3::Seconds(wormhole_start_time), 
                                          ns3::Seconds(stopTime));
        
        // Configure visualization
        g_wormholeManager->ConfigureVisualization(anim, 255, 0, 0); // Red color
        
        std::cout << "Created " << g_wormholeManager->GetTunnelCount() 
                  << " wormhole tunnels" << std::endl;
        std::cout << "Attack active from " << wormhole_start_time 
                  << "s to " << stopTime << "s" << std::endl;
        std::cout << "============================================\n" << std::endl;
        
        // ===== Wormhole Detection System Initialization =====
        if (enable_wormhole_detection) {
            std::cout << "\n=== Wormhole Detection System Configuration ===" << std::endl;
            std::cout << "Detection: " << (enable_wormhole_detection ? "ENABLED" : "DISABLED") << std::endl;
            std::cout << "Mitigation: " << (enable_wormhole_mitigation ? "ENABLED" : "DISABLED") << std::endl;
            std::cout << "Latency Threshold Multiplier: " << detection_latency_threshold << "x" << std::endl;
            std::cout << "Detection Check Interval: " << detection_check_interval << " seconds" << std::endl;
            
            // Create global detector
            g_wormholeDetector = new ns3::WormholeDetector();
            
            // Initialize detector
            g_wormholeDetector->Initialize(actual_node_count, detection_latency_threshold);
            g_wormholeDetector->EnableDetection(enable_wormhole_detection);
            g_wormholeDetector->EnableMitigation(enable_wormhole_mitigation);
            
            // Schedule periodic detection checks
            for (double t = detection_check_interval; t < stopTime; t += detection_check_interval) {
                ns3::Simulator::Schedule(ns3::Seconds(t), 
                                        &ns3::WormholeDetector::PeriodicDetectionCheck, 
                                        g_wormholeDetector);
            }
            
            // Schedule detection report printing before simulation ends
            ns3::Simulator::Schedule(ns3::Seconds(stopTime - 0.1), 
                                    &ns3::WormholeDetector::PrintDetectionReport, 
                                    g_wormholeDetector);
            
            // Schedule CSV export
            ns3::Simulator::Schedule(ns3::Seconds(stopTime - 0.05), 
                                    &ns3::WormholeDetector::ExportDetectionResults, 
                                    g_wormholeDetector,
                                    "wormhole-detection-results.csv");
            
            std::cout << "Detection system initialized successfully" << std::endl;
            std::cout << "================================================\n" << std::endl;
        }
        // ===== End of Detection System Initialization =====
    }
    else if (present_wormhole_attack_nodes) {
        // Use legacy wormhole implementation
        setup_wormhole_tunnels(anim);
    }
    
	setup_blackhole_attack(blackhole_malicious_nodes, total_size, simTime, anim,blackhole_malicious_controllers, controllers, getControllerNode);
	setup_replay_attack(reply_malicious_nodes,total_size,simTime,anim,reply_malicious_controllers,controllers,getControllerNode,1.0); // Replay delay in seconds
	setup_sybil_attack(sybil_malicious_nodes,total_size,simTime,anim,sybil_malicious_controllers,controllers,getControllerNode,3 );
	setup_routing_table_poisoning_attack(routing_table_poisoning_malicious_nodes,total_size,simTime,anim,routing_table_poisoning_malicious_controllers,controllers,getControllerNode,Ipv4Address("99.99.99.0"),Ipv4Mask("255.255.255.0"),1);

  Simulator::Stop(Seconds(simTime));
  Simulator::Run();
  
  // Print wormhole statistics if enhanced wormhole was used
  if (g_wormholeManager != nullptr) {
      g_wormholeManager->PrintStatistics();
      g_wormholeManager->ExportStatistics("wormhole-attack-results.csv");
      delete g_wormholeManager;
      g_wormholeManager = nullptr;
  }
  
  // Cleanup detector if it was used
  if (g_wormholeDetector != nullptr) {
      delete g_wormholeDetector;
      g_wormholeDetector = nullptr;
  }
  
  Simulator::Destroy();
  
 
  //apb.SetFinish();
  return 0;  
}